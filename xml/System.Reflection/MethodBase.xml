<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fec97ffc49df15f75e0a6d63b400a473181fc09d" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52602102" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <TypeSignature Language="F#" Value="type MethodBase = class&#xA;    inherit MemberInfo&#xA;    interface _MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>메서드와 생성자에 대한 정보를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `MethodBase` 기본 클래스인 <xref:System.Reflection.MethodInfo> 고 <xref:System.Reflection.ConstructorInfo>입니다.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">상속자에 대 한 완전 신뢰 합니다. 부분적으로 신뢰할 수 있는 코드에서이 클래스를 상속할 수 없습니다.</permission>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <block subset="none" type="overrides"><para>상속 하는 경우 <see langword="MethodBase" />, 다음 멤버를 재정의 해야 합니다: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />를 <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />를 <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> 하십시오 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, 및 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />합니다.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Reflection.MethodBase" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.MethodBase.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드와 관련된 특성을 가져옵니다.</summary>
        <value><see cref="T:System.Reflection.MethodAttributes" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 멤버는 특정 형식의 멤버와 관련 하 여 정의 된 특성 집합을 갖습니다.  
  
 가져오려는 <xref:System.Reflection.MethodAttributes>, 먼저 형식을 가져옵니다. 형식에서 메서드를 가져옵니다. 메서드에서 가져오기는 <xref:System.Reflection.MethodAttributes>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용자 정의 메서드 Mymethod의 특성을 표시 합니다.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 이 코드의 결과는 다음과 같습니다.  
  
 Reflection.MethodBase.Attributes 샘플  
  
 Mymethodbase Void Mymethod (Int32, System.String ByRef System.String ByRef) =  
  
 PrivateScope  
  
 FamANDAssem  
  
 패밀리  
  
 Public  
  
 HideBySig  
  
 ReuseSlot  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>사용 합니다 <see cref="P:System.Reflection.MethodBase.Attributes" /> 메서드는 지 여부를 결정 하는 속성 <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />등.</para></block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.MethodBase.CallingConvention" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드에 대한 호출 규칙을 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드에 대한 <see cref="T:System.Reflection.CallingConventions" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>제네릭 메서드에 할당되지 않은 제네릭 형식 매개 변수가 포함되어 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.MethodBase" /> 개체가 할당되지 않은 제네릭 형식 매개 변수를 포함하는 제네릭 메서드를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 자체의 형식 인수 또는 바깥쪽 형식에 개방형 생성된 형식 또는 제네릭 형식 정의 되지 않은 경우에 제네릭 메서드를 호출할 수 있습니다. 형식 임의로 복잡할 수 있으므로이 재귀 결정을 내릴는 어렵습니다. 편의 위해 및 오류의 가능성을 줄이기 위해는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성을 호출할 수 있는 닫힌된 생성 된 메서드를 구분 하기 위한 표준 방법이 제공 및 개방형 생성 메서드 일 수 없습니다. 경우는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`, 메서드를 호출할 수 없습니다.  
  
 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성 형식 매개 변수를 재귀적으로 검색 합니다. 예를 들어 반환 `true` 개방형 형식에서 모든 메서드에 대 한 `A<T>` (`A(Of T)` Visual Basic의) 경우에 자체 메서드는 제네릭이 아닙니다. 동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 반환 하는 속성 `false` 이러한 메서드에 대 한 합니다.  
  
 마찬가지로, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property 매개 변수 반환 `true` 모든 생성자는 개방형 형식에 대해도 생성자 없습니다 자체의 형식 매개 변수입니다.  
  
 제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다. 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodBase.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>@FSHO2@이 인스턴스가 지정한 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns><see langword="true" />가 이 인스턴스의 형식 및 값과 같으면 <paramref name="obj" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberSignature Language="F#" Value="static member GetCurrentMethod : unit -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetCurrentMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>실행 중인 메서드를 나타내는 <see langword="MethodBase" /> 개체를 반환합니다.</summary>
        <returns><see cref="M:System.Reflection.MethodBase.GetCurrentMethod" />는 실행 중인 메서드 내에서 호출되고 해당 메서드에 대한 정보를 반환하는 static 메서드입니다.  
  
실행 중인 메서드를 나타내는 <see langword="MethodBase" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제네릭 형식에서 현재 실행 중인 메서드에 정의 된 경우는 <xref:System.Reflection.MethodInfo> 에서 반환 하는 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 에서 제네릭 형식 정의 가져옵니다 (즉, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> 반환 `true`). 따라서 메서드는 호출 되었을 때 사용 된 형식 인수를 반영 하지 않습니다. 예를 들어 메서드 `M()` 제네릭 형식에 정의 된 `C<T>` (`C(Of T)` Visual Basic의), 및 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 에서 호출 됩니다 `C<string>.M()`, 한 다음 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 반환 `C<T>.M()` (`C(Of T).M()` Visual Basic의).  
  
 현재 실행 중인 메서드는 제네릭 메서드 이면 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 제네릭 메서드 정의 반환 합니다. 제네릭 메서드의 제네릭 형식에 정의 된 경우는 <xref:System.Reflection.MethodInfo> 에서 제네릭 형식 정의 가져옵니다.  
  
   
  
## Examples  
 다음 예제에서는 두 가지 종류를 정의합니다. 첫 번째는 제네릭이 아닌 클래스 `TestClass`, 생성자를 메서드가 포함 `GetValue`, 및 라는 읽기-쓰기 속성 `GetValue`. 두 번째는 라는 제네릭 클래스 `TestClass<T>` 생성자를 포함 하는 한 `GetValue` 메서드와 제네릭 메서드를 `ConvertValue<Y>`입니다. 각 생성자, 메서드 및 속성 접근자에 대 한 호출을 포함 합니다 <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> 메서드.  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">이 멤버가 런타임에 바인딩된 메커니즘을 사용하여 호출되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodBase.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열을 반환합니다.</summary>
        <returns>제네릭 메서드의 형식 인수나 제네릭 메서드 정의의 형식 매개 변수를 나타내는 <see cref="T:System.Type" /> 개체의 배열입니다. 현재 메서드가 제네릭 메서드가 아니면 빈 배열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환된 된 배열 요소의 제네릭 메서드의 형식 매개 변수 목록에 나타나는 순서는입니다.  
  
-   현재 메서드는 폐쇄형된 생성된 메서드 경우 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성에서 반환 `false`)를 반환 하는 배열을 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 메서드는 제네릭 메서드의 제네릭 형식 매개 변수에 할당 된 형식을 포함 정의 합니다.  
  
-   현재 메서드가 제네릭 메서드 정의 인 경우 배열 형식 매개 변수를 포함 합니다.  
  
-   현재 메서드가 개방형 생성된 메서드 이면 (즉, 합니다 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성이 반환 `true`) 일부 형식 매개 변수 및 형식에는 특정 형식이 할당 된 바깥쪽 제네릭 형식의 매개 변수 할당 된 형식으로 매개 변수 배열 포함 형식 및 형식 모두 매개 변수입니다. 사용 된 <xref:System.Type.IsGenericParameter%2A> 구분 하는 속성입니다. 이 시나리오의 데모를 제공 하는 코드 예제를 참조 하세요.를 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성입니다.  
  
 .NET Framework 버전 2.0에서는 제네릭 생성자가 지원되지 않습니다. 이 속성이 throw <xref:System.NotSupportedException> 파생된 클래스에서 재정의 되지 않으면 하므로 예외가 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.  
  
 제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다. 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">현재 개체가 <see cref="T:System.Reflection.ConstructorInfo" />인 경우. .NET Framework 버전 2.0에서는 제네릭 생성자가 지원되지 않습니다. 이 예외는 이 메서드가 파생 클래스에서 재정의되지 않은 경우의 기본 동작입니다.</exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodBase.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>부호 있는 32비트 정수 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodBody : unit -&gt; System.Reflection.MethodBody&#xA;override this.GetMethodBody : unit -&gt; System.Reflection.MethodBody" Usage="methodBase.GetMethodBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의된 경우, 현재 메서드의 MSIL 스트림, 지역 변수 및 예외에 액세스할 수 있도록 하는 <see cref="T:System.Reflection.MethodBody" /> 개체를 가져옵니다.</summary>
        <returns>현재 메서드의 MSIL 스트림, 지역 변수 및 예외에 액세스할 수 있도록 하는 <see cref="T:System.Reflection.MethodBody" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 재정의할 필요가 없습니다를 <xref:System.Reflection.MethodBase.GetMethodBody%2A> 사용 하기 위해. 호출할 수 있습니다 합니다 <xref:System.Reflection.MethodBase.GetMethodBody%2A> 메서드를 <xref:System.Reflection.MethodInfo> 및 <xref:System.Reflection.ConstructorInfo> 개체를 이러한 클래스의 런타임 버전에서의 메서드를 재정의 합니다. 예를 들어, 런타임 버전의를 <xref:System.Reflection.MethodInfo> 클래스에서 파생 되는 <xref:System.Reflection.MethodInfo> 클래스에서 파생 됩니다는 <xref:System.Reflection.MethodBase> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 라는 테스트 메서드를 정의 `MethodBodyExample` 해당 로컬 변수 정보 및 예외 처리 절을 표시 합니다. <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> 메서드는 가져오는 데는 <xref:System.Reflection.MethodBody> 테스트 메서드에 대 한 개체입니다.  
  
 합니다 <xref:System.Reflection.MethodBody.LocalVariables%2A> 속성은의 목록을 구하는 데 <xref:System.Reflection.LocalVariableInfo> 개체 및 해당 형식 및 인덱스 표시 순서. <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> 속성 예외 처리 절의 목록을 가져오는 데 사용 됩니다.  
  
> [!NOTE]
>  모든 컴퓨터 언어 <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> 절. Visual Basic 예제에서는 Visual Basic을 사용 하 여 필터 절, `When` 다른 언어에 대 한 예제에서 생략 되는 식입니다.  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드는 파생 클래스에서 재정의되지 않으면 유효하지 않습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">멤버에 대 한 메타 데이터에 액세스 합니다. 권한 값: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 핸들을 사용하여 메서드 정보를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">메서드의 핸들입니다.</param>
        <summary>메서드의 내부 메타데이터 표현(핸들)을 사용하여 메서드 정보를 가져옵니다.</summary>
        <returns>메서드에 대한 정보가 들어 있는 <see langword="MethodBase" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" />이 잘못되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetMethodFromHandle : RuntimeMethodHandle * RuntimeTypeHandle -&gt; System.Reflection.MethodBase" Usage="System.Reflection.MethodBase.GetMethodFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">생성자 또는 메서드의 내부 메타데이터 표현에 대한 핸들입니다.</param>
        <param name="declaringType">생성자 또는 메서드를 정의하는 제네릭 형식에 대한 핸들입니다.</param>
        <summary>지정된 제네릭 형식에 대해 지정된 핸들이 나타내는 생성자 또는 메서드의 <see cref="T:System.Reflection.MethodBase" /> 개체를 가져옵니다.</summary>
        <returns><paramref name="handle" />으로 지정된 제네릭 형식에서 <paramref name="declaringType" />로 지정된 메서드 또는 생성자를 나타내는 <see cref="T:System.Reflection.MethodBase" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.  
  
 A <xref:System.RuntimeMethodHandle> 생성자 또는 메서드의 제네릭 형식에 대 한 구조는 다른 나타낼 수 있습니다 <xref:System.Reflection.MethodBase> 제네릭 형식의 형식 매개 변수에 대해 지정 된 형식에 따라 개체입니다. 예를 들어 경우 `class G<T>` (`class G(Of T)` Visual basic에서는 `generic <T> ref class G` c + +에서) 형식을 반환 하는 메서드가 `T`의 <xref:System.Reflection.MethodBase> 와 같은 생성 된 클래스에서 메서드에 대 한 개체 `G<int>` 합니다 다릅니다<xref:System.Reflection.MethodBase>제네릭 형식 정의에서 해당 메서드에 대 한 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" />이 잘못되었습니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="methodBase.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의할 때 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그를 반환합니다.</summary>
        <returns><see langword="MethodImplAttributes" /> 플래그입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 동적 어셈블리에서 생성자를 정의 하 고 사용 하 여는 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 기본적으로 설정 되는 메서드 구현 플래그를 표시 하는 방법입니다.  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="methodBase.GetParameters " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 지정한 메서드나 생성자의 매개 변수를 가져옵니다.</summary>
        <returns>이 <see langword="ParameterInfo" /> 인스턴스에 의해 리플렉션된 메서드나 생성자의 시그니처와 일치하는 정보가 포함된 <see langword="MethodBase" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Reflection.MethodBase.GetParameters%2A> 의 매개 변수를 검색 하는 메서드는 `Invoke` 대리자 메서드.  
  
 이 예제에서는 명명 된 대리자를 정의 합니다. `MyDelegate` 명명 된 이벤트 `ev` 형식의 `MyDelegate`합니다. 코드를 `Main` 메서드 이벤트 시그니처를 대리자 형식의 이벤트를 가져와서 검색 가져오기는 `Invoke` 메서드는 대리자 형식으로 다음 검색 및 매개 변수를 표시 합니다.  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodBase.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 <see langword="MethodInfo" /> 인스턴스에 의해 리플렉션된 메서드나 생성자를 호출합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * obj[] -&gt; obj&#xA;override this.Invoke : obj * obj[] -&gt; obj" Usage="methodBase.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">메서드 또는 생성자를 호출할 개체입니다. 메서드가 static이면 이 인수는 무시됩니다. 생성자가 static이면 이 인수는 <see langword="null" /> 또는 생성자를 정의하는 클래스의 인스턴스여야 합니다.</param>
        <param name="parameters">호출된 메서드 또는 생성자에 대한 인수 목록입니다. 호출되는 메서드 또는 생성자의 매개 변수와 개수, 순서, 형식이 동일한 개체의 배열입니다. 매개 변수가 없는 경우 <paramref name="parameters" />는 <see langword="null" />이어야 합니다.  
  
이 인스턴스로 나타내는 메서드 또는 생성자가 <see langword="ref" /> 매개 변수(Visual Basic의 <see langword="ByRef" />)를 사용하는 경우 이 함수를 사용하여 메서드 또는 생성자를 호출하기 위해 해당 매개 변수에 특별한 특성이 필요하지 않습니다. 값으로 명시적으로 초기화되지 않은 이 배열의 모든 개체는 해당 개체 형식에 대해 기본값을 포함합니다. 참조 형식 요소의 경우 이 값은 <see langword="null" />입니다. 값 형식 요소의 경우 이 값은 특정 요소 형식에 따라 0, 0.0 또는 <see langword="false" />입니다.</param>
        <summary>지정된 매개 변수를 사용하여 현재 인스턴스로 나타낸 메서드 또는 생성자를 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값을 포함하는 개체이거나 생성자의 경우는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 호출 하는 편의 메서드를 <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> 메서드 오버 로드를 전달 <xref:System.Reflection.BindingFlags.Default> 에 대 한 `invokeAttr` 및 `null` 에 대 한 `binder` 및 `culture`.  
  
 호출 된 메서드가 예외를 throw 하는 경우는 <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> 메서드 예외를 반환 합니다.  
  
 사용 하 여 정적 메서드를 호출 하려면 해당 <xref:System.Reflection.MethodInfo> 개체를 전달 `null` 에 대 한 `obj`합니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 인스턴스 생성자 호출을 사용 하는 경우에 대 한 제공 된 개체가 `obj` 다시 초기화 됩니다; 즉, 모든 인스턴스 이니셜라이저 실행 됩니다. 반환 값은 `null`입니다. 클래스 생성자를 호출 하는 경우 클래스를 다시 초기화 됩니다. 즉, 모든 클래스 이니셜라이저가 실행 됩니다. 반환 값은 `null`입니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
 현재 메서드의 매개 변수 값 형식 및 해당 인수 이면 `parameters` 는 `null`, 런타임에 값 형식의 0으로 초기화 된 인스턴스를 전달 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 리플렉션을 사용 하 여 동적 메서드 조회 하는 방법을 보여 줍니다. 사용할 수 없습니다는 <xref:System.Reflection.MethodInfo> 런타임에 바인딩을 재정의 확인할 수 없습니다 때문에 파생된 클래스에서 재정의 된 메서드를 호출 하는 기본 클래스에서 개체입니다.  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 <see cref="T:System.Exception" />을 catch합니다.  
  
</para>
          </block>  
  
 <paramref name="obj" /> 매개 변수가 <see langword="null" />이고 메서드가 static이 아닌 경우  
  
또는 
메서드가 <paramref name="obj" /> 클래스에서 선언되지도 않고 상속되지도 않은 경우  
  
또는 
static 생성자가 호출되고 <paramref name="obj" />가 <see langword="null" />도 아니고 생성자를 선언한 클래스의 인스턴스도 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 배열의 요소가 이 인스턴스에서 리플렉트된 메서드 또는 생성자의 시그니처와 일치하지 않는 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">호출된 메서드 또는 생성자가 예외를 throw하는 경우  
  
또는 
현재 인스턴스가 확인할 수 없는 코드를 포함하는 <see cref="T:System.Reflection.Emit.DynamicMethod" />인 경우 <see cref="T:System.Reflection.Emit.DynamicMethod" />에 대한 설명에서 "확인" 섹션을 참조하세요.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 배열에 올바른 수의 인수가 포함되어 있지 않은 경우</exception>
        <exception cref="T:System.MethodAccessException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.MemberAccessException" />을 catch합니다.  
  
</para>
          </block>  
  
 호출자에 현재 인스턴스로 나타내는 메서드 또는 생성자를 실행할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드를 선언하는 형식이 오픈 제네릭 형식입니다. 즉, <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 선언 형식에 대해 <see langword="true" />를 반환합니다.</exception>
        <exception cref="T:System.NotSupportedException">현재 인스턴스는 <see cref="T:System.Reflection.Emit.MethodBuilder" />입니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="methodBase.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">메서드 또는 생성자를 호출할 개체입니다. 메서드가 static이면 이 인수는 무시됩니다. 생성자가 static이면 이 인수는 <see langword="null" /> 또는 생성자를 정의하는 클래스의 인스턴스여야 합니다.</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" />의 비트 플래그 0개 이상으로 조합된 비트 마스크입니다. <paramref name="binder" />가 <see langword="null" />이면 이 매개 변수에는 값 <see cref="F:System.Reflection.BindingFlags.Default" />가 할당됩니다. 따라서, 전달되는 모든 값은 무시됩니다.</param>
        <param name="binder">리플렉션을 사용하여 바인딩, 인수 형식의 강제 변환, 멤버 호출 및 <see langword="MemberInfo" /> 개체 검색을 사용할 수 있도록 하는 개체입니다. <paramref name="binder" />가 <see langword="null" />이면 기본 바인더가 사용됩니다.</param>
        <param name="parameters">호출된 메서드 또는 생성자에 대한 인수 목록입니다. 호출되는 메서드 또는 생성자의 매개 변수와 개수, 순서, 형식이 동일한 개체의 배열입니다. 이 목록은 매개 변수가 없으면 <see langword="null" />이어야 합니다.  
  
이 인스턴스가 나타내는 메서드나 생성자에 ByRef 매개 변수가 있으면 해당 매개 변수에 특수한 특성이 없어도 이 함수를 사용하여 메서드나 생성자를 호출할 수 있습니다. 값으로 명시적으로 초기화되지 않은 이 배열의 모든 개체는 해당 개체 형식에 대해 기본값을 포함합니다. 참조 형식 요소의 경우 이 값은 <see langword="null" />입니다. 값 형식 요소의 경우 이 값은 특정 요소 형식에 따라 0, 0.0 또는 <see langword="false" />입니다.</param>
        <param name="culture">형식의 강제 변환을 제어하는 데 사용되는 <see langword="CultureInfo" />의 인스턴스입니다. 이 매개 변수가 <see langword="null" />이면 현재 스레드에 대한 <see langword="CultureInfo" />가 사용됩니다. 예를 들어 1,000은 각 문화권마다 다르게 표현되므로 1,000을 나타내는 <see langword="String" />을 <see langword="Double" /> 값으로 변환하기 위해 이 매개 변수가 필요합니다.</param>
        <summary>파생 클래스에서 재정의된 경우, 지정된 매개 변수를 사용하여 리플렉션된 메서드나 생성자를 호출합니다.</summary>
        <returns>호출된 메서드의 반환 값이 포함된 <see langword="Object" />이거나, 생성자일 경우 <see langword="null" />이거나, 메서드의 반환 형식이 <see langword="null" />인 경우 <see langword="void" />입니다. 이 메서드나 생성자를 호출하기 전에 <see langword="Invoke" />는 사용자에게 액세스 권한이 있는지 확인한 다음 매개 변수가 올바른지 검사합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 인스턴스에 의해 리플렉션된 메서드를 호출 하는 동적으로 `obj`, 지정된 된 매개 변수를 전달 합니다. 메서드가 정적 이면는 `obj` 매개 변수가 무시 됩니다. 비정적 메서드에 대해 `obj` 상속 하거나 메서드를 선언 하 고,이 클래스와 동일한 형식 이어야 하는 클래스의 인스턴스여야 합니다. 메서드 매개 변수가 없는의 값이 있으면 `parameters` 있어야 `null`합니다. 그렇지 않은 경우 개수, 형식 및에서 요소의 순서 `parameters` 수, 형식 및이 인스턴스에서 리플 렉 트 메서드에 대 한 매개 변수의 순서와 동일 해야 합니다.  
  
 에 대 한 호출의 선택적 매개 변수를 생략할 수 없습니다 `Invoke`합니다. 선택적 매개 변수를 생략 하는 메서드를 호출 하려면 호출 해야 `Type.InvokeMember` 대신 합니다.  
  
> [!NOTE]
>  이 메서드 오버 로드 인스턴스 생성자 호출을 사용 하는 경우에 대 한 제공 된 개체가 `obj` 다시 초기화 됩니다; 즉, 모든 인스턴스 이니셜라이저 실행 됩니다. 반환 값은 `null`입니다. 클래스 생성자를 호출 하는 경우 클래스를 다시 초기화 됩니다. 즉, 모든 클래스 이니셜라이저가 실행 됩니다. 반환 값은 `null`입니다.  
  
 기본 값으로 전달 매개 변수에 대 한 일반 확대 이루어집니다 (Int16-> Int32, 예를 들어). 값으로 전달 참조 매개 변수에 대 한 일반적인 참조 확대 (기본 클래스 및 인터페이스 형식에 기본 클래스를 파생된 클래스) 허용 됩니다. 그러나 참조로 전달 기본 매개 변수 형식이 정확히 일치 해야 합니다. 참조로 전달 참조 매개 변수에 대 한 일반 확대 계속 적용 됩니다.  
  
 예를 들어 메서드를 반영 하 여이 인스턴스는 변수로 선언 `public boolean Compare(String a, String b)`, 한 다음 `parameters` 의 배열 이어야 `Objects` 길이가 2 인 되도록 `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.  
  
 현재 메서드의 매개 변수 값 형식 및 해당 인수 이면 `parameters` 는 `null`, 런타임에 값 형식의 0으로 초기화 된 인스턴스를 전달 합니다.  
  
 리플렉션 가상 메서드를 호출 하는 경우 동적 메서드 조회를 사용 합니다. 예를 들어, 클래스 B는 클래스에서 상속 하 고 모두 M 이라는 가상 메서드를 구현 합니다. 이제 있다고 가정 하 고는 `MethodInfo` A. 클래스에 M을 나타내는 개체 사용 하는 경우는 `Invoke` 리플렉션 클래스 2. 제공한 구현을 사용 합니다. 그런 다음 M b 형식의 개체에서 호출할 메서드 형식 B의 개체를 A로 캐스팅 하는 경우에 클래스 B에 의해 지정 된 구현이 사용 됩니다 (아래 코드 샘플 참조).  
  
 반면에 메서드가 가상이 아닌 경우 다음 리플렉션은 구현을 사용 형식이 올 지정한는 `MethodInfo` 대상으로 전달 되는 개체의 유형에 관계 없이 가져온 합니다.  
  
 완전히 신뢰할 수 있는 코드에 대 한 액세스 제한이 없습니다. 즉, 개인 생성자, 메서드, 필드 및 속성 액세스 하 고 수 코드를 완전히 신뢰할 수 있는 경우 리플렉션을 통해 호출 합니다.  
  
 호출 된 메서드가 예외를 throw 하는 경우 `TargetInvocationException.GetException` 예외를 반환 합니다. 이 구현에서 throw 된 `NotSupportedException`합니다.  
  
> [!NOTE]
>  부터 합니다 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)],이 메서드를 사용 하 여 호출자에 게 부여 된 경우 public이 아닌 멤버에 액세스할 수 있습니다 <xref:System.Security.Permissions.ReflectionPermission> 사용 하 여는 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 플래그 및 public이 아닌 멤버의 권한 부여 집합 호출자 에게만 부여 된 집합 또는 하위 집합 그 합니다. (참조 [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  이 기능을 사용하려면 응용 프로그램이 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 이상을 대상으로 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 모든 멤버를 <xref:System.Reflection.Binder?displayProperty=nameWithType> 오버 로드를 사용 하 여 클래스 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>합니다. Private 메서드 `CanConvertFrom` 지정된 된 형식에 대 한 호환 되는 형식을 찾습니다. 사용자 지정 바인딩 시나리오에서 호출 멤버의 다른 예제를 보려면 [를 사용 하 여 형식 동적 로드 및](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)합니다.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><paramref name="obj" /> 매개 변수가 <see langword="null" />이고 메서드가 static이 아닌 경우  
  
또는 
메서드가 <paramref name="obj" /> 클래스에서 선언되지도 않고 상속되지도 않은 경우  
  
또는 
static 생성자가 호출되고 <paramref name="obj" />가 <see langword="null" />도 아니고 생성자를 선언한 클래스의 인스턴스도 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 매개 변수의 형식이 이 인스턴스에 의해 리플렉션된 메서드 또는 생성자의 시그니처와 일치하지 않는 경우</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 배열에 올바른 수의 인수가 포함되어 있지 않은 경우</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">호출된 메서드 또는 생성자가 예외를 throw하는 경우</exception>
        <exception cref="T:System.MethodAccessException">호출자에 현재 인스턴스로 나타내는 메서드 또는 생성자를 실행할 수 있는 권한이 없습니다.</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드를 선언하는 형식이 오픈 제네릭 형식입니다. 즉, <see cref="P:System.Type.ContainsGenericParameters" /> 속성이 선언 형식에 대해 <see langword="true" />를 반환합니다.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">호출 될 때 런타임에 바인딩된 메커니즘을 통해 같은 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md">동적으로 형식 로드 및 사용</related>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Reflection.MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드가 추상 메서드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>해당 메서드가 추상 메서드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 클래스에 선언 된 추상 멤버 및에 제공 된 구현이 없습니다.  
  
 가져오려는 <xref:System.Reflection.MethodBase>, 먼저 형식을 가져옵니다. 형식에서 메서드를 가져옵니다. 메서드에서 가져오기는 `MethodBase`합니다. 경우는 `MethodBase` 또는 생성자가 public이 아닌, 보호 되 고 액세스할 수 없습니다. Public이 아닌 메서드에 액세스 하려면 설정 합니다 <xref:System.Reflection.BindingFlags> 마스크를 `NonPublic` 에서 `GetMethod`합니다.  
  
   
  
## Examples  
 다음 예제에서는 지정 된 메서드가 추상 이며 결과 표시 하는지 여부를 결정 합니다.  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="F:System.Reflection.MethodAttributes.Assembly" />에서 이 메서드나 생성자의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 같은 어셈블리의 다른 형식에만 표시되고 어셈블리 외부의 파생 형식에는 표시되지 않습니다.</summary>
        <value><see cref="F:System.Reflection.MethodAttributes.Assembly" />에서 이 메서드나 생성자의 표시 유형을 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 해당 형식의 표시 유형과 메서드의 실제 가시성 제한 됩니다. 합니다 <xref:System.Reflection.MethodBase.IsAssembly%2A> 속성 수 있습니다 `true` 메서드의 경우 있지만 경우 전용 중첩된 형식 메서드의 메서드를 포함 하는 형식 외부에 표시 되지 않습니다.  
  
 메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `internal` (`Friend` Visual basic에서). 이 속성은 `false` 메서드를 위한 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서); 사용 하 여는 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 이러한 메서드를 식별 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.  
  
> [!NOTE]
>  Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericMethod : bool" Usage="System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructor : bool" Usage="System.Reflection.MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 생성자인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드가 <see cref="T:System.Reflection.ConstructorInfo" /> 개체가 나타내는 생성자이면 <see langword="true" />이고(<see cref="T:System.Reflection.Emit.ConstructorBuilder" /> 개체에 대한 설명 부분 참조), 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Reflection.MethodBase.IsConstructor%2A> 속성이 반환 `false` 에 대 한를 <xref:System.Reflection.Emit.ConstructorBuilder> 경우가 아니면 동적 형식의 개체를 <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> 플래그에 포함 된를 `attributes` 생성자가 정의 될 때 매개 변수입니다. 생략 된 <xref:System.Reflection.MethodAttributes.RTSpecialName> 플래그 내보낸된 생성자의 정확성에 영향을 주지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="F:System.Reflection.MethodAttributes.Family" />에서 이 메서드나 생성자의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 해당 클래스 및 파생 클래스에만 표시됩니다.</summary>
        <value><see cref="F:System.Reflection.MethodAttributes.Family" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> 만 표시 한정자가 하는 경우 `protected`합니다. 이 속성은 `false` 메서드를 위한 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서); 사용 하 여는 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 이러한 메서드를 식별 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.  
  
> [!NOTE]
>  Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />에서 이 메서드나 생성자의 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 같은 어셈블리에 있는 경우에만 파생 클래스에서 호출할 수 있습니다.</summary>
        <value><see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected private` c + +에서입니다. Visual Basic 또는 C#에서 이러한 가시성을 사용 하 여 메서드를 정의할 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.  
  
> [!NOTE]
>  Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="F:System.Reflection.MethodAttributes.FamORAssem" />에서 이 메서드나 생성자의 잠재적 표시 유형을 설명하는지 여부를 나타내는 값을 가져옵니다. 즉, 이 메서드나 생성자는 파생 클래스(있는 경우) 및 같은 어셈블리의 클래스에서 호출할 수 있습니다.</summary>
        <value><see cref="F:System.Reflection.MethodAttributes.FamORAssem" />에서 이 메서드나 생성자에 대한 액세스를 정확하게 설명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식 멤버에 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 가시성을 호출할 수 있습니다 파생된 클래스에서 모든 멤버 또는 멤버는 같은 어셈블리에 있지만 다른 형식에서는 상속할 수 없습니다.  
  
 해당 형식의 표시 유형과 메서드의 실제 가시성 제한 됩니다. 합니다 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> 속성 수 있습니다 `true` 메서드의 경우 있지만 경우 전용 중첩된 형식 메서드의 메서드를 포함 하는 형식 외부에 표시 되지 않습니다.  
  
 메서드 또는 생성자의 표시 유형을 정확 하 게 설명 됩니다 <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> 표시 한정자가 하는 경우 `protected internal` C#에서 (`Protected Friend` Visual basic에서는 `protected public` c + +에서).  
  
   
  
## Examples  
 다음 코드 예제에서는 다양 한 수준의 가시성을 사용 하 여 메서드를 정의 하 고 값이 표시 됩니다 자신의 <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>를 <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, 및 <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> 속성입니다.  
  
> [!NOTE]
>  Visual Basic 및 C# 언어를 사용 하 여 메서드를 정의할 수 없습니다 <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> 가시성; 액세스 수준 c + + 예제 나타나도록 합니다.  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFinal : bool" Usage="System.Reflection.MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드가 <see langword="final" />인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드가 <see langword="final" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드를 재정의할 수 있는지 확인 하지 않았는지 확인 하기에 충분 하 <xref:System.Reflection.MethodBase.IsVirtual%2A> 는 `true`합니다. 재정의할, 메서드에 대 한 `IsVirtual` 이어야 합니다 `true` 하 고 `IsFinal` 여야 합니다 `false`합니다. 예를 들어 메서드 비가상 이며 수 있지만 인터페이스 메서드를 구현 합니다. 공용 언어 런타임에서 인터페이스 멤버를 구현 하는 모든 메서드를 표시 합니다 필요 `virtual`따라서 컴파일러는 메서드 표시 `virtual final`합니다. 메서드가로 표시 되어 있는 경우 되므로 `virtual` 되지만 재정의할 수는 없습니다.  
  
 메서드는 재정의할 수 있는지 여부를 확실 하 게 설정 하 고, 이와 같은 코드를 사용 합니다.  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 하는 경우 `IsVirtual` 됩니다 `false` 또는 `IsFinal` 는 `true`, 다음 메서드를 재정의할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 표시 `false` 에 대 한 `IsFinal`,이 생각 하면 발생할 수 있습니다. 코드 인쇄 `false` MyMethod 표시 되지 않는 경우에 `virtual` 재정의할 수 없습니다.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodBase.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 제네릭 메서드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.MethodBase" />가 제네릭 메서드를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성을 확인 하는지 여부를 현재 <xref:System.Reflection.MethodBase> 개체는 제네릭 메서드를 나타냅니다. 사용 하 여는 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> 속성을 확인 하는지 여부를 현재 <xref:System.Reflection.MethodBase> 개체는 열려 있는 생성 된 메서드 또는 폐쇄형된 생성된 메서드를 나타냅니다.  
  
> [!NOTE]
>  기본적으로 제네릭을 사용할 수 없습니다. 이 속성은 반환 `false` 파생된 클래스에서 재정의 되지 않은 경우. 이 속성을 반환 하므로 제네릭 생성자는.NET Framework 버전 2.0에서에서 지원 되지 않습니다 `false` 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.  
  
다음 표에서 제네릭 메서드와 관련 된 용어에 대 한 고정 조건입니다. 와 같은 제네릭 리플렉션에 사용 되는 다른 용어에 대 한 *제네릭 형식 매개 변수* 하 고 *제네릭 형식*를 참조는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.   

|용어|고정 조건이| 
|---|---| 
|제네릭 메서드 정의| <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> 속성은 `true`입니다. <br />제네릭 메서드를 정의합니다. 생성된 된 메서드를 호출 하 여 만들어집니다 합니다 <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> 메서드는 <xref:System.Reflection.MethodInfo> 제네릭 메서드 정의 나타내는 개체를 형식 인수의 배열을 지정 하 합니다. <br /><xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> 제네릭 메서드 정의에 대해서만 메서드를 호출할 수 있습니다. <br/>모든 제네릭 메서드 정의 된 제네릭 메서드를 이지만 메서드라고 해 서 해당 되지 않습니다.|    
|제네릭 메서드(generic method)|`IsGenericMethod` 속성은 `true`입니다. <br/> 제네릭 메서드 정의 열려 있는 생성 된 메서드 또는 폐쇄형된 생성된 메서드 수 있습니다.| 
|open 메서드 생성된|<xref:System.Reflection.MethodBase.ContainsGenericParameters> 속성은 `true`입니다. <br/>개방형 생성된 메서드를 호출 하는 것이 불가능 합니다.|  
|폐쇄형 생성된 메서드|<xref:System.Reflection.MethodBase.ContainsGenericParameters> 속성은 `false`입니다. <br/>검사를 재귀적으로 메서드에 할당 되지 않은 제네릭 매개 변수가 없는 경우. 포함 하는 형식에 제네릭 형식 매개 변수가 없습니다 및 형식 인수를 제네릭 형식 매개 변수가 없습니다. <br/>메서드를 호출할 수 있습니다.|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 제네릭 메서드 정의인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Reflection.MethodBase" /> 개체가 제네릭 메서드 정의를 나타내면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 <xref:System.Reflection.MethodBase> 는 제네릭 메서드 정의 나타냅니다.  
  
-   <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> 속성은 `true`입니다.  
  
-   각 <xref:System.Type> 에서 반환 된 배열에 있는 개체는 <xref:System.Reflection.MethodBase.GetGenericArguments%2A> 메서드:  
  
    -   <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> 속성은 `true`입니다.  
  
    -   <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> 속성 현재 인스턴스를 반환 합니다.  
  
    -   <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> 속성의 위치와 동일 합니다 <xref:System.Type> 배열에 있는 개체입니다.  
  
> [!NOTE]
>  기본적으로 제네릭을 사용할 수 없습니다. 이 속성은 반환 `false` 파생된 클래스에서 재정의 되지 않은 경우. 이 속성을 반환 하므로 제네릭 생성자는.NET Framework 버전 2.0에서에서 지원 되지 않습니다 `false` 현재 인스턴스 형식의 경우 <xref:System.Reflection.ConstructorInfo>합니다.  
  
 제네릭 메서드와 관련 된 용어에 대 한 고정 조건 목록에 대해서는 <xref:System.Reflection.MethodBase.IsGenericMethod%2A> 속성입니다. 제네릭 리플렉션에 사용 되는 용어의 고정 조건 목록에 대해서는 <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHideBySig : bool" Usage="System.Reflection.MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동일한 시그니처가 있는 동일한 종류의 멤버만을 파생 클래스에서 숨길 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>멤버를 시그니처로 숨길 수 있으면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C#을 사용 하 여 파생된 클래스의 멤버는 선언 하는 경우 `new` 한정자 또는 Visual Basic `Shadows` 한정자 기본 클래스에서 동일한 이름의 멤버를 숨길 수 있습니다. C# 서명 함으로써 기본 클래스 멤버를 숨깁니다. 기본 클래스 멤버를 여러 오버 로드가 있으면 숨겨져 있는 유일한 즉, 동일한 시그니처가 있는 것입니다. 반면, Visual Basic 기본 클래스 오버 로드를 모두 숨깁니다. 따라서 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 반환 `false` Visual Basic을 사용 하 여 선언 된 멤버에 `Shadows` 한정자, 및 `true` C#을 사용 하 여 선언 된 멤버에 `new` 한정자입니다.  
  
> [!WARNING]
>  이 속성 메서드에 게 있는지 여부를 확인 하지 않습니다는 <xref:System.Reflection.MethodAttributes.NewSlot> 특성입니다. 중 하나를 사용 하 여 선언 된 메서드를 `new` 또는 `Shadows` 한정자를 <xref:System.Reflection.MethodAttributes.NewSlot> 특성은 아니지만 사용 하 여 선언 된 메서드만 `new` (즉, C# 메서드만) 갖습니다는 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 로설정하는속성`true`.  메서드가 있는지 여부를 결정 하는 <xref:System.Reflection.MethodAttributes.NewSlot> 특성에 다음과 비슷한 코드를 사용 하 여: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` C# 또는 `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` Visual Basic의 합니다. 단, 하는 모든 방법을 사용 하 여 선언 되지만 `new` 또는 `Shadows` 가 합니다 <xref:System.Reflection.MethodAttributes.NewSlot> 특성에 있는 모든 메서드를 <xref:System.Reflection.MethodAttributes.NewSlot> 특성으로 선언 되 `new` 또는 `Shadows`.  
  
   
  
## Examples  
 다음 코드 예제는 오버 로드 된 메서드를 사용 하 여 기본 클래스 및 오버 로드 중 하나를 숨기는 파생된 클래스를 포함 합니다. Visual Basic 버전의 코드 예제는 <xref:System.Reflection.MethodBase.IsHideBySig%2A> 속성이 반환 `false` 파생된 클래스의 멤버에 대 한 합니다. 속성은 C# 버전의 코드 예제에서는 반환 `true` 파생된 클래스의 멤버에 대 한 합니다.  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버가 전용인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드에 대한 액세스가 클래스 자신의 다른 멤버로 제한되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식 멤버에 `Private` 수준 표시 유형이 호출 될 수 같은 클래스에 없는 다른 모든 멤버에서입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드가 public 메서드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드가 public 메서드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가져오려는 <xref:System.Reflection.MethodBase>, 먼저 형식을 가져옵니다. 형식에서 메서드를 가져옵니다. 메서드에서 가져오기는 `MethodBase`합니다. 경우는 `MethodBase` 또는 생성자가 public이 아닌, 보호 되 고 액세스할 수 없습니다. Public이 아닌 메서드에 액세스 하려면 설정 합니다 <xref:System.Reflection.BindingFlags> 마스크를 `NonPublic` 에서 `GetMethod`합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Reflection.MethodBase.IsPublic%2A> 속성을 지정된 된 메서드가 공용 인지 여부를 나타내는 메시지를 표시 합니다.  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 중요한 형식이거나 보안 안전에 중요한 형식이어서 중요한 작업을 수행할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 중요하거나 보안 안전에 중요한 경우 <see langword="true" />이고 투명한 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 메서드나 생성자가 현재 신뢰 수준에서 보안 안전에 중요한 형식인지 즉, 중요한 작업을 수행할 수 있고 투명 코드로 액세스할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 메서드나 생성자가 현재 신뢰 수준에서 보안 안전에 중요한 경우 <see langword="true" />이고 보안에 중요하거나 투명한 경우 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다. 이러한 속성의 조합도 표에 표시 됩니다.  
  
|보안 수준|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|위험|`true`|`false`|`false`|  
|안전 중요|`true`|`true`|`false`|  
|투명|`false`|`false`|`true`|  
  
 이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 메서드나 생성자가 현재 신뢰 수준에서 투명하여 중요한 작업을 수행할 수 없는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 메서드나 생성자가 현재 신뢰 수준에서 보안에 투명하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 하는 경우 `true`는 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> 하 고 <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> 속성 반환 `false`합니다.  
  
 합니다 <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, 및 <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> 속성 메서드 또는 생성자는 CLR (공용 언어 런타임)에서 결정 된 대로 해당 현재 신뢰 수준에서의 투명도 수준을 보고 합니다. 이러한 속성을 사용 하는 것은 어셈블리 및 해당 형식과 멤버의 보안 주석을 검사 하 고 현재 신뢰 수준 검사 런타임 규칙을 복제 하는 보다 훨씬 간단 합니다.  
  
> [!IMPORTANT]
>  부분 신뢰 어셈블리에 대 한이 속성은 어셈블리의 현재 신뢰 수준에 따라 달라 집니다. 어셈블리를 부분적으로 신뢰할 수 있는 응용 프로그램 도메인 (예: 샌드박스 응용 프로그램 도메인)에 로드 하는 경우 런타임은 어셈블리의 보안 주석을 무시 합니다. 어셈블리 및 모든 해당 형식은 투명 하 게 처리 됩니다. 런타임이 해당 어셈블리를 완전히 신뢰할 수 있는 응용 프로그램 도메인 (예를 들어, 데스크톱 응용 프로그램의 기본 응용 프로그램 도메인)에 로드 되는 경우에 부분 신뢰 어셈블리의 보안 주석에 주의 지불 합니다. 반면, 신뢰할 수 있는 어셈블리 (즉, 강력한 이름의 어셈블리를 전역 어셈블리 캐시에 설치 된)를 이므로 항상 응용 프로그램 도메인의 신뢰 수준에 관계 없이 완전 신뢰를 사용 하 여 로드 된 현재 신뢰 수준 항상 완전히 신뢰할 수 있는 합니다. 사용 하 여 현재 신뢰 수준 어셈블리 및 응용 프로그램 도메인을 확인할 수 있습니다 합니다 <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> 고 <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> 속성입니다.  
  
 리플렉션 및 투명도 대 한 자세한 내용은 참조 하세요. [리플렉션의 보안 고려 사항](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)합니다. 투명성에 대 한 정보를 참조 하세요 [보안 변경 내용](~/docs/framework/security/security-changes.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">리플렉션의 보안 고려 사항</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 버전 4.0의 보안 변경 내용</related>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메서드의 이름이 특수한지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드의 이름이 특수하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.MethodAttributes.SpecialName> 비트가 멤버 (예: 속성 접근자와 메서드를 오버 로드할 연산자) 일부 컴파일러에서 특별 한 방식으로 처리 되는 플래그입니다.  
  
   
  
## Examples  
 이 예제에는 사용 방법을 보여 줍니다. <xref:System.Reflection.MethodBase.IsSpecialName%2A> 필터 내부 또는 전용 멤버 목록에서.  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 <see langword="static" />인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드가 <see langword="static" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 멤버를 클래스의 인스턴스 데이터를 암시적으로 참조 수 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVirtual : bool" Usage="System.Reflection.MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드가 <see langword="virtual" />인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메서드가 <see langword="virtual" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가상 멤버는 클래스의 인스턴스 데이터를 참조할 수 있습니다 및 클래스의 인스턴스를 통해 참조 해야 합니다.  
  
 메서드를 재정의할 수 있는지 확인 하지 않았는지 확인 하기에 충분 하 `IsVirtual` 는 `true`합니다. 재정의할, 메서드에 대 한 `IsVirtual` 이어야 합니다 `true` 하 고 <xref:System.Reflection.MethodBase.IsFinal%2A> 여야 합니다 `false`합니다. 예를 들어 메서드 비가상 이며 수 있지만 인터페이스 메서드를 구현 합니다. 공용 언어 런타임에서 인터페이스 멤버를 구현 하는 모든 메서드를 표시 합니다 필요 `virtual`따라서 컴파일러는 메서드 표시 `virtual final`합니다. 메서드가로 표시 되어 있는 경우 되므로 `virtual` 되지만 재정의할 수는 없습니다.  
  
 메서드는 재정의할 수 있는지 여부를 확실 하 게 설정 하 고, 이와 같은 코드를 사용 합니다.  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 하는 경우 `IsVirtual` 됩니다 `false` 또는 `IsFinal` 는 `true`, 다음 메서드를 재정의할 수 없습니다.  
  
 현재 메서드를 호출 하 여 기본 클래스의 메서드를 재정의 하는지 여부를 확인할 수 있습니다는 <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> 메서드. 다음 예제에서는 구현 하는 `IsOverride` 이 작업을 수행 하는 메서드입니다.  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 표시 `false` 에 대 한 `IsFinal`, 하다 고 생각 하 게 될 것입니다 `MyMethod` 재정의할 수 있습니다. 코드 인쇄 `false` 하더라도 `MyMethod` 표시 되지 않는 `virtual` 재정의할 수 없습니다.  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.MethodBase.MethodHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드의 내부 메타데이터 표현에 대한 핸들을 가져옵니다.</summary>
        <value><see cref="T:System.RuntimeMethodHandle" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들은는 가져온 응용 프로그램 도메인 에서만 유효 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메서드 구현의 특성을 지정하는 <see cref="T:System.Reflection.MethodImplAttributes" /> 플래그를 가져옵니다.</summary>
        <value>메서드 구현 플래그입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Reflection.MethodBase" /> 개체가 같은지를 나타냅니다.</summary>
        <returns><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodBase * System.Reflection.MethodBase -&gt; bool" Usage="System.Reflection.MethodBase.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">비교할 첫 번째 개체입니다.</param>
        <param name="right">비교할 두 번째 개체입니다.</param>
        <summary>두 <see cref="T:System.Reflection.MethodBase" /> 개체가 같지 않은지를 나타냅니다.</summary>
        <returns><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="rgszNames">매핑할 전달된 이름의 배열입니다.</param>
        <param name="cNames">매핑할 이름의 수입니다.</param>
        <param name="lcid">이름을 해석할 로캘 컨텍스트입니다.</param>
        <param name="rgDispId">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</param>
        <summary>이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />를 참조하세요.</summary>
        <returns>이 멤버에 대한 설명은 <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />를 참조하세요.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">반환할 형식 정보입니다.</param>
        <param name="lcid">형식 정보의 로캘 식별자입니다.</param>
        <param name="ppTInfo">요청된 형식 정보 개체에 대한 포인터를 받습니다.</param>
        <summary>인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</param>
        <summary>개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">멤버를 식별합니다.</param>
        <param name="riid">나중에 사용하기 위해 예약되어 있습니다. IID_NULL이어야 합니다.</param>
        <param name="lcid">인수를 해석할 로캘 컨텍스트입니다.</param>
        <param name="wFlags">호출의 컨텍스트를 설명하는 플래그입니다.</param>
        <param name="pDispParams">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="pVarResult">결과를 저장할 위치에 대한 포인터입니다.</param>
        <param name="pExcepInfo">예외 정보가 포함된 구조체에 대한 포인터입니다.</param>
        <param name="puArgErr">오류가 있는 첫 번째 인수의 인덱스입니다.</param>
        <summary>개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스에는 하며 관리 코드에서 호출할 수 없습니다. 에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsConstructor { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsFinal { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsHideBySig { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Runtime::InteropServices::_MethodBase::IsVirtual { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />를 참조하세요.</summary>
        <value>이 멤버에 대한 설명은 <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />를 참조하세요.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Reflection.MethodBase> 인스턴스가 <xref:System.Runtime.InteropServices._MethodBase> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>