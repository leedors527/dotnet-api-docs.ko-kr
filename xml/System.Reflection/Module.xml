<Type Name="Module" FullName="System.Reflection.Module">
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="04957-101">모듈에 대한 리플렉션을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-101">Performs reflection on a module.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-102">모듈은.dll 또는 클래스와 인터페이스를 하나 이상으로 이루어진 application.exe 같은 이식 가능한 실행 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-102">A module is a portable executable file, such as type.dll or application.exe, consisting of one or more classes and interfaces.</span></span> <span data-ttu-id="04957-103">하나의 모듈에는 여러 개의 네임스페이스가 있을 수 있으며 네임스페이스는 여러 개의 모듈로 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-103">There may be multiple namespaces contained in a single module, and a namespace may span multiple modules.</span></span>  
  
 <span data-ttu-id="04957-104">한 단위로 배치된 하나 이상의 모듈이 어셈블리를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-104">One or more modules deployed as a unit compose an assembly.</span></span> <span data-ttu-id="04957-105">둘 이상의 모듈 된 어셈블리를 만드는 방법은 참조 [다중 파일 어셈블리](~/docs/framework/app-domains/multifile-assemblies.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-105">For information about creating an assembly with more than one module, see [Multifile Assemblies](~/docs/framework/app-domains/multifile-assemblies.md).</span></span>  
  
 <span data-ttu-id="04957-106">.NET Framework 모듈 함수 및 응용 프로그램에서 서브루틴을 구성 하는 프로그래머에 사용 되는 Visual Basic의 모듈와 동일 하지 않은지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-106">Note that a .NET Framework module is not the same as a module in Visual Basic, which is used by a programmers to organize functions and subroutines in an application.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-107">다음 코드 예제에서는 모듈에 대 한 정보를 가져오려면 리플렉션을 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="04957-107">The following code examples show how to use reflection to get information about modules:</span></span>  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="04957-108">상속자에 대 한 완전 신뢰 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-108">for full trust for inheritors.</span></span> <span data-ttu-id="04957-109">부분적으로 신뢰할 수 있는 코드에서이 클래스는 상속 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-109">This class cannot be inherited by partially trusted code.</span></span></permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-110"><see cref="T:System.Reflection.Module" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-110">Initializes a new instance of the <see cref="T:System.Reflection.Module" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-111">생성 하는 동안이 생성자는 파생된 클래스에서 호출 <xref:System.Reflection.Module> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-111">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Module> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-112"><see cref="T:System.Reflection.Assembly" />의 이 인스턴스에 적합한 <see cref="T:System.Reflection.Module" />를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-112">Gets the appropriate <see cref="T:System.Reflection.Assembly" /> for this instance of <see cref="T:System.Reflection.Module" />.</span></span></summary>
        <value><span data-ttu-id="04957-113"><see langword="Assembly" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-113">An <see langword="Assembly" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-114">다음 예제에서는 지정된 된 모듈에 지정된 된 어셈블리의 전체 이름을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-114">The following example displays the full name of the specified assembly in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-115">이 모듈의 사용자 지정 특성을 포함하는 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-115">Gets a collection that contains this module's custom attributes.</span></span></summary>
        <value><span data-ttu-id="04957-116">이 모듈의 사용자 지정 특성을 포함하는 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-116">A collection that contains this module's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="04957-117">이 인스턴스와 비교할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-117">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="04957-118">이 모듈과 지정된 개체가 서로 같은지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-118">Determines whether this module and the specified object are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="04957-119"><see langword="true" />가 이 인스턴스와 같으면 <paramref name="o" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-119"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-120">이름을 기준으로 이 모듈에 정의된 형식의 목록을 필터링하는 <see langword="TypeFilter" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-120">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="04957-121">이 필드는 대/소문자를 구분하며 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-121">This field is case-sensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-122">필터는 후행 지원 "\*" 와일드 카드입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-122">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-123">다음 예제에서는 지정된 된 검색 조건과 일치 하는 모듈 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-123">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-124">이름을 기준으로 이 모듈에 정의된 형식의 목록을 필터링하는 <see langword="TypeFilter" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-124">A <see langword="TypeFilter" /> object that filters the list of types defined in this module based upon the name.</span></span> <span data-ttu-id="04957-125">이 필드는 대/소문자를 구분하며 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-125">This field is case-insensitive and read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-126">필터는 후행 지원 "\*" 와일드 카드입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-126">The filter supports a trailing "\*" wildcard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-127">다음 예제에서는 대/소문자를 무시 합니다. 지정 된 검색 조건과 일치 하는 모듈 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-127">The following example displays the module names that match the specified search criteria, ignoring the case.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="04957-128">클래스를 필터링하는 데 사용되는 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-128">The delegate used to filter the classes.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="04957-129">클래스를 필터링하는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-129">An Object used to filter the classes.</span></span></param>
        <summary><span data-ttu-id="04957-130">지정한 필터 및 필터 조건에서 허용하는 클래스 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-130">Returns an array of classes accepted by the given filter and filter criteria.</span></span></summary>
        <returns><span data-ttu-id="04957-131">필터가 허용한 클래스를 포함하는 <see langword="Type" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-131">An array of type <see langword="Type" /> containing classes that were accepted by the filter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-132"><xref:System.Reflection.ReflectionTypeLoadException> 특별 한 종류 로드 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-132"><xref:System.Reflection.ReflectionTypeLoadException> is a special class load exception.</span></span> <span data-ttu-id="04957-133">`ReflectionTypeLoadException.Types` 속성 로드 된 모듈에 정의 된 클래스의 배열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-133">The `ReflectionTypeLoadException.Types` property contains the array of classes that were defined in the module and were loaded.</span></span> <span data-ttu-id="04957-134">이 배열은 null 값을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-134">This array may contain some null values.</span></span> <span data-ttu-id="04957-135">`ReflectionTypeLoadException.LoaderExceptions` 속성은 예외 클래스 로더에 의해 throw 된 예외를 나타내는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-135">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the class loader.</span></span> <span data-ttu-id="04957-136">클래스 배열에 있는 구멍 제외 하 고 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-136">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="04957-137">제공한 대리자 `filter` 따라 전달 모듈에서 각 클래스에 대해 호출 됩니다는 `Type` 클래스를 나타내는 개체와 지정 된 `filterCriteria`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-137">The delegate given by `filter` is called for each class in the module, passing along the `Type` object representing the class as well as the given `filterCriteria`.</span></span> <span data-ttu-id="04957-138">경우 `filter` 반환 특정 클래스, 클래스는 반환된 된 배열에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-138">If `filter` returns a particular class, that class will be included in the returned array.</span></span> <span data-ttu-id="04957-139">경우 `filter` 반환 `null`, 반환 된 모든 클래스 및 `filterCriteria` 는 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-139">If `filter` returns `null`, all classes are returned and `filterCriteria` is ignored.</span></span>  
  
 <span data-ttu-id="04957-140">`FindTypes` 배열과 같은 매개 변수가 있는 형식을 조회에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-140">`FindTypes` cannot be used to look up parameterized types such as arrays.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-141">다음 예제는 `FindTypes` 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-141">The following example demonstrates the `FindTypes` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="04957-142">모듈에 있는 하나 이상의 클래스를 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-142">One or more classes in a module could not be loaded.</span></span></exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-143">이 모듈의 정규화된 이름과 경로를 나타내는 문자열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-143">Gets a string representing the fully qualified name and path to this module.</span></span></summary>
        <value><span data-ttu-id="04957-144">정규화된 모듈 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-144">The fully qualified module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-145">경로가 없는 이름을 가져오려면 <xref:System.Reflection.Module.Name%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-145">To get the name without the path, use <xref:System.Reflection.Module.Name%2A>.</span></span>  
  
 <span data-ttu-id="04957-146">이 모듈에 대 한 어셈블리가 바이트 배열에서 로드 된 경우 하면 `FullyQualifiedName` 모듈 됩니다: \<알 수 없음 >.</span><span class="sxs-lookup"><span data-stu-id="04957-146">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-147">모듈 이름은 대/소문자는 플랫폼에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="04957-147">The case of module name is platform-dependent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-148">다음 예제에서는 지정된 된 모듈의 정규화 된 이름이 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-148">The following example displays the fully qualified name of the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04957-149">호출자에게 필요한 사용 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-149">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="04957-150">경로에 대 한 정보에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-150">for access to information in the path.</span></span> <span data-ttu-id="04957-151">연관된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="04957-151">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-152">사용자 지정 특성을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-152">Returns custom attributes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="04957-153">이 인수는 이 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-153">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="04957-154">모든 사용자 지정 특성을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-154">Returns all custom attributes.</span></span></summary>
        <returns><span data-ttu-id="04957-155">모든 사용자 지정 특성을 포함하는 <see langword="Object" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-155">An array of type <see langword="Object" /> containing all custom attributes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-156">다음 예제에서는 지정된 된 검색 조건과 일치 하는 모듈 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-156">The following example displays the module names that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="04957-157">가져올 특성의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-157">The type of attribute to get.</span></span></param>
        <param name="inherit"><span data-ttu-id="04957-158">이 인수는 이 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-158">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="04957-159">지정한 형식의 사용자 지정 특성을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-159">Gets custom attributes of the specified type.</span></span></summary>
        <returns><span data-ttu-id="04957-160">지정된 형식의 모든 사용자 지정 특성을 포함하는 <see langword="Object" /> 형식의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-160">An array of type <see langword="Object" /> containing all custom attributes of the specified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-161">다음 예제에서는 지정된 된 검색 조건과 일치 하는 지정 된 형식의 모듈 이름을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-161">The following example displays the module names of the specified type that match the specified search criteria.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-162"><paramref name="attributeType" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-162"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-163"><paramref name="attributeType" />이 런타임에 제공되는 <see cref="T:System.Type" /> 개체가 아닌 경우.</span><span class="sxs-lookup"><span data-stu-id="04957-163"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="04957-164">예를 들어 <paramref name="attributeType" />이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체인 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-164">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-165">리플렉션 전용 컨텍스트에서 사용할 수 있는 현재 모듈에 대한 <see cref="T:System.Reflection.CustomAttributeData" /> 개체 목록을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-165">Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects for the current module, which can be used in the reflection-only context.</span></span></summary>
        <returns><span data-ttu-id="04957-166">현재 모듈에 적용된 특성에 대한 데이터를 나타내는 <see cref="T:System.Reflection.CustomAttributeData" /> 개체의 제네릭 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-166">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-167">리플렉션 전용 컨텍스트에 사용자 지정 특성 자체 리플렉션 전용 컨텍스트로 로드 된 코드에 정의 되어 있는 경우 코드의 한 사용자 지정 특성을 검사 하려면이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-167">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="04957-168">와 같은 메서드 <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> 특성의 인스턴스를 만들기 때문에 이러한 경우에 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-168">Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="04957-169">리플렉션 전용 컨텍스트에서 코드를 실행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-169">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="04957-170">자세한 내용 및 예제 코드에 대 한 참조는 <xref:System.Reflection.CustomAttributeData> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-170">For more information and example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-171">지정한 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-171">Returns a specified field.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-172">필드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-172">The field name.</span></span></param>
        <summary><span data-ttu-id="04957-173">지정된 이름을 갖는 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-173">Returns a field having the specified name.</span></span></summary>
        <returns><span data-ttu-id="04957-174">지정된 이름을 갖는 <see langword="FieldInfo" /> 개체이거나 필드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-174">A <see langword="FieldInfo" /> object having the specified name, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04957-175"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-175">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-176">필드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-176">The field name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04957-177">검색을 제어하는 데 사용되는 <see langword="BindingFlags" /> 비트 플래그 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-177">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <summary><span data-ttu-id="04957-178">지정된 이름 및 바인딩 특성을 갖는 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-178">Returns a field having the specified name and binding attributes.</span></span></summary>
        <returns><span data-ttu-id="04957-179">지정된 이름을 갖는 <see langword="FieldInfo" /> 개체이거나 필드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-179">A <see langword="FieldInfo" /> object having the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04957-180"><paramref name="name" /> 매개 변수가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-180">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-181">모듈에 정의된 전역 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-181">Returns the global fields defined on the module.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-182">모듈에 정의된 전역 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-182">Returns the global fields defined on the module.</span></span></summary>
        <returns><span data-ttu-id="04957-183">모듈에 정의된 전역 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체의 배열입니다. 전역 필드가 없으면 빈 배열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-183">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-184"><xref:System.Reflection.Module.GetFields%2A> 메서드 반환 하지 않습니다 필드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-184">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="04957-185">이 순서는 달라질 수 있으므로 코드 필드가 반환 되는 순서에 종속 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-185">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="04957-186">검색을 제한하는 <see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-186">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="04957-187">지정된 바인딩 플래그와 일치하는 모듈에 정의된 전역 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-187">Returns the global fields defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="04957-188">지정된 바인딩 플래그와 일치하는 모듈에 정의된 전역 필드를 나타내는 형식 <see cref="T:System.Reflection.FieldInfo" />의 배열입니다. 바인딩 플래그와 일치하는 전역 필드가 없으면 빈 배열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-188">An array of type <see cref="T:System.Reflection.FieldInfo" /> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-189"><xref:System.Reflection.Module.GetFields%2A> 메서드 반환 하지 않습니다 필드는 특정 순서로 같은 알파벳 또는 선언 순서 대로 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-189">The <xref:System.Reflection.Module.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="04957-190">이 순서는 달라질 수 있으므로 코드 필드가 반환 되는 순서에 종속 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-190">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-191">이 인스턴스의 해시 코드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-191">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="04957-192">부호 있는 32비트 정수 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-192">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-193">지정한 조건이 있는 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-193">Returns a method having the specified criteria.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-194">메서드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-194">The method name.</span></span></param>
        <summary><span data-ttu-id="04957-195">지정된 이름이 있는 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-195">Returns a method having the specified name.</span></span></summary>
        <returns><span data-ttu-id="04957-196">지정된 이름을 갖는 <see langword="MethodInfo" /> 개체이거나 메서드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-196">A <see langword="MethodInfo" /> object having the specified name, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-197"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-197"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-198">메서드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-198">The method name.</span></span></param>
        <param name="types"><span data-ttu-id="04957-199">검색할 매개 변수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-199">The parameter types to search for.</span></span></param>
        <summary><span data-ttu-id="04957-200">지정된 이름과 매개 변수 형식이 있는 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-200">Returns a method having the specified name and parameter types.</span></span></summary>
        <returns><span data-ttu-id="04957-201">지정된 조건에 따르는 <see langword="MethodInfo" /> 개체입니다. 또는 메서드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-201">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-202"><paramref name="name" />이 <see langword="null" />이거나, <paramref name="types" />가 <see langword="null" />이거나, <paramref name="types" />(i)가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-202"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-203">메서드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-203">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04957-204">검색을 제어하는 데 사용되는 <see langword="BindingFlags" /> 비트 플래그 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-204">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="04957-205"><see langword="Binder" />를 구현하는 개체로, 이 메서드와 관련된 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-205">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="04957-206">메서드의 호출 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-206">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="04957-207">검색할 매개 변수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-207">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="04957-208">바인딩을 형식이 수정된 매개 변수 서명과 함께 작동하도록 만드는 데 사용되는 매개 변수 한정자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-208">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="04957-209">지정된 이름, 바인딩 정보, 호출 규칙, 매개 변수 형식 및 한정자가 있는 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-209">Returns a method having the specified name, binding information, calling convention, and parameter types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="04957-210">지정된 조건에 따르는 <see langword="MethodInfo" /> 개체입니다. 또는 메서드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-210">A <see langword="MethodInfo" /> object in accordance with the specified criteria, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-211"><paramref name="name" />이 <see langword="null" />이거나, <paramref name="types" />가 <see langword="null" />이거나, <paramref name="types" />(i)가 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-211"><paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or <paramref name="types" /> (i) is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04957-212">메서드 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-212">The method name.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04957-213">검색을 제어하는 데 사용되는 <see langword="BindingFlags" /> 비트 플래그 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-213">One of the <see langword="BindingFlags" /> bit flags used to control the search.</span></span></param>
        <param name="binder"><span data-ttu-id="04957-214"><see langword="Binder" />를 구현하는 개체로, 이 메서드와 관련된 속성을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-214">An object that implements <see langword="Binder" />, containing properties related to this method.</span></span></param>
        <param name="callConvention"><span data-ttu-id="04957-215">메서드의 호출 규칙입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-215">The calling convention for the method.</span></span></param>
        <param name="types"><span data-ttu-id="04957-216">검색할 매개 변수 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-216">The parameter types to search for.</span></span></param>
        <param name="modifiers"><span data-ttu-id="04957-217">바인딩을 형식이 수정된 매개 변수 서명과 함께 작동하도록 만드는 데 사용되는 매개 변수 한정자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-217">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</span></span></param>
        <summary><span data-ttu-id="04957-218">지정한 기준을 만족하는 메서드 구현을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-218">Returns the method implementation in accordance with the specified criteria.</span></span></summary>
        <returns><span data-ttu-id="04957-219">지정된 구현 정보가 포함된 <see langword="MethodInfo" /> 개체이거나, 해당 메서드가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-219">A <see langword="MethodInfo" /> object containing implementation information as specified, or <see langword="null" /> if the method does not exist.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="04957-220"><paramref name="types" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-220"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-221">모듈에 정의된 전역 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-221">Returns the global methods defined on the module</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-222">모듈에 정의된 전역 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-222">Returns the global methods defined on the module.</span></span></summary>
        <returns><span data-ttu-id="04957-223">모듈에 정의된 모든 전역 메서드를 나타내는 <see cref="T:System.Reflection.MethodInfo" /> 개체의 배열입니다. 전역 메서드가 없으면 빈 배열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-223">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags"><span data-ttu-id="04957-224">검색을 제한하는 <see cref="T:System.Reflection.BindingFlags" /> 값의 비트 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limit the search.</span></span></param>
        <summary><span data-ttu-id="04957-225">지정된 바인딩 플래그와 일치하는 모듈에 정의된 전역 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-225">Returns the global methods defined on the module that match the specified binding flags.</span></span></summary>
        <returns><span data-ttu-id="04957-226">지정된 바인딩 플래그와 일치하는 모듈에 정의된 전역 메서드를 나타내는 형식 <see cref="T:System.Reflection.MethodInfo" />의 배열입니다. 바인딩 플래그와 일치하는 전역 메서드가 없으면 빈 배열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-226">An array of type <see cref="T:System.Reflection.MethodInfo" /> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="04957-227">개체의 serialization 또는 deserialization에 필요한 정보와 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-227">The information and data needed to serialize or deserialize an object.</span></span></param>
        <param name="context"><span data-ttu-id="04957-228">serialization에 대한 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-228">The context for the serialization.</span></span></param>
        <summary><span data-ttu-id="04957-229">serialize된 개체에 <see cref="T:System.Runtime.Serialization.ISerializable" />을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-229">Provides an <see cref="T:System.Runtime.Serialization.ISerializable" /> implementation for serialized objects.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-230"><paramref name="info" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04957-231">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-231">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="04957-232">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind"><span data-ttu-id="04957-233">이 메서드가 반환될 때 모듈의 코드 특성을 나타내는 <see cref="T:System.Reflection.PortableExecutableKinds" /> 값의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-233">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</span></span></param>
        <param name="machine"><span data-ttu-id="04957-234">이 메서드가 반환될 때 모듈의 대상 플랫폼을 나타내는 <see cref="T:System.Reflection.ImageFileMachine" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-234">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</span></span></param>
        <summary><span data-ttu-id="04957-235">모듈의 코드 특성과 대상 플랫폼을 나타내는 값 쌍을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-235">Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-236">이 모듈이 속한 어셈블리의 Authenticode 서명에 포함된 인증서에 해당하는 <see langword="X509Certificate" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-236">Returns an <see langword="X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to.</span></span> <span data-ttu-id="04957-237">어셈블리가 Authenticode로 서명되지 않은 경우에는 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-237">If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</span></span></summary>
        <returns><span data-ttu-id="04957-238"><see langword="X509Certificate" /> 개체를 반환하거나 이 모듈이 속한 어셈블리가 Authenticode로 서명되지 않은 경우에는 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-238">An <see langword="X509Certificate" /> object, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-239">지정된 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-239">Returns the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="04957-240">찾을 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-240">The name of the type to locate.</span></span> <span data-ttu-id="04957-241">이름은 네임스페이스를 포함하는 정규화된 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-241">The name must be fully qualified with the namespace.</span></span></param>
        <summary><span data-ttu-id="04957-242">대/소문자 구분을 수행하여 지정된 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-242">Returns the specified type, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="04957-243">형식이 이 모듈에 있으면 지정된 형식을 나타내는 <see langword="Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-243">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04957-244">형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-244">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="04957-245">형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-245">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="04957-246">형식을 사용 하 여 특정 모듈에서 검색할 수 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-246">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04957-247">호출 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> 매니페스트가 포함 된 모듈에 전체 어셈블리를 검색 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-247">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="04957-248">어떤 있는 모듈을이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-248">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-249">다음 예제에서는 지정된 된 모듈의 형식 이름을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-249">The following example displays the name of a type in the specified module.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-250"><paramref name="className" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-250"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="04957-251">클래스 이니셜라이저가 호출되고 예외를 throw되는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-251">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-252"><paramref name="className" />이 길이가 0인 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-252"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="04957-253"><paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-253"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="04957-254"><paramref name="className" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-254"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="04957-255">또는</span><span class="sxs-lookup"><span data-stu-id="04957-255">-or-</span></span>  
  
 <span data-ttu-id="04957-256">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-256">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="04957-257"><paramref name="className" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="04957-257"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="04957-258">또는</span><span class="sxs-lookup"><span data-stu-id="04957-258">-or-</span></span>  
  
 <span data-ttu-id="04957-259"><paramref name="className" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-259"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="04957-260">찾을 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-260">The name of the type to locate.</span></span> <span data-ttu-id="04957-261">이름은 네임스페이스를 포함하는 정규화된 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-261">The name must be fully qualified with the namespace.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="04957-262">대/소문자를 구분하지 않는 검색의 경우는 <see langword="true" />이고 대/소문자를 구분하는 검색의 경우는 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-262"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="04957-263">지정된 형식을 반환하고 지정된 대/소문자를 사용하여 모듈을 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-263">Returns the specified type, searching the module with the specified case sensitivity.</span></span></summary>
        <returns><span data-ttu-id="04957-264">형식이 이 모듈에 있으면 지정된 형식을 나타내는 <see langword="Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-264">A <see langword="Type" /> object representing the given type, if the type is in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04957-265">형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-265">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="04957-266">형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-266">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="04957-267">형식을 사용 하 여 특정 모듈에서 검색할 수 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-267">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04957-268">호출 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> 매니페스트가 포함 된 모듈에 전체 어셈블리를 검색 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-268">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="04957-269">어떤 있는 모듈을이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-269">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-270">다음 예제에서는 지정된 된 모듈에는 형식의 이름을 표시 지정 `false` 에 대 한는 `ignoreCase` 하도록 하 여 사용할 경우 무시 되지 것입니다. 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-270">The following example displays the name of a type in the specified module, specifying `false` for the `ignoreCase` parameter so that case will not be ignored.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-271"><paramref name="className" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-271"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="04957-272">클래스 이니셜라이저가 호출되고 예외를 throw되는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-272">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-273"><paramref name="className" />이 길이가 0인 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-273"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="04957-274"><paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-274"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="04957-275"><paramref name="className" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-275"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="04957-276">또는</span><span class="sxs-lookup"><span data-stu-id="04957-276">-or-</span></span>  
  
 <span data-ttu-id="04957-277">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-277">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="04957-278"><paramref name="className" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="04957-278"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="04957-279">또는</span><span class="sxs-lookup"><span data-stu-id="04957-279">-or-</span></span>  
  
 <span data-ttu-id="04957-280"><paramref name="className" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-280"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className"><span data-ttu-id="04957-281">찾을 형식의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-281">The name of the type to locate.</span></span> <span data-ttu-id="04957-282">이름은 네임스페이스를 포함하는 정규화된 이름이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-282">The name must be fully qualified with the namespace.</span></span></param>
        <param name="throwOnError">
          <span data-ttu-id="04957-283">형식을 찾을 수 없는 경우 예외를 throw하려면 <see langword="true" />이고, <see langword="false" />을 반환하려면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-283"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase">
          <span data-ttu-id="04957-284">대/소문자를 구분하지 않는 검색의 경우는 <see langword="true" />이고 대/소문자를 구분하는 검색의 경우는 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-284"><see langword="true" /> for case-insensitive search; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="04957-285">모듈을 검색할 때 대/소문자를 구분할지 여부와 형식을 찾을 수 없을 때 예외를 throw할지 여부를 지정하여 지정된 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-285">Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</span></span></summary>
        <returns><span data-ttu-id="04957-286">지정된 형식이 이 모듈에 선언된 경우 해당 형식을 나타내는 <see cref="T:System.Type" /> 개체이고, 그렇지 않으면 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-286">A <see cref="T:System.Type" /> object representing the specified type, if the type is declared in this module; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-287">`throwOnError` 매개 변수 형식의 찾을 수 없을 때의 결과만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="04957-287">The `throwOnError` parameter affects only what happens when the type is not found.</span></span> <span data-ttu-id="04957-288">다른 모든 예외가 throw 될 수 있는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-288">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="04957-289">특히, 형식을 찾았지만 로드할 수 없으면 <xref:System.TypeLoadException> throw 될 수 있는 경우에 `throwOnError` 은 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-289">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-290">형식을 다른 어셈블리에 전달 되었습니다, 하더라도이 메서드에 의해 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-290">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="04957-291">형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-291">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="04957-292">형식을 사용 하 여 특정 모듈에서 검색할 수 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-292">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04957-293">호출 <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> 매니페스트가 포함 된 모듈에 전체 어셈블리를 검색 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-293">Calling <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> on the module that contains the manifest will not search the entire assembly.</span></span> <span data-ttu-id="04957-294">어떤 있는 모듈을이 어셈블리에서 형식을 검색 하려면 <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-294">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-295">다음 예제에서는 지정된 된 모듈의 형식 이름을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-295">The following example displays the name of a type in the specified module.</span></span> <span data-ttu-id="04957-296">`throwOnError` 및 `ignoreCase` 으로 매개 변수가 지정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-296">The `throwOnError` and `ignoreCase` parameters are specified as `false`.</span></span>  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-297"><paramref name="className" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-297"><paramref name="className" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="04957-298">클래스 이니셜라이저가 호출되고 예외를 throw되는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-298">The class initializers are invoked and an exception is thrown.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-299"><paramref name="className" />이 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-299"><paramref name="className" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="04957-300"><paramref name="throwOnError" />가 <see langword="true" />이고 형식을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-300"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="04957-301"><paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리를 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-301"><paramref name="className" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="04957-302"><paramref name="className" />에 종속 어셈블리가 필요하며 이 어셈블리를 찾았지만 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-302"><paramref name="className" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
 <span data-ttu-id="04957-303">또는</span><span class="sxs-lookup"><span data-stu-id="04957-303">-or-</span></span>  
  
 <span data-ttu-id="04957-304">현재 어셈블리가 리플렉션 전용 컨텍스트에 로드되었으며 <paramref name="className" />에 종속 어셈블리가 필요하지만 이 어셈블리가 미리 로드되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-304">The current assembly was loaded into the reflection-only context, and <paramref name="className" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="04957-305"><paramref name="className" />에 종속 어셈블리가 필요하지만 파일이 유효한 어셈블리가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="04957-305"><paramref name="className" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
 <span data-ttu-id="04957-306">또는</span><span class="sxs-lookup"><span data-stu-id="04957-306">-or-</span></span>  
  
 <span data-ttu-id="04957-307"><paramref name="className" />에 현재 로드된 버전보다 높은 런타임 버전용으로 컴파일된 종속 어셈블리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-307"><paramref name="className" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-308">이 모듈 내에 정의된 모든 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-308">Returns all the types defined within this module.</span></span></summary>
        <returns><span data-ttu-id="04957-309">이 인스턴스에서 리플렉트된 모듈 내에 정의된 형식을 포함하는 형식 <see langword="Type" />의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-309">An array of type <see langword="Type" /> containing types defined within the module that is reflected by this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-310">`ReflectionTypeLoadException` 특별 한 로드 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-310">`ReflectionTypeLoadException` is a special load exception.</span></span> <span data-ttu-id="04957-311">`ReflectionTypeLoadException.Types` 속성 모듈에 정의 된 하 고 로드 된 형식의 배열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-311">The `ReflectionTypeLoadException.Types` property contains the array of types that were defined in the module and were loaded.</span></span> <span data-ttu-id="04957-312">이 배열은 null 값을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-312">This array may contain some null values.</span></span> <span data-ttu-id="04957-313">`ReflectionTypeLoadException.LoaderExceptions` 속성은 예외 로더에 의해 throw 된 예외를 나타내는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-313">The `ReflectionTypeLoadException.LoaderExceptions` property is an array of exceptions that represent the exceptions that were thrown by the loader.</span></span> <span data-ttu-id="04957-314">클래스 배열에 있는 구멍 제외 하 고 정렬 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-314">The holes in the class array line up with the exceptions.</span></span>  
  
 <span data-ttu-id="04957-315">예를 들어 클래스 중 하나의 클래스 이니셜라이저가 throw 하는 동안 예외가 되 고 로드 한 `TargetInvocationException` 의 해당 요소에 저장 됩니다는 `LoaderExceptions` 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-315">For example, if the class initializers of one of the classes throws an exception while it is being loaded, a `TargetInvocationException` is stored in the corresponding element of the `LoaderExceptions` array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-316">형식을 다른 어셈블리에 전달 되었습니다, 반환된 된 배열에 포함 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-316">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="04957-317">형식 전달에 대 한 정보를 참조 하십시오. [공용 언어 런타임에서 형식 전달](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-317">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="04957-318">모듈에 있는 하나 이상의 클래스를 로드할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-318">One or more classes in a module could not be loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="04957-319">호출자에게 필요한 권한이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-319">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="04957-320">현재 모듈에 대 한 리플렉션 권한입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-320">Reflection permission for the current module.</span></span></permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="04957-321">테스트할 사용자 지정 특성의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-321">The type of custom attribute to test for.</span></span></param>
        <param name="inherit"><span data-ttu-id="04957-322">이 인수는 이 형식의 개체에 대해 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-322">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="04957-323">이 모듈에 지정된 특성 형식이 적용되었는지 여부를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-323">Returns a value that indicates whether the specified attribute type has been applied to this module.</span></span></summary>
        <returns>
          <span data-ttu-id="04957-324">하나 이상의 <paramref name="attributeType" /> 인스턴스가 이 모듈에 적용되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-324"><see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-325">다음 예제에서는 사용 하는 `IsDefined` 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-325">The following example demonstrates a use of the `IsDefined` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="04957-326"><paramref name="attributeType" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-326"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-327"><paramref name="attributeType" />이 런타임에 제공되는 <see cref="T:System.Type" /> 개체가 아닌 경우.</span><span class="sxs-lookup"><span data-stu-id="04957-327"><paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime.</span></span> <span data-ttu-id="04957-328">예를 들어 <paramref name="attributeType" />이 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 개체인 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-328">For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-329">이 개체가 리소스인지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-329">Gets a value indicating whether the object is a resource.</span></span></summary>
        <returns>
          <span data-ttu-id="04957-330">이 개체가 리소스이면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-330"><see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-331">다음 예제에서는 사용 하는 `IsResource` 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-331">The following example demonstrates a use of the `IsResource` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-332">메타데이터 스트림 버전을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-332">Gets the metadata stream version.</span></span></summary>
        <value><span data-ttu-id="04957-333">메타데이터 스트림 버전을 나타내는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-333">A 32-bit integer representing the metadata stream version.</span></span> <span data-ttu-id="04957-334">두 개의 상위 바이트는 주 버전 번호를 나타내고 두 개의 하위 바이트는 부 버전 번호를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="04957-334">The high-order two bytes represent the major version number, and the low-order two bytes represent the minor version number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04957-335">메타 데이터 헤더에 대 한 자세한 내용은 인프라 CLI (공용 언어) 설명서에서 "II: 메타 데이터 정의 및 의미"을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="04957-335">For more information on the metadata header, see "Partition II: Metadata Definition and Semantics" in the Common Language Infrastructure (CLI) documentation.</span></span> <span data-ttu-id="04957-336">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-336">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-337">메타데이터에 있는 모듈을 식별하는 토큰을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-337">Gets a token that identifies the module in metadata.</span></span></summary>
        <value><span data-ttu-id="04957-338">메타데이터에서 현재 모듈을 식별하는 정수 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-338">An integer token that identifies the current module in metadata.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-339">관리 되지 않는 리플렉션 API에이 속성을 사용 하 여 얻은 토큰을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-339">The tokens obtained using this property can be passed to the unmanaged Reflection API.</span></span> <span data-ttu-id="04957-340">자세한 내용은 참조 [관리 되지 않는 리플렉션 API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-340">For more information, see [Unmanaged Reflection API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-341">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-341">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-342">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-342">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-343">모듈에 대한 핸들을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-343">Gets a handle for the module.</span></span></summary>
        <value><span data-ttu-id="04957-344">현재 모듈에 대한 <see cref="T:System.ModuleHandle" /> 구조체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-344">A <see cref="T:System.ModuleHandle" /> structure for the current module.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-345">모듈의 두 버전 간을 구분하는 데 사용할 수 있는 UUID(범용 고유 식별자)를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-345">Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</span></span></summary>
        <value><span data-ttu-id="04957-346">모듈의 두 버전 간을 구분하는 데 사용할 수 있는 <see cref="T:System.Guid" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-346">A <see cref="T:System.Guid" /> that can be used to distinguish between two versions of a module.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-347">관리 되지 않는 메타 데이터에 의해 반환 하는 GUID는 <xref:System.Reflection.Module.ModuleVersionId%2A> 으로 속성은 참조는 `mvid`, GUID 힙에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-347">In unmanaged metadata, the GUID returned by the <xref:System.Reflection.Module.ModuleVersionId%2A> property is referred to as the `mvid`, and is stored in the GUID heap.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-348">메타 데이터에 대 한 자세한 내용은 "II: 메타 데이터 정의 및 의미" 인프라 CLI (공용 언어) 설명서에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-348">More information about metadata can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-349">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-349">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-350">경로가 제거된 모듈의 이름을 나타내는 <see langword="String" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-350">Gets a <see langword="String" /> representing the name of the module with the path removed.</span></span></summary>
        <value><span data-ttu-id="04957-351">경로가 없는 모듈 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-351">The module name with no path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-352">`Name` 플랫폼 종속 문자열이입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-352">`Name` is a platform-dependent string.</span></span>  
  
 <span data-ttu-id="04957-353">이 모듈에 대 한 어셈블리가 바이트 배열에서 로드 된 경우 하면 `FullyQualifiedName` 모듈 됩니다: \<알 수 없음 >.</span><span class="sxs-lookup"><span data-stu-id="04957-353">If the assembly for this module was loaded from a byte array then the `FullyQualifiedName` for the module will be: \<Unknown>.</span></span>  
  
 <span data-ttu-id="04957-354">이름 및 경로 가져오려면 <xref:System.Reflection.Module.FullyQualifiedName%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-354">To get the name and the path, use <xref:System.Reflection.Module.FullyQualifiedName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-355">이 예제에서는 결과 보여 줍니다.는 `ScopeName`, `FullyQualifiedName`, 및 `Name` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-355">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="04957-356">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-356">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="04957-357">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-357">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="04957-358">두 <see cref="T:System.Reflection.Module" /> 개체가 같은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="04957-358">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are equal.</span></span></summary>
        <returns>
          <span data-ttu-id="04957-359"><see langword="true" />가 <paramref name="left" />와 같으면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-359"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="04957-360">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-360">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="04957-361">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-361">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="04957-362">두 <see cref="T:System.Reflection.Module" /> 개체가 같지 않은지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="04957-362">Indicates whether two <see cref="T:System.Reflection.Module" /> objects are not equal.</span></span></summary>
        <returns>
          <span data-ttu-id="04957-363"><see langword="true" />가 <paramref name="left" />와 다르면 <paramref name="right" />이고, 그러지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-363"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-364">메타데이터 토큰으로 식별되는 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-364">Returns the field identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-365">모듈의 필드를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-365">A metadata token that identifies a field in the module.</span></span></param>
        <summary><span data-ttu-id="04957-366">지정된 메타데이터 토큰으로 식별되는 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-366">Returns the field identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-367">지정된 메타데이터 토큰으로 식별되는 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-367">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-368">부모 필드를 식별 하는 메타 데이터 토큰을 확인 하려면 `TypeSpec` 에 요소 형식이 포함 된 서명이 `ELEMENT_TYPE_VAR` 또는 `ELEMENT_TYPE_MVAR`를 사용 하 여는 <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 필요한 컨텍스트를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-368">To resolve a metadata token that identifies a field whose parent `TypeSpec` has a signature containing element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="04957-369">즉, 제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 제네릭 형식 매개 변수에 의존 하는 필드에 대 한 메타 데이터 토큰을 확인 하는 경우에 해당 형식 매개 변수를 제공할 수 있는 오버 로드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-369">That is, when you are resolving a metadata token for a field that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-370">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-370">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-371">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-371">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="04957-372">제네릭 컨텍스트 (제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 매개 변수)를 사용 하 여 토큰을 확인을 보여 주는 코드에 대 한 참조는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-372">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-373"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 필드의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-373"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-374">또는</span><span class="sxs-lookup"><span data-stu-id="04957-374">-or-</span></span>  
  
 <span data-ttu-id="04957-375"><paramref name="metadataToken" />이 해당 부모 <see langword="TypeSpec" />에 <see langword="var" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="mvar" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처가 있는 필드를 식별하는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-375"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-376"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-376"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-377">모듈의 필드를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-377">A metadata token that identifies a field in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="04957-378">해당 토큰이 범위 내에 있는 형식의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 형식이 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-378">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="04957-379">해당 토큰이 범위 내에 있는 메서드의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드가 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-379">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="04957-380">지정된 제네릭 형식 매개 변수로 정의되는 컨텍스트에서 지정된 메타데이터 토큰으로 식별되는 필드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-380">Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="04957-381">지정된 메타데이터 토큰으로 식별되는 필드를 나타내는 <see cref="T:System.Reflection.FieldInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-381">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-382">사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 형식의 메서드로 여기서 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-382">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-383">사용 하 여는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 방법에 대 한 메서드를 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-383">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-384">필요 하지 않은 경우에 이러한 인수를 지정 하는 항상 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-384">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-385">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-385">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-386">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-386">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="04957-387">제네릭 컨텍스트 (제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 매개 변수)를 사용 하 여 토큰을 확인을 보여 주는 코드에 대 한 참조는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-387">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-388"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 필드의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-388"><paramref name="metadataToken" /> is not a token for a field in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-389">또는</span><span class="sxs-lookup"><span data-stu-id="04957-389">-or-</span></span>  
  
 <span data-ttu-id="04957-390"><paramref name="metadataToken" />이 식별하는 필드의 부모 <see langword="TypeSpec" />이 <see langword="var" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="mvar" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하고, <paramref name="genericTypeArguments" />와 <paramref name="genericMethodArguments" /> 중 하나 또는 둘 다에 대해 필요한 제네릭 형식 인수를 제공하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="04957-390"><paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-391"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-391"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-392">메타데이터 토큰으로 식별되는 형식이나 멤버를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-392">Returns the type or member identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-393">모듈에 있는 형식이나 멤버를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-393">A metadata token that identifies a type or member in the module.</span></span></param>
        <summary><span data-ttu-id="04957-394">지정된 메타데이터 토큰으로 식별되는 형식이나 멤버를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-394">Returns the type or member identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-395">지정된 메타데이터 토큰으로 식별되는 형식이나 멤버를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-395">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-396">에 대 한 메타 데이터 토큰을 확인 하려면는 `MethodSpec` 또는 `TypeSpec` 요소 형식이 포함 된 시그니처 `ELEMENT_TYPE_VAR` 또는 `ELEMENT_TYPE_MVAR`를 사용 하 여는 <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 필요한 컨텍스트를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-396">To resolve a metadata token for a `MethodSpec` or `TypeSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="04957-397">즉, 제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 제네릭 형식 매개 변수에 따라 달라 지는 멤버에 대 한 메타 데이터 토큰을 확인 하는 경우에 해당 형식 매개 변수를 제공할 수 있는 오버 로드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-397">That is, when you are resolving a metadata token for a member that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-398">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-398">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-399">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-399">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="04957-400">제네릭 컨텍스트 (제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 매개 변수)를 사용 하 여 토큰을 확인을 보여 주는 코드에 대 한 참조는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-400">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-401"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 형식이나 멤버의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-401"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-402">또는</span><span class="sxs-lookup"><span data-stu-id="04957-402">-or-</span></span>  
  
 <span data-ttu-id="04957-403"><paramref name="metadataToken" />이 <see langword="MethodSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="TypeSpec" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="var" /> 또는 <see langword="mvar" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-403"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span>  
  
 <span data-ttu-id="04957-404">또는</span><span class="sxs-lookup"><span data-stu-id="04957-404">-or-</span></span>  
  
 <span data-ttu-id="04957-405"><paramref name="metadataToken" />이 속성 또는 이벤트를 식별하는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-405"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-406"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-406"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-407">모듈에 있는 형식이나 멤버를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-407">A metadata token that identifies a type or member in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="04957-408">해당 토큰이 범위 내에 있는 형식의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 형식이 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-408">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="04957-409">해당 토큰이 범위 내에 있는 메서드의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드가 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-409">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="04957-410">지정된 제네릭 형식 매개 변수로 정의되는 컨텍스트에서 지정된 메타데이터 토큰으로 식별되는 형식 또는 멤버를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-410">Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="04957-411">지정된 메타데이터 토큰으로 식별되는 형식이나 멤버를 나타내는 <see cref="T:System.Reflection.MemberInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-411">A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-412">사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 형식의 메서드로 여기서 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-412">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-413">사용 하 여는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 방법에 대 한 메서드를 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-413">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-414">필요 하지 않은 경우에 이러한 인수를 지정 하는 항상 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-414">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-415">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-415">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-416">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="04957-417">제네릭 컨텍스트 (제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 매개 변수)를 사용 하 여 토큰을 확인을 보여 주는 코드에 대 한 참조는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-417">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-418"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 형식이나 멤버의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-418"><paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-419">또는</span><span class="sxs-lookup"><span data-stu-id="04957-419">-or-</span></span>  
  
 <span data-ttu-id="04957-420"><paramref name="metadataToken" />이 <see langword="MethodSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="TypeSpec" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="var" /> 또는 <see langword="mvar" />이고, <paramref name="genericTypeArguments" />와 <paramref name="genericMethodArguments" /> 중 하나 또는 둘 다에 대해 필요한 제네릭 형식 인수를 제공하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="04957-420"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span>  
  
 <span data-ttu-id="04957-421">또는</span><span class="sxs-lookup"><span data-stu-id="04957-421">-or-</span></span>  
  
 <span data-ttu-id="04957-422"><paramref name="metadataToken" />이 속성 또는 이벤트를 식별하는 경우</span><span class="sxs-lookup"><span data-stu-id="04957-422"><paramref name="metadataToken" /> identifies a property or event.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-423"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-423"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-424">메타데이터 토큰으로 식별되는 메서드를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-424">Returns the method identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-425">모듈의 메서드나 생성자를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-425">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <summary><span data-ttu-id="04957-426">지정된 메타데이터 토큰으로 식별되는 메서드나 생성자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-426">Returns the method or constructor identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-427">지정된 메타데이터 토큰으로 식별되는 메서드나 생성자를 나타내는 <see cref="T:System.Reflection.MethodBase" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-427">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-428">에 대 한 메타 데이터 토큰을 확인 하려면는 `MethodSpec` 요소 형식이 포함 된 시그니처 `ELEMENT_TYPE_VAR` 또는 `ELEMENT_TYPE_MVAR`를 사용 하 여는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 필요한 컨텍스트를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-428">To resolve a metadata token for a `MethodSpec` whose signature contains element type `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="04957-429">즉, 제네릭 형식의 제네릭 형식 매개 변수에 따라 달라 지는 메서드 및/또는 토큰이 포함 된 제네릭 메서드에 대 한 메타 데이터 토큰을 확인 하는 경우에 해당 형식 매개 변수를 제공할 수 있는 오버 로드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-429">That is, when you are resolving a metadata token for a method that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-430">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-430">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-431">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-431">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-432">두 오버 로드를 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Reflection.Module.ResolveMethod%2A> 제네릭 및 제네릭이 아닌 컨텍스트에서 사이트 메서드를 호출에서 메타 데이터 토큰을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-432">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="04957-433">코드 예제에서는 두 개의 제네릭 형식 정의 `G1<Tg1>` 및 `G2<Tg2>` (`G1(Of Tg1)` 및 `G2(Of Tg2)` Visual basic에서), 제네릭 메서드가 있으며 각 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-433">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>` (`G1(Of Tg1)` and `G2(Of Tg2)` in Visual Basic), each of which has a generic method.</span></span> <span data-ttu-id="04957-434">`G1<Tg1>` 형식 매개 변수를 사용 하는 제네릭이 아닌 메서드 역시 `Tg1` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-434">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="04957-435">제네릭 메서드 `GM2<Tgm2>` 글꼴로 `G2<Tg2>` 여러 개의 메서드 호출을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-435">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="04957-436">사례 1: 제네릭 메서드 `GM1<Tgm1>` 의 형식 매개 변수를 사용 하 여 호출은 `G2<Tg2>` 및 `GM2<Tgm2>` 형식 인수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-436">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="04957-437">호출 된 메서드의 매개 변수 형식에 대 한 형식 정의에서 폐쇄형된 제네릭 형식을 생성 하는 데 사용 되는 형식에 따라 달라 집니다 즉, `G2<Tg2>`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-437">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="04957-438">사례 2: 제네릭이 아닌 메서드 `M1` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-438">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="04957-439">이 메서드의 매개 변수 정의 형식의 형식 매개 변수를 사용 하 여 `G1<Tg1>`, 바뀌는 경우에 바깥쪽 형식의 형식 매개 변수에 의해 `G2<Tg2>`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-439">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="04957-440">사례 3: 제네릭 메서드 `GM1<Tgm1>` 을 라고 지정 <xref:System.Int32> 및 <xref:System.Object> 제네릭 형식과 제네릭 메서드의 형식 인수에 대 한 각각.</span><span class="sxs-lookup"><span data-stu-id="04957-440">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="04957-441">이 메서드 호출은 바깥쪽 형식 또는 메서드의 형식 매개 변수에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-441">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="04957-442">경우 4: 제네릭이 아닌 메서드 수 `M1` 의 `Example` 클래스 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-442">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="04957-443">이 메서드 호출은 바깥쪽 형식 또는 메서드의 형식 매개 변수에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-443">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="04957-444">또한이 예제에서는 정의 제네릭이 아닌 `Example` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-444">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="04957-445">이 클래스에는 메서드가 `M` 제네릭 메서드를 호출 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-445">This class has a method `M` that makes a call to a generic method:</span></span>  
  
-   <span data-ttu-id="04957-446">경우 5: 제네릭 메서드는 `GM1` 호출을 지정 하 <xref:System.Int32> 및 <xref:System.Object> 제네릭 형식과 제네릭 메서드의 형식 인수에 대 한 각각.</span><span class="sxs-lookup"><span data-stu-id="04957-446">Case 5: The generic method `GM1` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="04957-447">이 메서드에 대 한 컨텍스트는 없는 바깥쪽 제네릭 형식 또는 제네릭 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-447">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="04957-448">각 사례에 대 한 예에서는 먼저 생성 한 <xref:System.Reflection.MethodInfo> 호출된 된 메서드를 나타내며 다음 사용 하 여 토큰을 확인 하는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 에 대 한 값을 가져오는 방법을 `genericTypeArguments` 및 `genericMethodArguments` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-448">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="04957-449">메서드는 반환 하기 때문에이 기술은 모든 경우에 <xref:System.Type.EmptyTypes?displayProperty=nameWithType> 제네릭이 아닌 컨텍스트에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-449">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="04957-450">이 예제는 적용 된 비교 <xref:System.Reflection.MethodInfo> 를 생성 된 <xref:System.Reflection.MethodInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-450">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="04957-451">이 예제에서는 사용 하려고 시도 합니다는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> 메서드 오버 로드는 토큰을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-451">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="04957-452">메서드를 호출 하 여 제네릭 컨텍스트에 종속 되지 않는 때문에 3, 4 및 5, 경우에 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-452">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="04957-453">1 및 2의 경우 토큰을 확인 정보가 부족 하기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-453">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="04957-454">메타 데이터 토큰 값 열거도 하드 코드 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-454">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="04957-455">이 코드 예제를 변경한 경우에 토큰 값은 변경 될 수 있으므로입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-455">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="04957-456">새 토큰 값을 확인 하려면 코드를 컴파일하고 Ildasm.exe를 사용 하 여는 **토큰/** 어셈블리를 검사 하는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-456">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="04957-457">호출 시점에는 토큰을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-457">The tokens can be found at the points of call.</span></span> <span data-ttu-id="04957-458">열거형에 새 값을 삽입 하 고 예제를 다시 컴파일하십시오.</span><span class="sxs-lookup"><span data-stu-id="04957-458">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-459"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 메서드나 생성자의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-459"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-460">또는</span><span class="sxs-lookup"><span data-stu-id="04957-460">-or-</span></span>  
  
 <span data-ttu-id="04957-461"><paramref name="metadataToken" />이 <see langword="MethodSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="var" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="mvar" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-461"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-462"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-462"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-463">모듈의 메서드나 생성자를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-463">A metadata token that identifies a method or constructor in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="04957-464">해당 토큰이 범위 내에 있는 형식의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 형식이 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-464">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="04957-465">해당 토큰이 범위 내에 있는 메서드의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드가 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-465">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="04957-466">지정된 제네릭 형식 매개 변수로 정의되는 컨텍스트에서 지정된 메타데이터 토큰으로 식별되는 메서드 또는 생성자를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-466">Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="04957-467">지정된 메타데이터 토큰으로 식별되는 메서드를 나타내는 <see cref="T:System.Reflection.MethodBase" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-467">A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-468">사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 형식의 메서드로 여기서 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-468">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-469">사용 하 여는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 방법에 대 한 메서드를 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericMethodArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-469">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericMethodArguments`.</span></span> <span data-ttu-id="04957-470">필요 하지 않은 경우에 이러한 인수를 지정 하는 항상 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-470">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-471">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-471">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-472">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-472">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-473">두 오버 로드를 사용 하는 방법을 보여 주는 다음 예제는 <xref:System.Reflection.Module.ResolveMethod%2A> 제네릭 및 제네릭이 아닌 컨텍스트에서 사이트 메서드를 호출에서 메타 데이터 토큰을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-473">The following example shows how to use the two overloads of the <xref:System.Reflection.Module.ResolveMethod%2A> method to resolve metadata tokens from call sites in generic and non-generic contexts.</span></span>  
  
 <span data-ttu-id="04957-474">코드 예제에서는 두 개의 제네릭 형식 정의 `G1<Tg1>` 및 `G2<Tg2>`, 제네릭 메서드가 있으며 각 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-474">The code example defines two generic types, `G1<Tg1>` and `G2<Tg2>`, each of which has a generic method.</span></span> <span data-ttu-id="04957-475">`G1<Tg1>` 형식 매개 변수를 사용 하는 제네릭이 아닌 메서드 역시 `Tg1` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-475">`G1<Tg1>` also has a non-generic method that uses the type parameter `Tg1` for its parameter.</span></span> <span data-ttu-id="04957-476">제네릭 메서드 `GM2<Tgm2>` 글꼴로 `G2<Tg2>` 여러 개의 메서드 호출을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-476">The generic method `GM2<Tgm2>` in type `G2<Tg2>` contains several method calls:</span></span>  
  
-   <span data-ttu-id="04957-477">사례 1: 제네릭 메서드 `GM1<Tgm1>` 의 형식 매개 변수를 사용 하 여 호출은 `G2<Tg2>` 및 `GM2<Tgm2>` 형식 인수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-477">Case 1: The generic method `GM1<Tgm1>` is called, using the type parameters of `G2<Tg2>` and `GM2<Tgm2>` as the type arguments.</span></span> <span data-ttu-id="04957-478">호출 된 메서드의 매개 변수 형식에 대 한 형식 정의에서 폐쇄형된 제네릭 형식을 생성 하는 데 사용 되는 형식에 따라 달라 집니다 즉, `G2<Tg2>`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-478">In other words, the parameter types of the called method will depend on the types that are used to construct a closed generic type from the type definition for `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="04957-479">사례 2: 제네릭이 아닌 메서드 `M1` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-479">Case 2: The non-generic method `M1` is called.</span></span> <span data-ttu-id="04957-480">이 메서드의 매개 변수 정의 형식의 형식 매개 변수를 사용 하 여 `G1<Tg1>`, 바뀌는 경우에 바깥쪽 형식의 형식 매개 변수에 의해 `G2<Tg2>`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-480">The parameter of this method uses the type parameter of the defining type, `G1<Tg1>`, which is replaced in this case by the type parameter of the enclosing type, `G2<Tg2>`.</span></span>  
  
-   <span data-ttu-id="04957-481">사례 3: 제네릭 메서드 `GM1<Tgm1>` 을 라고 지정 <xref:System.Int32> 및 <xref:System.Object> 제네릭 형식과 제네릭 메서드의 형식 인수에 대 한 각각.</span><span class="sxs-lookup"><span data-stu-id="04957-481">Case 3: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="04957-482">이 메서드 호출은 바깥쪽 형식 또는 메서드의 형식 매개 변수에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-482">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
-   <span data-ttu-id="04957-483">경우 4: 제네릭이 아닌 메서드 수 `M1` 의 `Example` 클래스 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-483">Case 4: The non-generic method `M1` of the `Example` class is called.</span></span> <span data-ttu-id="04957-484">이 메서드 호출은 바깥쪽 형식 또는 메서드의 형식 매개 변수에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-484">This method call does not depend on the type parameters of the enclosing type or method.</span></span>  
  
 <span data-ttu-id="04957-485">또한이 예제에서는 정의 제네릭이 아닌 `Example` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-485">In addition, the example defines the non-generic `Example` class.</span></span> <span data-ttu-id="04957-486">이 클래스에는 메서드가 `M` 제네릭 메서드를 호출 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-486">This class has a method `M` that makes a call to a generic method.</span></span>  
  
-   <span data-ttu-id="04957-487">경우 5: 제네릭 메서드는 `GM1<Tgm1>` 호출을 지정 하 <xref:System.Int32> 및 <xref:System.Object> 제네릭 형식과 제네릭 메서드의 형식 인수에 대 한 각각.</span><span class="sxs-lookup"><span data-stu-id="04957-487">Case 5: The generic method `GM1<Tgm1>` is called, specifying <xref:System.Int32> and <xref:System.Object> for the type arguments of the generic type and the generic method, respectively.</span></span> <span data-ttu-id="04957-488">이 메서드에 대 한 컨텍스트는 없는 바깥쪽 제네릭 형식 또는 제네릭 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-488">The context for this method has no enclosing generic type or generic method.</span></span>  
  
 <span data-ttu-id="04957-489">각 사례에 대 한 예에서는 먼저 생성 한 <xref:System.Reflection.MethodInfo> 호출된 된 메서드를 나타내며 다음 사용 하 여 토큰을 확인 하는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 및 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 에 대 한 값을 가져오는 방법을 `genericTypeArguments` 및 `genericMethodArguments` 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-489">For each case, the example first constructs a <xref:System.Reflection.MethodInfo> that represents the called method, and then resolves the token using the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, using the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> methods to get the values for the `genericTypeArguments` and `genericMethodArguments` parameters.</span></span> <span data-ttu-id="04957-490">메서드는 반환 하기 때문에이 기술은 모든 경우에 <xref:System.Type.EmptyTypes?displayProperty=nameWithType> 제네릭이 아닌 컨텍스트에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-490">This technique works in all cases, because the methods return <xref:System.Type.EmptyTypes?displayProperty=nameWithType> for non-generic contexts.</span></span> <span data-ttu-id="04957-491">이 예제는 적용 된 비교 <xref:System.Reflection.MethodInfo> 를 생성 된 <xref:System.Reflection.MethodInfo>합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-491">The example compares the resolved <xref:System.Reflection.MethodInfo> with the constructed <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="04957-492">이 예제에서는 사용 하려고 시도 합니다는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> 메서드 오버 로드는 토큰을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-492">The example then attempts to use the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%29> method overload to resolve the token.</span></span> <span data-ttu-id="04957-493">메서드를 호출 하 여 제네릭 컨텍스트에 종속 되지 않는 때문에 3, 4 및 5, 경우에 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-493">This works in cases 3, 4, and 5, because the method calls do not depend on the generic context.</span></span> <span data-ttu-id="04957-494">1 및 2의 경우 토큰을 확인 정보가 부족 하기 때문에 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="04957-494">In cases 1 and 2, an exception is thrown because there is insufficient information to resolve the token.</span></span>  
  
 <span data-ttu-id="04957-495">메타 데이터 토큰 값 열거도 하드 코드 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-495">The metadata token values are hard-coded as an enumeration.</span></span> <span data-ttu-id="04957-496">이 코드 예제를 변경한 경우에 토큰 값은 변경 될 수 있으므로입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-496">If you change this code example, the token values are likely to change.</span></span> <span data-ttu-id="04957-497">새 토큰 값을 확인 하려면 코드를 컴파일하고 Ildasm.exe를 사용 하 여는 **토큰/** 어셈블리를 검사 하는 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-497">To determine the new token values, compile the code and use Ildasm.exe with the **/TOKENS** option to examine the assembly.</span></span> <span data-ttu-id="04957-498">호출 시점에는 토큰을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-498">The tokens can be found at the points of call.</span></span> <span data-ttu-id="04957-499">열거형에 새 값을 삽입 하 고 예제를 다시 컴파일하십시오.</span><span class="sxs-lookup"><span data-stu-id="04957-499">Insert the new values into the enumeration, and recompile the example.</span></span>  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-500"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 메서드나 생성자의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-500"><paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-501">또는</span><span class="sxs-lookup"><span data-stu-id="04957-501">-or-</span></span>  
  
 <span data-ttu-id="04957-502"><paramref name="metadataToken" />이 <see langword="MethodSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="var" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="mvar" />이고, <paramref name="genericTypeArguments" />와 <paramref name="genericMethodArguments" /> 중 하나 또는 둘 다에 대해 필요한 제네릭 형식 인수를 제공하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="04957-502"><paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-503"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-503"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-504">모듈에 있는 시그니처를 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-504">A metadata token that identifies a signature in the module.</span></span></param>
        <summary><span data-ttu-id="04957-505">메타데이터 토큰으로 식별되는 시그니처 blob을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-505">Returns the signature blob identified by a metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-506">시그니처 blob을 나타내는 바이트의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-506">An array of bytes representing the signature blob.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04957-507">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰 및 서명 하는 방법에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-507">Information about metadata tokens and signatures can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-508">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-508">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-509"><paramref name="metadataToken" />이 현재 모듈의 범위에 유효한 <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, 시그니처 또는 <see langword="FieldDef" /> 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-509"><paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-510"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-510"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-511">모듈의 문자열 힙에 있는 문자열을 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-511">A metadata token that identifies a string in the string heap of the module.</span></span></param>
        <summary><span data-ttu-id="04957-512">지정된 메타데이터 토큰으로 식별되는 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-512">Returns the string identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-513">메타데이터 문자열 힙의 문자열 값이 포함된 <see cref="T:System.String" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-513">A <see cref="T:System.String" /> containing a string value from the metadata string heap.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04957-514">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-514">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-515">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-515">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-516"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 문자열의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-516"><paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-517"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-517"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04957-518">메타데이터 토큰으로 식별되는 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-518">Returns the type identified by a metadata token.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-519">모듈의 형식을 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-519">A metadata token that identifies a type in the module.</span></span></param>
        <summary><span data-ttu-id="04957-520">지정된 메타데이터 토큰으로 식별되는 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-520">Returns the type identified by the specified metadata token.</span></span></summary>
        <returns><span data-ttu-id="04957-521">지정된 메타데이터 토큰으로 식별되는 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-521">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-522">에 대 한 메타 데이터 토큰을 확인 하려면는 `TypeSpec` 포함 된 시그니처 `ELEMENT_TYPE_VAR` 또는 `ELEMENT_TYPE_MVAR`를 사용 하 여는 <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드 오버 로드를 필요한 컨텍스트를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-522">To resolve a metadata token for a `TypeSpec` whose signature contains `ELEMENT_TYPE_VAR` or `ELEMENT_TYPE_MVAR`, use the <xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method overload, which allows you to supply the necessary context.</span></span> <span data-ttu-id="04957-523">즉, 제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 제네릭 형식 매개 변수에 따라 달라 지는 형식에 대 한 메타 데이터 토큰을 확인 하는 경우에 해당 형식 매개 변수를 제공할 수 있는 오버 로드를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-523">That is, when you are resolving a metadata token for a type that depends on the generic type parameters of the generic type and/or the generic method in which the token is embedded, you must use the overload that allows you to supply those type parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-524">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-524">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-525">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-525">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-526"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 형식의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-526"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-527">또는</span><span class="sxs-lookup"><span data-stu-id="04957-527">-or-</span></span>  
  
 <span data-ttu-id="04957-528"><paramref name="metadataToken" />이 <see langword="TypeSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="var" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="mvar" />인 경우</span><span class="sxs-lookup"><span data-stu-id="04957-528"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method).</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-529"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-529"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken"><span data-ttu-id="04957-530">모듈의 형식을 식별하는 메타데이터 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-530">A metadata token that identifies a type in the module.</span></span></param>
        <param name="genericTypeArguments"><span data-ttu-id="04957-531">해당 토큰이 범위 내에 있는 형식의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 형식이 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-531">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</span></span></param>
        <param name="genericMethodArguments"><span data-ttu-id="04957-532">해당 토큰이 범위 내에 있는 메서드의 제네릭 형식 인수를 나타내는 <see cref="T:System.Type" /> 개체의 배열이거나, 메서드가 제네릭이 아닌 경우에는 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-532">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</span></span></param>
        <summary><span data-ttu-id="04957-533">지정된 제네릭 형식 매개 변수로 정의되는 컨텍스트에서 지정된 메타데이터 토큰으로 식별되는 형식을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-533">Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</span></span></summary>
        <returns><span data-ttu-id="04957-534">지정된 메타데이터 토큰으로 식별되는 형식을 나타내는 <see cref="T:System.Type" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-534">A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-535">사용 하 여는 <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> 형식의 메서드로 여기서 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-535">Use the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method on the type where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-536">사용 하 여는 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> 방법에 대 한 메서드를 `metadataToken` 범위에 대 한 제네릭 형식 인수의 배열을 가져옵니다 `genericTypeArguments`합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-536">Use the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> method on the method where `metadataToken` is in scope to obtain an array of generic type arguments for `genericTypeArguments`.</span></span> <span data-ttu-id="04957-537">필요 하지 않은 경우에 이러한 인수를 지정 하는 항상 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-537">It is always safe to provide these arguments, even when they are not needed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04957-538">공용 언어 인프라 (CLI) 설명서의 "II: 메타 데이터 정의 및 의미"에 메타 데이터 토큰에 대 한 정보를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-538">Information about metadata tokens can be found in the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04957-539">이 설명서는 온라인입니다. 참조 [ECMA C# 및 Common Language Infrastructure 표준](http://go.microsoft.com/fwlink/?LinkID=99212) msdn 및 [Standard ecma-335-인프라 CLI (공용 언어)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-539">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the ECMA Web site.</span></span>  
  
 <span data-ttu-id="04957-540">제네릭 컨텍스트 (제네릭 형식 및/또는 토큰이 포함 된 제네릭 메서드의 매개 변수)를 사용 하 여 토큰을 확인을 보여 주는 코드에 대 한 참조는 <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-540">For code that demonstrates token resolution using the generic context (that is, the generic type parameters of the generic type and/or the generic method in which the token is embedded) see the <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="04957-541"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 형식의 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-541"><paramref name="metadataToken" /> is not a token for a type in the scope of the current module.</span></span>  
  
 <span data-ttu-id="04957-542">또는</span><span class="sxs-lookup"><span data-stu-id="04957-542">-or-</span></span>  
  
 <span data-ttu-id="04957-543"><paramref name="metadataToken" />이 <see langword="TypeSpec" />(제네릭 형식의 형식 매개 변수) 또는 <see langword="var" />(제네릭 메서드의 형식 매개 변수) 요소 형식이 포함된 시그니처를 사용하는 <see langword="mvar" />이고, <paramref name="genericTypeArguments" />와 <paramref name="genericMethodArguments" /> 중 하나 또는 둘 다에 대해 필요한 제네릭 형식 인수를 제공하지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="04957-543"><paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="04957-544"><paramref name="metadataToken" />이 현재 모듈의 범위에 있는 유효한 토큰이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="04957-544"><paramref name="metadataToken" /> is not a valid token in the scope of the current module.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04957-545">모듈의 이름을 나타내는 문자열을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-545">Gets a string representing the name of the module.</span></span></summary>
        <value><span data-ttu-id="04957-546">모듈 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-546">The module name.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-547">`ScopeName` 속성은 공용 언어 런타임에서 사용 되지 않지만 메타 데이터 Api를 사용 하 여 모듈을 실행할 때 속성에 원하는 모든 문자열을 저장 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-547">The `ScopeName` property is not used by the common language runtime, but you can use it to store any string you want in the property when you emit a module using the metadata APIs.</span></span> <span data-ttu-id="04957-548">자체 리플렉션 없도록 설정할 수 있습니다는 `ScopeName` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-548">Reflection itself does not allow you to set the `ScopeName` property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04957-549">이 예제에서는 결과 보여 줍니다.는 `ScopeName`, `FullyQualifiedName`, 및 `Name` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-549">This example shows the effect of the `ScopeName`, `FullyQualifiedName`, and `Name` properties.</span></span>  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="04957-550">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-550">Reserved for future use.</span></span> <span data-ttu-id="04957-551">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-551">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="04957-552">매핑할 전달된 이름의 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-552">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="04957-553">매핑할 이름의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-553">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="04957-554">이름을 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-554">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="04957-555">이름에 해당하는 ID를 받는 호출자가 할당한 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-555">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="04957-556">이름 집합을 해당하는 디스패치 식별자 집합에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-556">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-557">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-557">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04957-558">에 대 한 자세한 내용은 `IDispatch::GetIDsOfNames`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-558">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04957-559">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-559">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="04957-560">반환할 형식 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-560">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="04957-561">형식 정보의 로캘 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-561">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="04957-562">요청된 형식 정보 개체에 대한 포인터를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-562">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="04957-563">인터페이스의 형식 정보를 가져오는 데 사용할 수 있는 개체의 형식 정보를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-563">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-564">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-564">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04957-565">에 대 한 자세한 내용은 `IDispatch::GetTypeInfo`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-565">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04957-566">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-566">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="04957-567">개체에서 제공하는 형식 정보 인터페이스의 수를 받는 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="04957-567">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="04957-568">개체에서 제공하는 형식 정보 인터페이스의 수를 검색합니다(0 또는 1).</span><span class="sxs-lookup"><span data-stu-id="04957-568">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-569">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04957-570">에 대 한 자세한 내용은 `IDispatch::GetTypeInfoCount`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-570">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04957-571">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="04957-572">멤버를 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-572">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="04957-573">나중에 사용하기 위해 예약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-573">Reserved for future use.</span></span> <span data-ttu-id="04957-574">IID_NULL이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-574">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="04957-575">인수를 해석할 로캘 컨텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-575">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="04957-576">호출의 컨텍스트를 설명하는 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-576">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="04957-577">인수의 배열, 명명된 인수에 대한 인수 DISPID의 배열 및 배열에 있는 요소의 개수가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-577">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="04957-578">결과를 저장할 위치에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-578">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="04957-579">예외 정보가 포함된 구조체에 대한 포인터입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-579">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="04957-580">오류가 있는 첫 번째 인수의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-580">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="04957-581">개체에서 노출하는 메서드와 속성에 대한 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-581">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04957-582">이 메서드는 비관리 코드에서 액세스를 위한 관리 되는 클래스는 하며 관리 코드에서 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-582">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04957-583">에 대 한 자세한 내용은 `IDispatch::Invoke`, MSDN Library를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-583">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04957-584">COM <c>IDispatch</c> 인터페이스를 사용하는 런타임에 바인딩된 액세스는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="04957-584">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04957-585">모듈의 이름을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="04957-585">Returns the name of the module.</span></span></summary>
        <returns><span data-ttu-id="04957-586">이 모듈의 이름을 나타내는 <see langword="String" />입니다.</span><span class="sxs-lookup"><span data-stu-id="04957-586">A <see langword="String" /> representing the name of this module.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04957-587">다음 예제에서는 사용 하는 `ToString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="04957-587">The following example demonstrates a use of the `ToString` method.</span></span>  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>