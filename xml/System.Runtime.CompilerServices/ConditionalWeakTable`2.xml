<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="53074d9f587b6441982542e293dc0d030bd2cfc6" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58713192" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">필드가 연결된 참조 형식입니다.</typeparam>
    <typeparam name="TValue">필드의 형식입니다. 참조 형식이어야 합니다.</typeparam>
    <summary>컴파일러에서 관리되는 개체에 개체 필드를 동적으로 연결할 수 있도록 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 클래스에 언어 컴파일러에서 런타임에 관리 되는 개체에 임의의 속성을 연결할 수 있도록 합니다. <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 개체가 키로 표현 되는 관리 되는 개체 값으로 표현 되는 연결 된 속성에 바인딩하는 사전입니다. 개체의 키는의 개별 인스턴스를 `TKey` 클래스는 속성이 연결 된 해당 값은 해당 개체에 할당 된 속성 값입니다.  
  
 키는 고유 해야 합니다. 즉,는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 클래스는 관리 되는 개체당 하나의 연결 된 값을 지원 합니다. 두 키가 동일한 경우에 전달 하는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 반환 되는 `true`합니다.  
  
> [!NOTE]
>  재정의 하 여 같음 비교를 제어할 수 없는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 를 키에 대 한 해시 코드를 명시적으로 설정 합니다. 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 클래스를 사용 하지 않습니다 합니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 를 계산 하는 메서드 코드를 해시 하 고 따라서 호출 하지 않습니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 재정의 합니다.  
  
 하지만 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 키/값 쌍의 컬렉션을 보유 하는 클래스를 가장 잘 간주 됩니다 사전 개체 대신 테이블입니다. <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 클래스는 여러 가지 방법으로 사전에서 다릅니다.  
  
-   키를 유지 하지 않습니다. 즉, 키 유지 되지 않는 컬렉션의 멤버 이므로만 합니다.  
  
-   모든 메서드는 포함 되지 않습니다 (같은 `GetEnumerator` 또는 `Contains`) 사전 일반적으로 있는 합니다.  
  
-   구현 하지 않기를 <xref:System.Collections.Generic.IDictionary%602> 인터페이스입니다.  
  
 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 클래스 컬렉션에 저장 된 키의 개체 수명 관리에 있는 다른 컬렉션 개체에서 다릅니다. 일반적으로 개체 컬렉션으로 저장 된 경우 해당 수명 동안 제거 됩니다 (및 개체에 대 한 추가 참조가 없는) 하거나 자체 컬렉션 개체가 제거 될 때까지 지속 됩니다. 그러나는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블에 키/값 쌍을 보장 하지 않습니다 키 지속 됩니다 (예를 들어 테이블에 있는 경우 키 하나에 값 V1 사용 하 여 테이블에 저장 된 값을 통해 도달할 수 있는 경우에 추가 클래스 및 P2는 대 한 참조를 포함 하는 값을 사용 하 여 두 번째 키, B). 대신 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 키에 다른 참조가 없는 테이블 밖으로 키/값 항목을 자동으로 제거 합니다. 예제에서는 그림을 제공합니다.  
  
   
  
## Examples  
 다음 예제에서는 키에 저장 되는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블 외부 참조가 삭제 된 후에 테이블 유지 되지 않습니다. 이 예제에서는 두 개의 클래스를 정의: `ManagedClass`, 테이블의 키를 나타내는 및 `ClassData`, 키의 값을 나타냅니다. 이 예제에서는 각 형식의 세 개체를 인스턴스화합니다. 도 인스턴스화합니다를 <xref:System.WeakReference> 초를 나타내는 개체 `ManagedClass`, 두 번째 되지 않으며 `ManagedClass` 인스턴스. 두 번째 검색 하려는 시도가 `ManagedClass` 에서 개체를 <xref:System.WeakReference.Target%2A> 속성 개체에 대 한 참조가 남아 있는지 나타냅니다.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>인스턴스는 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 클래스는 스레드로부터 안전 합니다. 모든 추가 잠금 작업을 수행 하는 호출자를 필요 하지 않습니다.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> 생성자는 빈 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블은 키/값 쌍을 포함 하는,. 호출 하 여 키/값 쌍을 추가할 수 있습니다 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, 또는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 메서드.  
  
 모든 키를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 개체 고유 해야 합니다. 키는 동일한 개체를 참조 하는 경우에 고유 하지 않습니다 (즉,에 대 한 인수로 전달 하는 경우는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 반환 되는 `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">추가할 키입니다. <paramref name="key" />는 속성이 연결된 개체를 나타냅니다.</param>
        <param name="value">키의 속성 값입니다.</param>
        <summary>테이블에 키를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 키를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 개체 고유 해야 합니다. 키는 동일한 개체를 참조 하는 경우에 고유 하지 않습니다 (즉,에 대 한 인수로 전달 하는 경우는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드가 반환 되는 `true`).  
  
 키가 추가 작업 하는 동안 가비지 수집, 기존 키/값 쌍 제거 되 고 예외가 발생 하지 않고 새로운 키/값 쌍 추가 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `MainClass` 클래스 및 `MainInfo` 에 대 한 정보를 제공 하는 클래스는 `MainClass` 인스턴스. 다음 호출 하 여는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 추가할 메서드를 `MainClass` 개체 및 해당 연결 된 `MainInfo` 개체를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블. 예제에 대 한 호출도 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 및 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 테이블에 키/값 쌍을 추가 하는 메서드는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 기존 키의 값을 검색 하는 방법.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" />가 이미 있는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 컬렉션기에서 <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> 개체를 회수할 때 리소스가 해제되고 다른 정리 작업이 수행되도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가비지 수집기를 호출 하 여 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> 종료 준비가 된 경우.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">검색할 키입니다. <paramref name="key" />는 속성이 연결된 개체를 나타냅니다.</param>
        <summary>테이블에서 지정된 키를 각각 검색하여 해당 값을 반환합니다. 테이블에 키가 없는 경우 테이블의 값을 나타내는 클래스의 기본 생성자를 메서드가 호출하여 지정된 키에 바인딩된 값을 만듭니다.</summary>
        <returns>테이블에 이미 <paramref name="key" />가 있으면 <paramref name="key" />에 해당하는 값이고, 그렇지 않으면 <paramref name="TValue" /> 제네릭 형식 매개 변수에 의해 정의된 클래스의 기본 생성자가 만든 새 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `key` 존재 하지 않는 테이블의 메서드를 추가 하 여 정의 된 클래스의 기본 생성자를 호출 하 여 인스턴스화된 개체와 함께 `TValue` 제네릭 형식 매개 변수입니다. 경우는 `TValue` 클래스에 기본 생성자는 <xref:System.MissingMethodException> throw 됩니다.  
  
 이 방법은 권장 되는 기존 값을 검색 하거나 새 값을 추가 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블의 값 클래스 기본 생성자를 정의 하는 경우 테이블입니다. 기본 생성자를 정의 하지 않으면, 대신를 호출할 수 있습니다는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 테이블의 값을 나타내는 개체를 인스턴스화하고 콜백 제공한 메서드를 사용 하는 메서드  
  
 키/값 쌍의 키가 없는 테이블의 경우 호출을 추가 하지 않고 기존 키의 값을 검색 하 여 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 정의 `MainClass` 클래스 및 `MainInfo` 에 대 한 정보를 제공 하는 클래스는 `MainClass` 인스턴스. 예제에서는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 추가할 메서드를 `MainClass` 개체 및 해당 연결 된 `MainInfo` 개체를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블. 예제에 대 한 호출도 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 및 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 테이블에 키/값 쌍을 추가 하는 메서드는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 기존 키의 값을 검색 하는 방법.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.MissingMemberException" />을 catch합니다.  
  
</para>
          </block>  
  
 테이블 값을 나타내는 클래스가 기본 생성자를 정의하지 않는 경우</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">검색할 키입니다. <paramref name="key" />는 속성이 연결된 개체를 나타냅니다.</param>
        <param name="createValueCallback">지정된 <paramref name="key" />에 대한 값을 만들 수 있는 메서드에 대한 대리자입니다. <c>TKey</c> 형식의 단일 매개 변수가 있으며 <c>TValue</c> 형식의 값을 반환합니다.</param>
        <summary>테이블에서 지정된 키를 각각 검색하여 해당 값을 반환합니다. 테이블에 키가 없는 경우 메서드가 콜백 메서드를 호출하여 지정된 키에 바인딩된 값을 만듭니다.</summary>
        <returns>테이블에 이미 <paramref name="key" />가 있으면 <paramref name="key" />에 연결된 값이고, 그렇지 않으면 <paramref name="createValueCallback" /> 대리자가 반환하는 새 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `key` 테이블에 없는 경우 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 에서 정의한 메서드를 호출 합니다 `createValueCallback` 매개 변수 키를 전달 합니다. 새 값을 테이블의 키에 바인딩된 이며 결과적으로 반환 됩니다.  
  
 테이블의 값을 나타내는 클래스는 기본 생성자를 정의 하지 않습니다 하는 경우에이 메서드를 사용 합니다. 기본 생성자를 정의 해당 하는 경우 사용 된 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 메서드 대신 합니다. 키/값 쌍의 키가 없는 테이블의 경우 호출을 추가 하지 않고 기존 키의 값을 검색 하 여 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 메서드.  
  
 여러 스레드가 동일한 키를 만들려고 `createValueCallback` 동일한 키를 사용 하 여 여러 번 호출할 수 있습니다. 이러한 호출 중 하나에만 성공 하 고 해당 반환된 값 테이블에 추가 됩니다. 스레드 값을 만드는 데 성공 하면 확정적이 지 않습니다. 이 규칙을 호출 하도록 허용 `createValueCallback` 내부 테이블 잠금이 교착 상태를 방지 하기 위해 외부입니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `MainClass` 클래스 및 `MainInfo` 에 대 한 정보를 제공 하는 클래스는 `MainClass` 인스턴스. 정적 정의 (`Shared` Visual Basic에서) `CreateAttachedValue` 에 할당할 수 있는 메서드를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> 대리자를 전달할를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 메서드. 예제에서는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 추가할 메서드를 `MainClass` 개체 및 해당 연결 된 `MainInfo` 개체를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블. 예제에 대 한 호출도 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> 및 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> 테이블에 키/값 쌍을 추가 하는 메서드는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 기존 키의 값을 검색 하는 방법.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> 또는 <paramref name="createValueCallback" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">제거할 키입니다.</param>
        <summary>테이블에서 키와 해당 값을 제거합니다.</summary>
        <returns>키를 찾아서 제거하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가이 작업 하는 동안 가비지 수집, 메서드가 예외를 발생 하지 않습니다 하 고 반환 값은 정의 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">연결된 속성이 있는 개체를 나타내는 키입니다.</param>
        <param name="value">이 메서드가 반환될 때 연결된 속성 값을 포함합니다. <paramref name="key" />를 찾을 수 없으면 <paramref name="value" />에 기본값이 포함됩니다.</param>
        <summary>지정된 키의 값을 가져옵니다.</summary>
        <returns><paramref name="key" />가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가 있는지 가비지 수집 된이 작업 중에 메서드를 반환할 수 있습니다 `false` 설정 및 `value` 기본값으로 (처럼 키가 존재 하지 않는) 값입니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `MainClass` 클래스 및 `MainInfo` 에 대 한 정보를 제공 하는 클래스는 `MainClass` 인스턴스. 예제에서는 합니다 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, 및 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> 에 키/값 쌍을 추가 하는 메서드를 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> 테이블. 호출 하 여 각각의 경우에는 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> 키/값 쌍이 테이블에 추가 되었는지 확인 하는 방법입니다.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />가 <see langword="null" />입니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>