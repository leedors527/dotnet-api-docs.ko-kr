<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <Metadata><Meta Name="ms.openlocfilehash" Value="feb79acca8efbdf44147cc99768cca329c454105" /><Meta Name="ms.sourcegitcommit" Value="112ca25eddde8ac8b788d67c406b7745ba914261" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/15/2019" /><Meta Name="ms.locfileid" Value="54311463" /></Metadata><TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <TypeSignature Language="F#" Value="type RuntimeHelpers = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c6f7f-101">컴파일러에 대한 지원을 제공하는 정적 메서드 및 속성의 집합을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-101">Provides a set of static methods and properties that provide support for compilers.</span></span> <span data-ttu-id="c6f7f-102">이 클래스는 상속될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c6f7f-103">다음 예제에서는 사용 하 여 핸들을 안정적으로 설정 하는 방법의 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="c6f7f-104">핸들을 지정 된 기존 핸들을 안정적으로 설정 하려면 해야 하는 기본 핸들을 할당 및 해당 핸들 내에서 후속 기록을 <xref:System.Runtime.InteropServices.SafeHandle> 개체는 원자성을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="c6f7f-105">이러한 작업 (예: 스레드 중단 또는 메모리 부족 예외) 사이 오류 유출 네이티브 핸들 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="c6f7f-106">사용할 수는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 핸들이 누출 되지 있는지 확인 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member EnsureSufficientExecutionStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c6f7f-107">남아 있는 스택 공간이 평균적인 .NET Framework 함수를 실행할 정도로 충분히 큰지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> 수행할 복구 작업 및 발생 하는 예외에 대 한 충분 한 공간을 유지 하는 인위적으로 제한 된 스택에 대 한 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="c6f7f-109">인위적인 스택 제한 안전 하 게 예외를 throw 하려면 충분 한 공간이 유지 하도록 공용 언어 런타임에 의해 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="c6f7f-110">이 메서드는 바인딩되지 않은 재귀가 발생할 인해 스택 오버플로가 발생할 수 있는 상황에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="c6f7f-111">것도 사용 될 수 있지만 안전 하 게 다른 개발 시나리오에서는 컴파일러 서비스 시나리오에서 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="c6f7f-112">스택 공간이 충분 한 경우 예외가 throw 되지 않습니다 및 대부분의.NET Framework 형식 및 멤버 여전히 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c6f7f-113">이 메서드에 제약이 있는 실행 지역 (CER) 지원의 일부 아니며와 혼동 해서는 안 됩니다는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException"><span data-ttu-id="c6f7f-114">이용 가능한 스택 공간이 평균적인 .NET Framework 함수를 실행하는데 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-114">The available stack space is insufficient to execute the average .NET Framework function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.Equals (o1, o2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1"><span data-ttu-id="c6f7f-115">비교할 첫 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-115">The first object to compare.</span></span></param>
        <param name="o2"><span data-ttu-id="c6f7f-116">비교할 두 번째 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-116">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="c6f7f-117">지정한 <see cref="T:System.Object" /> 인스턴스가 동일한지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="c6f7f-118"><paramref name="o1" /> 매개 변수가 <paramref name="o2" /> 매개 변수와 같은 인스턴스이거나 둘 다 <see langword="null" />이거나 <c>o1.Equals(o2)</c>가 <see langword="true" />를 반환하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-118"><see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-119">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6f7f-120">다음 예제를 사용 하 여 두 개체를 비교 하는 방법에 설명 합니다 <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="static member ExecuteCodeWithGuaranteedCleanup : System.Runtime.CompilerServices.RuntimeHelpers.TryCode * System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode * obj -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup (code, backoutCode, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code"><span data-ttu-id="c6f7f-121">시도할 코드에 대한 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-121">A delegate to the code to try.</span></span></param>
        <param name="backoutCode"><span data-ttu-id="c6f7f-122">예외가 발생하는 경우 실행할 코드에 대한 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-122">A delegate to the code to run if an exception occurs.</span></span></param>
        <param name="userData"><span data-ttu-id="c6f7f-123"><paramref name="code" /> 및 <paramref name="backoutCode" />로 전달할 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-123">The data to pass to <paramref name="code" /> and <paramref name="backoutCode" />.</span></span></param>
        <summary><span data-ttu-id="c6f7f-124"><see cref="T:System.Delegate" />를 사용하여 코드를 실행하고 다른 <see cref="T:System.Delegate" />를 사용하여 예외가 발생한 경우 추가 코드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-125">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-126">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-126">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-127">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-127">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : obj -&gt; int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="c6f7f-128">해시 코드를 검색할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-128">An object to retrieve the hash code for.</span></span></param>
        <summary><span data-ttu-id="c6f7f-129">특정 개체에 대한 해시 함수로 사용되며 해시 테이블과 같은 해시 코드를 사용하는 데이터 구조 및 알고리즘에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="c6f7f-130"><paramref name="o" /> 매개 변수로 식별되는 개체의 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-131"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 메서드를 항상 호출 합니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 메서드 비가상으로, 개체의 형식이 재정의 하는 경우에는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c6f7f-132">따라서 사용 하 여 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 호출에서 다를 수 있습니다 `GetHashCode` 사용 하 여 개체에 직접는 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="c6f7f-133">하지만 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 동일 개체 참조에 대 한 동일한 해시 코드를 반환 하는 메서드, 하지 사용 해야이 메서드 개체 id를 테스트 하려면 때문이 해시 코드를 개체 참조를 고유 하 게 식별 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="c6f7f-134">개체 식별에 대 한 테스트 (즉, 두 개의 테스트 개체를 메모리에서 같은 개체 참조)를 호출 합니다 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c6f7f-135">사용 해야 하거나 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> 문자열 내부 풀에 추가 하기 때문에 두 개의 문자열 같은 개체 참조를 나타내는 여부를 테스트 하려면.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="c6f7f-136">문자열 인터닝에 대 한 테스트를 호출 합니다 <xref:System.String.IsInterned%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6f7f-137">합니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 고 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 메서드 차이점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="c6f7f-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 개체의 같음 정의 기반으로 하는 해시 코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="c6f7f-139">예를 들어, 동일한 콘텐츠로 두 문자열 값이 동일한 돌아갑니다 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="c6f7f-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 개체 id를 나타내는 해시 코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="c6f7f-141">즉, 두 개의 string 변수 내용이 동일 하 고는 내부 풀에 추가 하는 문자열을 나타냅니다 (참조를 [문자열 인터닝](#interning) 섹션) 또는 메모리에 단일 문자열로 반환 동일한 나타내는 해시 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c6f7f-142"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> 항상 같은 개체 참조에 대 한 동일한 해시 코드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="c6f7f-143">그러나는 성립 되지: 같은 해시 코드는 같은 개체 참조를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="c6f7f-144">특정 해시 코드 값을 특정 개체 참조; 고유 하지 않습니다. 다른 개체 참조는 동일한 해시 코드를 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="c6f7f-145">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="c6f7f-146">문자열 인터닝</span><span class="sxs-lookup"><span data-stu-id="c6f7f-146">String Interning</span></span>  
 <span data-ttu-id="c6f7f-147">CLR (공용 언어 런타임) 문자열의 내부 풀 유지 관리 및 리터럴 풀에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="c6f7f-148">두 개의 문자열이 (예를 들어 `str1` 하 고 `str2`)는 동일한 문자열 리터럴, CLR은 설정에서 형성 된 `str1` 및 `str2` 메모리를 절약 하는 관리 되는 힙에 동일한 위치를 가리키도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="c6f7f-149">호출 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 이 두 문자열에서 개체에는 이전 섹션에서 두 번째 글머리 기호 항목 달리 동일한 해시 코드를 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="c6f7f-150">CLR는 리터럴만 풀에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="c6f7f-151">같은 연결 문자열 작업의 결과 컴파일러는 단일 문자열 리터럴로 문자열 연결을 확인 하지 않는 한 풀에 추가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="c6f7f-152">따라서 경우 `str2` 연결 작업의 결과로 만들어진 및 `str2` 동일 `str1`를 사용 하 여 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 개체 이러한 두 개의 문자열에는 같은 해시 코드를 생성 하지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="c6f7f-153">풀에 연결 된 문자열을 명시적으로 추가 하려는 경우 사용 된 <xref:System.String.Intern%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c6f7f-154">사용할 수도 있습니다는 <xref:System.String.IsInterned%2A?displayProperty=nameWithType> 문자열로 참조를 풀된에 있는지 여부를 확인 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6f7f-155">다음 예제에서는 간의 차이 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 및 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c6f7f-156">다음 예제의 출력이 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="c6f7f-157">에 전달 된 문자열의 첫 번째 집합에 대 한 해시 코드의 두 집합의 `ShowHashCodes` 메서드는 문자열을 완전히 다르기 때문에 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="c6f7f-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 에 전달 된 문자열의 두 번째 집합에 대해 동일한 해시 코드를 생성 하는 `ShowHashCodes` 메서드를 문자열 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="c6f7f-159">그러나는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="c6f7f-160">첫 번째 문자열 리터럴 문자열을 사용 하 여 정의 되 고 따라서 인턴 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="c6f7f-161">두 번째 문자열의 값이 동일한 경우에 해당 인턴 지정 되지를 호출 하 여 반환 되기 때문에 <xref:System.String.Format%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="c6f7f-162">생성 된 해시 코드를 세 번째 문자열의 경우 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> 에서 생성 된 해시 코드는 마찬가지로 두 문자열이 동일한 경우에 대 한 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c6f7f-163">이 컴파일러에 단일 문자열 리터럴로, 두 문자열에 할당 된 값을 처리 하기 때문에 동일한 인턴 지정된 문자열에 문자열 변수를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectValue : obj -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="c6f7f-164">상자에 넣을 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-164">The value type to be boxed.</span></span></param>
        <summary><span data-ttu-id="c6f7f-165">값 형식을 상자에 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-165">Boxes a value type.</span></span></summary>
        <returns><span data-ttu-id="c6f7f-166">값 형식이 값 클래스이면 <paramref name="obj" />의 boxed 사본이고, 그렇지 않으면 <paramref name="obj" /> 자체입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-167">값 형식을 boxing 하면 개체를 만들고 새 개체에 지정 된 값 형식의 필드의 단순 복사를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="c6f7f-168">이 메서드 값 클래스를 값 클래스의 별칭 지정 동작을 그대로 유지 하면서 개체로 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="c6f7f-169">반환 값을 변경할 수 또는 변경할 수 없는 값 클래스 인지에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="c6f7f-170">할당 되는 값을 변경할 수 있는 값 클래스 이면 메서드 값 클래스 복사 의미 체계 때문에 클래스의 단순 복사본을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="c6f7f-171">할당 되는 값을 변경할 수 없는 값 클래스 이면 메서드는 클래스의 복사본 대신 자체 개체를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="c6f7f-172">동적으로 형식화 된 언어의 컴파일러는 boxed 값 형식을 unboxed 값 형식에 동일 하 게 작동 하는지 확인 하려면이 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="c6f7f-173">즉, boxed 값 형식, 전달 및 항상 값으로 전달 하는 경우 복제 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="c6f7f-174">컴파일러를 호출할 수 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> 값 형식 개체에 할당할 또는 값 형식을 형식 개체를 매개 변수로 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="c6f7f-175">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6f7f-176">다음 예제에서는 값 클래스를 사용 하 여 상자 하는 방법에 설명 합니다 <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetUninitializedObject : Type -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="F#" Value="static member InitializeArray : Array * RuntimeFieldHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray (array, fldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="c6f7f-177">초기화할 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-177">The array to be initialized.</span></span></param>
        <param name="fldHandle"><span data-ttu-id="c6f7f-178">배열을 초기화하는 데 사용되는 데이터의 위치를 지정하는 필드 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-178">A field handle that specifies the location of the data used to initialize the array.</span></span></param>
        <summary><span data-ttu-id="c6f7f-179">모듈에 저장되는 데이터의 배열을 신속하게 초기화하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-179">Provides a fast way to initialize an array from data that is stored in a module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-180">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberSignature Language="F#" Value="static member IsReferenceOrContainsReferences : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetToStringData : int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c6f7f-181">지정된 문자열에 있는 데이터의 오프셋을 바이트 단위로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-181">Gets the offset, in bytes, to the data in the given string.</span></span></summary>
        <value><span data-ttu-id="c6f7f-182"><see cref="T:System.String" /> 개체의 처음부터 문자열의 첫 번째 문자까지의 바이트 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-183">컴파일러는 관리 되는 문자열의 문자에 대 한 안전 하지 않거나, 하지만 효율적이 고 포인터가 작업에 대 한이 속성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="c6f7f-184">컴파일러는 사용 하기 전에 가비지 수집기에 의해 이동에 대 한 문자열을 고정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="c6f7f-185">공용 언어 런타임 문자열; 변경할 수 없는 참고 즉, 해당 내용은 읽거나 있지만 변경 되지 않습니다 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegions : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c6f7f-186">코드 본문을 CER(제약이 있는 실행 영역)로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-186">Designates a body of code as a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-187">표시 하려면이 메서드를 사용 하는 컴파일러 `catch`, `finally`, 및 `fault` 제약이 있는 실행 지역 (Cer)으로 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="c6f7f-188">제한 된 영역의 강력한 안정성 계약을 사용 하 여 다른 코드를 호출 해야 하는 것으로 표시 되는 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="c6f7f-189">할당 되거나 오류를 처리 하도록 준비 되 면 하지 않는 한 가상 메서드 호출을 준비 되지 않은 또는 불안정 한 확인 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="c6f7f-190">중간 이상 제외 하 고 언어 opcode는 `NOP`, 호출 간에 허용 되는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 메서드 및 `try` 블록.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="c6f7f-191">Cer에 대 한 자세한 내용은 참조의 클래스는 <xref:System.Runtime.ConstrainedExecution> 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="c6f7f-192">사용 하 여 표시 되는 Cer를 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 메서드 완벽 하 게 작동 하지 않습니다 경우는 <xref:System.StackOverflowException> 에서 생성 되는 `try` 블록입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="c6f7f-193">자세한 내용은 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> 메서드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="c6f7f-194"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 메서드는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c6f7f-195">다음 예제에서는 사용 하 여 핸들을 안정적으로 설정 하는 방법의 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="c6f7f-196">핸들을 지정 된 기존 핸들을 안정적으로 설정 하려면 해야 하는 기본 핸들을 할당 및 해당 핸들 내에서 후속 기록을 <xref:System.Runtime.InteropServices.SafeHandle> 개체는 원자성을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="c6f7f-197">이러한 작업 (예: 스레드 중단 또는 메모리 부족 예외) 사이 오류 유출 네이티브 핸들 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="c6f7f-198">사용할 수는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> 핸들이 누출 되지 있는지 확인 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-199">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-200">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegionsNoOP : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c6f7f-201">조사를 하지 않고 코드 본문을 CER(제약이 있는 실행 영역)로 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-202">컴파일러는이 메서드를 직접 호출할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="c6f7f-203">대신 CER 호출 하 여 정의 된 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-204">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-204">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-205">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-205">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareContractedDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="c6f7f-206">준비할 이벤트 대리자입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-206">The event delegate to prepare.</span></span></param>
        <summary><span data-ttu-id="c6f7f-207">애플리케이션이 <see cref="T:System.AppDomain" /> 이벤트 대리자를 동적으로 준비하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-208"><xref:System.AppDomain> 이벤트와 같은 위임 <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, 및 <xref:System.AppDomain.UnhandledException> 시작 시 자동으로 준비 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="c6f7f-209">준비 하는 다음 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="c6f7f-210">메서드를 사용 하 여 특성을 <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="c6f7f-211">메서드를 사용 하 여 특성을 <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="c6f7f-212">호출 된 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> 메서드를 동적으로 대리자를 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="c6f7f-213">자세한 내용은 문서를 참조 [유지 Your Code Running with the Reliability Features.NET Framework의](https://go.microsoft.com/fwlink/?LinkId=145491) MSDN Magazine의 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](https://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-214">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-214">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-215">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-215">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="c6f7f-216">준비할 대리자 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-216">The delegate type to prepare.</span></span></param>
        <summary><span data-ttu-id="c6f7f-217">지정된 대리자가 CER(제약이 있는 실행 영역)에 포함될 준비가 되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-218">컴파일러는 사용이 메서드는 대리자의 호출 메서드를 준비 하 고 해당 호출 (및 대리자의 정적으로 결정할 수 있는 호출 그래프)의 대상을 준비할 수 제약이 있는 실행 지역 (CER)으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-219">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-219">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-220">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-220">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c6f7f-221">CER(제약이 있는 실행 영역)에 포함하기 위해 메서드를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-221">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="c6f7f-222">준비할 메서드에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-222">A handle to the method to prepare.</span></span></param>
        <summary><span data-ttu-id="c6f7f-223">CER(제약이 있는 실행 영역)에 포함하기 위해 메서드를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-223">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-224">컴파일러는 사용 된 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> 제약이 있는 실행 지역 (CER) 내에서 만들어진 가상 호출을 처리 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="c6f7f-225">JIT 컴파일 시 공용 언어 런타임 일반적으로 충분 한 정보가 없는 가상 호출의 대상에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="c6f7f-226">따라서 런타임에서 처음에 호출 그래프의 해당 세그먼트를 준비 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="c6f7f-227">CER을 사용 하는 코드에 충분 한 지식이 전으로 CER에서 언제 든 지 대상을 결정할 실제로 입력 한 호출할 수 있는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> 일반적으로 인수로 지정 된 메서드에서 시작 되는 CER에 대 한 동일한 런타임 준비를 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-228">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-229">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle * RuntimeTypeHandle[] -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod (method, instantiation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="c6f7f-230">준비할 메서드에 대한 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-230">A handle to the method to prepare.</span></span></param>
        <param name="instantiation"><span data-ttu-id="c6f7f-231">메서드에 전달할 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-231">The instantiation to pass to the method.</span></span></param>
        <summary><span data-ttu-id="c6f7f-232">지정된 인스턴스를 사용하여 CER(제약이 있는 실행 영역)에 포함하기 위해 메서드를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-233">제네릭 사용 하 여 컴파일러에 대 한 지원을 제공할 수 있습니다는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="c6f7f-234">공용 언어 런타임에서 제네릭 형식 매개 변수 (두 형식 매개 변수와 메서드 또는 메서드 자체를 포함 하는 클래스)을 가진 메서드를 기반으로 제약이 있는 실행 지역 (Cer)를 준비할 수 없습니다 인스턴스화될 때 해당 형식 매개 변수 참조 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="c6f7f-235">이 오버 로드를 사용 하 여 (예: 배열 형식의), 특정 인스턴스화를 전달할 수 있습니다 (해당 되는 경우) 먼저 클래스 형식 매개 변수를 지정 하 고 뒤에 메서드 형식 매개 변수 (있는 경우).</span><span class="sxs-lookup"><span data-stu-id="c6f7f-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="c6f7f-236">런타임은 메서드의 해당 인스턴스를 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="c6f7f-237">(이 경우 사용 되는 인스턴스에 하나 이상의 참조 형식 매개 변수를 포함 하는 경우에 필요) 따라서 CER 스타일을 사용할 수 있습니다 `try` 제네릭 메서드 (또는 제네릭 클래스의 제네릭이 아닌 메서드에) 절 있으며의 인스턴스화를 사용 하 여 안정적으로 작동 <xref:System.Int32> 또는 다른 값 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="c6f7f-238">참조를 인스턴스화할 수 등의 형식은 <xref:System.String>, 명시적인 사용 해야 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> 메서드는 CER에서 메서드를 먼저 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-239">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-240">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberSignature Language="F#" Value="static member ProbeForSufficientStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c6f7f-241">사용자 코드에서 정해진 적당량의 스택 공간만 사용한다고 가정할 경우 다음 코드 블록 내에서 스택 오버플로가 발생할 수 없도록 특정한 스택 공간의 크기를 조사합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span></span> <span data-ttu-id="c6f7f-242">이 메서드 대신 CER(제약이 있는 실행 영역)을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-242">We recommend that you use a constrained execution region (CER) instead of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-243">이 메서드는 Microsoft SQL Server 및 Microsoft Exchange Server와 같은 스택 오버플로에 대해 복원 력 있는 호스트에서 실행 중인 때 제약이 있는 실행 지역 (CER) 인프라에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="c6f7f-244">이 메서드는 현재 x86 48KB 스택 공간에 대 한 프로브 플랫폼 하지만 정확한 크기 시간이 지남에 따라 변경 될 수 있으며 다른 플랫폼에서 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="c6f7f-245">이 메서드는 컴파일러에도 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="c6f7f-246">사용 하는 대신는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> 메서드를 표준 CER을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="c6f7f-247">보통 수준의 스택 공간을 사용 하려는 경우 즉, 호출 된 <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> 메서드 바로 앞에 `try` / `finally` 또는 `try` / `catch` 블록.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="c6f7f-248">재귀 메서드 또는 스택 공간을 많이 사용 하려는 호출 하는 경우 사용 해야는 <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c6f7f-249">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-249">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c6f7f-250">이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-250">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="static member RunClassConstructor : RuntimeTypeHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="c6f7f-251">형식 이니셜라이저를 실행해야 하는 형식을 지정하는 형식 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-251">A type handle that specifies the type for which a type initializer should be run.</span></span></param>
        <summary><span data-ttu-id="c6f7f-252">지정된 형식의 형식 이니셜라이저(정적 생성자라고도 함)가 실행되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-252">Ensures that the type initializer (also known as a static constructor) for the specified type has been run.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-253">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="c6f7f-254">형식 이니셜라이저가 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-254">The type initializer throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberSignature Language="F#" Value="static member RunModuleConstructor : ModuleHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module"><span data-ttu-id="c6f7f-255">실행할 모듈 생성자 메서드를 지정하는 핸들입니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-255">A handle that specifies the module constructor method to run.</span></span></param>
        <summary><span data-ttu-id="c6f7f-256">지정된 모듈 생성자 메서드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-256">Runs a specified module constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c6f7f-257">이 메서드는 컴파일러에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c6f7f-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="c6f7f-258">모듈 생성자가 예외를 throw한 경우</span><span class="sxs-lookup"><span data-stu-id="c6f7f-258">The module constructor throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member TryEnsureSufficientExecutionStack : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
