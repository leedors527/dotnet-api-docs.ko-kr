<Type Name="DllImportAttribute" FullName="System.Runtime.InteropServices.DllImportAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="69b97a15f89704bcf13a0181c90ad94a99851a98" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/17/2019" /><Meta Name="ms.locfileid" Value="59676620" /></Metadata><TypeSignature Language="C#" Value="public sealed class DllImportAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DllImportAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.DllImportAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DllImportAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DllImportAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DllImportAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>관리되지 않는 DLL(동적 연결 라이브러리)에서 특성 사용 해당 메서드를 정적 진입점으로 노출함을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드에이 특성을 적용할 수 있습니다.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute> 특성은 관리 되지 않는 DLL에서 내보낸 함수를 호출 하는 데 필요한 정보를 제공 합니다. 최소한, 진입점을 포함 하는 DLL의 이름을 제공 해야 합니다.  
  
 C# 및 c + + 메서드 정의에 직접이 특성을 적용 사용 하는 경우 Visual Basic 컴파일러가이 특성을 내보내는 반면는 `Declare` 문입니다. 포함 하는 복잡 한 메서드 정의 대 한 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping>, <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention>, <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling>, <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig>, <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError>, 또는 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 필드, Visual Basic 메서드 정의에 직접이 특성을 적용 합니다.  
  
 **참고** JScript이이 특성을 지원 하지 않습니다. JScript 프로그램에서 관리 되지 않는 API 메서드에 액세스 하는 C# 또는 Visual Basic 래퍼 클래스를 사용할 수 있습니다.  
  
 플랫폼을 사용 하는 방법에 대 한 자세한 내용은 서비스에 대 한 액세스 관리 되지 않는 Dll 함수 호출을 참조 하십시오 [관리 되지 않는 DLL 함수 사용](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)합니다.  
  
> [!NOTE]
>  <xref:System.Runtime.InteropServices.DllImportAttribute> 제네릭 형식의 마샬링은 지원 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 가져오려면 Win32 특성 `MessageBox` 함수입니다.  다음 코드 예제에서는 가져온된 메서드를 호출 합니다.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
    <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DllImportAttribute (string dllName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.DllImportAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dllName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DllImportAttribute(System::String ^ dllName);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.DllImportAttribute : string -&gt; System.Runtime.InteropServices.DllImportAttribute" Usage="new System.Runtime.InteropServices.DllImportAttribute dllName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dllName">관리되지 않는 메서드를 포함하는 DLL의 이름입니다. DLL이 어셈블리에 포함되어 있는 경우 이 이름에는 어셈블리 표시 이름이 포함될 수 있습니다.</param>
        <summary>가져올 메서드가 포함된 DLL의 이름을 사용하여 <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 링커를 사용 하 여 예를 들어, 어셈블리에는 관리 되지 않는 DLL 파일은 포함 하는 경우 또는 `/linkresource` 컴파일러 옵션의 일부로 어셈블리 표시 이름을 지정할 수 `dllName`입니다. 예를 들어 라는 관리 되지 않는 DLL `unmanaged.dll` 이라는 관리 되는 어셈블리에 포함 되어 `MyAssembly`, 다음 코드와 같이 특성을 지정할 수 있습니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#2)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#2)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#2)]  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 가져오려면 Win32 특성 `MessageBox` 함수입니다.  다음 코드 예제에서는 가져온된 메서드를 호출 합니다.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BestFitMapping">
      <MemberSignature Language="C#" Value="public bool BestFitMapping;" />
      <MemberSignature Language="ILAsm" Value=".field public bool BestFitMapping" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberSignature Language="VB.NET" Value="Public BestFitMapping As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool BestFitMapping;" />
      <MemberSignature Language="F#" Value="val mutable BestFitMapping : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>유니코드 문자를 ANSI 문자로 변환할 때 가장 적합한 매핑 동작을 활성화 또는 비활성화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `true`, 가장 적합 한 매핑 동작은 사용할 수 있습니다; 그렇지 않으면, 최적 매핑을 사용할 수 없습니다. 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> 필드는 `true` 기본적으로 합니다. 이 필드에 대 한 설정에 대 한 모든 수준 설정을 재정의 합니다 <xref:System.Runtime.InteropServices.BestFitMappingAttribute?displayProperty=nameWithType> 특성입니다.  
  
 공용 언어 런타임을 모든 Windows 98 또는 Windows 내에서 실행 중인 관리 되지 않는 메서드를 전달 하는 유니코드 문자를 관리 하는 ANSI 문자로 변환 최적된 매핑을 사용 하면 interop 마샬러가 존재 하는 정확히 일치 하는 경우 닫기 일치 하는 문자를 제공 합니다. 예를 들어 마샬러를 'c' ANSI 문자를 허용 하는 관리 되지 않는 메서드에 대 한 저작권 유니코드 문자를 변환 합니다. 문자가 없는 가장 적합된 한 표현입니다. 이러한 문자를 매핑할 수 없는 호출 됩니다. 기본값에 매핑할 수 없는 문자는 주로 '?' ANSI 문자입니다.  
  
> [!CAUTION]
>  특정 유니코드 문자는 백슬래시와 같은 위험한 문자로, 변환할 '\\' 문자를 경로 변경할 수 있습니다. 설정 하 여 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 필드를 `true`, 예외를 throw 하 여 호출자에 게 매핑할 수 없는 문자의 현재 상태를 알릴 수 있습니다.  
  
> [!CAUTION]
>  제공 되는 기본값을 변경할 수 없습니다는 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> 고 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 안전 배열을 관리 되지 않는 ANSI Char 또는 Lpstr는 관리 되는 배열 요소가 전달 하면 필드입니다. 최적된 매핑을 항상 사용 하도록 설정 하 고 예외가 throw 되지 않습니다. 이 조합은 보안 모델을 손상 시킬 수는 알아야 합니다.  
  
   
  
## Examples  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다. 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute>, 대신는 `Declare` 문을, 관리 코드에서 DLL 함수를 정의 합니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> 필드는 이러한 사례 중 하나입니다. 다음 예제에서는 엄격한 적용 하는 방법을 보여 줍니다 문자 매핑을 보안 플랫폼에 ANSI 문자 집합을 지정 하 고 가장 적합된 한 매핑 동작을 사용 하지 않도록 설정 또는 매핑되지 않은 유니코드 문자에 예외를 throw 하 여 메서드 정의 호출 합니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="T:System.Runtime.InteropServices.BestFitMappingAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop 마샬링</related>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CallingConvention CallingConvention;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CallingConvention CallingConvention" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public CallingConvention As CallingConvention " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CallingConvention CallingConvention;" />
      <MemberSignature Language="F#" Value="val mutable CallingConvention : System.Runtime.InteropServices.CallingConvention" Usage="System.Runtime.InteropServices.DllImportAttribute.CallingConvention" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CallingConvention</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>진입점의 호출 규칙을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드 중 하나를 설정 하 여 <xref:System.Runtime.InteropServices.CallingConvention> 열거형 멤버입니다. 기본값을 <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> 필드는 <xref:System.Runtime.InteropServices.CallingConvention.Winapi>에이 기본값이 됩니다 <xref:System.Runtime.InteropServices.CallingConvention.StdCall> 규칙.  
  
   
  
## Examples  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다. 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute>, 대신는 `Declare` 문을, 관리 코드에서 DLL 함수를 정의 합니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.CallingConvention> 필드는 이러한 사례 중 하나입니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#1)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CallingConvention" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.DllImportAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문자열 매개 변수를 메서드로 마샬링하는 방법을 지정하고 이름 관리를 제어합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 필드를 사용 하 여 멤버와는 <xref:System.Runtime.InteropServices.CharSet> 열거형 문자열 매개 변수 마샬링 동작을 지정 하 고 (지정 된 정확한 이름 또는 "A" 또는 "W"로 끝나는 이름)을 호출 하는 진입점 이름을 지정 합니다. C# 및 Visual Basic의 기본 열거형 멤버 `CharSet.Ansi` c + +에 대 한 기본 열거형 멤버 이며 `CharSet.None`, 동등한 `CharSet.Ansi`합니다. 사용할 Visual basic의 경우는 `Declare` 문을 지정 하는 `CharSet` 필드입니다.  
  
 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> 필드의 동작에 영향을 줍니다는 `CharSet` 필드를 호출 하는 진입점 이름을 결정 합니다. 자세한 설명 및 문자열 마샬링 및 이름 일치와 관련 된 동작의 예에는 `CharSet` 필드를 참조 하십시오 [문자 집합 지정](~/docs/framework/interop/specifying-a-character-set.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 가져오려면 Win32 특성 `MessageBox` 함수입니다.  다음 코드 예제에서는 가져온된 메서드를 호출 합니다.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.Canonical#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.Canonical/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public string EntryPoint;" />
      <MemberSignature Language="ILAsm" Value=".field public string EntryPoint" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public EntryPoint As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ EntryPoint;" />
      <MemberSignature Language="F#" Value="val mutable EntryPoint : string" Usage="System.Runtime.InteropServices.DllImportAttribute.EntryPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호출할 DLL 진입점의 이름 또는 서수를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 진입점을 포함 하는 DLL의 이름을 나타내는 문자열을 제공 하 여 진입점 이름을 지정 하거나 해당 서 수로 진입점을 식별할 수 있습니다. 예를 들어 1은 # 기호로 서 수 붙습니다. 공용 언어 런타임에서 사용 하 여 표시 된 the.NET 메서드의 이름을 사용 하 여이 필드를 생략 하면는 <xref:System.Runtime.InteropServices.DllImportAttribute>합니다.  
  
 자세한 내용은 참조 하세요. [Dll 함수 식별](~/docs/framework/interop/identifying-functions-in-dlls.md)합니다. 사용 하는 방법을 보여 주는 예는 <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> 필드를 참조 하십시오 [진입점 지정](~/docs/framework/interop/specifying-an-entry-point.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 가져오려면 Win32 특성 `MessageBox` 함수입니다.  사용 하 여 코드 예제는 <xref:System.Runtime.InteropServices.DllImportAttribute.EntryPoint> 함수를 지정 하는 속성으로 이름을 변경한 다음, `MyNewMessageBoxMethod`합니다.  
  
 [!code-csharp[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.DllImport.EntryPoint#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.DllImport.EntryPoint/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.DllImportAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ExactSpelling">
      <MemberSignature Language="C#" Value="public bool ExactSpelling;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ExactSpelling" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberSignature Language="VB.NET" Value="Public ExactSpelling As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ExactSpelling;" />
      <MemberSignature Language="F#" Value="val mutable ExactSpelling : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" /> 필드로 인해 공용 언어 런타임이 지정된 이름 이외의 진입점 이름을 관리되지 않는 DLL에서 검색할지 여부를 제어합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `false`, 문자 A 사용 하 여 추가 진입점 이름을 호출 되 때를 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> 필드 설정 됩니다 `CharSet.Ansi`, W 문자로 추가 진입점 이름을 호출 되 고 때를 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet?displayProperty=nameWithType> 필드 설정 됩니다는 `CharSet.Unicode`합니다. 일반적으로 관리 되는 컴파일러는이 필드를 설정합니다.  
  
 다음 표에서 간의 관계를 보여 줍니다.는 <xref:System.Runtime.InteropServices.DllImportAttribute.CharSet> 및 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> 필드, 프로그래밍 언어에서 적용 되는 기본 값을 기반으로 합니다. 기본 설정을 재정의할 수 있지만 주의 해야 합니다.  
  
|언어|ANSI|유니코드(Unicode)|자동|  
|--------------|----------|-------------|----------|  
|Visual Basic|ExactSpelling:=True|ExactSpelling:=True|ExactSpelling:=False|  
|C#|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
|C++|ExactSpelling=false|ExactSpelling=false|ExactSpelling=false|  
  
   
  
## Examples  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다.는 <xref:System.Runtime.InteropServices.DllImportAttribute>를 사용 하는 대신는 `Declare` 문을, 관리 코드에서 DLL 함수를 정의 합니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.ExactSpelling> 필드는 이러한 사례 중 하나입니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#4)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#4)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveSig">
      <MemberSignature Language="C#" Value="public bool PreserveSig;" />
      <MemberSignature Language="ILAsm" Value=".field public bool PreserveSig" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberSignature Language="VB.NET" Value="Public PreserveSig As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool PreserveSig;" />
      <MemberSignature Language="F#" Value="val mutable PreserveSig : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.PreserveSig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="HRESULT" /> 또는 <see langword="retval" /> 반환 값이 있는 관리되지 않는 메서드가 직접 변환되는지 아니면 <see langword="HRESULT" /> 또는 <see langword="retval" /> 반환 값이 자동으로 예외로 변환되는지 여부를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드를 `true` 사용 하 여 관리 되지 않는 용법을 직접 변환할 `HRESULT` 또는 `retval` 값;으로 설정 `false` 자동으로 변환할 `HRESULT` 또는 `retval` 예외에 대 한 값입니다. 기본적으로 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드는 `true`합니다.  
  
 때 `true`, 결과 메서드 서명을 포함 하는 정수 값을 반환 합니다 `HRESULT` 값입니다.  이 경우 수동으로 반환 값을 검사 하며 그에 따라 응답 응용 프로그램에서 합니다.  
  
 설정 하는 경우는 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드를 `false`, 결과 메서드 시그니처에 정수 대신 반환 형식이 void (`HRESULT`) 형식을 반환 합니다.  관리 되지 않는 메서드를 생성 하는 경우는 `HRESULT`, 형식의 반환 값을 자동으로 무시 `S_OK` (또는 0) 및 예외를 throw 하지 않습니다.  에 대 한 `HRESULT`이외의 s `S_OK`, 런타임에서 자동으로 해당 하는 예외를 throw 합니다 `HRESULT`합니다.  유의 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 특성에는 반환 하는 방법으로이 변환을 수행는 `HRESULT`합니다.  
  
 기본 오류 보고 동작을 변경할 수도 있습니다 `HRESULT`s 오류 보고 응용 프로그램의 구조에 예외 보다 적합 한 경우에는 예외입니다.  
  
 그러나이 필드는 비슷합니다는 <xref:System.Runtime.InteropServices.PreserveSigAttribute>, 달리을 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드에 기본값을 사용 하는 특성에 대 한 `false`합니다.  
  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다.는 <xref:System.Runtime.InteropServices.DllImportAttribute>를 사용 하는 대신는 `Declare` 문을, 관리 코드에서 DLL 함수를 정의 합니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드는 이러한 사례 중 하나입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Runtime.InteropServices.DllImportAttribute> 관리 되지 않는 가져오려는 `SHAutoComplete` 함수를 한 번를 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드 설정 `true` 및 사용 하 여 다시를 <xref:System.Runtime.InteropServices.DllImportAttribute.PreserveSig> 필드로 `false`.  이 코드 예제에서는 합니다 `SHAutoComplete` 한 번은 예외를 사용 하 여 모든 오류를 생성 하는 함수 및 `HRESULT` 다음입니다.  
  
 [!code-csharp[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.PreserveSigAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.PreserveSigAttribute/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.PreserveSigAttribute" />
      </Docs>
    </Member>
    <Member MemberName="SetLastError">
      <MemberSignature Language="C#" Value="public bool SetLastError;" />
      <MemberSignature Language="ILAsm" Value=".field public bool SetLastError" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberSignature Language="VB.NET" Value="Public SetLastError As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool SetLastError;" />
      <MemberSignature Language="F#" Value="val mutable SetLastError : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.SetLastError" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특성 사용 메서드에서 반환하기 전에 호출 수신자가 <see langword="SetLastError" /> Windows API 함수를 호출할지 여부를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` 호출 수신자는 호출을 나타내려면 `SetLastError`이 고, 그렇지 않으면 `false`합니다. 기본값은 `false`입니다.  
  
 런타임이 마샬러 호출 `GetLastError` 및 다른 API 호출에 의해 덮어쓰여지지 않도록 방지 하기 위해 반환 되는 값을 캐시 합니다. 호출 하 여 오류 코드를 검색할 수 있습니다 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>합니다.  
  
   
  
## Examples  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다.는 <xref:System.Runtime.InteropServices.DllImportAttribute>를 사용 하는 대신는 `Declare` 문을, 관리 코드에서 DLL 함수를 정의 합니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> 필드는 이러한 사례 중 하나입니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#5)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#5)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      </Docs>
    </Member>
    <Member MemberName="ThrowOnUnmappableChar">
      <MemberSignature Language="C#" Value="public bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="ILAsm" Value=".field public bool ThrowOnUnmappableChar" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberSignature Language="VB.NET" Value="Public ThrowOnUnmappableChar As Boolean " />
      <MemberSignature Language="C++ CLI" Value="public: bool ThrowOnUnmappableChar;" />
      <MemberSignature Language="F#" Value="val mutable ThrowOnUnmappableChar : bool" Usage="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ANSI "?" 문자로 변환되는 매핑할 수 없는 유니코드 문자가 나오면 예외를 throw하거나 throw하지 않습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true` interop 마샬러가 나타낼 때마다 예외를 throw 하는 문자가 나오면; `false` 나타내는 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 필드가 비활성화 됩니다. 이 필드는 `false` 기본적으로 합니다.  
  
 공용 언어 런타임을 모든 Windows 98 또는 Windows 내에서 실행 중인 관리 되지 않는 메서드를 전달 하는 유니코드 문자를 관리 하는 ANSI 문자로 변환 최적된 매핑을 사용 하면 interop 마샬러가 존재 하는 정확히 일치 하는 경우 닫기 일치 하는 문자를 제공 합니다. 예를 들어 마샬러를 'c' ANSI 문자를 허용 하는 관리 되지 않는 메서드에 대 한 저작권 유니코드 문자를 변환 합니다. 문자가 없는 가장 적합된 한 표현입니다. 이러한 문자를 매핑할 수 없는 호출 됩니다. 기본값에 매핑할 수 없는 문자는 주로 '?' ANSI 문자입니다.  
  
> [!CAUTION]
>  특정 유니코드 문자는 백슬래시와 같은 위험한 문자로, 변환할 '\\' 문자를 경로 변경할 수 있습니다. 설정 하 여 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 필드를 `true`, 예외를 throw 하 여 호출자에 게 매핑할 수 없는 문자의 현재 상태를 알릴 수 있습니다.  
  
> [!CAUTION]
>  제공 되는 기본값을 변경할 수 없습니다는 <xref:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping> 고 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 안전 배열을 관리 되지 않는 ANSI Char 또는 Lpstr는 관리 되는 배열 요소가 전달 하면 필드입니다. 최적된 매핑을 항상 사용 하도록 설정 하 고 예외가 throw 되지 않습니다. 이 조합은 보안 모델을 손상 시킬 수는 알아야 합니다.  
  
   
  
## Examples  
 경우에 따라 Visual Basic 개발자는 다음과 같이 사용 됩니다. 합니다 <xref:System.Runtime.InteropServices.DllImportAttribute> 사용 하는 대신 관리 되는 코드에서 DLL 함수를 정의 하는 `Declare` 문입니다. 설정 된 <xref:System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar> 필드는 이러한 사례 중 하나입니다. 다음 예제에서는 엄격한 적용 하는 방법을 보여 줍니다 문자 매핑을 보안 플랫폼에 ANSI 문자 집합을 지정 하 고 가장 적합된 한 매핑 동작을 사용 하지 않도록 설정 또는 매핑되지 않은 유니코드 문자에 예외를 throw 하 여 메서드 정의 호출 합니다.  
  
 [!code-cpp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cpp/source.cpp#3)]
 [!code-csharp[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/cs/source.cs#3)]
 [!code-vb[System.Runtime.InteropServices.DllImportAttribute#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.dllimportattribute/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.CharSet" />
        <altmember cref="F:System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" />
        <related type="Article" href="https://msdn.microsoft.com/library/115f7a2f-d422-4605-ab36-13a8dd28142a">Interop 마샬링</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Runtime.InteropServices.DllImportAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>진입점을 포함하는 DLL 파일의 이름을 가져옵니다.</summary>
        <value>진입점을 포함하는 DLL 파일의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 전체 경로나 상대 경로 제공할 수 있습니다. 경로 제공 하는 경우 메시지 DLL이 다른 방법으로 로드 하지 않는 한 런타임에 현재 경로에서 DLL 여야 합니다. 그러나 주의 DLL이 이동 된 경우 부정확성 발생할 수 있습니다는 정규화 된 경로 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>