<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f116e83772ad89fa2d72ace082b41f76d2be95c6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39967261" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RemotingServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>원격 개체와 프록시를 사용하고 게시할 수 있도록 여러 메서드를 제공합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 트랜잭션, 활성화 및 수명 관리 등의 문제를 다루는 서비스 공급자 인 경우가 아니면 프록시 참조 및 개체 참조를 구분할 필요가 없습니다. 원격 인프라는 원격 개체는 클라이언트의 공간에 있는 것 처럼 보일 투명 프록시를 사용 합니다. 프록시는 원격 위치의 실제 개체에 대 한 호출을 전달 하 여이 작업을 수행 합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>잘 알려진 개체에 대한 프록시를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">연결하려고 하는 서버 쪽에 있는 잘 알려진 개체의 <see cref="T:System.Type" />입니다.</param>
        <param name="url">서버 클래스의 URL입니다.</param>
        <summary>지정된 <see cref="T:System.Type" />과 URL이 있는 잘 알려진 개체에 대한 프록시를 만듭니다.</summary>
        <returns>지정된 잘 알려진 개체의 엔드포인트를 가리키는 원격 개체에 대한 프록시입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 프록시 개체는 지정된 된 잘 알려진 개체의 끝점을 가리킵니다. 프록시에서 메서드를 호출할 때까지 메시지가 네트워크를 통해 전송 됩니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Runtime.Remoting.RemotingServices.Connect%2A> 잘 알려진 개체에 프록시를 만드는 방법.  
  
 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 원격 형식 및 채널을 구성할 수 있는 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">연결하려고 하는 잘 알려진 개체의 <see cref="T:System.Type" />입니다.</param>
        <param name="url">잘 알려진 개체의 URL입니다.</param>
        <param name="data">채널 관련 데이터이며, <see langword="null" />일 수 있습니다.</param>
        <summary>지정된 <see cref="T:System.Type" />과 URL 및 채널 관련 데이터가 잘 알려진 개체에 대한 프록시를 만듭니다.</summary>
        <returns>요청한 잘 알려진 개체의 엔드포인트를 가리키는 프록시입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 프록시 개체는 지정된 된 잘 알려진 개체의 끝점을 가리킵니다. 프록시에서 메서드를 호출할 때까지 메시지가 네트워크를 통해 전송 됩니다.  
  
 합니다 `data` 개체를 채널에 대 한 정보를 통신에 사용 되 고 전달 되는 <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 원격 형식 및 채널을 구성할 수 있는 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">해당 채널로부터의 연결을 끊을 개체입니다.</param>
        <summary>등록된 원격 채널을 통해 개체가 메시지를 더 이상 받지 않도록 합니다.</summary>
        <returns>등록된 원격 채널에서 개체의 연결이 끊어졌으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> 원격 채널에서 개체를 분리 하는 방법입니다.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> 매개 변수가 프록시인 경우</exception>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 원격 형식 및 채널을 구성할 수 있는 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">호출하려는 메서드가 들어 있는 원격 개체입니다.</param>
        <param name="reqMsg">지정된 원격 개체의 메서드에 대한 메서드 호출 메시지입니다.</param>
        <summary>지정된 원격 개체에 연결한 다음, 제공된 <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" />를 해당 개체에서 실행합니다.</summary>
        <returns>원격 메서드의 응답입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 메서드는 다른, 예: 원격 개체에 지정 된 메서드 호출을 전달 하는 서버에서 특별 한 경우에 사용 됩니다. 호출자가 적절 한 컨텍스트에 있는 경우에이 메서드를 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> 원격 개체에 대 한 메서드 호출을 전달 하는 방법입니다.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">메서드가 개체의 기본 컨텍스트가 아닌 컨텍스트에서 호출된 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">요청한 엔보이 싱크와 연결된 원격 개체의 프록시입니다.</param>
        <summary>지정된 프록시가 가리키는 원격 개체에 메시지를 보낼 때 사용하는 엔보이 싱크 체인을 반환합니다.</summary>
        <returns>지정된 프록시와 연결된 엔보이 싱크 체인입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 엔보이 싱크는와 함께 전송 싱크는 <xref:System.Runtime.Remoting.ObjRef> 메시지 개체를 반환할 때 사용 되는 개체입니다. 현재 메서드는 개체의 프록시 및 자체 개체 간의 통신 중에 사용 되는 엔보이 싱크를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">수명 서비스를 가져올 개체입니다.</param>
        <summary>지정된 개체의 수명 정책을 제어하는 수명 서비스 개체를 반환합니다.</summary>
        <returns>
          <paramref name="obj" />의 수명을 제어하는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 수명 서비스에 대 한 반환된 된 개체 형식의 개체 수는 <xref:System.Runtime.Remoting.Lifetime.ILease>합니다. 경우는 `obj` 매개 변수가 `null`, 메서드가 반환 `null`합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> 메서드를 지정된 된 개체에 대 한 수명 임대를 가져옵니다.  
  
 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]  
  
 를 컴파일하고이 예제를 실행 하려면 컴파일 및 서버, timerserver.exe, 및는 공유 라이브러리를 컴파일 timerservice.dll 실행 해야 합니다.  
  
 Timerserver.exe 소스는 다음과 같습니다.  
  
 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]  
  
 Timerservice.dll 소스는 다음과 같습니다.  
  
 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">메서드 기본 사항을 추출할 메서드 메시지입니다.</param>
        <summary>지정된 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />에서 메서드 기본 사항을 반환합니다.</summary>
        <returns>
          <paramref name="msg" /> 매개 변수에서 추출한 메서드 기본 사항입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 기본 사항을 결정 합니다 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>, <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>, 및 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> 속성을 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> 구현 하는 클래스에서 사용 되는 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> 인터페이스입니다. 많이 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> 클래스를 참조 해야 합니다 <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없거나 호출 스택의 상위에 있는 직접 실행 호출자 중 적어도 하나에 public이 아닌 멤버의 형식 정보를 검색할 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">serialize할 개체입니다.</param>
        <param name="info">개체가 serialize될 <see cref="T:System.Runtime.Serialization.SerializationInfo" />입니다.</param>
        <param name="context">serialization의 소스 및 대상입니다.</param>
        <summary>참조로 마샬링된 지정된 개체를 제공된 <see cref="T:System.Runtime.Serialization.SerializationInfo" />로 serialize합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 또는 <paramref name="info" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">URI가 요청된 <see cref="T:System.MarshalByRefObject" />입니다.</param>
        <summary>지정된 개체의 URI를 검색합니다.</summary>
        <returns>지정된 개체에 URI가 있으면 해당 URI이고, 개체가 아직 마샬링되지 않았으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Runtime.Remoting.ObjRef" />를 만들려는 개체에 연결되어 있는 프록시입니다.</param>
        <summary>원격 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" />를 지정된 프록시에서 반환합니다.</summary>
        <returns>지정된 프록시가 연결되어 있는 원격 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" />이거나, 개체나 프록시가 아직 마샬링되지 않았으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다. 역마샬링 하는 동안 합니다 <xref:System.Runtime.Remoting.ObjRef> 원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하려면 구문 분석 및 <xref:System.Runtime.Remoting.Proxies.RealProxy> 개체가 만들어집니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI와 관련 된 원격 응용 프로그램에 도달 하는 방법에 대 한 정보 및 위치 개체는 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 가져오는 방법을 보여 줍니다는 <xref:System.Runtime.Remoting.ObjRef> 지정된 된 개체에 대 한 인스턴스.  
  
 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">투명 프록시입니다.</param>
        <summary>지정된 투명 프록시를 지원하는 실제 프록시를 반환합니다.</summary>
        <returns>투명 프록시를 지원하는 실제 프록시 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 종류의 remoting 경계 간에 개체를 사용 하는 클라이언트 개체에 대 한 투명 프록시 실제로 사용 됩니다. 투명 프록시는 실제 개체는 클라이언트의 공간에 상주 하는 느낌을 제공 합니다. 원격 인프라를 사용 하 여 실제 개체에 대해 호출을 전달 하 여 달성 합니다.  
  
 투명 프록시 형식의 관리 되는 런타임 클래스의 인스턴스에 의해 지원 됩니다 <xref:System.Runtime.Remoting.Proxies.RealProxy>합니다. <xref:System.Runtime.Remoting.Proxies.RealProxy> 투명 프록시에서 작업을 전달 하는 데 필요한 기능 중 일부를 구현 합니다.  
  
 프록시 개체는 가비지 컬렉션, 멤버 및 메서드를 실행 하는 것에 대 한 지원 등의 관리 되는 개체의 연결 된 의미 체계를 상속 하 고 양식 새 클래스를 확장할 수 있습니다. 프록시 (투명 프록시), 원격 개체와 동일한 클래스의 개체 처럼 동작 하 고 관리 되는 개체 이기도 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI">
          <see cref="T:System.Type" />이 요청된 개체의 URI입니다.</param>
        <summary>지정된 URI가 있는 개체의 <see cref="T:System.Type" />을 반환합니다.</summary>
        <returns>지정된 URI가 있는 개체의 <see cref="T:System.Type" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uri를 사용 하 여 끝점을 식별 하는 원격 서비스를 <xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> 메서드를 사용 하는 원격 인프라 (예: 채널 싱크, 동적 싱크 및 컨텍스트 싱크)의 플러그형 부분에서 매우 유용 <xref:System.Runtime.Remoting.Messaging.IMessage> 개체를 현재 메서드는 URI에서 연결 된 형식 개체를 반환 합니다.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없거나 호출 스택의 상위에 있는 직접 실행 호출자 중 적어도 하나에 public이 아닌 멤버의 형식 정보를 검색할 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">public이 아닌 멤버의 형식 정보를 검색 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">세션 ID가 요청된 <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />입니다.</param>
        <summary>메시지의 세션 ID를 검색합니다.</summary>
        <returns>현재 세션을 고유하게 식별하는 세션 ID 문자열을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동일한 세션 ID는 동일한 응용 프로그램의 개체에 대해 반환 될 수 있습니다 하지만이 메서드는 다른 원격 응용 프로그램에서 두 개체에 대해 동일한 세션 ID를 반환 하지 않습니다.  
  
 세션 및 세션 Id 식별 하는 방법에 대 한 자세한 내용은 ASP.Net을 참조 하세요 [ASP.NET 세션 상태 개요](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 현재 세션의 세션 ID 문자열을 가져오는 방법을 보여 줍니다.  
  
 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">해당 메서드에 대한 호출이 들어 있는 메시지입니다.</param>
        <summary>지정된 메시지의 메서드가 오버로드되었는지 여부를 나타내는 부울 값을 반환합니다.</summary>
        <returns>
          <paramref name="msg" />로 호출된 메서드가 오버로드되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">검사할 개체입니다.</param>
        <summary>주어진 투명 프록시로 지정된 개체가 현재 메서드를 호출한 개체가 아닌 다른 응용 프로그램 도메인에 포함되어 있는지 여부를 나타내는 부울 값을 반환합니다.</summary>
        <returns>개체가 현재 응용 프로그램 도메인 외부에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 응용 프로그램 도메인에 대 한 자세한 내용은 [응용 프로그램 도메인](http://msdn.microsoft.com/library/39e57d07-a740-4cd4-ae82-e119ea3856c1)합니다.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">검사할 개체입니다.</param>
        <summary>지정된 프록시가 나타내는 개체가 현재 메서드를 호출한 개체가 아닌 다른 컨텍스트에 포함되어 있는지 여부를 나타내는 부울 값을 반환합니다.</summary>
        <returns>개체가 현재 컨텍스트 외부에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨텍스트는 그 안에 상주 하는 개체의 환경을 정의 하는 속성의 시퀀스를 정렬된 합니다. 컨텍스트는 이러한 동기화, 트랜잭션,-just-in-time 활성화, 보안 및 등 특정 자동 서비스 필요로 하는 개체에 대 한 활성화 프로세스 중 생성 됩니다. 컨텍스트에는 여러 개의 개체가 존재할 수 있습니다.  
  
   
  
## Examples  
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">다루고 있는 메서드입니다.</param>
        <summary>주어진 메시지에서 지정된 메서드를 호출한 클라이언트가 실행을 계속하기 전에 서버가 메서드 처리를 마칠 때까지 기다리는지 여부를 나타내는 부울 값을 반환합니다.</summary>
        <returns>해당 메서드가 단방향 메서드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단방향 메서드를 호출 하는 경우에 메시지 처리를 완료 하려면 서버에 대 한 클라이언트 기다리지 않습니다. 클라이언트 방법을 알지 여부 서버 성공적으로 처리할 메시지의 응용 프로그램에 반환 합니다. 메서드는 한 가지 방법은 사용 하 여 표시 되는 <xref:System.Runtime.Remoting.Messaging.OneWayAttribute>합니다.  
  
 단방향 메서드는 반환 값 또는 out 매개 변수를 가질 수 없습니다.  
  
   
  
## Examples  
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">직접 실행 호출자에 인프라 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">한 인프라 코드를 사용 하 여 작동 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">확인할 개체에 대한 참조입니다.</param>
        <summary>지정된 개체가 투명 프록시 개체인지 또는 실제 개체인지를 나타내는 부울 값을 반환합니다.</summary>
        <returns>
          <paramref name="proxy" /> 매개 변수에 지정된 개체가 투명 프록시 개체인지 또는 실제 개체인지를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 종류의 remoting 경계 간에 개체를 사용 하는 클라이언트 실제로 투명 프록시를 사용 하 여 개체에 대 한 됩니다. 투명 프록시는 실제 개체는 클라이언트의 공간에 상주 하는 느낌을 제공 합니다. 원격 인프라를 사용 하 여 실제 개체에 대해 호출을 전달 하 여 달성 합니다.  
  
 투명 프록시 형식의 관리 되는 런타임 클래스의 인스턴스 자체는 <xref:System.Runtime.Remoting.Proxies.RealProxy>합니다. <xref:System.Runtime.Remoting.Proxies.RealProxy> 투명 프록시에서 작업을 전달 하는 데 필요한 기능 중 일부를 구현 합니다. 프록시 개체는 가비지 컬렉션, 멤버 및 메서드를 실행 하는 것에 대 한 지원 등의 관리 되는 개체의 연결 된 의미 체계를 상속 하 고 양식 새 클래스를 확장할 수 있습니다. 따라서 프록시에는 이중 특성이 있습니다. 원격 개체 (투명 프록시)와 동일한 클래스의 개체와 작업을 수행 해야 한편 및 다른 자체 관리 되는 개체입니다.  
  
 모든 원격 하나당에 관계 없이 프록시 개체를 사용할 수는 <xref:System.AppDomain>합니다. 응용 프로그램 프록시 참조 및 개체 참조를 구분 하지 해야 합니다. 그러나 서비스 공급자 정품 인증과 같은 문제를 다루는, 수명 관리와 트랜잭션 해야 이러한 차이점을 확인 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> 개체는 프록시 또는 실제 개체 인지 여부를 결정 하는 방법입니다. 전체 예제 코드에 대 한 예제를 참조 하세요.를 <xref:System.Runtime.Remoting.Messaging.AsyncResult> 클래스입니다.  
  
 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">원격 교환의 단계를 식별하는 내부적으로 정의된 상수입니다.</param>
        <summary>외부 디버거에 원격 교환의 단계를 로깅합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `"REMOTING_PERF"` 전처리 기호를 사용 하 여 메서드에 적용 되는 <xref:System.Diagnostics.ConditionalAttribute> 특성입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 <see cref="T:System.MarshalByRefObject" />를 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스로 변환하여 응용 프로그램 도메인과 네트워크 사이에서 전송이 가능하도록 serialize합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">변환할 개체입니다.</param>
        <summary>
          <see cref="T:System.MarshalByRefObject" />를 가져와서 원격 인프라에 등록한 다음 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스로 변환합니다.</summary>
        <returns>
          <paramref name="Obj" /> 매개 변수에 지정된 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 원격 하위 영역에 도달 하는 방법에 대 한 정보 개체가 위치한 합니다.  
  
 마샬링하는 동안 현재 스레드의 컨텍스트를 사용, 컨텍스트가 아닌 활성화 되어 있던 개체를 만들 때. URI 명시적으로 설정 되지 않은 경우는 <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> 메서드를 원격 id 인프라에서 자동으로 생성 됩니다.  
  
 두 가지 이유 중 하나에 대 한 프록시를 사용 하 여 URI를 연결할 수 없습니다: URI를 나타내는 개체에 대 한 서버 쪽에서 생성 된 또는 URI가 알려져 있는 경우에 개체는 잘 알려져 있는 경우. 따라서이 경우는 `Obj` 매개 변수가 프록시인, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체로 처리 되므로 이러한 제한이 완화 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" /> 매개 변수가 개체 프록시인 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">변환할 개체입니다.</param>
        <param name="URI">새 <see cref="T:System.Runtime.Remoting.ObjRef" />를 초기화하는 데 사용할 지정된 URI입니다. <see langword="null" />일 수 있습니다.</param>
        <summary>주어진 <see cref="T:System.MarshalByRefObject" />를 지정된 URI가 포함된 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스로 변환합니다.</summary>
        <returns>
          <paramref name="Obj" /> 매개 변수에 지정된 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 원격 하위 영역에 도달 하는 방법에 대 한 정보 개체가 위치한 합니다.  
  
 마샬링하는 동안 현재 스레드의 컨텍스트를 사용, 컨텍스트가 아닌 활성화 되어 있던 개체를 만들 때.  
  
 두 가지 이유 중 하나에 대 한 프록시를 사용 하 여 URI를 연결할 수 없습니다: URI를 나타내는 개체에 대 한 서버 쪽에서 생성 된 또는 URI가 알려져 있는 경우에 개체는 잘 알려져 있는 경우. 따라서이 경우는 `Obj` 매개 변수가 프록시인, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체로 처리 되므로 이러한 제한이 완화 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에는 현재 사용 하는 방법을 보여 줍니다. <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> 메서드를 지정된 된 개체를 마샬링합니다.  
  
 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" />가 개체 프록시이고, <paramref name="URI" /> 매개 변수가 <see langword="null" />이 아닌 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj">
          <see cref="T:System.Runtime.Remoting.ObjRef" />으로 변환할 개체입니다.</param>
        <param name="ObjURI">
          <c>Obj</c> 매개 변수에 지정한 개체를 마샬링할 때 사용할 URI입니다. <see langword="null" />일 수 있습니다.</param>
        <param name="RequestedType">
          <c>Obj</c>가 마샬링될 <see cref="T:System.Type" />입니다. <see langword="null" />일 수 있습니다.</param>
        <summary>
          <see cref="T:System.MarshalByRefObject" />를 가져와서 지정된 URI 및 제공된 <see cref="T:System.Runtime.Remoting.ObjRef" />이 있는 <see cref="T:System.Type" /> 클래스의 인스턴스로 변환합니다.</summary>
        <returns>
          <paramref name="Obj" /> 매개 변수에 지정된 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" /> 클래스의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 원격 하위 영역에 도달 하는 방법에 대 한 정보 개체가 위치한 합니다.  
  
 지정 된 <xref:System.Type> 원격 인프라에 의해 노출 된 형식 계층 구조의 범위를 제한 하는 데 사용 됩니다. 예를 들어 개체 A B C 개체에서 파생 하 고 개체에서 파생 되 고 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> 클라이언트 프록시 A. 아니라 B와 C 간의 캐스팅 수 라고  
  
 마샬링하는 동안 현재 스레드의 컨텍스트를 사용, 컨텍스트가 아닌 활성화 되어 있던 개체를 만들 때.  
  
 두 가지 이유 중 하나에 대 한 프록시를 사용 하 여 URI를 연결할 수 없습니다: URI를 나타내는 개체에 대 한 서버 쪽에서 생성 된 또는 URI가 알려져 있는 경우에 개체는 잘 알려져 있는 경우. 따라서이 경우는 `Obj` 매개 변수가 프록시인, 예외가 throw 됩니다. 사용자 지정 프록시에 대 한 투명 프록시 서버 개체로 처리 되므로 이러한 제한이 완화 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="Obj" />가 원격 개체의 프록시이고, <paramref name="ObjUri" /> 매개 변수가 <see langword="null" />이 아닌 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">URI를 설정할 개체입니다.</param>
        <param name="uri">지정된 개체에 할당할 URI입니다.</param>
        <summary>
          <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> 메서드에 대한 다음 호출의 URI를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 메서드에서 설정 하는 URI는 지정된 된 개체를 마샬링할 때 사용 됩니다.  
  
 마샬링 한 후 지정된 된 개체의 URI 문자열에 설정 되는 `uri` 매개 변수를 추가 합니다 <xref:System.Guid> 현재 <xref:System.AppDomain>합니다.  
  
 현재 응용 프로그램에서 HTTP 포트를 수신 대기 중인 경우 두 문자열에 지정 된 합니다 `uri` 매개 변수 및 `uri` 문자열에 추가 합니다 <xref:System.Guid> 현재 <xref:System.AppDomain> 지정된 된 개체에 대 한 경로. 응용 프로그램은 HTTP 포트 9000에서 수신 대기 하는 경우와 같이 그 둘 다 http://localhost:9000/objectUri, 및 http://localhost:9000/\<appdomainguid>/objectUri 경로에서 지정 된 개체는 `obj` 매개 변수입니다.  
  
   
  
## Examples  
 다음 코드 예제에서 사용 될 URI를 설정 하는 방법에 설명 합니다 <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> 지정된 된 개체를 마샬링할 때 메서드.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="obj" />가 지역 개체가 아니고, 이미 마샬링되었거나, 현재 메서드가 이미 호출된 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 <see cref="T:System.Runtime.Remoting.ObjRef" />를 프록시 개체로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">프록시가 만들어질 원격 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" />입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Remoting.ObjRef" />를 가져오고 이를 사용하여 프록시 개체를 만듭니다.</summary>
        <returns>지정된 <see cref="T:System.Runtime.Remoting.ObjRef" />가 나타내는 개체의 프록시입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다. 역마샬링 하는 동안 합니다 <xref:System.Runtime.Remoting.ObjRef> 원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하려면 구문 분석 및 <xref:System.Runtime.Remoting.Proxies.RealProxy> 개체가 만들어집니다. 구문 분석 된 내용의 <xref:System.Runtime.Remoting.ObjRef> 투명 프록시 공용 언어 런타임에 등록 되기 전에 투명 프록시에 추가 됩니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 원격 하위 영역에 도달 하는 방법에 대 한 정보 개체가 위치한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 개체의 역마샬링 하는 방법에 설명 합니다.  
  
 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="objectRef" /> 매개 변수에 지정된 <see cref="T:System.Runtime.Remoting.ObjRef" /> 인스턴스의 형식이 잘못된 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">프록시가 만들어질 원격 개체를 나타내는 <see cref="T:System.Runtime.Remoting.ObjRef" />입니다.</param>
        <param name="fRefine">프록시를 서버의 형식으로 구체화하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>
          <see cref="T:System.Runtime.Remoting.ObjRef" />를 가져오고, 이를 사용하여 프록시 개체를 만들고, 서버의 형식으로 구체화합니다.</summary>
        <returns>지정된 <see cref="T:System.Runtime.Remoting.ObjRef" />가 나타내는 개체의 프록시입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.Remoting.ObjRef> 응용 프로그램 도메인 경계를 넘어 개체 참조를 전송 하는 데 사용 하는 개체의 직렬화 표현입니다. 만들기는 <xref:System.Runtime.Remoting.ObjRef> 에 개체 마샬링 이라고 합니다. <xref:System.Runtime.Remoting.ObjRef> 채널을 통해 다른 응용 프로그램 도메인에 전송할 수 있습니다 (가능한 경우 다른 프로세스 또는 컴퓨터에서). 다른 응용 프로그램 도메인에 한 번의 <xref:System.Runtime.Remoting.ObjRef> 일반적으로 실제 개체에 연결 하는 개체에 대 한 프록시를 만드는 구문 분석 되어야 합니다. 이 작업은 역마샬링 이라고 합니다. 역마샬링 하는 동안 합니다 <xref:System.Runtime.Remoting.ObjRef> 원격 개체와 투명 프록시 개체의 메서드 정보를 추출 하려면 구문 분석 및 <xref:System.Runtime.Remoting.Proxies.RealProxy> 개체가 만들어집니다. 구문 분석 된 내용의 <xref:System.Runtime.Remoting.ObjRef> 투명 프록시 공용 언어 런타임에 등록 되기 전에 투명 프록시에 추가 됩니다.  
  
 A <xref:System.Runtime.Remoting.ObjRef> 설명 하는 정보를 포함 합니다 <xref:System.Type> 및 클래스는 마샬링하는 개체의 특정 개체 인스턴스 및 통신을 고유 하 게 식별 하는 URI 관련 원격 하위 영역에 도달 하는 방법에 대 한 정보 개체가 위치한 합니다.  
  
 형식 프록시는를 처음 만들면 <xref:System.MarshalByRefObject>합니다. 다른 형식으로 캐스팅 하면 원격 인프라는 추적 하 불필요 하 게 형식을 로드 하지 않으려면 자주 사용 하는 형식입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="objectRef" /> 매개 변수에 지정된 <see cref="T:System.Runtime.Remoting.ObjRef" /> 인스턴스의 형식이 잘못된 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출 스택의 상위 호출자 중 하나 이상에게 원격 형식 및 채널을 구성하기 위한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">원격 인프라의 구성 합니다. 요청 값: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />; 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>