<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d5e8a4971198a319f82050992ceb17fc564a9011" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39935381" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>레지스트리 키에 대한 Windows 액세스 제어 보안을 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.AccessControl.RegistrySecurity> 개체 레지스트리 키에 대 한 액세스 권한을 지정 하 고 액세스 시도 감사 하는 방법을 지정 합니다. 레지스트리 키에 대 한 액세스 권한 규칙을 나타내는 각 액세스 규칙으로 표시 됩니다는 <xref:System.Security.AccessControl.RegistryAccessRule> 개체입니다. 각 감사 규칙은 표현 된 <xref:System.Security.AccessControl.RegistryAuditRule> 개체입니다.  
  
 이 미러링 각 보안 개체에 최대 하나의 임의 액세스 제어 목록 (DACL) 보안된 개체 및 최대 하나의 시스템 액세스 제어 목록 (SACL) 되는 액세스를 지정 하는 액세스를 제어 하는 기본 Windows 보안 시스템 시도 감사 합니다. DACL과 SACL는 액세스 및 사용자 및 그룹에 대 한 감사를 지정 하는 액세스 제어 항목 (ACE) 목록을 정렬 하는 데 사용 됩니다. A <xref:System.Security.AccessControl.RegistryAccessRule> 또는 <xref:System.Security.AccessControl.RegistryAuditRule> 개체는 둘 이상의 ACE를 나타낼 수 있습니다.  
  
> [!NOTE]
>  Windows 액세스 제어 보안 레지스트리 키에만 적용할 수 있습니다. 키에 저장 하는 개별 키/값 쌍에 적용할 수 없습니다.  
  
 <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, 및 <xref:System.Security.AccessControl.RegistryAuditRule> 클래스 Acl 및 Ace의 구현 세부 정보를 숨깁니다. 그러면 17 다양 한 ACE 형식과 올바르게 상속 및 전파 액세스 권한 유지 관리의 복잡성을 무시할 수 있습니다. 이러한 개체는 또한 다음과 같은 일반적인 액세스 제어 오류를 방지 하기 위해 설계 되었습니다.  
  
-   Null DACL을 사용 하 여 보안 설명자를 만드는 중입니다. DACL null 참조에는 모든 사용자를 잠재적 서비스 거부 공격을 만드는 개체에 대 한 액세스 규칙을 추가할 수 있습니다. 새 <xref:System.Security.AccessControl.RegistrySecurity> 개체는 항상 모든 사용자에 대 한 모든 액세스를 거부 하는 빈 DACL을 사용 하 여 시작 합니다.  
  
-   Ace의 정식 순서 위반 합니다. DACL의 ACE 목록이 정식 순서 대로 유지 되지 않으면, 사용자가 실수로에 부여 될 수 액세스 보안된 개체입니다. 예를 들어, 거부 된 액세스 권한은 항상 액세스 권한이 허용된 하기 전에 나타나야 합니다. <xref:System.Security.AccessControl.RegistrySecurity> 개체는 내부적으로 올바른 순서를 유지 합니다.  
  
-   리소스 관리자 제어만 해야 하는 보안 설명자 플래그를 조작 합니다.  
  
-   잘못 된 조합 ACE 플래그를 만드는 중입니다.  
  
-   상속 된 Ace를 조작 합니다. 상속 및 전파 액세스 규칙과 감사 규칙의 변경에 대 한 응답에서 리소스 관리자에 의해 처리 됩니다.  
  
-   Acl에 의미 없는 Ace를 삽입 합니다.  
  
 .NET 보안 개체에 의해 지원 되지 않습니다만 기능 대부분의 같은 응용 프로그램 개발자는 피해 야 하는 위험한 작업 같습니다.  
  
-   리소스 관리자가 일반적으로 수행 되는 하위 수준 작업입니다.  
  
-   추가 하거나 정식 순서를 유지 하지 않는 방식으로 액세스 제어 항목을 제거 합니다.  
  
 레지스트리 키에 대 한 Windows 액세스 제어 보안을 수정 하려면 사용 합니다 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드를를 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다. 추가 및 규칙을 제거 하 여 보안 개체를 수정 하 고 다음 사용 된 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 다시 연결 하는 방법입니다.  
  
> [!IMPORTANT]
>  변경한을 <xref:System.Security.AccessControl.RegistrySecurity> 호출할 때까지 개체에서는 레지스트리 키의 액세스 수준을 주지 않습니다는 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 레지스트리 키 변경 된 보안 개체를 할당 하는 방법입니다.  
  
 액세스 제어 보안 한 레지스트리 키에서 다른 위치로 복사할를 사용 하 여는 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드를를 <xref:System.Security.AccessControl.RegistrySecurity> 첫 번째 레지스트리 키에 대 한 액세스 및 감사 규칙을 나타내는 개체를 사용 하 여를 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 해당 규칙을 할당 하는 메서드를 두 번째 레지스트리 키입니다. 규칙을 사용 하 여 두 번째 레지스트리 키에 할당할 수도 있습니다는 <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> 또는 <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> 사용 하는 메서드를 <xref:System.Security.AccessControl.RegistrySecurity> 매개 변수 개체입니다.  
  
 보안 설명자 정의 언어 (SDDL)에 대 한 투자를 사용 하 여 사용자가 사용할 수는 <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 레지스트리 키에 대 한 액세스 규칙을 설정 하는 방법 및 <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> SDDL 형식의 액세스 규칙을 나타내는 문자열을 가져오는 방법입니다. 이 새로운 개발에 권장 되지 않습니다.  
  
   
  
## Examples  
 이 섹션에는 두 코드 예제가 있습니다. 첫 번째 예제에서는 추가 및 제거 하는 경우 어떻게 호환 규칙 병합 및 두 번째은 상속 및 전파 플래그를 추가 및 삭제 규칙에 미치는 영향  
  
 예제 1  
  
 다음 코드 예제에서는 하는 방법을 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 메서드는 호환 되는 규칙에서 권한을 제거 하는 방법과 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> 메서드 호환 규칙을 사용 하 여 권한을 병합 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체 및 현재 사용자를 허용 하는 규칙을 추가 <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> 권한. 사용자 권한을 부여 하는 규칙을 만듭니다 <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, 동일한 상속 및 전파 권한을 사용 하 여 첫 번째 규칙을 사용 하 여 합니다 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 에서이 새 규칙을 제거 하는 방법의 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다. <xref:System.Security.AccessControl.RegistryRights.SetValue> 구성 요소는 <xref:System.Security.AccessControl.RegistryRights.ReadKey>이므로 호환 되는 규칙에서 제거 됩니다. 규칙에는 <xref:System.Security.AccessControl.RegistrySecurity> 개체의 나머지는 유권자 들을 함께 표시 됩니다 <xref:System.Security.AccessControl.RegistryRights.ReadKey>합니다.  
  
 예제 코드를 호출 합니다 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> 병합 하는 방법 합니다 <xref:System.Security.AccessControl.RegistryRights.SetValue> 에서 규칙에 다시 마우스 오른쪽 단추로 <xref:System.Security.AccessControl.RegistrySecurity> 개체.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 이 단원의 두 번째 예제에서는 보안 개체를 연결 하 고 예제 이렇게 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 고 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>입니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 예제 2  
  
 다음 코드 예제에서는 상속 및 전파를 사용 하 여 액세스 규칙을 보여 줍니다. 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체, 한 다음를 만들고 있는 두 개의 규칙을 추가 <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> 플래그입니다. 첫 번째 규칙에 전파 플래그가 없으므로 두 번째 <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> 고 <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>입니다.  
  
 프로그램에 규칙을 표시 합니다 <xref:System.Security.AccessControl.RegistrySecurity> 개체를 사용 하 여 다음을 <xref:System.Security.AccessControl.RegistrySecurity> 하위 키를 만들 개체입니다. 프로그램을 만들고 자식 하위 키에 손자 하위 키를 다음 각 하위 키에 대 한 보안을 표시 합니다. 마지막으로 프로그램은 테스트 키를 삭제 합니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>기본값을 사용하여 <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 <xref:System.Security.AccessControl.RegistrySecurity> 개체는 항상 모든 사용자에 대 한 모든 액세스를 거부 되는 빈 임의 액세스 목록 (DACL)를 사용 하 여 시작 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 클래스가 액세스 권한을 나타내는 데 사용하는 열거형을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" /> 열거형을 나타내는 <see cref="T:System.Security.AccessControl.RegistryRights" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity> 재정의 클래스를 <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> 속성 및 액세스 권한을 나타내는 데 사용 하는 형식 반환 합니다. 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션을 사용 하 여 작업할 때 각 보안 개체에 사용할 올바른 열거형 형식을 확인 하려면이 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">규칙을 적용할 사용자 또는 그룹을 식별하는 <see cref="T:System.Security.Principal.IdentityReference" />입니다.</param>
        <param name="accessMask">정수로 캐스팅된 허용하거나 거부할 액세스 권한을 지정하는 <see cref="T:System.Security.AccessControl.RegistryRights" /> 값의 비트 조합입니다.</param>
        <param name="isInherited">규칙의 상속 여부를 지정하는 부울 값입니다.</param>
        <param name="inheritanceFlags">규칙이 하위 키에 상속되는 방식을 지정하는 <see cref="T:System.Security.AccessControl.InheritanceFlags" /> 값의 비트 조합입니다.</param>
        <param name="propagationFlags">규칙이 하위 키에 상속되는 방식을 수정하는 <see cref="T:System.Security.AccessControl.PropagationFlags" /> 값의 비트 조합입니다. <c>inheritanceFlags</c>의 값이 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />이면 의미가 없습니다.</param>
        <param name="type">권한 허용 여부를 지정하는 <see cref="T:System.Security.AccessControl.AccessControlType" /> 값 중 하나입니다.</param>
        <summary>지정된 액세스 권한, 액세스 제어 및 플래그로 지정한 사용자의 새 액세스 제어 규칙을 만듭니다.</summary>
        <returns>지정한 사용자의 지정한 권한을 나타내는 <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 액세스 제어 규칙 만들기에 대 한 권장 되는 방법은 생성자를 사용 하는 것은 <xref:System.Security.AccessControl.RegistryAccessRule> 클래스입니다.  
  
> [!NOTE]
>  지정할 수 있지만 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> 플래그, 이렇게 지점이 없습니다. 액세스 제어를 위해 하위 키에서 이름/값 쌍을 없는 별도 개체입니다. 이름/값 쌍에 액세스 권한은 하위 키의 사용 권한에 따라 제어 됩니다. 또한 모든 하위 컨테이너 이므로 (즉, 이러한 포함할 수 있습니다 다른 하위 키), 영향을 받지 않습니다는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그입니다. 마지막으로, 지정 된 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그 규칙 유지 관리를 호환 규칙의 일반 조합은 방해가 되기 때문에 불필요 하 게 복잡해 집니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> 또는 <paramref name="type" />에 잘못된 값을 지정하는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="accessMask" />가 0입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" />의 형식이 <see cref="T:System.Security.Principal.SecurityIdentifier" />도 아니고 <see cref="T:System.Security.Principal.NTAccount" />와 같이 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 형식으로 변환할 수 있는 형식도 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 클래스가 액세스 규칙을 나타내는 데 사용하는 형식을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" /> 클래스를 나타내는 <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity> 재정의 클래스를 <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> 속성과 액세스 규칙을 나타내는 데 사용 하는 형식 반환 합니다. 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션을 사용 하 여 작업할 때 사용할 각 보안 개체에 대 한 올바른 액세스 규칙을 확인 하려면이 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">추가할 액세스 제어 규칙입니다.</param>
        <summary>새 규칙을 병합할 수 있는 일치하는 액세스 제어를 검색합니다. 아무 것도 발견되지 않으면 새 규칙을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> 메서드를 사용 하 여 동일한 사용자 또는 그룹 및 동일한 규칙에 대 한 검색 <xref:System.Security.AccessControl.AccessControlType> 으로 `rule`입니다. 일치 항목이 없는 경우, `rule` 추가 됩니다. 일치 하는 규칙 발견 되 면 rights in `rule` 기존 규칙을 사용 하 여 병합 됩니다.  
  
 다른 상속 플래그를 있는 경우에 규칙을 병합할 수 없습니다. 예를 들어, 사용자가 없는 상속 플래그를 사용 하 여 읽기 액세스를 허용 하는 경우 및 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> 하위 키에 대 한 상속을 사용 하 여 사용자 쓰기 액세스 권한 부여 규칙을 추가 하는 데 사용 됩니다 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), 두 가지 규칙을 병합할 수 없습니다.  
  
 다른 규칙은 <xref:System.Security.AccessControl.AccessControlType> 값 병합 되지 않습니다.  
  
 가장 경제적인 방법 rights를 표현 하는 규칙입니다. 예를 들어 사용자가 <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> 하 고 <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> 권한 및 사용자 추가 허용 하는 규칙 <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> 권한을 사용자에의 모든 구성 부분 <xref:System.Security.AccessControl.RegistryRights.ReadKey> 권한. 사용자의 권한, 쿼리 하는 경우 표시 됩니다 포함 하는 규칙 <xref:System.Security.AccessControl.RegistryRights.ReadKey> 권한. 마찬가지로, 제거 하는 경우 <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> 권한, 다른 구성 요소가 <xref:System.Security.AccessControl.RegistryRights.ReadKey> 권한 다시 나타납니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 레지스트리 액세스 규칙을 만들고 추가 합니다는 <xref:System.Security.AccessControl.RegistrySecurity> 을 보여 주는 개체 권한을 허용 및 거부 하는 규칙의 호환 규칙 하는 동안 별도로 유지 하는 방법 종류 병합 됩니다.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 보안 개체를 연결 하는 예제를 찾을 수 있습니다 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 고 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>입니다.  
  
 상속 및 전파 플래그를 보여 주는 코드 예제를 찾을 수 있습니다는 <xref:System.Security.AccessControl.RegistryAccessRule> 클래스입니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">추가할 감사 규칙입니다. 이 규칙에서 지정하는 사용자가 검색을 결정합니다.</param>
        <summary>새 규칙을 병합할 수 있는 감사 규칙을 검색합니다. 아무 것도 발견되지 않으면 새 규칙을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> 메서드를 같은 사용자 또는 그룹을 사용 하 여 규칙 검색 `rule`합니다. 일치 항목이 없는 경우, `rule` 추가 됩니다. 일치 하는 규칙 발견 되 면에서 플래그 `rule` 기존 규칙에 병합 됩니다.  
  
 다른 상속 플래그를 있는 경우에 규칙을 병합할 수 없습니다. 예를 들어, 키를 쓰려고 하면 실패 한 경우는 없습니다 상속 플래그를 사용 하 여 특정 사용자에 대 한 감사 및 <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> 사용 권한을 변경 하려면 실패 한 시도 대 한 상속 하지만 동일한 사용자에 대 한 감사 되어야 하는 지정 하는 규칙을 추가 하는 데 사용 됩니다 하위 키 (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), 두 가지 규칙을 병합할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">규칙을 적용할 사용자 또는 그룹을 식별하는 <see cref="T:System.Security.Principal.IdentityReference" />입니다.</param>
        <param name="accessMask">정수로 캐스팅된 감사할 액세스 권한을 지정하는 <see cref="T:System.Security.AccessControl.RegistryRights" /> 값의 비트 조합입니다.</param>
        <param name="isInherited">규칙의 상속 여부를 지정하는 부울 값입니다.</param>
        <param name="inheritanceFlags">규칙이 하위 키에 상속되는 방식을 지정하는 <see cref="T:System.Security.AccessControl.InheritanceFlags" /> 값의 비트 조합입니다.</param>
        <param name="propagationFlags">규칙이 하위 키에 상속되는 방식을 수정하는 <see cref="T:System.Security.AccessControl.PropagationFlags" /> 값의 비트 조합입니다. <c>inheritanceFlags</c>의 값이 <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />이면 의미가 없습니다.</param>
        <param name="flags">성공 또는 실패를 감사할지 아니면 둘 다 감사할지를 지정하는 <see cref="T:System.Security.AccessControl.AuditFlags" /> 값의 비트 조합입니다.</param>
        <summary>새 감사 규칙을 만들어 규칙을 적용할 사용자, 감사할 액세스 권한, 규칙의 상속과 전파 및 감사 규칙을 트리거할 결과를 지정합니다.</summary>
        <returns>지정한 플래그를 사용하여 지정한 사용자의 지정한 감사 규칙을 나타내는 <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 개체입니다. 메서드의 반환 형식은 기본 클래스 <see cref="T:System.Security.AccessControl.AuditRule" />이지만 반환 값은 파생 클래스로 안전하게 캐스팅할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 감사 규칙을 만들기 위한 권장된 방법의 생성자를 사용 하는 것은 <xref:System.Security.AccessControl.RegistryAuditRule> 클래스입니다.  
  
> [!NOTE]
>  지정할 수 있지만 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> 플래그, 이렇게 지점이 없습니다. 감사 제어를 위해 하위 키에서 이름/값 쌍을 없는 별도 개체입니다. 이름/값 쌍에 대 한 감사 권한은 하위 키의 사용 권한에 따라 제어 됩니다. 또한 모든 하위 컨테이너 이므로 (즉, 이러한 포함할 수 있습니다 다른 하위 키), 영향을 받지 않습니다는 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그입니다. 마지막으로, 지정 된 <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> 플래그 규칙 유지 관리를 호환 규칙의 일반 조합은 방해가 되기 때문에 불필요 하 게 복잡해 집니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> 또는 <paramref name="flags" />에 잘못된 값을 지정하는 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="accessMask" />가 0입니다.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" />의 형식이 <see cref="T:System.Security.Principal.SecurityIdentifier" />도 아니고 <see cref="T:System.Security.Principal.NTAccount" />와 같이 <see cref="T:System.Security.Principal.SecurityIdentifier" /> 형식으로 변환할 수 있는 형식도 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Security.AccessControl.RegistrySecurity" /> 클래스에서 감사 규칙을 나타내는 데 사용하는 형식을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Type" /> 클래스를 나타내는 <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스는 <xref:System.Security.AccessControl.ObjectSecurity> 재정의 클래스를 <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> 속성과 감사 권한을 나타내는 데 사용 하는 형식 반환 합니다. 배열 또는 여러 유형의 보안 개체를 포함 하는 컬렉션을 사용 하 여 작업할 때 각 보안 개체에 사용할 올바른 감사 규칙을 확인 하려면이 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">검색할 사용자 및 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />을 비롯하여 일치하는 규칙(있다면)과 호환되어야 하는 상속 및 전파 플래그 집합을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlType" />입니다. 발견된 경우 호환되는 규칙에서 제거할 권한을 지정합니다.</param>
        <summary>지정한 액세스 규칙과 사용자 및 <see cref="T:System.Security.AccessControl.AccessControlType" />(허용 또는 거부)이 같고 상속 및 전파 플래그가 호환되는 액세스 제어 규칙을 검색합니다. 그러한 규칙이 있으면 지정한 액세스 규칙에 포함된 권한이 규칙에서 제거됩니다.</summary>
        <returns>호환 가능한 규칙이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Security.AccessControl.RegistrySecurity> 동일한 사용자와 동일한 규칙에 대 한 검색 됩니다 <xref:System.Security.AccessControl.AccessControlType> 값 `rule`합니다. 없는 이러한 규칙을 찾을 수 없는 작업을 수행 및 메서드 반환 `false`합니다. 일치 하는 규칙 발견 되 면 해당 상속 및 호환성 플래그에 지정 된 플래그를 사용 하 여 호환성을 위해 검사할지 `rule`합니다. 호환 가능한 규칙이 있으면 아무런 작업도 및 메서드 반환 `false`합니다. 에 지정 된 호환 플래그를 가진 규칙이 없으면 권한은 `rule` 호환 되는 규칙에서 제거 됩니다 메서드에서 반환 `true`합니다. 경우 `rule` 호환 되는 규칙에 포함 되지 않은 권한을 지정, 해당 권리에 대해 아무런 동작이 발생 합니다. 현재에서 전체 규칙을 제거할 모든 권리를 호환 되는 규칙에서 제거 하면 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 하는 방법을 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 메서드는 호환 되는 규칙에서 권한을 제거 하는 방법과 <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> 메서드 호환 규칙을 사용 하 여 권한을 병합 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체 및 현재 사용자를 허용 하는 규칙을 추가 <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> 권한. 사용자 권한을 부여 하는 규칙을 만듭니다 <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, 동일한 상속 및 전파 권한을 사용 하 여 첫 번째 규칙을 사용 하 여 합니다 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 에서이 새 규칙을 제거 하는 방법의 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다. <xref:System.Security.AccessControl.RegistryRights.SetValue> 구성 요소는 <xref:System.Security.AccessControl.RegistryRights.ReadKey>이므로 호환 되는 규칙에서 제거 됩니다. 규칙에는 <xref:System.Security.AccessControl.RegistrySecurity> 개체의 나머지는 유권자 들을 함께 표시 됩니다 <xref:System.Security.AccessControl.RegistryRights.ReadKey>합니다.  
  
 예제 코드를 호출 합니다 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 병합 하는 방법 합니다 <xref:System.Security.AccessControl.RegistryRights.SetValue> 에서 규칙에 다시 마우스 오른쪽 단추로 <xref:System.Security.AccessControl.RegistrySecurity> 개체.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 이 단원의 두 번째 예제에서는 보안 개체를 연결 하 고 예제 이렇게 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">검색할 사용자 및 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />을 지정하는 <see cref="T:System.Security.AccessControl.AccessControlType" />입니다. 이 규칙에서 지정한 모든 권한, 상속 플래그 또는 전파 플래그는 무시됩니다.</param>
        <summary>지정한 규칙과 사용자 및 <see cref="T:System.Security.AccessControl.AccessControlType" />(허용 또는 거부)이 같은 모든 액세스 제어 규칙을 검색하여 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Security.AccessControl.RegistrySecurity> 는 동일한 사용자와 동일한 규칙에 대 한 검색 됩니다 <xref:System.Security.AccessControl.AccessControlType> 값 `rule`합니다. 모든 권한, 상속 플래그 또는 전파 플래그 지정 된 `rule` 이 검색을 수행 하는 경우 무시 됩니다. 일치 하는 규칙이 없습니다 발견 되 면 아무런 동작이 발생 합니다.  
  
 예를 들어, 사용자는 다른 상속 및 전파 플래그를 사용 하 여 다양 한 권한을 허용 하는 여러 규칙을 제거할 수 있습니다 이러한 모든 규칙을 만들어를 <xref:System.Security.AccessControl.RegistryAccessRule> 사용자 지정 하는 개체 및 <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, 임의의 권한 및 플래그를 사용 하 여 전달 규칙을 설명 하는 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예에서는 합니다 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> 사용자와 일치 하는 모든 규칙을 제거 하는 메서드 및 <xref:System.Security.AccessControl.AccessControlType>, 권한 및 플래그를 무시 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체 및 다른 상속 및 전파 플래그를 사용 하 여 현재 사용자에 대 한 다양 한 권한을 거부 하 고 사용할 수 있는 규칙을 추가 합니다. 현재 사용자가 소유권을 허용 하 고 해당 규칙을 전달 하는 새 규칙을 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> 메서드 액세스를 허용 하는 두 개의 규칙을 제거 합니다.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 참조 된 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드 및 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">제거할 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />입니다.</param>
        <summary>지정한 규칙과 정확히 일치하는 액세스 제어 규칙을 검색하여 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 규칙은 정확히 일치 하는 경우에 제거 됩니다 `rule` 모든 세부 정보에 플래그를 포함 합니다. 사용자가 같은 다른 규칙 및 <xref:System.Security.AccessControl.AccessControlType> 영향을 받지 않습니다.  
  
> [!IMPORTANT]
>  규칙을 나타내는 하나 또는 자세한 기본 액세스 제어 항목 (ACE) 및 이러한 항목은 분할 되거나 사용자에 대 한 액세스 보안 규칙을 수정 하는 경우 필요에 따라 조합 합니다. 따라서 규칙을 더 이상 있을 경우에서 추가 될 때 특정 형식에는 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> 메서드는 제거할 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에 따르면는 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> 메서드는 정확 하 게 일치 하는 경우에 규칙을 제거 합니다.  
  
 이 예제에서는 서로 다른 권한을 허용 하는 두 개의 규칙을 만듭니다. 규칙은 상속 및 전파 플래그가 호환 없으므로 첫 번째 병합할 두 번째 규칙을 추가 하는 경우. 예제에서는 호출을 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> 메서드에 첫 번째 규칙을 지정 합니다 이지만 규칙 병합 되므로 일치 하는 규칙이 없습니다. 다음 호출을 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> 결합 된 규칙 및 마지막 호출에서 두 번째 규칙 제거 방법을 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> 첫 번째 규칙을 제거 하는 방법.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 참조 된 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드 및 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">검색할 사용자 및 일치하는 규칙(있다면)이 호환되어야 하는 상속 및 전파 플래그 집합을 지정하는 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />입니다. 발견된 경우 호환되는 규칙에서 제거할 권한을 지정합니다.</param>
        <summary>지정한 규칙과 사용자가 같고 상속 및 전파 플래그가 호환되는 감사 제어 규칙을 검색합니다. 호환되는 규칙이 있으면 지정한 규칙에 포함된 권한이 규칙에서 제거됩니다.</summary>
        <returns>호환 가능한 규칙이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Security.AccessControl.RegistrySecurity> 사용자가 같은 있는 감사 규칙을 검색 하는 `rule`합니다. 없는 이러한 규칙을 찾을 수 없는 작업을 수행 및 메서드 반환 `false`합니다. 일치 하는 규칙 발견 되 면 해당 상속 및 호환성 플래그에 지정 된 플래그를 사용 하 여 호환성을 위해 검사할지 `rule`합니다. 호환 가능한 규칙이 있으면 아무런 작업도 및 메서드 반환 `false`합니다. 에 지정 된 호환 플래그를 가진 규칙이 없으면 권한은 `rule` 호환 되는 규칙에서 제거 됩니다 메서드에서 반환 `true`합니다. 경우 `rule` 호환 되는 규칙에 포함 되지 않은 권한을 지정, 해당 권리에 대해 아무런 동작이 발생 합니다. 현재에서 전체 규칙을 제거할 모든 권리를 호환 되는 규칙에서 제거 하면 <xref:System.Security.AccessControl.RegistrySecurity> 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">검색할 사용자를 지정하는 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />입니다. 이 규칙에서 지정한 모든 권한, 상속 플래그 또는 전파 플래그는 무시됩니다.</param>
        <summary>지정한 규칙과 같은 사용자를 가진 모든 감사 규칙을 검색하고 해당 규칙이 있을 경우 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 <xref:System.Security.AccessControl.RegistrySecurity> 와 동일한 사용자에 게는 감사 규칙을 검색 하는 `rule`합니다. 모든 권한, 상속 플래그 또는 전파 플래그 지정 된 `rule` 이 검색을 수행 하는 경우 무시 됩니다. 일치 하는 규칙이 없습니다 발견 되 면 아무런 동작이 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">제거할 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />입니다.</param>
        <summary>지정한 규칙과 정확히 일치하는 감사 규칙을 검색하여 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 규칙은 정확히 일치 하는 경우에 제거 됩니다 `rule` 모든 세부 정보에 플래그를 포함 합니다. 동일한 사용자에 대 한 다른 감사 규칙을 받지 않습니다.  
  
> [!IMPORTANT]
>  규칙을 나타내는 하나 또는 자세한 기본 액세스 제어 항목 (ACE) 및 이러한 항목은 분할 되거나 사용자에 대 한 감사 보안 규칙을 수정 하는 경우 필요에 따라 조합 합니다. 따라서 규칙을 더 이상 있을 경우에서 추가 될 때 특정 형식에는 <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> 메서드는 제거할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">추가할 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />입니다. 이 규칙에서 지정하는 사용자가 이 규칙이 추가되기 전에 제거할 규칙을 결정합니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.AccessControlType" />과 상관없이 지정한 규칙과 사용자가 같은 모든 액세스 제어 규칙을 제거한 다음 지정한 규칙을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 지정한 규칙과 일치 액세스 규칙이 있는 경우 `rule` 추가 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 방법을 <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> 메서드는 일치 하는 지정 된 규칙과 일치 하는 사용자에 대 한 모든 규칙을 대체 합니다.  
  
 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체 및 다른 상속 및 전파 플래그를 사용 하 여 현재 사용자에 대 한 다양 한 권한을 거부 하 고 사용할 수 있는 규칙을 추가 합니다. 현재 키를 읽을 수만 허용 하 고 사용 하는 새 규칙을 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> 메서드를 사용자에 대 한 모든 규칙을 제거 하 고 새 규칙으로 바꿉니다.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 참조 된 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드 및 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">추가할 <see cref="T:System.Security.AccessControl.RegistryAccessRule" />입니다. 이 규칙의 사용자 및 <see cref="T:System.Security.AccessControl.AccessControlType" />은 이 규칙이 추가되기 전에 제거할 규칙을 결정합니다.</param>
        <summary>지정된 규칙과 사용자 및 <see cref="T:System.Security.AccessControl.AccessControlType" />(허용 또는 거부)이 같은 모든 액세스 제어 규칙을 제거한 다음 지정한 규칙을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정한 규칙에 있으면 <xref:System.Security.AccessControl.AccessControlType.Allow>,이 메서드의 결과 모두 제거 하는 <xref:System.Security.AccessControl.AccessControlType.Allow> 지정한 규칙으로 바꿔 지정된 된 사용자에 대 한 규칙입니다. 지정된 된 규칙에 있으면 <xref:System.Security.AccessControl.AccessControlType.Deny>모든 <xref:System.Security.AccessControl.AccessControlType.Deny> 지정된 된 사용자에 대 한 규칙은 지정 된 규칙을 사용 하 여 대체 됩니다.  
  
 규칙이 있는 경우 없는 사용자와 <xref:System.Security.AccessControl.AccessControlType> 지정한 규칙과 일치 `rule` 추가 됩니다.  
  
   
  
## Examples  
 다음 코드 예에서는 합니다 <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> 사용자와 일치 하는 모든 규칙을 제거 하는 메서드 및 <xref:System.Security.AccessControl.AccessControlType> 의 `rule`권한 및 플래그를 무시 하 고 사용 하 여 대체 `rule`합니다.  
  
 이 예에서는 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity> 개체 및 다른 상속 및 전파 플래그를 사용 하 여 현재 사용자에 대 한 다양 한 권한을 거부 하 고 사용할 수 있는 규칙을 추가 합니다. 현재 키를 읽을 수만 허용 하 고 사용 하는 새 규칙을 만듭니다는 <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> 메서드 액세스를 허용 하는 두 개의 규칙을 제거 하 고 새 규칙으로 바꿉니다. 액세스를 거부 하는 규칙을 받지 않습니다.  
  
> [!NOTE]
>  이 예제에서는 보안 개체를 연결 하지 않습니다는 <xref:Microsoft.Win32.RegistryKey> 개체입니다. 참조 된 <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> 메서드 및 <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">추가할 <see cref="T:System.Security.AccessControl.RegistryAuditRule" />입니다. 이 규칙에서 지정하는 사용자가 이 규칙이 추가되기 전에 제거할 규칙을 결정합니다.</param>
        <summary>
          <see cref="T:System.Security.AccessControl.AuditFlags" /> 과 상관없이 지정한 규칙과 사용자가 같은 모든 감사 규칙을 제거한 다음 지정한 규칙을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 지정한 규칙과 일치 감사 규칙이 있는 경우 `rule` 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>