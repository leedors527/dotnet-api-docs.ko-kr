<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3c5cadd87a930834cdbe8bf2c763e2c830f3df42" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37461867" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="c28cd-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c28cd-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c28cd-102">부분적으로 신뢰할 수 있는 코드에는 항상 보안 위험을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="c28cd-103">이 리소스에 액세스 권한이 있는 악의적인 코드를 대신 하 여 작업을 수행할 경우에 따라 조작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="c28cd-104">이러한 방식으로 악성 코드를 허용 하는 보다 더 높은 보안 액세스를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="c28cd-105">공용 언어 런타임에 대 한 모든 호출에서 스택 워크를 실행 하 여 이러한 공격 으로부터 관리 되는 코드를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="c28cd-106">스택 워크는 호출 스택의 모든 코드 보호 된 리소스에 액세스할 수 있는 권한이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="c28cd-107">공격을 시도 하는 코드는 호출 스택의 어딘가에 있을 항상, 때문에 자체 보안 권한을 초과 없게 됩니다 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c28cd-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c28cd-109">호출 <xref:System.Security.IStackWalk.Assert%2A> 호출 스택의 상위 호출자 권한 검사를 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="c28cd-110">따라서 이러한 호출자에이 게 필수 사용 권한을 없는 경우에 리소스 여전히 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="c28cd-111">어설션 코드를 호출 하는 경우에 유효 <xref:System.Security.IStackWalk.Assert%2A> 어설션 중인 권한에 대 한 보안 검사를 통과 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="c28cd-112">에 대 한 호출 <xref:System.Security.IStackWalk.Assert%2A> 호출 코드에 대 한 후속 호출 될 때까지 또는 해당 호출자에 게 반환 될 때까지 유효 <xref:System.Security.IStackWalk.Assert%2A> 이전 어설션이 비효율적인 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="c28cd-113">또한 <xref:System.Security.CodeAccessPermission.RevertAssert%2A> 나 <xref:System.Security.CodeAccessPermission.RevertAll%2A> 제거는 보류 중인 <xref:System.Security.IStackWalk.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="c28cd-114"><xref:System.Security.IStackWalk.Assert%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="c28cd-115">그러나 호출 스택에 있는 낮은 코드를 호출 하는 경우 <xref:System.Security.IStackWalk.Demand%2A> 해당 사용 권한에 대 한는 <xref:System.Security.SecurityException> 스택 워크를 호출 하려고 하는 코드에 도달할 때 발생 하는 <xref:System.Security.IStackWalk.Assert%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="c28cd-116">코드는 호출 되므로 이런 <xref:System.Security.IStackWalk.Assert%2A> 에 권한이 부여 되지는, 하 려 했지만 <xref:System.Security.IStackWalk.Assert%2A> 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c28cd-117">호출 하므로 <xref:System.Security.IStackWalk.Assert%2A> 제거 호출 체인에 모든 코드는 요구 사항을 받아야 지정된 된 리소스를 액세스할 수 있는 권한이, 잘못 되었거나 부적절 하 게 사용 하는 경우 보안 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="c28cd-118">따라서 주의 기울여야를 사용 하 여 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="c28cd-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c28cd-120">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-120">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c28cd-121">이 메서드는 일반적으로 기본 호출자에 게 리소스에 액세스할 수 있는 권한이 있는지 확인 되는 보안 라이브러리에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-121">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="c28cd-122">보안 클래스 라이브러리에 파일 클래스를 호출 하는 예를 들어 <xref:System.Security.IStackWalk.Demand%2A> 필요한 <xref:System.Security.Permissions.FileIOPermission> 는 호출자가 요청한 파일 작업을 수행 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-122">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="c28cd-123">이 메서드를 호출 하는 코드의 사용 권한은 검사 하지 않습니다. 확인 코드의 직접 실행 호출자에서 시작 하 고 스택을 나아갑니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-123">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="c28cd-124"><xref:System.Security.IStackWalk.Demand%2A> 없는 경우에 성공 <xref:System.Security.SecurityException> 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-124"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="c28cd-125">A caller higher in the call stack does not have the permission specified by the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-125">A caller higher in the call stack does not have the permission specified by the current permission object.</span>
          </span>
          <span data-ttu-id="c28cd-126">-or-  A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-126">-or-  A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c28cd-127">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-127">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c28cd-128">이 메서드는 호출 스택의 상위 호출자가 해당 호출자가 액세스할 권한이 부여 된 경우에이 메서드를 호출 하는 코드를 통해 보호 되는 리소스에 액세스 하지 못하도록 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-128">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="c28cd-129">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-129">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="c28cd-130"><xref:System.Security.IStackWalk.Deny%2A> 프로그래머의 책임을 제한 하거나 호출 하는 메서드를 방지할 수 있으므로 실수로 인 한 보안 취약점을 방지할 수 있습니다 <xref:System.Security.IStackWalk.Deny%2A> 를 사용 하 여 거부 된 권한으로 보호 되는 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-130"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="c28cd-131">메서드를 호출 하는 경우 <xref:System.Security.IStackWalk.Deny%2A> 는 권한에 경우에 <xref:System.Security.IStackWalk.Demand%2A> 에 도달 하면 해당 보안 확인이 실패 한 해당 권한을 하위 호출 스택의 호출자가 호출 되는 <xref:System.Security.IStackWalk.Deny%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-131">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="c28cd-132"><xref:System.Security.IStackWalk.Deny%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-132"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="c28cd-133">
            <para>이 메서드를 재정의할 수 없습니다.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-133">
              <para>You cannot override this method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c28cd-134">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c28cd-134">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c28cd-135"><xref:System.Security.IStackWalk.PermitOnly%2A> 비슷합니다 <xref:System.Security.IStackWalk.Deny%2A>스택 워크는 성공이 고, 그렇지 때 있는 상황에서, 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-135"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="c28cd-136">점이 <xref:System.Security.IStackWalk.Deny%2A> 실패는 스택 워크는 사용 권한을 지정 하지만 <xref:System.Security.IStackWalk.PermitOnly%2A> 실패 스택 워크가 발생 하지 않는 유일한 사용 권한을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-136">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="c28cd-137">지정 된 리소스에 액세스 하려면 코드를 사용할 수 있도록 하려면이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-137">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="c28cd-138"><xref:System.Security.IStackWalk.PermitOnly%2A> 해당 권한 요청에 실패 합니다 부여 되지 않은 사용 권한을 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-138"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="c28cd-139">그러나 하위 호출에서 나중에 스택 하는 경우 호출 <xref:System.Security.IStackWalk.Demand%2A> 해당 사용 권한에 대 한는 <xref:System.Security.SecurityException> 스택 워크를 호출 하려고 하는 코드에 도달할 때 발생 하는 <xref:System.Security.IStackWalk.PermitOnly%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-139">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="c28cd-140">코드는 호출 되므로이 작업이 <xref:System.Security.IStackWalk.PermitOnly%2A> 에 권한이 부여 되지를 호출 했지만 <xref:System.Security.IStackWalk.PermitOnly%2A> 해당 사용 권한에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-140">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="c28cd-141">호출 스택의 메서드 호출 스택의 상위에 메서드를 호출 낮은 호출 스택의 있도록에 일반적으로 하향식으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c28cd-141">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>