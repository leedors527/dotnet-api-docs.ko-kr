<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d189e4c6144e1a754ee34f3bee909a94e068d2e2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55355705" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>서비스 계약 구현의 내부 실행 동작을 지정합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서비스 전체 실행 동작을 지정하려면 <xref:System.ServiceModel.ServiceBehaviorAttribute> 특성을 서비스 구현에 적용합니다. 메서드 수준에서 실행 동작을 지정하려면 <xref:System.ServiceModel.OperationBehaviorAttribute> 특성을 사용합니다. 이 특성은 서비스 구현에만 적용할 수 있습니다. 작업 예제에 대 한 참조를 [서비스: 동작 샘플](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90))합니다.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> 속성은 개발자가 구현 해야 하는 일반적인 기능을 사용 하는 Windows Communication Foundation (WCF) 프로그래밍 모델 기능입니다. 속성 및 기타 동작에 대 한 자세한 내용은 참조 하세요. [서비스 런타임 동작 지정](~/docs/framework/wcf/specifying-service-run-time-behavior.md)합니다. 기본 런타임 속성에 대 한 자세한 내용은 참조는 다음 속성 집합의 일부 [Extending ServiceHost 및 서비스 모델 계층](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md)합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> 속성은 디스패처 시스템이 요청을 처리하는 엔드포인트를 찾을 때 사용하는 필터의 형식을 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> 속성은 채널이 닫히고 서비스가 나머지 메시지의 처리를 마쳤을 때 자동으로 세션을 닫습니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 속성은 내부 스레딩 모델을 제어하여 재진입 콜백 개체나 다중 스레드 서비스의 지원을 가능하게 합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> 속성은 구성 파일에서 `name` 요소의 `<service>` 특성에 사용할 이름을 선언하는 데 사용됩니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 속성을 사용하면 런타임은 메시지 처리에 필요 없는 추가 serialization 정보를 무시할 수 있습니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 속성은 서비스에서 처리되지 않은 예외가 SOAP 오류로 반환되는지 여부를 지정합니다. 이 속성은 디버깅 용도로만 사용할 수 있습니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 속성은 클라이언트와의 교환 과정에서 서비스 및 해당 서비스 개체를 재활용할 것인지 여부 및 그 시기를 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 속성은 개체 그래프에서 serialize되는 항목의 수를 제한합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> 및 <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> 속성은 서비스 요소의 WSDL 식에 사용되는 이름과 네임스페이스를 제어합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 속성은 트랜잭션이 완료되었을 때 서비스 개체가 재활용되는지 여부를 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> 속성에서는 세션을 닫을 때 처리되지 않은 트랜잭션을 완료할 것인지 여부를 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> 속성은 계약이 지원하는 트랜잭션 격리 수준을 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> 속성은 트랜잭션 완료가 이루어지지 않으면 중단되는 기간을 지정합니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> 속성은 인바운드 메서드 호출을 사용자 인터페이스 스레드와 자동으로 동기화하는지 여부를 나타냅니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 속성은 `MustUnderstand`로 표시된 SOAP 헤더가 실제로 인식되었음을 확인해야 하는지 여부를 시스템에 알려 줍니다.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 속성은 애플리케이션 구성 파일을 사용하여 설정할 수도 있습니다. 자세한 내용은 <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 속성을 보여 줍니다. `BehaviorService` 클래스는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 특성을 사용하여 다음을 나타냅니다.  
  
-   트랜잭션이 완료되면 서비스 개체가 재활용됩니다.  
  
-   세션별로 서비스 개체가 하나씩 있습니다.  
  
-   서비스는 단일 스레드이며 재진입 호출을 지원하지 않습니다.  
  
 또한 작업 수준에서 <xref:System.ServiceModel.OperationBehaviorAttribute> 값은 `TxWork` 메서드가 흐름이 지정된 트랜잭션에 자동으로 참여하거나 작업 수행을 위해 새로운 트랜잭션을 생성함을 나타내며 처리되지 않은 예외가 발생하지 않으면 트랜잭션이 자동으로 커밋됨을 나타냅니다.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 다음 코드 예제가 제대로 실행되려면 기본 바인딩에서 트랜잭션 이동을 지원해야 합니다. 예를 들어, <xref:System.ServiceModel.WSHttpBinding>을 사용하여 트랜잭션 이동을 지원하려면 코드 또는 애플리케이션 구성 파일에서 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 속성을 `true`로 설정합니다. 다음 코드 예제에서는 앞에 나온 샘플에 대한 구성 파일을 보여 줍니다.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">서비스: 동작 샘플</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.ServiceModel.ServiceBehaviorAttribute" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute>의 기본값은 다음과 같습니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A>는 <xref:System.ServiceModel.AddressFilterMode.Exact>로 설정됩니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> 속성은 `true`입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>는 <xref:System.ServiceModel.ConcurrencyMode.Single>로 설정됩니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> 속성은 어셈블리 정보가 없는, 네임스페이스 정규화된 형식 이름입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 속성은 `false`입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 속성은 64KB로 설정됩니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> 속성은 네임스페이스 또는 어셈블리 정보가 없는, 서비스 형식 이름입니다.  
  
-   합니다 <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> 속성이 "http://tempuri.org"입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> 속성은 `true`입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>가 `false`인 경우  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A>가 `true`인 경우  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> 속성은 `false`입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> 속성은 <xref:System.Transactions.IsolationLevel.Unspecified>입니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> 속성은 <xref:System.TimeSpan.Zero>로 설정됩니다.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 속성은 `true`입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디스패처가 들어오는 메시지를 올바른 엔드포인트로 라우팅하는 데 사용하는 <see cref="T:System.ServiceModel.AddressFilterMode" />를 가져오거나 설정합니다.</summary>
        <value>디스패처가 들어오는 메시지를 올바른 엔드포인트로 라우팅하는 데 사용하는 <see cref="T:System.ServiceModel.AddressFilterMode" /> 개체입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 <see cref="T:System.ServiceModel.AddressFilterMode" /> 값 중 하나가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트가 출력 세션을 닫을 때 세션을 자동으로 닫을지 여부를 지정합니다.</summary>
        <value>클라이언트가 출력 세션을 닫을 때 서비스가 자동으로 세션을 닫으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 클라이언트가 출력 세션을 닫고 서비스에서 나머지 메시지 처리를 마치면 서버는 해당 세션을 닫습니다. <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A>을 `false`로 설정하면 서버에서 세션을 자동으로 닫지 못하고 세션 수명에 대한 사용자 지정 컨트롤이 활성화됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스가 하나의 스레드, 여러 개의 스레드 또는 재진입 호출을 지원할지 여부를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.ServiceModel.ConcurrencyMode" /> 값 중 하나입니다. 기본값은 <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 서비스의 인스턴스가 하나의 스레드 또는 동시에 실행되는 여러 스레드를 처리하는지 여부 그리고 단일 스레드인 경우 재진입이 지원되는지 여부를 나타냅니다.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 속성은 다른 설정과 상호 작용합니다. 예를 들어, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 값을 <xref:System.ServiceModel.InstanceContextMode.Single>로 설정한 경우 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 값을 <xref:System.ServiceModel.ConcurrencyMode.Multiple>로 설정하지 않으면 서비스에서 한 번에 하나의 메시지만 처리할 수 있습니다. 또한 이 속성은 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성과 함께 동작을 생성합니다. 자세한 내용은 참조 하세요 [세션, Instancing, and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)합니다.  
  
 <xref:System.ServiceModel.ConcurrencyMode>를 <xref:System.ServiceModel.ConcurrencyMode.Single>로 설정하면 시스템은 서비스의 인스턴스를 한 번에 하나의 실행 스레드로 제한하므로, 스레딩 문제를 처리하지 않아도 됩니다. 값이 <xref:System.ServiceModel.ConcurrencyMode.Multiple>이면 언제든지 한 번에 여러 스레드가 서비스 개체를 실행할 수 있습니다. 이런 경우 스레드 안전성을 확인해야 합니다.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 또한에서는 한 번에 단일 스레드 액세스를 제한 작업을 처리 하는 동안 다른 메시지가 작업을 입력할 수 있습니다. 작업 중에 다른 서비스에 대한 호출이 발생하면 현재 메시지는 해당 작업에 대한 잠금을 해제하며 따라서 이 작업은 다른 메시지를 처리할 수 있습니다. 서비스 호출이 반환되면 잠금이 다시 설정되고 원래의 메시지가 처리 완료 시까지 또는 해당 작업에 대한 다른 호출이 발생할 때까지 처리를 계속할 수 있습니다.  
  
> [!IMPORTANT]
>  경우에 <xref:System.ServiceModel.ConcurrencyMode.Single> 인스턴스를 제한 한 번에 실행 한 스레드 서비스를 설정 해야 <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> 순서가 메시지가 없으면 보장 하려면 1로 합니다.  
>   
>  또한 개체 상태의 프로그램 호출 전에 일관성을 유지 해야 하 고 설명선이 포함 된 후에 작업-로컬 데이터가 유효한 지 확인 해야 합니다. 서비스 인스턴스는 WCF 채널을 통해 다른 서비스를 호출하는 방법으로만 잠금 해제됩니다. 이런 경우 호출된 서비스는 콜백을 통해 첫 번째 서비스에 재진입할 수 있습니다. 첫 번째 서비스가 재진입이 아닌 경우 호출 시퀀스는 교착 상태에 빠지게 됩니다. 자세한 내용은 <xref:System.ServiceModel.ConcurrencyMode>를 참조하세요.  
  
 처리 중인 작업에서 아웃바운드 호출 도중, 해당 작업에 속하지 않은 데이터를 수정할 수 있습니다. 원래의 메시지가 다시 처리를 시작할 때 로컬 상태 데이터는 항상 유효합니다. 따라서 아웃바운드 호출에 앞서 먼저, 작업에 속하지 않은 데이터가 다른 들어오는 호출에 대해 유효한지 확인하고, 아웃바운드 호출 반환 후에는 작업에 속하지 않은 데이터의 유효성을 다시 검사해야 합니다.  
  
 다음 의사(pseudo) 코드에서는 성공적인 재진입 지원에 필요한 패턴을 보여 줍니다.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>가 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>일 때 아웃바운드 호출에 대해 Begin/End 비동기 호출 패턴을 사용하면 예외가 트리거됩니다. 비동기 아웃바운드 호출에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>가 <xref:System.ServiceModel.ConcurrencyMode.Multiple>인 작업이 필요하며, 이 경우 사용자는 동기화 문제를 처리해야 합니다.  
  
 일반적으로 인스턴스에 대해 동시성 모드를 위반하는 메시지가 도착할 경우 그 메시지는 인스턴스가 사용 가능해지거나 시간 제한이 초과할 때까지 대기합니다.  
  
 또한 <xref:System.ServiceModel.ConcurrencyMode>가 <xref:System.ServiceModel.ConcurrencyMode.Single>로 설정되었으며 인스턴스가 해제될 때까지 기다리는 동안 재진입 호출이 차단되는 경우, 시스템은 교착 상태를 감지하고 예외를 throw합니다.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> 속성이 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A>로 설정된 상태에서 `true`가 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>인 경우에는 런타임에 <xref:System.ServiceModel.ConcurrencyMode.Single>이 throw됩니다.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A>이 true로 설정된 작업이 있고 `false`를 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>로 설정한 경우, 명시적으로 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>를 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>로 설정해야 합니다. 그렇지 않으면, <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A>의 기본값이 `true`이므로 유효성 검사 예외가 throw됩니다.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>와 다른 속성 간의 상호 작용이 있어서 런타임 동작을 바꿀 수 있습니다. 이러한 상호 작용의 설명은 참조 하세요 [세션, Instancing, and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 및 <xref:System.ServiceModel.ConcurrencyMode.Multiple>을 사용했을 때의 차이점을 보여 줍니다. 이 샘플을 뒤 실제 구현이 없어 컴파일되지 않습니다 하지만 보장 Windows Communication Foundation (WCF) 만들고 사용자의 작업 코드에 대 한 의미는 스레딩의 종류를 보여지 않습니다.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 <see cref="T:System.ServiceModel.ConcurrencyMode" /> 값 중 하나가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 구성 파일에서 서비스 요소를 찾는 데 사용되는 값을 가져오거나 설정합니다.</summary>
        <value>구성 파일에서 찾을 값입니다. 기본값은 어셈블리 정보가 없는, 정규화된 형식 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구성 파일에서 특정 서비스를 지정하려면 이 값을 사용합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">값이 null인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 빈 문자열인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스에서 주문한 디스패치를 확인하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서비스에서 주문한 디스패치를 확인하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서비스를 구현하고 서비스의 단일 인스턴스로 사용되는 개체를 검색하며, 단일 인스턴스가 없는 경우 <see langword="null" />입니다.</summary>
        <returns>서비스의 구현입니다. 기본값은 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값이 `null`이 아닌 경우, 서비스에 전달되도록 주소가 지정된 모든 메시지를 디스패치할 대상 서비스 인스턴스가 제공됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>네트워크에서 알 수 없는 serialization 데이터를 보낼지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>알 수 없는 serialization 데이터를 보내지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 형식을 구현 하는 경우는 <xref:System.Runtime.Serialization.IExtensibleDataObject> 인터페이스를 해당 형식으로 역직렬화 하는 동안 네트워크를 통해 제공 된 모든 추가 데이터에 대 한 알 수 없는 저장 합니다. 예를 들어, `Person` 형식에 `FirstName` 및 `LastName`이라는 멤버가 있으며 `PhoneNumber`라는 요소가 도착하면 이 요소가 저장됩니다. 나중에 이 형식을 serialize할 때 `PhoneNumber`를 다시 내보냅니다. 문제는에 대 한 스키마 `Person` 서비스만는에서 내보낸 `FirstName` 및 `LastName`이므로 스키마에 적합 하지 않은 인스턴스를 생성 하는 Windows Communication Foundation (WCF). 스키마를 엄격하게 준수하는 것이 중요하다면 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A>를 `true`로 설정하여 이 다시 내보내기 동작을 해제할 수 있습니다.  
  
 와 상관 없이 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> 설정을 WCF 항상 알려진된 데이터 처리 (모두 in 및 out) 하 고 추가 데이터가 들어올 때 예외를 throw 하지 않습니다. 사용 하 여이 속성을 설정할 수도 있습니다는 [&lt;dataContractSerializer&gt;](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) 애플리케이션 구성 파일의 요소입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A>의 사용과 <xref:System.Runtime.Serialization.IExtensibleDataObject>의 구현을 보여 줍니다. 이 샘플에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A>가 `false`로 설정된 상태에서 클라이언트가 알고 있는 추가 데이터가 다시 클라이언트로 라운드트립됩니다.  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>일반적인 처리되지 않은 실행 예외를 <see cref="T:System.ServiceModel.FaultException`1" /> 형식의 <see cref="T:System.ServiceModel.ExceptionDetail" />으로 변환하고 오류 메시지로 보내도록 지정하는 값을 가져오거나 설정합니다. 서비스 문제를 해결하려면 개발하는 동안에만 이 값을 <see langword="true" />로 설정합니다.</summary>
        <value>처리되지 않은 예외가 SOAP 오류로 반환되면 <see langword="true" />이고, 그렇지 않을 경우 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 디버깅을 위해 예외 정보가 클라이언트로 이동할 수 있게 하려면 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A>를 `true`로 설정합니다. 이 속성에서는 요청-응답 또는 이중 메시징을 지원하는 바인딩이 필요합니다.  
  
 관리되는 모든 애플리케이션에서 처리 오류는 <xref:System.Exception> 개체로 표시됩니다. SOAP 기반 애플리케이션에서 WCF 애플리케이션과 같은 서비스 작업을 구현 하는 메서드는 오류 정보를 SOAP 오류 메시지를 사용 하 여 통신 합니다. WCF 애플리케이션 두 가지 유형의 오류 시스템에서 실행 되므로 클라이언트로 전송 해야 하는 모든 관리 되는 예외 정보는 예외에서 SOAP 오류로 변환 되어야 합니다. 자세한 내용은 [지정 및 계약 및 서비스에서 오류 처리](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)합니다.  
  
 개발 과정에서 디버깅에 도움이 되도록 서비스에서 기타 예외도 클라이언트에 돌려보내도록 하는 경우가 있습니다. 이는 개발 전용 기능이므로 배포된 서비스에서는 사용할 수 없습니다.  
  
 디버깅 개발을 용이 하 게 설정 합니다 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 에 `true` 코드 또는 애플리케이션 구성 파일을 사용 합니다.  
  
 이 설정을 사용하면 서비스는 더 안전한 예외 정보를 자동으로 호출자에게 반환합니다. 이 오류는 <xref:System.ServiceModel.FaultException%601> 형식의 <xref:System.ServiceModel.ExceptionDetail> 개체로 클라이언트에 나타납니다.  
  
> [!IMPORTANT]
>  설정 <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> 에 `true` 내부 정보를 가져올 수 있도록 클라이언트는 서비스 메서드 예외;만 임시로 서비스 애플리케이션을 디버깅 하는 방법으로 권장 됩니다. 또한 이 방법으로 처리되지 않은 관리되는 예외를 반환하는 메서드의 WSDL에는 <xref:System.ServiceModel.FaultException%601> 형식의 <xref:System.ServiceModel.ExceptionDetail>에 대한 계약이 포함되지 않습니다. 디버깅 정보를 제대로 얻으려면 클라이언트는 알 수 없는 SOAP 오류의 가능성을 예상해야 합니다.  
  
 이 속성을 설정 `true` 수행할 수도 있습니다 애플리케이션 구성 파일을 사용 하며 [&lt;serviceDebug&gt;](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) 다음 코드 예제와 같이 요소.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 속성을 보여 줍니다. `BehaviorService` 클래스는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 특성을 사용하여 다음을 나타냅니다.  
  
-   구현 메서드가 UI 스레드에서 호출됩니다.  
  
-   세션별로 서비스 개체가 하나씩 있습니다.  
  
-   서비스는 단일 스레드이며 재진입 호출을 지원하지 않습니다.  
  
 또한 작업 수준에서 <xref:System.ServiceModel.OperationBehaviorAttribute> 값은 `TxWork` 메서드가 흐름이 지정된 트랜잭션에 자동으로 참여하거나 작업 수행을 위해 새로운 트랜잭션을 생성함을 나타내며 처리되지 않은 예외가 발생하지 않으면 트랜잭션이 자동으로 커밋됨을 나타냅니다.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 다음 코드 예제가 제대로 실행되려면 기본 바인딩에서 트랜잭션 이동을 지원해야 합니다. 예를 들어, <xref:System.ServiceModel.WSHttpBinding>을 사용하여 트랜잭션 이동을 지원하려면 코드 또는 애플리케이션 구성 파일에서 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 속성을 `true`로 설정합니다. 다음 코드 예제에서는 앞에 나온 샘플에 대한 구성 파일을 보여 줍니다.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>새 서비스 개체 생성 시점을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.ServiceModel.InstanceContextMode" /> 값 중 하나입니다. 기본값은 <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 서비스 개체 생성 시점을 지정하려면 <xref:System.ServiceModel.InstanceContextMode> 속성을 사용합니다. 서비스 개체가 통신 채널과 직접 연결되지 않으므로 서비스 개체의 수명은 클라이언트와 서비스 애플리케이션 사이의 채널이 가지는 수명과 관계가 없습니다. 기본값인 <xref:System.ServiceModel.InstanceContextMode.PerSession>은 클라이언트와 서비스 애플리케이션 간에 새 통신 세션이 설정될 경우 서비스 애플리케이션이 새 서비스 개체를 만들도록 합니다. 동일 세션 내의 후속 호출은 동일한 개체가 처리합니다.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession>은 각 서비스 개체가 하나의 클라이언트 채널의 요청을 처리함을 나타냅니다.  
  
> [!NOTE]
>  <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 속성은 다른 설정과 상호 작용합니다. 예를 들어, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 값을 <xref:System.ServiceModel.InstanceContextMode.Single>로 설정한 경우 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 값을 <xref:System.ServiceModel.ConcurrencyMode.Multiple>로 설정하지 않으면 서비스에서 한 번에 하나의 메시지만 처리할 수 있습니다. 또한 이 속성은 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 속성과 함께 동작을 생성합니다. 자세한 내용은 참조 하세요 [세션, Instancing, and Concurrency](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md)합니다.  
  
 단일 수명 동작(예: 호스트 애플리케이션이 <xref:System.ServiceModel.ServiceHost.%23ctor%2A> 생성자를 호출하고 서비스로 사용할 개체를 전달하는 경우)에 대해서는 서비스 클래스에서 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A>를 `Single`로 설정해야 합니다. 그렇지 않으면 런타임에 예외가 throw됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 속성을 보여 줍니다. `BehaviorService` 클래스는 <xref:System.ServiceModel.ServiceBehaviorAttribute> 특성을 사용하여 다음을 나타냅니다.  
  
-   구현 메서드가 UI 스레드에서 호출됩니다.  
  
-   세션별로 서비스 개체가 하나씩 있습니다.  
  
-   서비스는 단일 스레드이며 재진입 호출을 지원하지 않습니다.  
  
 또한 작업 수준에서 <xref:System.ServiceModel.OperationBehaviorAttribute> 값은 `TxWork` 메서드가 흐름이 지정된 트랜잭션에 자동으로 참여하거나 작업 수행을 위해 새로운 트랜잭션을 생성함을 나타내며 처리되지 않은 예외가 발생하지 않으면 트랜잭션이 자동으로 커밋됨을 나타냅니다.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 다음 코드 예제가 제대로 실행되려면 기본 바인딩에서 트랜잭션 이동을 지원해야 합니다. 예를 들어, <xref:System.ServiceModel.WSHttpBinding>을 사용하여 트랜잭션 이동을 지원하려면 코드 또는 애플리케이션 구성 파일에서 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 속성을 `true`로 설정합니다. 다음 코드 예제에서는 앞에 나온 샘플에 대한 구성 파일을 보여 줍니다.  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 <see cref="T:System.ServiceModel.InstanceContextMode" /> 값 중 하나가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>serialize된 개체에 허용되는 최대 항목 수를 가져오거나 설정합니다.</summary>
        <value>개체에 허용되는 최대 항목 수입니다. 기본값은 65536바이트(64KB)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 개체 그래프에서 serialize되는 항목의 수를 제한하려면 <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> 속성을 사용합니다. 사용 하 여이 속성을 설정할 수도 있습니다는 [&lt;dataContractSerializer&gt;](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) 애플리케이션 구성 파일의 요소입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>WSDL(웹 서비스 기술 언어)에서 서비스 요소의 이름 특성 값을 가져오거나 설정합니다.</summary>
        <value>내보낼 때 <see langword="&lt;wsdl:service&gt;" /> 요소의 이름 특성의 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>WSDL(웹 서비스 기술 언어)에서 서비스의 대상 네임스페이스 값을 가져오거나 설정합니다.</summary>
        <value><see langword="targetNamespace" /> 요소를 포함하는 <see langword="&lt;wsdl:definitions&gt;" /> 요소에 대한 <see langword="&lt;wsdl:service&gt;" /> 특성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 트랜잭션이 완료되면 서비스 개체를 해제하는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>서비스 개체가 해제되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A>이 true로 설정된 작업이 있고 `false`를 <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType>로 설정한 경우, 명시적으로 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>를 <xref:System.ServiceModel.ConcurrencyMode.Reentrant>로 설정해야 합니다. 그렇지 않으면, <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A>의 기본값이 `true`이므로 유효성 검사 예외가 throw됩니다.  
  
 또한 서비스 개체를 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> 생성자에 전달하는 방법으로 서비스를 생성한 경우 이 속성의 값은 `false`처럼 처리됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 트랜잭션 격리 수준을 <xref:System.Transactions.IsolationLevel.ReadCommitted>로 설정하고, 동시 트랜잭션을 지원하지 않으며, 작업 호출로부터의 흐름이 지정된 트랜잭션이 필요하고, 처리되지 않은 예외가 발생하지 않으면 서비스에 대한 트랜잭션을 자동으로 커밋합니다.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 다음 코드 예제가 제대로 실행되려면 기본 바인딩에서 트랜잭션 이동을 지원해야 합니다. 예를 들어, <xref:System.ServiceModel.WSHttpBinding>을 사용하여 트랜잭션 이동을 지원하려면 코드 또는 애플리케이션 구성 파일에서 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 속성을 `true`로 설정합니다. 다음 코드 예제에서는 앞에 나온 샘플에 대한 구성 파일을 보여 줍니다.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">서비스의 단일 인스턴스입니다.</param>
        <summary>서비스를 구현하고 서비스의 단일 인스턴스로 사용되는 개체를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서비스에 전달되도록 주소가 지정된 모든 메시지를 디스패치할 대상 서비스 인스턴스를 제공합니다.  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A>가 `null`이 아닌 값으로 설정된 경우 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A>는 <xref:System.ServiceModel.InstanceContextMode.Single>로 설정되어야 하며, 그렇지 않으면 <xref:System.InvalidOperationException>이 throw됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">설정된 값이 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> 속성이 기본값에서 변경되었으며 이를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> 속성이 기본값에서 변경되었으며 이를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> 속성이 기본값에서 변경되었으며 이를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> 속성이 기본값에서 변경되었으며 이를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> 속성이 기본값에서 변경되었으며 이를 serialize해야 하는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">서비스 설명입니다.</param>
        <param name="serviceHostBase">서비스 호스트입니다.</param>
        <param name="endpoints">서비스 엔드포인트입니다.</param>
        <param name="parameters">바인딩에서 동작을 지원하는 데 필요한 데이터 개체입니다.</param>
        <summary>사용자 지정 데이터 개체를 동작 속성을 지원하는 바인딩에 전달합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">서비스 설명입니다.</param>
        <param name="serviceHostBase">서비스 호스트입니다.</param>
        <summary>동작 속성을 지원하도록 서비스 런타임을 사용자 지정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">서비스 설명입니다.</param>
        <param name="serviceHostBase">서비스 호스트입니다.</param>
        <summary>서비스 설명 및 서비스 호스트가 동작을 지원할 수 있음을 확인합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 세션이 오류 없이 닫힐 때 보류 중인 트랜잭션이 완료되는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>현재 세션이 오류 없이 닫힐 때 보류 중인 트랜잭션이 완료되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스 내부에서 만들어지는 새 트랜잭션 및 클라이언트로부터 들어오는 트랜잭션의 트랜잭션 격리 수준을 지정합니다.</summary>
        <value>트랜잭션 격리 수준을 지정하는 <see cref="T:System.Transactions.IsolationLevel" /> 값입니다. 기본값은 <see cref="F:System.Transactions.IsolationLevel.Unspecified" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 트랜잭션이 실행되는 격리 수준에 따라 다른 트랜잭션에서 변경이 있을 경우 데이터를 처리하는 방법 및 이러한 변경으로부터 보호하기 위해 사용자의 트랜잭션이 잠금을 보유해야 하는 기간이 결정됩니다. 예를 들어, 기본값인 <xref:System.Transactions.IsolationLevel.Unspecified>는 트랜잭션이 완료될 때까지 어떠한 업데이트나 삽입도 발생할 수 없음을 지정합니다.  
  
 이 속성은 클라이언트로부터 들어오는 트랜잭션의 격리 수준을 제한하는 데에도 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 트랜잭션 격리 수준을 <xref:System.Transactions.IsolationLevel.ReadCommitted>로 설정하고, 동시 트랜잭션을 지원하지 않으며, 메서드 호출로부터의 흐름이 지정된 트랜잭션이 필요하고, 처리되지 않은 예외가 발생하지 않으면 트랜잭션을 자동으로 커밋합니다.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 다음 코드 예제가 제대로 실행되려면 기본 바인딩에서 트랜잭션 이동을 지원해야 합니다. 예를 들어, <xref:System.ServiceModel.WSHttpBinding>을 사용하여 트랜잭션 이동을 지원하려면 코드 또는 애플리케이션 구성 파일에서 <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> 속성을 `true`로 설정합니다. 다음 코드 예제에서는 앞에 나온 샘플에 대한 구성 파일을 보여 줍니다.  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 <see cref="T:System.Transactions.IsolationLevel" /> 값 중 하나가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>트랜잭션을 완료해야 하는 기간을 가져오거나 설정합니다.</summary>
        <value>트랜잭션이 완료되어야 하거나, 완료되지 못할 경우 자동으로 중단되어야 하는 제한 시간을 나타내는 <see cref="T:System.TimeSpan" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값은 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType> 속성을 설정합니다. 사용 하 여이 속성을 설정할 수도 있습니다는 [&lt;serviceTimeouts&gt;](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) 애플리케이션 구성 파일의 요소입니다.  
  
   
  
## Examples  
 다음 구성 파일에서는 트랜잭션 시간 제한을 3분으로 지정합니다.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">값이 null인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">값이 <see cref="F:System.TimeSpan.Zero" />보다 작거나 <see cref="F:System.TimeSpan.MaxValue" />보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 동기화 컨텍스트를 사용하여 스레드 실행을 선택할지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>모든 서비스 호출이 <see cref="T:System.Threading.SynchronizationContext" />에서 지정한 스레드에서 실행되어야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 애플리케이션에서 요구하는 사용자 인터페이스 스레드 선호도를 제공하려면 이 속성을 사용합니다. 예를 들어, Windows Forms 애플리케이션이 singleton 서비스 개체로 등록될 수 있습니다. 그런 경우 이 서비스에 대한 모든 호출이 Windows Forms 스레드에서 실행되어야 합니다. <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A>가 `true`로 설정되는 기본 환경에서는 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>로부터 캡처한 스레드에서 실행될 모든 서비스 호출을 동기화합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>SOAP <see langword="MustUnderstand" /> 헤더 처리를 시스템에서 수행하는지 아니면 애플리케이션에서 수행하는지를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>시스템에서 SOAP 헤더 <see langword="true" /> 처리를 수행할 경우 <see langword="MustUnderstand" />이고, 애플리케이션에서 이 처리를 수행할 경우 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도착하는 메시지 헤더에 적용되는 유효성 검사를 해제하려면 <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> 속성을 사용합니다. 정상적인 실행에서는 메시지 헤더를 <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> 속성과 비교하여 도착하는 헤더가 서비스에서 명시적으로 처리되는지를 확인합니다. 이 확인을 사용하지 않으려면 이 속성을 `false`로 설정합니다. `false`로 설정하면 애플리케이션에서 MustUnderstand="true"로 표시된 헤더를 검사하여 인식되지 않은 헤더가 있을 경우 오류를 반환합니다. 이 기능은 형식화된 메시지 또는 형식화되지 않은 메시지를 사용할 경우와 같이 들어오는 SOAP 메시지를 애플리케이션에서 수락하고 사용자 지정 헤더 처리를 수행해야 할 때 유용합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>