<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dbc0f7ae686463d4772e0cdd1f503f889472ddd" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56779384" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>서비스 응용 프로그램의 일부로 존재할 서비스에 기본 클래스를 제공합니다. <see cref="T:System.ServiceProcess.ServiceBase" />는 새 서비스 클래스를 만들 때 파생되어야 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 <xref:System.ServiceProcess.ServiceBase> 서비스 애플리케이션에서 서비스 클래스를 정의 하는 경우. 유용한 서비스 재정의 된 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 고 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 메서드. 추가 기능에 대해 재정의할 수 있습니다 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 고 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 서비스 상태에서 변경에 대 한 응답에서 특정 동작을 사용 하 여 합니다.  
  
 서비스는 사용자 인터페이스를 지원 하지 않는 장기 실행 로그온 한 사용자 계정으로 실행 되지 않을 수 있습니다. 서비스는 모든 사용자가 컴퓨터에 로그온 하지 않고 실행할 수 있습니다.  
  
 기본적으로 서비스 관리자 계정과 동일 하지 않는 시스템 계정으로 실행 합니다. 시스템 계정의 권한을 변경할 수 없습니다. 사용할 수 있습니다는 <xref:System.ServiceProcess.ServiceProcessInstaller> 서비스가 실행 되는 사용자 계정을 지정 합니다.  
  
 실행 파일 서비스가 둘 이상 포함 될 수 있지만 별도 있어야 <xref:System.ServiceProcess.ServiceInstaller> 각 서비스에 대 한 합니다. <xref:System.ServiceProcess.ServiceInstaller> 인스턴스 시스템을 사용 하 여 서비스를 등록 합니다. 또한 설치 관리자는 서비스 명령을 기록 하는 데 사용할 수 있는 이벤트 로그를 사용 하 여 각 서비스를 연결 합니다. `main()` 함수 실행 파일에는 실행할 서비스를 정의 합니다. 실행 파일의 위치를 가리키는 디렉터리가 아니라 시스템 디렉터리가, 서비스의 현재 작업 디렉터리를 하는 것입니다.  
  
 시스템 서비스를 시작 하면 실행 파일을 찾습니다 하 고 실행 합니다 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 메서드 실행 파일 내에 포함 된 해당 서비스에 대 한 합니다. 그러나 서비스를 실행 하는과 같지는 않습니다 실행 파일을 실행 합니다. 실행 파일 서비스를 로드합니다. (예: 시작 및 중지) 서비스가 서비스 제어 관리자를 통해 액세스 합니다.  
  
 호출 하면 실행 파일을 <xref:System.ServiceProcess.ServiceBase> 파생 클래스의 생성자는 첫 번째 시간 서비스에서 시작을 호출 합니다. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 명령 처리 메서드는 생성자가 실행 한 후에 즉시 호출 됩니다. 생성자에서 수행한 생성자에 의해 수행 되는 처리를 구분 하는 데 필요한 이므로 처음 서비스 로드 된 후에 다시 실행 되지 않습니다 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>합니다. 해제할 수 있는 모든 리소스 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 작성 해야 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>합니다. 서비스를 다시 시작 하는 경우 제대로 생성 되지 않고 생성자에서 리소스를 만드는 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 리소스를 릴리스 했습니다.  
  
 서비스 제어 관리자 (SCM)는 서비스와 상호 작용 하는 방법을 제공 합니다. 서비스를 시작, 중지, 일시 중지, 계속 하기, 또는 사용자 지정 명령을 전달할 SCM을 사용할 수 있습니다. 값을 사용 하는 SCM <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 및 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 서비스 중지를 허용 하는지 여부를 결정할 일시 중지 또는 명령을 계속 합니다. 중지, 일시 중지 및 계속 SCM의 상황에 맞는 메뉴만 경우에 설정 된 해당 속성 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 또는 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `true` 서비스 클래스에 있습니다. 명령을 사용 하도록 설정 하는 경우 서비스에 전달 됩니다 하 고 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 라고 합니다. 하는 경우 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 됩니다 `false`, 해당 명령 처리 메서드 (같은 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 메서드를 구현한 경우에 처리 되지 것입니다.  
  
 사용할 수는 <xref:System.ServiceProcess.ServiceController> SCM을 프로그래밍 방식으로 수행 하는 클래스 사용자 인터페이스를 사용 하 여 수행 합니다. 콘솔에서 사용할 수 있는 작업을 자동화할 수 있습니다. 경우 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 됩니다 `true` 되었지만 해당 명령 처리 메서드를 구현 하지 않았음을 (같은 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) 시스템 예외를 throw 하 고 해당 명령이 무시 합니다.  
  
 구현할 필요가 없습니다 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, 또는 다른 방법을에서 <xref:System.ServiceProcess.ServiceBase>합니다. 서비스의 동작을 설명 하는 반면 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>이므로 최소한이 멤버를 재정의 해야 합니다. 합니다 `main()` 실행 파일의 함수를 호출 하 여 서비스를 서비스 제어 관리자 실행 파일에 등록 된 <xref:System.ServiceProcess.ServiceBase.Run%2A> 메서드. <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 의 속성을 <xref:System.ServiceProcess.ServiceBase> 에 전달 된 개체를 <xref:System.ServiceProcess.ServiceBase.Run%2A> 메서드 일치 해야 합니다는 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> 해당 서비스에 대 한 서비스 설치 관리자의 속성.  
  
 사용할 수 있습니다 `InstallUtil.exe` 시스템에서 서비스를 설치 합니다.  
  
> [!NOTE]
>  서비스 호출 있지만 둘 다에 대 한 알림을 받으려면 애플리케이션 이벤트 로그 외에 다른 로그를 지정할 수 있습니다 합니다 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 또는 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 속성 사용자 지정 로그에 쓸 수 있습니다. 설정할 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `false` 자동 로깅을 사용 하지 않을 경우.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.ServiceProcess.ServiceBase" /> 클래스의 새 인스턴스를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스를 만들지 마십시오는 <xref:System.ServiceProcess.ServiceBase> 클래스입니다. 파생 대신 <xref:System.ServiceProcess.ServiceBase> 하 고 파생 된 클래스를 인스턴스화합니다. 상속 된 클래스에 대 한 생성자에서 구현 해야 할 최소 <xref:System.ServiceProcess.ServiceBase> 설정 하는 것은 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 구성 요소에서 합니다. 특히 생성자에서 다른 프로세스가 필요 합니다. 대부분의 초기화를 처리 하는 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 생성자 대신 합니다. 그렇지 않으면 보장이 없습니다 개체 중지 된 후에 서비스를 다시 시작 하면 다시 초기화 됩니다.  
  
 파생된 클래스에서 생성자를 재정의 하는 경우 코드에서 기본 클래스 생성자를 호출 합니다.  
  
 합니다 <xref:System.ServiceProcess.ServiceBase> 생성자 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `true`입니다. 서비스 제어 관리자 (SCM)에서 서비스를 호출을 자동으로 로그인 하려면 설정 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `false`입니다.  
  
 단일 서비스를 포함 하는 실행 파일을 하는 경우 시스템 시작에서 SCM에 선택 된 중지 라고 하는 경우 소멸자를 실행 하는 경우 서비스의 생성자를 호출 합니다.  
  
 여러 서비스를 포함 하는 실행 파일, 실행 파일의 모든 서비스에 대해 호출할 생성자 시작 한 서비스에 대해를 호출 하면 되지만 지정된 된 서비스만 시작 됩니다. 모든 서비스가 중지 되었으며, 각각이 아닌 각 서비스가 중지 되 면 서비스에 대 한 소멸자는 함께 실행 됩니다.  
  
> [!NOTE]
>  기본 클래스 생성자를 재정의 하면 파생 된 클래스의 생성자에서 명시적으로 호출 해야 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이벤트 로그에 있는 시작, 중지, 일시 중지 및 계속 명령을 보고할지 여부를 나타냅니다.</summary>
        <value>이벤트 로그에 있는 정보를 보고하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `true` 서비스 시작, 중지, 일시 중지, 상태 변경 정보 뿐만 아니라 보고서 명령 오류, 애플리케이션 이벤트 로그를 사용 하 고 서비스에서 이벤트를 계속에 지시 합니다. 로그의 서비스 이름이 사용 됩니다 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>합니다.  
  
 애플리케이션 로그를 사용 하지 않고 사용자 지정 이벤트 로그에 정보를 보고를 설정 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `false` 명령 처리 메서드 내에서 명령을 작성 하 고 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 적절 한 로그에 게시 하도록 합니다.  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>를 제공 하는 이벤트 로그에 대 한 소스 문자열을 설정 해야 서비스 이벤트 로그에 기록 하려고 시도 합니다. 원본 이름 설정 되기 전에 이벤트 로그에 액세스 하는 동안 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스에서 컴퓨터 전원 상태 변경 알림을 처리할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서비스에서 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> 클래스에 나타나 있는 컴퓨터 전원 상태 변경을 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 컴퓨터 전원 상태 변경, 서비스 제어 관리자 (SCM) 확인 서비스의 값을 사용 하 여 전원 이벤트 명령을 허용 하는지 여부를 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>입니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> 은 `true`, 명령이 서비스에 전달 되 고 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 메서드 정의 하는 경우 호출 됩니다. 하는 경우 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 구현 되지 않은 파생된 클래스에서 SCM는 빈 기본 클래스를 통한 전원 이벤트를 처리 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 속성이 서비스가 시작된 후 수정된 경우</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>터미널 서버 세션에서 받은 세션 변경 이벤트를 서비스에서 처리할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서비스에서 터미널 서버 세션 변경 이벤트를 처리할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">이 속성이 서비스가 시작된 후 수정된 경우</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스를 일시 중지했다가 다시 시작할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서비스를 일시 중지할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 설정 합니다 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 서비스에 대 한 생성자에서 속성입니다.  
  
 서비스 일시 중지 하는 경우 무엇이 중단 합니다. (또는 서비스 제어 관리자를 통해 프로그래밍 방식으로), 서비스를 계속 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 실행 합니다.  
  
 서비스 일시 중지 요청을 전송 시스템 리소스를 절약할 수 있습니다. 일시 중지 될 수 있습니다 모든 시스템 리소스를 해제 하지 않지만 중지 합니다. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 보다 작은 처리 하는 데 자주 구현 됩니다 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 고 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>입니다.  
  
 때 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 은 `true`, 재정의 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 서비스 제어 관리자 (SCM) 서비스 일시 중지 또는 계속 요청을 전달 하는 경우 발생 되어야 하는 처리를 지정 합니다. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 처리를 취소 하기 위해 구현 해야 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>합니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `false`SCM 일시 중지를 통과 하지 못합니다, 계속 하므로 서비스에 요청 합니다 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 구현 될 경우에 메서드 호출 되지 것입니다. SCM에에 `Pause` 및 `Continue` 컨트롤을 사용할 때 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">서비스가 이미 시작된 경우. 서비스가 시작된 후에는 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 속성을 변경할 수 없습니다.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시스템이 종료될 때 서비스에 알릴지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>시스템이 종료될 때 서비스에 알리려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.  기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> 는 `true`, 시스템 종료 될 때 서비스에 알립니다. 종료 시는 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 파생된 클래스에서 구현 되는 경우 메서드가 호출 됩니다.  
  
> [!NOTE]
>  시스템만 시키는 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 실행할; 메서드를 서비스를 호출할 수 있지만 권장 되지는 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">서비스가 이미 시작된 경우. 서비스가 시작된 후에는 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 속성을 변경할 수 없습니다.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시작한 서비스를 중지할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서비스를 중지할 수 있고 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> 메서드가 호출되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서비스 제어 관리자 (SCM) 서비스의 값을 사용 하 여 Stop 명령을 허용 하는지 여부를 확인 중지 서비스에서 호출 되 면 <xref:System.ServiceProcess.ServiceBase.CanStop%2A>합니다. 서비스의 대부분의 경우 값 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 는 `true`, 하지만 일부 운영 체제 서비스를 중지 하는 사용자를 예를 들어 허용 하지 않습니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 됩니다 `true`를 중지 명령이 서비스에 전달 되 및 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 정의 된 경우 호출 됩니다. 하는 경우 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 빈 기본 클래스를 통해 중지 명령이 SCM 핸들 파생된 클래스에서 구현 되지 않았습니다 <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">서비스가 이미 시작된 경우. 서비스가 시작된 후에는 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 속성을 변경할 수 없습니다.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary><see cref="T:System.ServiceProcess.ServiceBase" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.ServiceProcess.ServiceBase.Dispose%2A> 파생된 클래스에서 (그리고이 통해에서 <xref:System.ServiceProcess.ServiceBase> 클래스) 파생된 클래스를 사용 하 여 작업을 마쳤으면 합니다. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> 메서드 파생된 클래스를 사용할 수 없는 상태로 유지 합니다. 호출한 후 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, 파생된 클래스에 대 한 모든 참조를 해제 해야 하 고 <xref:System.ServiceProcess.ServiceBase> 된 차지 하는 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.  
  
> [!NOTE]
>  항상 호출 <xref:System.ServiceProcess.ServiceBase.Dispose%2A> 에서 파생 된 클래스에 대 한 마지막 참조를 해제 하기 전에 <xref:System.ServiceProcess.ServiceBase>입니다. 이 고, 그렇지 리소스 <xref:System.ServiceProcess.ServiceBase> 파생된 클래스는 사용 하 고 가비지 수집에서 개체의 소멸자를 호출할 때까지 해제 되지 않습니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 코드를 처리 하는 데 주로 구현 되 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>에 대 한 호출을 사용 하 여 결합 된 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>합니다. 구현에 파생된 클래스에서이 작업을 수행 하려는 경우 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 무엇이 든 할당할 <xref:System.ServiceProcess.ServiceBase.Dispose%2A> 해제 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램 이벤트 로그에 서비스 명령 호출(예: 시작 및 중지)의 알림을 쓰는 데 사용할 수 있는 이벤트 로그를 가져옵니다.</summary>
        <value>응용 프로그램 로그에 등록되는 소스가 있는 <see cref="T:System.Diagnostics.EventLog" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성자가 초기화 하는 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 속성을 사용 하 여 인스턴스를 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> 및 <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> 속성 집합입니다. 원본이 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 서비스의 로그는 컴퓨터의 애플리케이션 로그입니다. 이 값은 자동으로 설정 하며 서비스 명령의 자동 로깅에 대 한 변경할 수 없습니다.  
  
 때 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 는 `true`, 시작, 중지, 일시 중지, 계속 하기, 및 사용자 지정 명령을 자동으로 애플리케이션 이벤트 로그에 기록 됩니다. 사용할 수는 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 도 해당 로그에 추가 메시지를 쓸 속성입니다. 구성 요소 호출 <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> 이 사용 하 여 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 멤버입니다.  
  
 애플리케이션 로그를 사용 하지 않고 사용자 지정 이벤트 로그에 정보를 보고를 설정 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 에 `false` 명령 처리 메서드 내에서 명령을 작성 하 고 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 적절 한 로그에 게시 하도록 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스의 종료 코드를 가져오거나 설정합니다.</summary>
        <value>서비스의 종료 코드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 된 <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> 서비스 제어 관리자에는 오류를 표시 하는 서비스를 중지 하기 전에 0이 아닌 값으로 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>서비스 이름의 최대 크기를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName 및 DisplayName 서비스 클래스에 속성을 설정 하는 경우 따라야 하는 크기 제한에 모두 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 구현되는 경우 <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" />는 계속 명령이 SCM(서비스 컨트롤 관리자)에 의해 서비스에 전달될 때 실행됩니다. 서비스에서 일반 기능을 일시 중지했다가 다시 시작할 때 수행할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 미러링에 대 한 애플리케이션의 응답 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>합니다. (또는 서비스 콘솔을 통해 프로그래밍 방식으로), 서비스를 계속 하는 경우는 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 다시 활성화 될 실행 되 고 서비스를 처리 합니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 때 재정의 해야 합니다 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 속성은 `true`합니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `false`SCM 일시 중지를 통과 하지 못합니다, 계속 하므로 서비스에 요청 합니다 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 구현 될 경우에 메서드 호출 되지 것입니다. SCM에에 `Pause` 및 `Continue` 컨트롤을 사용할 때 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">서비스에 전달된 명령 메시지입니다.</param>
        <summary>파생 클래스에서 구현되는 경우 <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />는 SCM(서비스 컨트롤 관리자)이 서비스에 사용자 지정 명령을 전달할 때 실행됩니다. 지정된 매개 변수 값을 사용하는 명령이 발생할 때 수행할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 시작, 중지, 일시 중지 및 계속 서비스 이외의 추가 기능을 지정할 수 있습니다.  
  
 SCM 서비스를 지원 하는지 여부를 확인 하는 사용자 지정 명령을 검사 하지 않습니다는 `command` 매개 변수가 전달 합니다. 사용자 지정 명령 서비스에 직접 전달합니다. 서비스를 인식 하지 못하는 경우를 `command` 매개 변수를 없습니다.  
  
 사용자 지정 명령에 의해 발생 하는 <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> 문에서 <xref:System.ServiceProcess.ServiceController> 구성 요소입니다. Switch 문을 사용 하 여 경우... 다음 조건을 사용 하 여 서비스에서 정의한 사용자 지정 명령을 처리할 수 있습니다.  
  
 애플리케이션에서 정의 하거나에서 사용할 수 있는 사용자 지정 명령에 대 한 값만 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> 128과 255 사이의 됩니다. 정수 128 아래 시스템 예약 값에 해당합니다.  
  
 경우는 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 속성은 `true`, 다른 모든 명령과 마찬가지로 사용자 지정 명령, 메서드 실행 성공 또는 실패 여부를 보고 하는 이벤트 로그에 엔트리를 씁니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 구현되는 경우 일시 중지 명령이 SCM(서비스 컨트롤 관리자)에 의해 서비스에 전달될 때 실행됩니다. 서비스가 일시 중지될 때 수행할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 서비스 일시 중지 명령의 받을 때 발생 하는 처리를 지정 합니다. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 때 재정의 해야 합니다 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 속성은 `true`합니다.  
  
 (또는 서비스 콘솔을 통해 프로그래밍 방식으로), 일시 중지 된 서비스를 계속 합니다 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 처리를 실행 하 고 서비스를 다시 활성화 됩니다.  
  
 일시 중지 명령을 특정 이벤트에 반응 하는 애플리케이션 허용 합니다. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 작업을 수행 하도록 정의 하지 않은 서비스 수는 없습니다.  
  
 서비스 일시 중지 요청을 전송 하는 모든 시스템 리소스를 해제 하지 않으므로 시스템 리소스가 절약 수 있습니다. 예를 들어, 스레드는 계속 열려 스레드가 중지 수 대신 서비스를 일시 중지, 프로세스에서 열린 경우에 해당 서비스를 계속할 때 다시 할당 필요가 없습니다. 모든 시스템 리소스를 해제 하려면 일시 중지를 정의 하는 경우 중지 명령 처럼 동작 합니다.  
  
 설정 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 를 `true`, 재정의 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> SCM 서비스를 일시 중지 또는 계속 요청을 전달 하는 경우 발생 되어야 하는 처리를 지정 합니다. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 처리를 취소 하기 위해 구현 해야 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>합니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 됩니다 `false`, SCM 일시 중지를 통과 하지 못합니다 또는 계속 하므로 서비스에 요청 합니다 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 메서드 구현 하는 경우에 호출 되지 것입니다. SCM에에 `Pause` 및 `Continue` 컨트롤을 사용할 때 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> 는 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">전원 상태에 대한 시스템의 알림을 나타내는 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />입니다.</param>
        <summary>파생 클래스에서 구현되는 경우 컴퓨터의 전원 상태가 변경될 때 실행되며, 시스템 종료와는 다른 일시 중단 모드로 될 때 랩톱 컴퓨터에 적용됩니다.</summary>
        <returns>파생 클래스에서 구현된 경우 응용 프로그램의 필요에 따라 반환 값이 결정됩니다. 예를 들어 <see langword="QuerySuspend" /> 브로드캐스트 상태가 전달되는 경우 <see langword="false" />를 반환하여 응용 프로그램에서 쿼리를 거부하도록 할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 시스템 이벤트에 표시 된 경우 발생 하는 처리를 지정 하는 <xref:System.ServiceProcess.PowerBroadcastStatus> 열거형 경우-예를 들어, 컴퓨터는 일시 중단 된 모드에서 오거나 배터리 전원 부족을 나타냅니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> 때 재정의 해야 합니다 <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> 속성은 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">변경 형식을 식별하는 구조체입니다.</param>
        <summary>터미널 서버 세션에서 보낸 변경 이벤트를 받았을 때 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 해야 합니다 <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> 속성을 `true` 이 메서드의 실행을 사용 하도록 설정 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 구현되는 경우 시스템이 종료될 때 실행됩니다. 시스템 종료 직전에 발생할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 시스템 종료 될 때 발생 하는 처리를 지정 합니다.  
  
 이 이벤트는 운영 체제 종료 되는 컴퓨터를 끌 때가 아니라 경우에 발생 합니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> 때 재정의 해야 합니다 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> 속성은 `true`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">시작 명령에 의해 전달된 데이터입니다.</param>
        <summary>파생 클래스에서 구현되는 경우 시작 명령이 SCM(서비스 컨트롤 관리자)에 의해 서비스에 전달될 때 또는 운영 체제가 시작될 때(자동으로 시작되는 서비스의 경우) 실행됩니다. 서비스가 시작될 때 수행할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 서비스 시작 명령의 받을 때 발생 하는 처리를 지정 합니다. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 서비스의 동작을 지정 하는 방법이입니다. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 데이터를 전달 하는 방법으로 인수를 사용할 수 있지만이 사용법은 드물게 나타납니다.  
  
> [!CAUTION]
>  에 있어야 하는 처리를 수행 하는 생성자를 넣지 마십시오 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>합니다. 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 서비스의 모든 초기화를 처리 하도록 합니다. 애플리케이션의 실행 하는 경우 생성자가 호출 서비스가 실행 될 때가 아니라 실행 합니다. 실행 파일을 실행 하기 전에 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>입니다. 예를 들어 계속 SCM 메모리에 개체를 이미 보유 하기 때문에 생성자 다시 호출 되지 않습니다. 하는 경우 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 생성자에서 대신 할당 된 리소스를 해제 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, 필요한 리소스는 두 번째로 서비스를 호출할 때 만들어지지 합니다.  
  
 서비스를 설정 하 여 컴퓨터를 다시 부팅할 때 자동으로 시작 되도록 설정할 수는 <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> 서비스의 설치 관리자에서 <xref:System.ServiceProcess.ServiceStartMode.Automatic>합니다. 이러한 상황에서는 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 시스템 시작 시 호출 됩니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 파생된 클래스에서 재정의 될 예정입니다. 유용 하 게 서비스용 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 모두에서 구현 하는 서비스 클래스.  
  
 서비스에 대 한 초기화 인수를 처리 합니다 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Main 메서드에 나타나지 메서드. 인수는 `args` 매개 변수 배열 서비스 콘솔에서 서비스에 대 한 속성 창에서 수동으로 설정할 수 있습니다. 콘솔에 입력 된 인수를 저장 되지 않습니다. 제어판에서 서비스를 시작 하는 경우를 한 번만 서비스에도 전달 됩니다. 서비스의 레지스트리 키에 대 한 ImagePath 문자열 값에 서비스를 자동으로 시작할 때 제공 해야 하는 인수를 배치할 수 있습니다 (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< 서비스 이름 >*). 사용 하 여 레지스트리에서 인수를 얻을 수 있습니다는 <xref:System.Environment.GetCommandLineArgs%2A> 메서드를 예를 들어: `string[] imagePathArgs = Environment.GetCommandLineArgs();`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 구현되는 경우 중지 명령이 SCM(서비스 컨트롤 관리자)에 의해 서비스에 전달될 때 실행됩니다. 서비스 실행이 중지될 때 수행할 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 서비스 중지 명령의 받을 때 발생 하는 처리를 지정 합니다.  
  
 값을 사용 하 여 SCM 중지 명령을 받으면 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 서비스가 중지 명령을 허용 여부를 확인 합니다. 경우 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 은 `true`, Stop 명령 서비스에 전달 됩니다 및 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 정의 되어 있는 경우 호출 됩니다. 경우 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 구현 되지 않은 SCM 서비스에서 중지 명령을 처리 합니다.  
  
 하는 경우 <xref:System.ServiceProcess.ServiceBase.CanStop%2A> 는 `false`, SCM 중지 명령을 무시 합니다. 서비스에 전달 되지 않습니다. 중지 명령을 반환 하 고 예외가 throw 됩니다.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 파생된 클래스에서 재정의 될 예정입니다. 유용 하 게 서비스용 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 및 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 모두에서 구현 하는 서비스 클래스.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">요청된 시간(밀리초)입니다.</param>
        <summary>보류 중인 작업을 위한 추가 시간을 요청합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> 호출할 메서드 재정의 된 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, 또는 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 표시에서 서비스 제어 관리자 (SCM)를 방지 하기 위해 보류 중인 작업을 위한 추가 시간을 요청 하는 방법의 서비스 응답 하지 않습니다.  보류 중인 작업이 없는 경우 계속 하기, 일시 중지, 시작 또는 중지를 <xref:System.InvalidOperationException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">서비스 상태가 보류 중이 아닌 경우</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서비스 실행 파일에 주 진입점을 제공합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">시작할 서비스를 나타내는 <see cref="T:System.ServiceProcess.ServiceBase" />입니다.</param>
        <summary>SCM(서비스 컨트롤 관리자)에 서비스의 실행 파일을 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 호출 합니다 `main()` 서비스 서비스 제어 관리자를 사용 하 여 서비스를 등록 하려면 실행 파일의 함수입니다. 호출한 후 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, 서비스 제어 관리자에 대 한 호출의 결과 시작 명령 문제는 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 서비스에서 메서드. 시작 명령이 실행 될 때까지 서비스가 시작 되지 않습니다.  
  
 합니다 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> 메서드는 거의 동일한 방법으로 <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> Windows Forms 애플리케이션에 대 한 합니다.  
  
 경우 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 됩니다 `true`를 지정 하면 항목이 이벤트 로그에 기록 됩니다는 `service` 매개 변수 시작 하지 못했습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">시작할 서비스를 나타내는 ServiceBase 인스턴스의 배열입니다.</param>
        <summary>SCM(서비스 컨트롤 관리자)에 여러 서비스의 실행 파일을 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 호출 합니다 `main()` 서비스 서비스 제어 관리자를 사용 하 여 서비스를 등록 하는 실행 파일의 함수입니다. 호출한 후 <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, 서비스 제어 관리자에 대 한 호출의 결과 시작 명령 문제는 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> 서비스에서 메서드. 시작 명령이 실행 될 때까지 서비스를 시작 하지 않습니다.  
  
 합니다 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> 메서드는 거의 동일한 방법으로 <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> Windows Forms 애플리케이션에 대 한 메서드.  
  
 하는 경우 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 는 `true`, 배열에 있는 모든 서비스가 시작 되지 않을 경우 항목이 이벤트 로그에 기록 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">시작할 서비스를 제공하지 않은 경우. 배열은 <see langword="null" />이거나 비어 있을 수 있습니다.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서비스에 대한 서비스 컨트롤 핸들을 가져옵니다.</summary>
        <value>서비스에 대한 서비스 컨트롤 핸들이 포함된 <see cref="T:System.IntPtr" /> 구조체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서비스 컨트롤 핸들을 서비스 제어 관리자 (SCM) 사용 하 여 통신 하는 데 사용 됩니다.  관리 되지 않는 사용 하 여 호출 서비스에 대 한 서비스 제어 관리자의 상태 정보를 업데이트 하는 핸들을 사용할 수 있습니다 `SetServiceStatus` 함수입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드에 액세스 합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">인수 배열에 들어 있는 인수의 수입니다.</param>
        <param name="argPointer">인수 배열을 가리키는 <see cref="T:System.IntPtr" /> 구조체입니다.</param>
        <summary>명령 처리기를 등록하고 서비스를 시작합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>시스템의 서비스를 식별하는 데 사용되는 약식 이름을 가져오거나 설정합니다.</summary>
        <value>서비스 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 서비스 제어 관리자에 서비스를 식별 합니다. 이 속성의 값을 서비스에 대해 기록 된 이름과 동일 해야 합니다 <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> 해당 설치 관리자 클래스의 속성입니다. 코드에는 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 서비스의 일반적으로 설정 되어를 `main()` 실행 파일의 함수입니다.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 도 지정 하는 합니다 <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> 연관를 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 속성. 이 <xref:System.ServiceProcess.ServiceBase.EventLog%2A> 애플리케이션 로그 서비스 명령 정보를 기록 하는 인스턴스입니다.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>를 제공 하는 이벤트 로그에 대 한 소스 문자열을 설정 해야 서비스 이벤트 로그에 씁니다. 원본 이름 설정 되기 전에 이벤트 로그에 액세스 하려고 하면 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">서비스가 이미 시작된 경우. 서비스가 시작된 후에는 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 속성을 변경할 수 없습니다.</exception>
        <exception cref="T:System.ArgumentException">지정된 이름은 길이가 0인 문자열이거나 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />보다 길거나 지정된 이름에 슬래시 또는 백슬래시 문자가 포함되어 있습니다.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>실행 중인 서비스를 중지합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.ServiceProcess.ServiceBase.Stop%2A> 메서드 호출 및 서비스 상태가 중지 중임을 나타내기 위해 설정 된 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> 메서드.  애플리케이션 중지 된 후 서비스 상태가 중지로 설정 됩니다. 호스 티 드 서비스 애플리케이션을 사용 하는 경우 애플리케이션 도메인 로드 아닙니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>