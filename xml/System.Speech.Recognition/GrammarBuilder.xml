<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5180154fc823f5d48fbe9b004e9bbaeb45758265" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39988873" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>음성 인식 문법에 대 한 제약 조건을 프로그래밍 방식으로 작성 하는 메커니즘을 제공 합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 음성 인식 문법 정의 된 XML 형식에 일반적으로 작성 되는 [음성 인식 문법 Specification (SRGS) 버전 1.0](http://go.microsoft.com/fwlink/?LinkId=201761)합니다. SRGS 문법을 프로그래밍 방식으로 생성 하려는 같지만 잘 알고 있다면 사용할 수는 <xref:System.Speech.Recognition.SrgsGrammar> 네임 스페이스에는 요소와 특성 SRGS 정의한 멤버가 정확 하 게 일치 합니다. SRGS, 익숙한 되지 않거나 문법은 효율적으로 수행할 수 많은 일반적인 시나리오를 작성 하는 간단 하 고 프로그래밍 방식으로 접근 방법을 사용할 경우 사용할 수는 <xref:System.Speech.Recognition.GrammarBuilder> 고 <xref:System.Speech.Recognition.Choices> 클래스입니다.  
  
 사용 하 여 <xref:System.Speech.Recognition.GrammarBuilder> 계층적 트리를 작성 하는 개체 구성 <xref:System.Speech.Recognition.Choices> 프리앰블 및 각 노드에서 후 amble 구를 사용 하 여 섞어서 및 의미를 전달 하는 값 의미 체계를 사용 하 여 시드 대체 구가 포함 된 개체를 다시는 응용 프로그램입니다.  
  
 사용 하는 <xref:System.Speech.Recognition.GrammarBuilder> 만들려면를 <xref:System.Speech.Recognition.Grammar> 개체, 다음 단계를 사용 합니다.  
  
1.  <xref:System.Speech.Recognition.GrammarBuilder> 개체를 만듭니다.  
  
2.  제약 조건을 추가 합니다 <xref:System.Speech.Recognition.GrammarBuilder>와 같은 <xref:System.String> 개체를 <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>, 및 기타 <xref:System.Speech.Recognition.GrammarBuilder> 문법에 대 한 제약 조건을 정의 하는 개체입니다.  
  
3.  중 하나를 사용 합니다 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 만들려면 생성자를 <xref:System.Speech.Recognition.Grammar> 개체에서 완료 된 <xref:System.Speech.Recognition.GrammarBuilder> 문법입니다.  
  
 사용 하 여 작성 <xref:System.Speech.Recognition.GrammarBuilder> 는 단일 규칙이 목록 또는 목록의 목록 등을 포함 하는 문법에 가장 적합 합니다. 여러 규칙이 있는 또는 내부 규칙 참조를 확인 해야 하는 문법을 프로그래밍 방식으로 빌드의 클래스를 사용 합니다 <xref:System.Speech.Recognition.SrgsGrammar> 네임 스페이스입니다.  
  
 인스턴스의 <xref:System.Speech.Recognition.GrammarBuilder> 다른 특정 클래스에서 암시적 변환 하거나 결합 하 여 가져올 수도 있습니다는 <xref:System.Speech.Recognition.GrammarBuilder> 문법에 대 한 제약 조건을 포함 하는 두 번째 개체를 사용 하 여... 자세한 내용은 참조 하세요. 합니다 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 하 고 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자 및 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드.  
  
 기존 규칙을 추가할 <xref:System.Speech.Recognition.GrammarBuilder>를 사용 합니다 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, 및 <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> 메서드.  
  
> [!IMPORTANT]
>  음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 디버깅에 도움이 되는 <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> 속성의 현재 상태를 반환 합니다 <xref:System.Speech.Recognition.GrammarBuilder> 문자열로 합니다.  
  
 빌드 및 음성 인식 문법을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [음성 인식](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) 하 고 [GrammarBuilder 문법을 만드는](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Recognition.GrammarBuilder> 하 고 <xref:System.Speech.Recognition.Choices> 두 구 중 하나를 인식할 수 있는 문법 구성 하는 개체 "배경 *colorChoice*" 또는 "백그라운드로 *colorChoice*".  
  
 이 예제에서는 사용을 <xref:System.Speech.Recognition.Choices> 개체에 대 한 허용 가능한 값 목록을 만드는 데 *colorChoice* 배열에서 <xref:System.String> 개체입니다. A <xref:System.Speech.Recognition.Choices> 개체는 비슷합니다는 `one-of` SRGS 사양의 요소 말할 때 인식할 수 있는 대체 구 집합을 포함 하 고 합니다. 또한이 예제에서는 <xref:System.Speech.Recognition.Choices> 배열을 두 개의 그룹 개체 <xref:System.Speech.Recognition.GrammarBuilder> 결과 문법 인식할 수 있는 대체 구의 쌍 개체입니다. 대체 단어 또는 문구는 대부분의 문법의 구성 요소 및 <xref:System.Speech.Recognition.Choices> 문법을 사용 하 여 생성에 대 한 개체는이 기능을 제공 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
 이 예에서는 마지막으로 만듭니다는 <xref:System.Speech.Recognition.Grammar> 에서 개체를 <xref:System.Speech.Recognition.GrammarBuilder> 에서 생성 된를 <xref:System.Speech.Recognition.Choices> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다른 클래스에서 암시적 변환 하거나 결합 하 여이 클래스의 인스턴스를 가져올 수도 있습니다는 <xref:System.Speech.Recognition.GrammarBuilder> 개체에서 두 번째 개체를 사용 하 여 <xref:System.Speech.Recognition.GrammarBuilder>입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 메서드.  
  
 기존 제약 조건을 추가 하려면 <xref:System.Speech.Recognition.GrammarBuilder>를 사용 합니다 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, 및 <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> 메서드 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자.  
  
> [!IMPORTANT]
>  음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 빌드 및 음성 인식 문법을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [음성 인식](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) 하 고 [GrammarBuilder 문법을 만드는](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기존 규칙을 추가할 <xref:System.Speech.Recognition.GrammarBuilder> 개체를 사용 합니다 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>, <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>, 및 <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> 메서드 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자.  
  
> [!IMPORTANT]
>  음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Recognition.GrammarBuilder> 하 고 <xref:System.Speech.Recognition.Choices> 두 구 중 하나를 인식할 수 있는 문법 구성 하는 개체 "배경 *colorChoice*" 또는 "백그라운드로 *colorChoice*".  
  
 이 예제에서는 사용을 <xref:System.Speech.Recognition.Choices> 개체에 대 한 허용 가능한 값 목록을 만드는 데 *colorChoice* 배열에서 <xref:System.String> 개체입니다. A <xref:System.Speech.Recognition.Choices> 개체는 비슷합니다는 `one-of` SRGS 사양의 요소 말할 때 인식할 수 있는 대체 구 집합을 포함 하 고 합니다. 또한이 예제에서는 <xref:System.Speech.Recognition.Choices> 배열을 두 개의 그룹 개체 <xref:System.Speech.Recognition.GrammarBuilder> 결과 문법 인식할 수 있는 대체 구의 쌍 개체입니다. 대체 단어 또는 문구는 대부분의 문법의 구성 요소 및 <xref:System.Speech.Recognition.Choices> 문법을 사용 하 여 생성에 대 한 개체는이 기능을 제공 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
 이 예에서는 마지막으로 만듭니다는 <xref:System.Speech.Recognition.Grammar> 에서 개체를 <xref:System.Speech.Recognition.GrammarBuilder> 에서 생성 된를 <xref:System.Speech.Recognition.Choices> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">대체 집합입니다.</param>
        <summary>대체 집합에서 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대체 단어를 포함 하는 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하세요. [GrammarBuilder 문법을 만드는를 사용 하 여 선택](http://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Recognition.GrammarBuilder> 하 고 <xref:System.Speech.Recognition.Choices> 두 구 중 하나를 인식할 수 있는 문법 구성 하는 개체 "배경 *colorChoice*" 또는 "백그라운드로 *colorChoice*".  
  
 이 예제에서는 사용을 <xref:System.Speech.Recognition.Choices> 개체에 대 한 허용 가능한 값 목록을 만드는 데 *colorChoice* 배열에서 <xref:System.String> 개체입니다. A <xref:System.Speech.Recognition.Choices> 개체는 비슷합니다는 `one-of` SRGS 사양의 요소 말할 때 인식할 수 있는 대체 구 집합을 포함 하 고 합니다. 또한이 예제에서는 <xref:System.Speech.Recognition.Choices> 배열을 두 개의 그룹 개체 <xref:System.Speech.Recognition.GrammarBuilder> 결과 문법 인식할 수 있는 대체 구의 쌍 개체입니다. 대체 단어 또는 문구는 대부분의 문법의 구성 요소 및 <xref:System.Speech.Recognition.Choices> 문법을 사용 하 여 생성에 대 한 개체는이 기능을 제공 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
 이 예에서는 마지막으로 만듭니다는 <xref:System.Speech.Recognition.Grammar> 에서 개체를 <xref:System.Speech.Recognition.GrammarBuilder> 에서 생성 된를 <xref:System.Speech.Recognition.Choices> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">의미 키입니다.</param>
        <summary>의미 키에서 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들 때를 <xref:System.Speech.Recognition.GrammarBuilder> 에서 인스턴스를 <xref:System.Speech.Recognition.SemanticResultValue> 개체 인식 결과에서 반환 될 수 있는 문법에 의미 체계 정보를 추가 합니다. 사용 하 여 인식 결과의 의미 체계 정보에 액세스할 수 있습니다는 <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> 속성을 <xref:System.Speech.Recognition.RecognizedPhrase>에 대 한 처리기에서 사용할 수 있는 `SpeechRecognized` 이벤트입니다. 경우는 <xref:System.Speech.Recognition.GrammarBuilder> 정의 <xref:System.Speech.Recognition.SemanticResultKey>,이 키와 연결 된 인식 결과의 의미 체계 정보를 검색 하려면 사용할 수 있습니다. 예를 참조 하세요 <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>에 표시 됩니다 <xref:System.Speech.Recognition.SemanticResultValue> 및 <xref:System.Speech.Recognition.SemanticResultKey>합니다.  
  
> [!IMPORTANT]
>  생성 하는 경우 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *colorChoice*" 및 "백그라운드로 *colorChoice*" 여기서 * colorChoice* 색 집합에서 선택 됩니다. 문법 여러 색 이름 중 하나를 사용 하 게 하 고 응용 프로그램에 인식할 수 있는 색 이름에 대 한 의미 체계 정보를 반환 합니다.  
  
 예제에서는 단일 <xref:System.Speech.Recognition.SemanticResultKey> 사용 하 여 검색할 수 있습니다는 <xref:System.Speech.Recognition.SemanticValue> 연결 된 사용자가 음성으로 변환 하는 색을 사용 하 여 합니다. 예를 들어, 입력에 구의 경우 "집합 배경이 빨강으로"를 의미 체계 "#ff0000"에 대 한 처리기를 사용 하 여 검색할 수 있는 값을 포함 하는 인식 결과 `SpeechRecognized` 이벤트입니다.  
  
 이 예제에서는 사용 <xref:System.String>, <xref:System.Speech.Recognition.Choices>를 <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 마지막에 포함 된 모든 제약 조건을 작성 하는 개체 <xref:System.Speech.Recognition.GrammarBuilder> 개체 `bothPhrases`합니다. 마지막으로 생성 합니다는 <xref:System.Speech.Recognition.Grammar> 개체에서 완료 된 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">의미 값이거나 이름/값 쌍입니다.</param>
        <summary>의미 값에서 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들 때를 <xref:System.Speech.Recognition.GrammarBuilder> 에서 인스턴스를 <xref:System.Speech.Recognition.SemanticResultValue> 개체 인식 결과에서 반환 될 수 있는 문법에 의미 체계 정보를 추가 합니다. 사용 하 여 인식 결과의 의미 체계 정보에 액세스할 수 있습니다는 <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> 속성을 <xref:System.Speech.Recognition.RecognizedPhrase>에 대 한 처리기에서 사용할 수 있는 `SpeechRecognized` 이벤트입니다. 경우는 <xref:System.Speech.Recognition.GrammarBuilder> 정의 <xref:System.Speech.Recognition.SemanticResultKey>,이 키와 연결 된 인식 결과의 의미 체계 정보를 검색 하려면 사용할 수 있습니다. 예를 참조 하세요 <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>에 표시 됩니다 <xref:System.Speech.Recognition.SemanticResultValue> 및 <xref:System.Speech.Recognition.SemanticResultKey>합니다.  
  
> [!IMPORTANT]
>  생성 하는 경우 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *colorChoice*" 및 "백그라운드로 *colorChoice*" 여기서 * colorChoice* 색 집합에서 선택 됩니다. 문법 여러 색 이름 중 하나를 사용 하 게 하 고 응용 프로그램에 인식할 수 있는 색 이름에 대 한 의미 체계 정보를 반환 합니다.  
  
 예제에서는 단일 <xref:System.Speech.Recognition.SemanticResultKey> 사용 하 여 검색할 수 있습니다는 <xref:System.Speech.Recognition.SemanticValue> 연결 된 사용자가 음성으로 변환 하는 색을 사용 하 여 합니다. 예를 들어, 입력에 구의 경우 "집합 배경이 빨강으로"를 의미 체계 "#ff0000"에 대 한 처리기를 사용 하 여 검색할 수 있는 값을 포함 하는 인식 결과 `SpeechRecognized` 이벤트입니다.  
  
 이 예제에서는 사용 <xref:System.String>, <xref:System.Speech.Recognition.Choices>를 <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 마지막에 포함 된 모든 제약 조건을 작성 하는 개체 <xref:System.Speech.Recognition.GrammarBuilder> 개체 `bothPhrases`합니다. 마지막으로 생성 합니다는 <xref:System.Speech.Recognition.Grammar> 개체에서 완료 된 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">단어의 시퀀스입니다.</param>
        <summary>단어 시퀀스에서 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구는 스피치 인식 그래 머 인식할 수 있는 정확한 음성된 구를 나타냅니다. 문자열이 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하세요. [GrammarBuilder 문법을 만드는를 사용 하 여 문자열](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Recognition.GrammarBuilder> 하 고 <xref:System.Speech.Recognition.Choices> 두 구 중 하나를 인식할 수 있는 문법 구성 하는 개체 "배경 *colorChoice*" 또는 "백그라운드로 *colorChoice*".  
  
 에 대 한 허용 되는 값의 목록을 만든 후 *colorChoice* 사용 하 여를 <xref:System.Speech.Recognition.Choices> 개체를 두 예제에서는 초기화 <xref:System.Speech.Recognition.GrammarBuilder> 개체를 `makePhrase` 및 `setPhrase`, 인수로 문자열을 사용 하 합니다.  
  
 이 예에서는 마지막으로 만듭니다는 <xref:System.Speech.Recognition.Grammar> 에서 개체를 <xref:System.Speech.Recognition.Choices> 개체를 캐스팅할를 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">단어의 시퀀스입니다.</param>
        <param name="subsetMatchingCriteria">일치하는 모드는 언어 인식 문법을 사용하여 구를 인식합니다.</param>
        <summary>단어 시퀀스의 하위 집합에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` 스피치 인식 그래 머 인식할 수 있는 구 매개 변수를 나타냅니다. `subsetMatchingMode` 매개 변수는 전체 구가의 성공적인 인식을 위해 읽을 수 있는 구문의 하위 집합을 지정 합니다. 사용자가 항목과 일치 하는 전체 이름을 사용 하지 않고도 긴 이름이 있는 항목의 목록이 포함 된 문법을 만드는 하는 데 사용할 수 있습니다.  
  
 일치 하는 모드에 대 한 자세한 내용은 참조 하세요. <xref:System.Speech.Recognition.SubsetMatchingMode>합니다. 문자열이 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하세요. [GrammarBuilder 문법을 만드는를 사용 하 여 문자열](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)합니다.  
  
   
  
## Examples  
 다음 예제에서는 각각에 대 한 음성 인식 문법을 만드는 <xref:System.Speech.Recognition.SubsetMatchingMode> 값과 일치 하는 모드 문법 중에서 선택 하는 것에 대 한 문법입니다. 경우 값 `phrase` 는 "하나 두 3 4 5 6 7", 시퀀스 문법 인식 입력 한 다음 "두 세 4", 하지만 입력 하지 "하나 세 5". 그러나 일부 순서가 지정 된 문법 모두 이러한 입력을 인식합니다.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">반복된 요소입니다.</param>
        <param name="minRepeat">입력이 <c>builder</c>가 정의한 요소와 일치하여 일치 항목을 구성해야 하는 최소 횟수입니다.</param>
        <param name="maxRepeat">입력이 <c>builder</c>가 정의한 요소와 일치하여 일치 항목을 구성할 수 있는 최소 횟수입니다.</param>
        <summary>반복된 요소에서 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 값 `minRepeat` 가 0 이면 새 <xref:System.Speech.Recognition.GrammarBuilder> 선택적 요소를 나타냅니다.  
  
 값 `minRepeat` 0 보다 크거나 해야 값 보다 작거나 같으면 `maxRepeat`합니다.  
  
> [!IMPORTANT]
>  에 대 한 반복을 지정 하는 경우 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스에서 동일한 키 이름 또는 합니다 를반복적으로수정할수있는여러의미체계요소를사용하여의미체계는중복요소를만들지않으려면있는지확인<xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 피자를 주문에 대 한 음성 인식 문법을 만듭니다. 선택 사항, opening 구 뒤에 1 ~ 4 개의 토 핑을 시작 하 고 "피자" 라는 단어를 사용 하 여 닫습니다.  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">반복된 단어의 시퀀스입니다.</param>
        <param name="minRepeat">입력이 구에 일치하여 일치 항목을 구성해야 하는 최소 횟수입니다.</param>
        <param name="maxRepeat">입력이 구에 일치하여 일치 항목을 구성할 수 있는 최대 횟수입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />의 단어의 시퀀스에서의 <see cref="T:System.String" /> 클래스의 새 인스턴스를 초기화하며 <see cref="T:System.String" />이 얼마나 반복될 수 있는지를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 값 `minRepeat` 가 0 이면 새 <xref:System.Speech.Recognition.GrammarBuilder> 선택적 요소를 나타냅니다.  
  
 값 `minRepeat` 0 보다 크거나 해야 값 보다 작거나 같으면 `maxRepeat`합니다. 문자열이 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하세요. [GrammarBuilder 문법을 만드는를 사용 하 여 문자열](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)합니다.  
  
   
  
## Examples  
 다음 예제에서는 피자를 주문에 대 한 음성 인식 문법을 만듭니다. 선택 사항, opening 구 뒤에 1 ~ 4 개의 토 핑을 시작 하 고 "피자" 라는 단어를 사용 하 여 닫습니다.  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 문법 요소의 시퀀스를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드는 다양성을 만드는 다양 한 형식을 결합할 수 있습니다 하 고 유연 하 게 문법 사용 하 여 빌드한 다른 메커니즘을 제공 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 이러한 메서드는 정적 해당 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 에서도 정의 되는 메서드는 <xref:System.Speech.Recognition.GrammarBuilder> 클래스입니다. 새 요소의 순서를 결정 하는 매개 변수의 순서 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
 A <xref:System.Speech.Recognition.GrammarBuilder> 에서 가져올 수도 있습니다 <xref:System.Speech.Recognition.Choices>를 <xref:System.Speech.Recognition.SemanticResultKey>를 <xref:System.Speech.Recognition.SemanticResultValue>, 및 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733) 개체입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 빌드 및 음성 인식 문법을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [음성 인식](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) 하 고 [GrammarBuilder 문법을 만드는](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">대체 항목 집합을 나타내는 첫 번째 문법 요소입니다.</param>
        <param name="builder">두 번째 문법 요소입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.Choices" /> 개체와 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체를 차례로 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="choices" /> 요소와 <paramref name="builder" /> 요소 시퀀스에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 암시적 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다.  
  
 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.Choices> 하 고 <xref:System.Speech.Recognition.GrammarBuilder> 포함 하는 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스에서 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [GrammarBuilder 문법을 추가 의미 체계](https://msdn.microsoft.com/library/hh361581.aspx)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">문법 요소입니다.</param>
        <param name="choices">두 번째 문법 요소로, 대체 요소의 집합을 나타냅니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체와 <see cref="T:System.Speech.Recognition.Choices" /> 개체를 차례로 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder" /> 요소와 <paramref name="choices" /> 요소 시퀀스에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 암시적 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다.  
  
 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.Choices> 하 고 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 다른 문법 요소를 사용 하 여 인스턴스는 동일한 키 이름 또는 의미 체계는 여러 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 반복적으로 수정할 수는 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다. 에 대 한 호출에서 명시적 캐스트 연산자는 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드는 선택 사항입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">문법 요소입니다.</param>
        <param name="builder2">두 번째 문법 요소입니다.</param>
        <summary>두 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체의 시퀀스를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder1" /> 요소와 <paramref name="builder2" /> 요소 시퀀스에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 암시적 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder1` 또는 `builder2` 매개 변수입니다.  
  
 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.Choices> 하 고 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 다른 문법 요소를 사용 하 여 인스턴스는 동일한 키 이름 또는 의미 체계는 여러 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 반복적으로 수정할 수는 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다. 에 대 한 호출에서 명시적 캐스트 연산자는 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드는 선택 사항입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">문법 요소입니다.</param>
        <param name="phrase">두 번째 문법 요소로, 단어의 시퀀스를 나타냅니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체와 그 뒤에 구를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder" /> 요소와 <paramref name="phrase" /> 요소 시퀀스에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 암시적 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다.  
  
 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다. 에 대 한 호출에서 명시적 캐스트 연산자는 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드는 선택 사항입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">첫 번째 문법 요소로, 단어의 시퀀스를 나타냅니다.</param>
        <param name="builder">두 번째 문법 요소입니다.</param>
        <summary>구와 그 뒤에 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="phrase" /> 요소와 <paramref name="builder" /> 요소 시퀀스에 대한 <see cref="T:System.Speech.Recognition.GrammarBuilder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 암시적 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다.  
  
 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 및 <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> 연산자입니다.  
  
   
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다. 에 대 한 호출에서 명시적 캐스트 연산자는 <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> 메서드는 선택 사항입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>문법 요소를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 메서드를 사용 하 여 기존 문법 요소를 추가할 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 문법 요소를 만들 때에 점진적으로 스피치 인식 그래 머의 제약 조건을 개발 하 여 기존 작성기에 추가할 수 있습니다. 각 요소는 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
 이 메서드에 추가 하는 것에 대 한 오버 로드가 <xref:System.Speech.Recognition.GrammarBuilder>, <xref:System.String>를 <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, 및 <xref:System.Speech.Recognition.SemanticResultValue> 개체입니다.  
  
> [!IMPORTANT]
>  음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 빌드 및 음성 인식 문법을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [음성 인식](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) 하 고 [GrammarBuilder 문법을 만드는](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">추가할 대체 집합입니다.</param>
        <summary>대체 항목의 집합을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices` 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
> [!IMPORTANT]
>  추가 하는 경우 <xref:System.Speech.Recognition.Choices> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 <xref:System.Speech.Recognition.GrammarBuilder> 개체 키 이름이 동일한 또는 반복적으로 할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다. 수정 된 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 "phone" 라는 단어는 선택 사항 구 "직장 호출 James" 및 "휴대폰에서 호출 Anne"와 같은 음성 인식 문법을 만듭니다. 이 예제에서는 사용을 강조 표시 된 <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> 메서드.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">추가할 문법 요소입니다.</param>
        <summary>문법 요소를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder` 문법 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
> [!NOTE]
>  추가 하는 경우 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 <xref:System.Speech.Recognition.GrammarBuilder> 개체 키 이름이 동일한 또는 반복적으로 할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다. 수정 된 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 "phone" 라는 단어는 선택 사항 구 "직장 호출 James" 및 "휴대폰에서 호출 Anne"와 같은 음성 인식 문법을 만듭니다. <xref:System.Speech.Recognition.GrammarBuilder> 및 <xref:System.Speech.Recognition.Choices> 개체 문법을 생성 하는 데 사용 됩니다. 이 예제에서는 사용을 강조 표시 된 <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> 메서드.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">추가할 의미 키입니다.</param>
        <summary>의미 키를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key` 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
> [!IMPORTANT]
>  추가 하는 경우 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 <xref:System.Speech.Recognition.GrammarBuilder> 개체, 키 이름이 동일한 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 반드시를 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제는 항공편에 대 한 원본 및 대상 도시를 선택 하는 것에 대 한 콘솔 응용 프로그램의 일부입니다. 응용 프로그램 "시카고에 마이애미에서 fly 하려고 합니다."와 같은 구를 인식합니다 에 대 한 처리기를 <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> 이벤트를 사용 하는 <xref:System.Speech.Recognition.SemanticResultKey> 에 지정 된 공항 코드를 추출 하는 <xref:System.Speech.Recognition.SemanticResultValue> 원본 및 대상 도시에 대 한 합니다.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">추가할 의미 값입니다.</param>
        <summary>의미 값을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
> [!IMPORTANT]
>  추가 하는 경우 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 <xref:System.Speech.Recognition.GrammarBuilder> 개체, 키 이름이 동일한 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 반드시를 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제는 항공편에 대 한 원본 및 대상 도시를 선택 하는 것에 대 한 콘솔 응용 프로그램의 일부입니다. 응용 프로그램 "시카고에 마이애미에서 fly 하려고 합니다."와 같은 구를 인식합니다 에 대 한 처리기를 <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> 이벤트를 사용 하는 <xref:System.Speech.Recognition.SemanticResultKey> 에 지정 된 공항 코드를 추출 하는 <xref:System.Speech.Recognition.SemanticResultValue> 원본 및 대상 도시에 대 한 합니다.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">추가할 단어의 시퀀스입니다.</param>
        <summary>구를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase` 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">추가할 단어의 시퀀스입니다.</param>
        <param name="subsetMatchingCriteria">일치하는 모드는 문법을 사용하여 구를 인식합니다.</param>
        <summary>구의 하위 집합에 대한 요소를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하위 요소는 요소의 현재 시퀀스의 끝에 추가 됩니다. 문자열을 사용 하 여 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하세요. [GrammarBuilder 문법을 만드는를 사용 하 여 문자열](http://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114)합니다.  
  
 하위 집합 일치 모드가 사용에 대 한 자세한 정보를 참조 하세요. <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 각각에 대 한 음성 인식 문법을 만드는 <xref:System.Speech.Recognition.SubsetMatchingMode> 값입니다. 예를 들어, 생성 된 문법 `OrderedSubset` 는 구 인식 "세 4 5" 및 "하나 세 5"과 문법을 `Subsequence` 구 인식 "3 4 5", 하지만 구의 하지 "하나 세 5".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">추가할 반복된 문법 요소입니다.</param>
        <param name="minRepeat">입력이 <c>builder</c>가 정의한 요소와 일치하여 일치 항목을 구성해야 하는 최소 횟수입니다.</param>
        <param name="maxRepeat">입력이 <c>builder</c>가 정의한 요소와 일치하여 일치 항목을 구성할 수 있는 최소 횟수입니다.</param>
        <summary>반복된 문법 요소를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 `minRepeat` 0 보다 크거나 해야 값 보다 작거나 같으면 `maxRepeat`합니다.  
  
> [!IMPORTANT]
>  추가 하는 경우 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 <xref:System.Speech.Recognition.GrammarBuilder> 개체 키 이름이 동일한 또는 반복적으로 할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다. 수정 된 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
   
  
## Examples  
 다음 예제에서는 "phone" 라는 단어는 선택 사항 구 "직장 호출 James" 및 "휴대폰에서 호출 Anne"와 같은 음성 인식 문법을 만듭니다. <xref:System.Speech.Recognition.GrammarBuilder> 및 <xref:System.Speech.Recognition.Choices> 개체 문법을 생성 하는 데 사용 됩니다. 이 예제에서는 사용을 강조 표시 된 <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> 메서드.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">추가할 반복된 단어의 시퀀스입니다.</param>
        <param name="minRepeat">입력이 <c>구</c>에 일치하여 일치 항목을 구성해야 하는 최소 횟수입니다.</param>
        <param name="maxRepeat">입력이 <c>구</c>에 일치하여 일치 항목을 구성할 수 있는 최소 횟수입니다.</param>
        <summary>반복된 구를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 `minRepeat` 0 보다 크거나 해야 값 보다 작거나 같으면 `maxRepeat`합니다.  
  
   
  
## Examples  
 다음 예제에서는 "phone" 라는 단어는 선택 사항 구 "직장 호출 James" 및 "휴대폰에서 호출 Anne"와 같은 음성 인식 문법을 만듭니다. <xref:System.Speech.Recognition.GrammarBuilder> 및 <xref:System.Speech.Recognition.Choices> 개체 문법을 생성 하는 데 사용 됩니다. 이 예제에서는 사용을 강조 표시 된 <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> 메서드.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>받아쓰기 문법을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> 메서드를 사용 하는 규칙으로 받아쓰기 문법에 추가할 수는 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
 받아쓰기 문법에 대 한 자세한 내용은 참조 하세요. <xref:System.Speech.Recognition.DictationGrammar>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 받아쓰기 문법을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 받아쓰기 문법에 대 한 자세한 내용은 참조 하세요. <xref:System.Speech.Recognition.DictationGrammar>합니다.  
  
   
  
## Examples  
 다음 예제에서는 받아쓰기를 통합 하는 스피치 인식 그래 머를 만듭니다.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">추가할 받아쓰기 문법의 범주입니다.</param>
        <summary>지정된 받아쓰기 문법을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 맞춤법 받아쓰기 문법을 사용 하려면 `category` 에 `spelling`입니다.  
  
 받아쓰기 문법에 대 한 자세한 내용은 참조 하세요. <xref:System.Speech.Recognition.DictationGrammar>합니다.  
  
   
  
## Examples  
 다음 예제에서는 맞춤법 받아쓰기 문법 규칙을 통합 하는 스피치 인식 그래 머를 만듭니다.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>문법 파일 또는 문법 규칙을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> 메서드 문법 파일 또는 파일에서 문법 규칙을 추가할 수 있습니다. 이러한 메서드를 사용 하도록 응용 프로그램을 미리 배포 된 또는 공개적으로 사용할 수 있는 문법 규칙을 사용 합니다. 응용 프로그램 읽기 권한이 있어야 합니다 지정된 문법 파일의 위치입니다.  
  
 이러한 메서드는 다음 형식에서 음성 인식 문법을 읽을 수 있습니다.  
  
-   W3C에 따르는 XML 형식 파일 [음성 인식 문법 Specification (SRGS) 버전 1.0](http://go.microsoft.com/fwlink/?LinkId=201761)  
  
-   Microsoft 음성 인식 문법 이진 형식 (파일 확장명이.cfg)를 준수 하는 이진 파일  
  
 컴파일하는 XML 형식의 SRGS 문법 파일 확장명이.cfg 인 이진 문법 파일을 줄일 수 있습니다는 일치 항목을 검색 하 여 사용 하는 시간 문법 수가 단어와 구 인식 해야 하는 경우에 특히. SRGS 문법을 CFG 이진 형식으로 컴파일하는 방법에 대 한 내용은 <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">지원되는 형식으로 음성 인식 문법을 설명하는 파일 경로나 유니버설 리소스 식별자(URI)</param>
        <summary>문법 정의 파일을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 하는 URI를 `path` 인수는 로컬 또는 원격 일 수 있습니다. 응용 프로그램 읽기 권한이 있어야 합니다 지정된 문법 파일의 위치입니다.  
  
 W3C 음성 인식 문법 Specification (SRGS) 표현에는 루트 규칙을 정의할 수 있습니다. 이 메서드는 문법을 문법 요소의 현재 시퀀스에 해당 루트 규칙을 사용 하 여 시작을 추가 합니다. 특정 문법 규칙에 추가 하려면 사용 된 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> 메서드.  
  
   
  
## Examples  
 다음 C# 예제에서는 라는 규칙을 사용 하는 음성 인식 문법을 `Cities` 로컬 SRGS 파일인 cities.grxml 합니다. Cities.grxml 파일의 내용을 C# 코드 예제에서는 아래에 나타납니다.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">지원되는 형식으로 음성 인식 문법을 설명하는 파일의 경로나 파일의 유니버설 리소스 식별자(URI)</param>
        <param name="rule">추가하는 규칙의 식별자 또는 문법 파일의 기본 루트 규칙을 추가하는 <see langword="null" /></param>
        <summary>문법 정의 파일의 지정된 규칙을 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 하는 URI를 `path` 인수는 로컬 또는 원격 일 수 있습니다. 응용 프로그램 읽기 권한이 있어야 합니다 지정된 문법 파일의 위치입니다.  
  
 사용 하 여 사용할 수는 <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> 해당 루트 규칙을 사용 하 여 시작 하는 문법 파일을 추가 하는 방법입니다.  
  
   
  
## Examples  
 다음 C# 예제에서는 라는 규칙을 사용 하는 음성 인식 문법을 `Cities` 로컬 SRGS 파일인 cities.grxml 합니다. Cities.grxml 파일의 내용을 C# 코드 예제에서는 아래에 나타납니다.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>입력과 일치하는 인식 문법 요소를 문법 요소의 현재 시퀀스에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와일드 카드 요소의 요소의 현재 시퀀스의 끝에 추가 됩니다.  
  
 와일드 카드 요소의 음성된 단어를 찾습니다. 배경 소음과 또는 대기에는 일치 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 와일드 카드로 암호 입력을 허용 하는 문법에 대해서를 만듭니다. 이 예제에서는 연결을 <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> 암호 입력의 유효성을 검사 하는 문법에 대 한 이벤트 처리기입니다.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>음성 인식 문법의 문화권을 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />의 문화권입니다. 기본값은 실행 중인 스레드의 <see cref="P:System.Threading.Thread.CurrentUICulture" /> 속성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Speech.Recognition.Grammar.%23ctor%2A> 생성자를 만듭니다는 <xref:System.Speech.Recognition.Grammar> 해당 문화권의 음성 인식기에서 사용할 수 있는 개체입니다. 만 <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> 의 속성을 <xref:System.Speech.Recognition.GrammarBuilder> 가 제공 하는 대로 문법 생성자의 매개 변수는 결과 음성 인식 문법의 문화권을 설정 하는 데 사용 됩니다.  
  
 Microsoft Windows와 System.Speech API는 모든 유효한 언어-국가 코드를 받습니다. 지정 된 언어를 사용 하 여 음성 인식을 수행 하는 `Culture` 속성, 음성 인식 엔진을 지 원하는 언어-국가 코드를 설치 해야 합니다. Microsoft Windows 7과 함께 제공 되는 음성 인식 엔진은 다음 언어-국가 코드를 사용 하 여 작동 합니다.  
  
-   en-5GB입니다. English (United Kingdom)  
  
-   EN-US입니다. 영어 (미국)  
  
-   de-DE. 독일어 (독일)  
  
-   원본: ES-ES 합니다. 스페인어 (스페인)  
  
-   fr-FR. 프랑스어 (프랑스)  
  
-   JA-JP 합니다. 일본어 (일본)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En", "fr"와 같은 두 문자 언어 코드 또는 "es" 허용도 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 최대 4 개의 토 핑을 사용 하 여 피자를 주문에 대 한 음성 인식 문법을 만듭니다. 구체적으로 설정 된 <xref:System.Speech.Recognition.GrammarBuilder> 개체의 문화권을 영어 (미국)입니다.  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />가 포함하는 문법의 콘텐츠와 구조를 보여주는 문자열을 가져옵니다.</summary>
        <value>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />의 현재 콘텐츠 및 구조체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 최대 4 개의 토 핑을 사용 하 여 피자를 주문에 대 한 음성 인식 문법을 만듭니다. 상태를 기록 합니다 <xref:System.Speech.Recognition.GrammarBuilder> 문법을 만들기 전에 콘솔. 이 메서드는 다음 출력을 생성합니다.  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>두 문법 요소의 시퀀스에 해당하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 요소의 순서를 결정 하는 피연산자의 순서 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
> [!IMPORTANT]
>  결합 하는 경우 주의 것이 좋습니다 <xref:System.Speech.Recognition.Choices> 나 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 다른 문법 요소를 사용 하 여 인스턴스. 음성 인식기 키 이름이 같은 중복 된 의미 체계 요소 또는 동일한 의미 체계 요소의 값을 반복적으로 수정할 수 있는 여러 의미 체계 요소가 포함 된 음성 인식 문법을 사용 하는 경우 예외가 throw 할 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [를 사용 하 여 SemanticResultKey 및 SemanticResultValue 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 빌드 및 음성 인식 문법을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [음성 인식](http://msdn.microsoft.com/library/6a7dc524-07fc-4862-8d48-8c10dc64b919) 하 고 [GrammarBuilder 문법을 만드는](http://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">대체 항목 집합을 나타내는 첫 번째 문법 요소입니다.</param>
        <param name="builder">두 번째 문법 요소입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.Choices" /> 개체와 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체를 차례로 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="choices" /> 매개 변수 다음에 나오는 <paramref name="builder" /> 매개 변수의 시퀀스에 대해 <see cref="T:System.Speech.Recognition.GrammarBuilder" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 변환을 지원 합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.Choices> 하 고 <xref:System.Speech.Recognition.GrammarBuilder> 포함 하는 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스에서 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">문법 요소입니다.</param>
        <param name="choices">두 번째 문법 요소로, 대체 요소의 집합을 나타냅니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />와 그 뒤에 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 포함하는 새 <see cref="T:System.Speech.Recognition.Choices" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder" /> 매개 변수 다음에 나오는 <paramref name="choices" /> 매개 변수의 시퀀스에 대해 <see cref="T:System.Speech.Recognition.GrammarBuilder" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 변환을 지원합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.Choices> 하 고 <xref:System.Speech.Recognition.GrammarBuilder> 포함 하는 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스에서 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 의 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">문법 요소입니다.</param>
        <param name="builder2">두 번째 문법 요소입니다.</param>
        <summary>두 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체의 시퀀스를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder1" /> 매개 변수 다음에 나오는 <paramref name="builder2" /> 매개 변수의 시퀀스에 대해 <see cref="T:System.Speech.Recognition.GrammarBuilder" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 변환을 지원 합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder1` 및 `builder2` 매개 변수입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 연산자입니다.  
  
> [!IMPORTANT]
>  결합 하면 <xref:System.Speech.Recognition.GrammarBuilder> 포함 된 개체 <xref:System.Speech.Recognition.SemanticResultValue> 또는 <xref:System.Speech.Recognition.SemanticResultKey> 인스턴스를 동일한 키 이름 또는 반복적으로 수정할 수 있는 여러 의미 체계 요소를 사용 하 여 의미 체계는 중복 요소를 만들지 않으려면 있는지 확인 합니다 <xref:System.Speech.Recognition.SemanticValue.Value%2A> 속성을 <xref:System.Speech.Recognition.SemanticValue> 개체입니다. 이러한 상황을 발생 하는 경우 음성 인식기에서 예외를 throw 수 있습니다. 의미 체계 정보가 포함 된 음성 인식 문법을 빌드하는 방법에 대 한 자세한 내용은 참조 하십시오 [이해 SemanticResultValue 및 SemanticResultKey 개체](http://msdn.microsoft.com/library/0fea1236-5261-4608-89b3-9ce9ffc22a1c)합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">문법 요소입니다.</param>
        <param name="phrase">두 번째 문법 요소로, 단어의 시퀀스를 나타냅니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.GrammarBuilder" />와 그 뒤에 구를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="builder" /> 매개 변수 다음에 나오는 <paramref name="phrase" /> 매개 변수의 시퀀스에 대해 <see cref="T:System.Speech.Recognition.GrammarBuilder" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 변환을 지원 합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 연산자입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">첫 번째 문법 요소로, 단어의 시퀀스를 나타냅니다.</param>
        <param name="builder">두 번째 문법 요소입니다.</param>
        <summary>구와 그 뒤에 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 포함하는 새 <see cref="T:System.Speech.Recognition.GrammarBuilder" />를 만듭니다.</summary>
        <returns>
          <paramref name="phrase" /> 매개 변수 다음에 나오는 <paramref name="builder" /> 매개 변수의 시퀀스에 대해 <see cref="T:System.Speech.Recognition.GrammarBuilder" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder> 다음 클래스에서 변환을 지원 합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 이 메서드는 개체에 대해 위에 나열 된 `builder` 매개 변수입니다. 자세한 내용은 참조는 <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> 연산자입니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 두 구 인식할 수 있는 음성 인식 문법을 "배경 *color*" 및 "백그라운드로 *색*" 여기서 *색* 색 집합에서 선택 됩니다. 다양 한 형식 최종 문법을 같은 빌드에 사용 되 [문자열](http://go.microsoft.com/fwlink/?LinkId=159733)를 <xref:System.Speech.Recognition.Choices>, 및 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>다른 형식을 <see cref="T:System.Speech.Recognition.GrammarBuilder" />로 변환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 변환의 새 인스턴스를 만듭니다 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 다음 클래스의 각 캐스팅할 수 있습니다는 <xref:System.Speech.Recognition.GrammarBuilder>합니다.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 각 암시적 변환 생성자를 호출 하는 것과 같습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">변환할 대체 집합입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.Choices" /> 개체를 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체로 변환합니다.</summary>
        <returns>변환된 <see cref="T:System.Speech.Recognition.Choices" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 변환의 새 인스턴스를 만듭니다 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 이 변환 연산자는 호출할 때와 동일한 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> 를 지정 하 고 `choices` 에 대 한는 `alternateChoices`합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 "yes" 또는 "no" 질문에 대 한 응답을 인식할 수 있는 음성 인식 문법을 만듭니다. 암시적 변환 연산자 생성에서 되는 <xref:System.Speech.Recognition.SemanticResultValue> 에서 개체를 <xref:System.Speech.Recognition.Choices> 개체를 생성 하는 <xref:System.Speech.Recognition.Choices> 에서 두 개체 <xref:System.Speech.Recognition.SemanticResultValue> 개체 및 생성에서를 <xref:System.Speech.Recognition.Grammar> 개체를 <xref:System.Speech.Recognition.SemanticResultKey> 개체입니다.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">변환할 의미 키입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.SemanticResultKey" /> 개체를 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체로 변환합니다.</summary>
        <returns>변환된 <see cref="T:System.Speech.Recognition.SemanticResultKey" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 변환의 새 인스턴스를 만듭니다 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 이 변환 연산자는 호출할 때와 동일한 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> 를 지정 하 고 `semanticKey` 에 대 한는 `key`합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 "yes" 또는 "no" 질문에 대 한 응답을 인식할 수 있는 음성 인식 문법을 만듭니다. 암시적 변환 연산자 생성에서 되는 <xref:System.Speech.Recognition.SemanticResultValue> 에서 개체를 <xref:System.Speech.Recognition.Choices> 개체를 생성 하는 <xref:System.Speech.Recognition.Choices> 에서 두 개체 <xref:System.Speech.Recognition.SemanticResultValue> 개체 및 생성에서를 <xref:System.Speech.Recognition.Grammar> 개체를 <xref:System.Speech.Recognition.SemanticResultKey> 개체입니다.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">변환할 <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 개체입니다.</param>
        <summary>
          <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 개체를 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체로 변환합니다.</summary>
        <returns>변환된 <see cref="T:System.Speech.Recognition.SemanticResultValue" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 변환의 새 인스턴스를 만듭니다 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 이 변환 연산자는 호출할 때와 동일한 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> 를 지정 하 고 `semanticValue` 에 대 한는 `value`합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 "yes" 또는 "no" 질문에 대 한 응답을 인식할 수 있는 음성 인식 문법을 만듭니다. 암시적 변환 연산자 생성에서 되는 <xref:System.Speech.Recognition.SemanticResultValue> 에서 개체를 <xref:System.Speech.Recognition.Choices>개체를 생성 하는 <xref:System.Speech.Recognition.Choices> 에서 두 개체 <xref:System.Speech.Recognition.SemanticResultValue> 개체 및 생성에서를 <xref:System.Speech.Recognition.Grammar> 개체를 <xref:System.Speech.Recognition.SemanticResultKey> 개체입니다.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">변환할 문자열입니다.</param>
        <summary>문자열을 <see cref="T:System.Speech.Recognition.GrammarBuilder" /> 개체로 변환합니다.</summary>
        <returns>변환된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 암시적 변환의 새 인스턴스를 만듭니다 <xref:System.Speech.Recognition.GrammarBuilder>합니다. 이 변환 연산자는 호출할 때와 동일한 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> 동일 지정 `phrase`합니다.  
  
 이 연산자에 대 한 해당 메서드는 <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Recognition.GrammarBuilder> 하 고 <xref:System.Speech.Recognition.Choices> 두 구 중 하나를 인식할 수 있는 문법 구성 하는 개체 "배경 *colorChoice*" 또는 "백그라운드로 *colorChoice*".  
  
 에 대 한 허용 되는 값의 목록을 만든 후 *colorChoice* 사용 하 여를 <xref:System.Speech.Recognition.Choices> 개체를 예제에서는 두 개의 초기화 <xref:System.Speech.Recognition.GrammarBuilder> 개체를 `makePhrase` 및 `setPhrase`, 문자열에서 암시적 변환을 사용 하 여 개체입니다.  
  
 이 예에서는 마지막으로 만듭니다는 <xref:System.Speech.Recognition.Grammar> 에서 개체를 <xref:System.Speech.Recognition.Choices> 개체를 캐스팅할를 <xref:System.Speech.Recognition.GrammarBuilder> 개체입니다.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>