<Type Name="PromptBuilder" FullName="System.Speech.Synthesis.PromptBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="14118e75456eed1da06612825ae9e28e57c83a9f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52739039" /></Metadata><TypeSignature Language="C#" Value="public class PromptBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit PromptBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Synthesis.PromptBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class PromptBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class PromptBuilder" />
  <TypeSignature Language="F#" Value="type PromptBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>빈 <see cref="T:System.Speech.Synthesis.Prompt" /> 개체를 만들고 콘텐츠 추가, 음성 선택, 음성 특성 제어, 단어 읽기 발음 제어를 위한 메서드를 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Speech.Synthesis.PromptBuilder>, 다양 한 콘텐츠 형식 (문자열 또는 파일)로 일반 텍스트, SSML 태그를 포함 하 여 메시지에 오디오 기록 추가 하거나 심지어 다른 <xref:System.Speech.Synthesis.PromptBuilder> 개체입니다.  
  
 텍스트를 추가 하는 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 강조, 속도 및 볼륨 중 하나를 사용 하는 등 음성 특성을 선택적으로 제어를 <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> 메서드.  그룹으로 음성 특성을 제어할 수도 있습니다는 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> 고 <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> 메서드.  
  
 텍스트를 추가 하 고 말하는 제어할 수 있습니다 사용 하 여 발음 하는 방법 또는 합니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A>, 또는 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> 메서드.  
  
 오버 로드 된 중 하나를 사용 하 여 프롬프트에서 현재 선택 된 음성 변경 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 메서드를 사용 하거나 지정 하는 특정 음성 이름 연령 / 성별 등의 음성 특성을 필요 합니다.  
  
 음성을 생성 하는 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 인수로 전달할 수 있습니다는 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> 메서드.  
  
 자세한 내용은 [복잡 한 프롬프트 생성](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361616(v%3doffice.14))합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 클래스의 새 인스턴스를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PromptBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PromptBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 클래스의 새 인스턴스를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 새 <xref:System.Speech.Synthesis.PromptBuilder> 인스턴스 및 텍스트 문자열을 추가 합니다.  
  
```csharp  
using System.Speech.Synthesis;  
  
public void MySimpleText ()  
{  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendText("Hello world!");  
}  
```  
  
 다음 태그에서 음성 합성 태그 언어 (SSML), 해당 보여 줍니다 (`xml:lang` 의 필수 특성을 `speak` 요소).  
  
```xml  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US">  
  Hello world!  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PromptBuilder (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.#ctor(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PromptBuilder(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="new System.Speech.Synthesis.PromptBuilder : System.Globalization.CultureInfo -&gt; System.Speech.Synthesis.PromptBuilder" Usage="new System.Speech.Synthesis.PromptBuilder culture" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">해당 언어, 문화권의 이름, 쓰기 체계, 사용 달력과 날짜 서식 지정 및 문자열 정렬 방법 등 특정 문화권에 대한 정보를 제공합니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 클래스의 새 인스턴스를 만들고 문화권을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에 대 한 값을 설정 합니다 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 속성입니다. <xref:System.Speech.Synthesis.SpeechSynthesizer> 개체는 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고 합니다 `culture` 프롬프트를 처리 하는 데 매개 변수입니다. 지정된 된 문화권을 사용 하 여 음성 있으면 사용 됩니다. 지정된 된 문화권을 사용 하 여 음성을 찾을 수 없는 경우 기본 음성을 사용 됩니다.  
  
 올바르게 지정 된 언어의 단어 발음을 `culture` 매개 변수를 지 원하는 언어는 음성 합성 (텍스트 음성 변환 또는 TTS) 엔진을 설치 해야 합니다. 설치 된 TTS 엔진 음성을 호출 됩니다. 사용 하 여 특정 문화권에 대 한 설치 된 음성에 대 한 정보를 가져오려고 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 Microsoft Windows 및 System.Speech API 값에 대해 유효한 모든 언어-국가 코드를 수락 `culture`합니다. Windows 7과 함께 제공 되는 TTS 엔진에는 다음 언어-국가 코드를 지원 합니다.  
  
-   EN-US입니다. 영어 (미국)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En"와 같은 두 문자 언어 코드도 허용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 만듭니다는 <xref:System.Speech.Synthesis.PromptBuilder> 인스턴스 및 지정 해당 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A>.  
  
```csharp  
using System.Speech.Synthesis;  
  
public void MySimpleText ()  
{  
    PromptBuilder builder = new PromptBuilder(new System.Globalization.CultureInfo("en-US"));  
    builder.AppendText("Hello world!");  
}  
```  
  
 다음 태그에 해당 하는 SSML 보여 줍니다.  
  
```xml  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US">  
  Hello world!  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAudio">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 오디오 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendAudio : string -&gt; unit" Usage="promptBuilder.AppendAudio path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">오디오 파일의 정규화된 경로입니다.</param>
        <summary>지정된 오디오 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" />에 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (Uri audioFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(class System.Uri audioFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (audioFile As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(Uri ^ audioFile);" />
      <MemberSignature Language="F#" Value="member this.AppendAudio : Uri -&gt; unit" Usage="promptBuilder.AppendAudio audioFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioFile" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="audioFile">오디오 파일의 URI입니다.</param>
        <summary>지정된 URI의 오디오 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" />에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는의 새 인스턴스를 초기화 합니다 <xref:System.Speech.Synthesis.PromptBuilder> 클래스 및 오디오 파일을 뒤에 다음 텍스트를 추가 합니다.  
  
```csharp  
using System.Speech.PromptBuilder;  
  
public void SimpleConcatenation()  
{  
    // Add a prompt fragment from a .wav file.  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendText("How are you today?");  
    builder.AppendAudio(new Uri ("http://www.speech.microsoft.com/ding.wav"));  
}  
```  
  
 다음 태그에 해당 하는 SSML 태그를 보여 줍니다.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis"  
       xmlns:ms="http://www.microsoft.com/speech/synthesis" xml:lang="en">  
  
  How are you today?  
  <audio src="http://www.speech.microsoft.com/ding.wav" />  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (Uri audioFile, string alternateText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(class System.Uri audioFile, string alternateText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (audioFile As Uri, alternateText As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(Uri ^ audioFile, System::String ^ alternateText);" />
      <MemberSignature Language="F#" Value="member this.AppendAudio : Uri * string -&gt; unit" Usage="promptBuilder.AppendAudio (audioFile, alternateText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioFile" Type="System.Uri" />
        <Parameter Name="alternateText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="audioFile">오디오 파일의 URI입니다.</param>
        <param name="alternateText">오디오를 나타내는 대체 텍스트를 포함하는 문자열입니다.</param>
        <summary>지정된 오디오 파일 및 대체 텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" />에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 음성 합성 엔진이 오디오 파일을 재생할 수 없는 경우 대체 텍스트를 말합니다.  
  
   
  
## Examples  
 오디오 파일을 추가 하는 다음 예제는 <xref:System.Speech.Synthesis.PromptBuilder> 인스턴스 및 오디오 파일을 재생할 수 없는 경우 문의 텍스트를 지정 합니다.  
  
```csharp  
using System.Speech.PromptBuilder;  
  
public void SimpleConcatenation()  
{  
  
    // Concatenate a prompt fragment from a .wav file.  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendAudio(new Uri ("C:\\OnHold.wav"), "Your call will be answered in the order it was received");  
}  
```  
  
 다음 태그에 해당 하는 SSML 태그를 보여 줍니다.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis"  
       xmlns:ms="http://www.microsoft.com/speech/synthesis" xml:lang="en">  
  
  <audio src="C:\OnHold.wav"> Your call will be answered in the order it was received. </audio>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBookmark">
      <MemberSignature Language="C#" Value="public void AppendBookmark (string bookmarkName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBookmark(string bookmarkName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBookmark(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBookmark (bookmarkName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBookmark(System::String ^ bookmarkName);" />
      <MemberSignature Language="F#" Value="member this.AppendBookmark : string -&gt; unit" Usage="promptBuilder.AppendBookmark bookmarkName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">추가된 책갈피의 이름을 포함하는 문자열입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 책갈피를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 음성 합성 엔진이 생성을 <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> 중 하나를 사용 하 여 프롬프트를 말하기 하는 동안 책갈피를 발견할 경우 이벤트를 <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A>, <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A>, <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A>, 또는 <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 책갈피를 포함 하 고 WAV 파일 재생에 출력을 전송 하는 프롬프트를 만듭니다. 에 대 한 처리기를 <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> 콘솔로 이벤트가 발생 하는 경우 이벤트에 책갈피 및 오디오 스트림에서 위치 이름을 씁니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Build a prompt and append bookmarks.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "The weather forecast for today is partly cloudy with some sun breaks.");  
        builder.AppendBookmark("Daytime forecast");  
        builder.AppendText(  
          "Tonight's weather will be cloudy with a 30% chance of showers.");  
        builder.AppendBookmark("Nightime forecast");  
  
        // Add a handler for the BookmarkReached event.  
        synth.BookmarkReached +=  
          new EventHandler<BookmarkReachedEventArgs>(synth_BookmarkReached);  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Write the name and position of the bookmark to the console.  
    static void synth_BookmarkReached(object sender, BookmarkReachedEventArgs e)  
    {  
      Console.WriteLine("Bookmark ({0}) reached at: {1} ",  
        e.Bookmark, e.AudioPosition);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendBreak">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 내용에 중단(일시 중지)을 삽입합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak();" />
      <MemberSignature Language="F#" Value="member this.AppendBreak : unit -&gt; unit" Usage="promptBuilder.AppendBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 중단을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 중단에 대 한 기간을 지정 하지 않습니다. <xref:System.Speech.Synthesis.SpeechSynthesizer> 언어 컨텍스트를 기반으로 하는 기간 값을 결정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 바꿈으로 구분 된 두 문장을 포함 하는 프롬프트를 빌드하고 컴퓨터의 기본 오디오 장치에 대 한 프롬프트를 말합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45.");  
        builder.AppendBreak();  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:30, and 9:15.");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak (System.Speech.Synthesis.PromptBreak strength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak(valuetype System.Speech.Synthesis.PromptBreak strength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak(System.Speech.Synthesis.PromptBreak)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak (strength As PromptBreak)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak(System::Speech::Synthesis::PromptBreak strength);" />
      <MemberSignature Language="F#" Value="member this.AppendBreak : System.Speech.Synthesis.PromptBreak -&gt; unit" Usage="promptBuilder.AppendBreak strength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strength" Type="System.Speech.Synthesis.PromptBreak" />
      </Parameters>
      <Docs>
        <param name="strength">다음 증가 값을 사용하여 중단 기간을 나타냅니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 중단을 추가하고 중단의 강도(기간)를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Speech.Synthesis.PromptBreak> 열거형 단어 경계 간의 분리 간격으로 (일시 중지)의 범위를 나타냅니다. 음성 합성 엔진 간격의 정확한 기간을 결정합니다. 중단 요청 되 면 다음이 값 중 하나일 이러한 값과 해당 밀리초 중단 값 간의 매핑을 포함 하는 텍스트 음성 변환 (TTS) 엔진으로 전달 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 바꿈으로 구분 된 두 문장을 포함 하는 프롬프트를 빌드하고 WAV 파일 재생에 출력을 보냅니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45");  
        builder.AppendBreak(PromptBreak.Medium);  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak (TimeSpan duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak(valuetype System.TimeSpan duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak (duration As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak(TimeSpan duration);" />
      <MemberSignature Language="F#" Value="member this.AppendBreak : TimeSpan -&gt; unit" Usage="promptBuilder.AppendBreak duration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="duration">틱 단위의 시간으로, 1틱은 100나노초에 해당합니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 지정된 기간의 중단을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 나누기를 일시 중지 또는 단어 간의 운율 다른 경계 제어를 사용할 수 있습니다. 나누기를 선택 사항입니다. 중단 없는 경우 신시사이저 언어 컨텍스트에 따라 단어 사이의 구분선을 결정 합니다.  
  
   
  
## Examples  
 다음 예제에서는 15,000,000 틱 (1.5 초)으로 나누기로 구분 된 두 문장을 포함 하는 프롬프트를 빌드하고 컴퓨터의 기본 오디오 장치에 대 한 프롬프트를 말합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45");  
        builder.AppendBreak(new TimeSpan(15000000));  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendPromptBuilder">
      <MemberSignature Language="C#" Value="public void AppendPromptBuilder (System.Speech.Synthesis.PromptBuilder promptBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendPromptBuilder(class System.Speech.Synthesis.PromptBuilder promptBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendPromptBuilder(System.Speech.Synthesis.PromptBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendPromptBuilder(System::Speech::Synthesis::PromptBuilder ^ promptBuilder);" />
      <MemberSignature Language="F#" Value="member this.AppendPromptBuilder : System.Speech.Synthesis.PromptBuilder -&gt; unit" Usage="promptBuilder.AppendPromptBuilder promptBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="promptBuilder" Type="System.Speech.Synthesis.PromptBuilder" />
      </Parameters>
      <Docs>
        <param name="promptBuilder">추가할 콘텐츠입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체를 다른 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 두 개를 만듭니다 <xref:System.Speech.Synthesis.PromptBuilder> 인스턴스를 세 번째 추가 합니다 <xref:System.Speech.Synthesis.PromptBuilder>합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\showtimes.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\showtimes.wav");  
  
        // Build child prompts.  
        PromptBuilder theatreA = new PromptBuilder();  
        theatreA.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 9:30");  
        theatreA.AppendBreak(PromptBreak.Large);  
        PromptBuilder theatreB = new PromptBuilder();  
        theatreB.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Build the parent prompt and append the two child prompts.  
        PromptBuilder showTimes = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        showTimes.AppendText(  
          "The following are the show times for tonight's movies:");  
        showTimes.AppendPromptBuilder(theatreA);  
        showTimes.AppendPromptBuilder(theatreB);  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(showTimes);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendSsml">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>SSML 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendSsml : string -&gt; unit" Usage="promptBuilder.AppendSsml path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">추가할 SSML 파일의 정규화된 경로입니다.</param>
        <summary>지정된 경로의 SSML 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSML 파일에는 준수 하는 XML 서식 파일을 해야 합니다 [Speech Synthesis Markup Language (SSML) 버전 1.0](https://go.microsoft.com/fwlink/?LinkId=201763) 사양입니다.  
  
 SSML 태그를 사용 하 여 문자열을 추가할 수 있습니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>합니다.  
  
   
  
## Examples  
 뒤에 나오는 예제 만듭니다는 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 사용 하 여 SSML 파일의 내용을 추가 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> 메서드.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a file that defines an SSML prompt.  
        PromptBuilder ssmlFile = new PromptBuilder();  
        ssmlFile.AppendSsml("c:\\test\\Weather.ssml");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(ssmlFile);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 다음은 앞의 예제를 참조 하는 SSML 파일입니다.  
  
```xml  
<?xml version="1.0" encoding="ISO-8859-1"?>  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis"  
 xml:lang="en-US">  
  
  <s> The weather forecast for today is partly cloudy with some sun breaks. </s>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (Uri ssmlFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(class System.Uri ssmlFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (ssmlFile As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(Uri ^ ssmlFile);" />
      <MemberSignature Language="F#" Value="member this.AppendSsml : Uri -&gt; unit" Usage="promptBuilder.AppendSsml ssmlFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlFile" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="ssmlFile">추가할 SSML 파일의 정규화된 URI입니다.</param>
        <summary>지정된 URI의 SSML 파일을 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSML 파일에는 준수 하는 XML 서식 파일을 해야 합니다 [Speech Synthesis Markup Language (SSML) 버전 1.0](https://www.w3.org/TR/speech-synthesis/) 사양입니다.  
  
 SSML 태그를 사용 하 여 문자열을 추가할 수 있습니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>합니다.  
  
   
  
## Examples  
 뒤에 나오는 예제 만듭니다는 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 사용 하 여 SSML 파일의 내용을 추가 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> 메서드.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a file that defines an SSML prompt.  
        PromptBuilder ssmlFile = new PromptBuilder();  
        ssmlFile.AppendSsml(new Uri("c:\\test\\Weather.ssml"));  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(ssmlFile);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 다음은 앞의 예제를 참조 하는 SSML 파일입니다.  
  
```xml  
<?xml version="1.0" encoding="ISO-8859-1"?>  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis"  
 xml:lang="en-US">  
  
  <s> The weather forecast for today is partly cloudy with some sun breaks. </s>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (System.Xml.XmlReader ssmlFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(class System.Xml.XmlReader ssmlFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (ssmlFile As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(System::Xml::XmlReader ^ ssmlFile);" />
      <MemberSignature Language="F#" Value="member this.AppendSsml : System.Xml.XmlReader -&gt; unit" Usage="promptBuilder.AppendSsml ssmlFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlFile" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="ssmlFile">추가할 XML 파일의 정규화된 이름입니다.</param>
        <summary>SSML 프롬프트를 참조하는 <c>XMLReader</c> 개체를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSML 파일에는 준수 하는 XML 서식 파일을 해야 합니다 [Speech Synthesis Markup Language (SSML) 버전 1.0](https://www.w3.org/TR/speech-synthesis/) 사양입니다.  
  
 SSML 태그를 사용 하 여 문자열을 추가할 수 있습니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Speech.Synthesis.PromptBuilder> 에서 개체를 <xref:System.Xml.XmlReader> Speech Synthesis Markup Language (SSML) 태그를 포함 하는 파일을 참조 하는 개체입니다.  
  
```csharp  
using System;  
using System.Xml;  
using System.IO;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Create the path to the SSML file.  
        string weatherFile = Path.GetFullPath("c:\\test\\Weather.xml");  
        PromptBuilder builder = null;  
  
        // Create an XML Reader from the file, create a PromptBuilder and   
        // append the XmlReader.  
        if (File.Exists(weatherFile))  
        {  
          XmlReader reader = XmlReader.Create(weatherFile);  
          builder = new PromptBuilder();  
          builder.AppendSsml(reader);  
          reader.Close();  
        }  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsmlMarkup">
      <MemberSignature Language="C#" Value="public void AppendSsmlMarkup (string ssmlMarkup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsmlMarkup(string ssmlMarkup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsmlMarkup (ssmlMarkup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsmlMarkup(System::String ^ ssmlMarkup);" />
      <MemberSignature Language="F#" Value="member this.AppendSsmlMarkup : string -&gt; unit" Usage="promptBuilder.AppendSsmlMarkup ssmlMarkup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlMarkup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ssmlMarkup">SSML 태그가 포함된 문자열입니다.</param>
        <summary>SSML 태그를 포함하는 지정된 문자열을 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSML 태그를 추가 하는 경우 적절 한 이스케이프 문자를 사용 해야 합니다. 이전 버전과-슬래시 이전 값을 묶는 따옴표를 확인 합니다 `interpret-as` 다음 예제에서는 특성:  
  
```csharp  
builder.AppendSsmlMarkup("<say-as interpret-as = \"characters\"> chair </say-as>");  
```  
  
> [!NOTE]
>  문자열 인수를 받았던 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> 포함할 수 없습니다를 `speak` 요소입니다.  
  
 사용 하는 경우 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> 인라인 정의 발음에서 지정 하는 `phoneme` 요소는 현재 음성 엔진에서 지 원하는 제공, 다음 음성 알파벳에서 휴대폰을 사용할 수 있습니다.  
  
-   International Phonetic Alphabet (IPA)  
  
-   Universal Phone Set (UPS)  
  
-   SAPI 전화 설정  
  
 모든 SSML 규격 음성 엔진 IPA에서 휴대폰을 증명 합니다.  
  
 SSML 태그 중 하나를 사용 하 여 포함 된 파일을 추가할 수도 있습니다는 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> 메서드. 태그 언어를 사용 하 여 서식이 지정 되지 않은 텍스트를 읽을 추가할 중 하나를 사용 합니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias%2A>를 <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint%2A>, 또는 <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendText">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 텍스트를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string -&gt; unit" Usage="promptBuilder.AppendText textToSpeak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가할 텍스트를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 SSML 태그 언어로 서식이 지정 된 텍스트에 추가 하려면 사용 하 여 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>입니다.  
  
   
  
## Examples  
 뒤에 나오는 예제 만듭니다는 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 사용 하 여 텍스트 문자열을 추가 합니다 <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> 메서드.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a text string.  
        PromptBuilder speakText = new PromptBuilder();  
        speakText.AppendText("Say the name of the song you want to hear");  
  
        // Speak the contents of the prompt.  
        synth.Speak(speakText);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptEmphasis emphasis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptEmphasis emphasis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptEmphasis)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, emphasis As PromptEmphasis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptEmphasis emphasis);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string * System.Speech.Synthesis.PromptEmphasis -&gt; unit" Usage="promptBuilder.AppendText (textToSpeak, emphasis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="emphasis" Type="System.Speech.Synthesis.PromptEmphasis" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <param name="emphasis">텍스트에 적용할 강조 또는 스트레스 값입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트의 강조 정도를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows의 음성 합성 엔진 지금은 강조 매개 변수를 지원 하지 않습니다. 강조 매개 변수 값을 설정할 청각적 변하지 합성 된 음성 출력에서 생성 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptRate rate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptRate rate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptRate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, rate As PromptRate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptRate rate);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string * System.Speech.Synthesis.PromptRate -&gt; unit" Usage="promptBuilder.AppendText (textToSpeak, rate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="rate" Type="System.Speech.Synthesis.PromptRate" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <param name="rate">텍스트에 적용할 말하기 속도 값입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트의 읽기 속도를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder> 개체 및 텍스트 문자열을 추가 합니다. 이 예제에서는 사용은 <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> 주문의 내용을 열거 하는 문자열을 추가 하는 느린 말하는 지정 하는 방법 평가 합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder speakRate = new PromptBuilder();  
        speakRate.AppendText("Your order for");  
        speakRate.AppendText("one kitchen sink and one faucet", PromptRate.Slow);  
        speakRate.AppendText("has been confirmed.");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(speakRate);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptVolume volume);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptVolume volume) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptVolume)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, volume As PromptVolume)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptVolume volume);" />
      <MemberSignature Language="F#" Value="member this.AppendText : string * System.Speech.Synthesis.PromptVolume -&gt; unit" Usage="promptBuilder.AppendText (textToSpeak, volume)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="volume" Type="System.Speech.Synthesis.PromptVolume" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <param name="volume">텍스트에 적용할 말하기 볼륨(크기) 값입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트를 읽을 볼륨을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Speech.Synthesis.PromptVolume.Default> 에 대 한 설정 <xref:System.Speech.Synthesis.PromptVolume> 은 동일한 전체 볼륨으로 <xref:System.Speech.Synthesis.PromptVolume.ExtraLoud>입니다. 다른 설정은 전체 볼륨을 기준으로 음성 출력의 볼륨을 줄입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> 볼륨 설정을 지정 하는 메서드는는 <xref:System.Speech.Synthesis.SpeechSynthesizer> 음성 출력에 적용 해야 합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt that applies different volume settings.  
        PromptBuilder builder = new PromptBuilder();  
        builder.AppendText("This is the default speaking volume.", PromptVolume.Default);  
        builder.AppendBreak();  
        builder.AppendText("This is the extra loud speaking volume.", PromptVolume.ExtraLoud);  
        builder.AppendBreak();  
        builder.AppendText("This is the medium speaking volume.", PromptVolume.Medium);  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithAlias">
      <MemberSignature Language="C#" Value="public void AppendTextWithAlias (string textToSpeak, string substitute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithAlias(string textToSpeak, string substitute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithAlias (textToSpeak As String, substitute As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithAlias(System::String ^ textToSpeak, System::String ^ substitute);" />
      <MemberSignature Language="F#" Value="member this.AppendTextWithAlias : string * string -&gt; unit" Usage="promptBuilder.AppendTextWithAlias (textToSpeak, substitute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="substitute" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">텍스트 표현이 들어 있는 문자열입니다.</param>
        <param name="substitute">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 텍스트를 추가하고 추가된 텍스트 대신 읽을 별칭 텍스트를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 문서를 음성 및 프롬프트 기록된 폼을 포함할 수 있습니다. 예를 들어 작성된 형식을 SAPI, 같은 머리글자어 수 및 음성된 형식을 머리 글자어를이 사례 음성 응용 프로그램 프로그래밍 인터페이스에 대 한 확장 된 텍스트를 수 있습니다.  
  
   
  
## Examples  
 에 텍스트 문자열 ("Speech Synthesis Markup Language") 및 별칭 ("SSML")를 추가 하는 다음 예제는 <xref:System.Speech.Synthesis.PromptBuilder> 개체입니다. 신시사이저 "S S M L" 발음 됩니다.  
  
```  
PromptBuilder alias = new PromptBuilder();  
alias.AppendTextWithAlias("Speech Synthesis Markup Language","SSML");   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendTextWithHint">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트의 콘텐츠 형식을 지정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendTextWithHint">
      <MemberSignature Language="C#" Value="public void AppendTextWithHint (string textToSpeak, System.Speech.Synthesis.SayAs sayAs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithHint(string textToSpeak, valuetype System.Speech.Synthesis.SayAs sayAs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint(System.String,System.Speech.Synthesis.SayAs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithHint(System::String ^ textToSpeak, System::Speech::Synthesis::SayAs sayAs);" />
      <MemberSignature Language="F#" Value="member this.AppendTextWithHint : string * System.Speech.Synthesis.SayAs -&gt; unit" Usage="promptBuilder.AppendTextWithHint (textToSpeak, sayAs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="sayAs" Type="System.Speech.Synthesis.SayAs" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <param name="sayAs">텍스트의 콘텐츠 형식입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 <see cref="T:System.Speech.Synthesis.SayAs" /> 열거형의 멤버를 사용하여 콘텐츠 형식을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 content-type `sayAs` 내용의 발음 하는 방법에 대 한 음성 합성 엔진에 대 한 지침을 제공할 수 `textToSpeak`입니다.  
  
   
  
## Examples  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and define the data types for some of the added strings.  
        PromptBuilder sayAs = new PromptBuilder();  
        sayAs.AppendText("Your");  
        sayAs.AppendTextWithHint("1st", SayAs.NumberOrdinal);  
        sayAs.AppendText("request was for");  
        sayAs.AppendTextWithHint("1", SayAs.NumberCardinal);  
        sayAs.AppendText("room, on");  
        sayAs.AppendTextWithHint("10/19/2012,", SayAs.MonthDayYear);  
        sayAs.AppendText("with early arrival at");  
        sayAs.AppendTextWithHint("12:35pm", SayAs.Time12);  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(sayAs);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithHint">
      <MemberSignature Language="C#" Value="public void AppendTextWithHint (string textToSpeak, string sayAs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithHint(string textToSpeak, string sayAs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithHint (textToSpeak As String, sayAs As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithHint(System::String ^ textToSpeak, System::String ^ sayAs);" />
      <MemberSignature Language="F#" Value="member this.AppendTextWithHint : string * string -&gt; unit" Usage="promptBuilder.AppendTextWithHint (textToSpeak, sayAs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="sayAs" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">읽을 텍스트가 들어 있는 문자열입니다.</param>
        <param name="sayAs">텍스트의 콘텐츠 형식입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트의 콘텐츠 형식을 지정하는 <see cref="T:System.String" />을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여에 포함 되지 않은 콘텐츠 형식을 지정 하는 <xref:System.Speech.Synthesis.SayAs> 열거형입니다. 그러나 TTS 엔진 지정 하는 매개 변수를 지원 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithPronunciation">
      <MemberSignature Language="C#" Value="public void AppendTextWithPronunciation (string textToSpeak, string pronunciation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithPronunciation(string textToSpeak, string pronunciation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithPronunciation (textToSpeak As String, pronunciation As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithPronunciation(System::String ^ textToSpeak, System::String ^ pronunciation);" />
      <MemberSignature Language="F#" Value="member this.AppendTextWithPronunciation : string * string -&gt; unit" Usage="promptBuilder.AppendTextWithPronunciation (textToSpeak, pronunciation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="pronunciation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">언어의 기존 알파벳을 사용하여 작성된 형식의 단어를 포함하는 문자열입니다.</param>
        <param name="pronunciation">IPA(국제 음성 기호)로 읽을 전화를 포함하는 문자열입니다.</param>
        <summary>텍스트를 <see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 추가하고 텍스트의 발음을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 신시사이저의 내용을 말합니다 합니다 `pronunciation` 의 내용이 아닌, 매개 변수는 `textToSpeak` 매개 변수입니다.  
  
 프롬프트에 지정 된 인라인 발음 단어의 개별 항목에만 적용 하 고 음성 엔진 또는 현재 활성으로 해당의 발음을 재정의 합니다. 일반적으로 음성 합성 엔진 발음 하지 수 뿐만 아니라 예상 하는 적절 한 이름과 같은 일반적이 지 않은 단어의 발음 또는 사용자 정의 발음 기존 단어에 대 한 인라인 발음을 사용 합니다.  
  
 인라인 발음 휴대폰 International Phonetic Alphabet (IPA)를 사용 하 여 지정 되어야 합니다. 휴대폰에 문자 또는 음성의 신중한 소리를 나타내는 문자입니다. 부합 하는 음성 엔진 합니다 [Speech Synthesis Markup Language (SSML) 버전 1.0](https://go.microsoft.com/fwlink/?LinkId=201763) 사양 IPA에서 휴대폰 발음 됩니다. 다른 음성 알파벳을 사용 하 여 인라인 발음을 지정 하려면 참조 <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>합니다.  
  
 IPA 게시는 [차트](https://go.microsoft.com/fwlink/?LinkId=58362) 해당 휴대폰을 나열 하 고 유니코드 숫자에 매핑합니다.  
  
 일부 휴대폰 IPA 알파벳에서 문자로 동일한 표현을 라틴어 알파벳에 있습니다. 이러한 경우 라틴 문자를 입력 하 고 휴대폰에 대 한 적절 한 표현이를 것이 가능 합니다. 일반적으로 텍스트에 사용 된 라틴 문자 IPA phone 집합의 몇 가지 휴대폰을 나타낼 수 있습니다, 라틴 문자를 입력 하면 하지 원하는 정확한 IPA 휴대폰에서 발생할 수 있습니다. IPA 알파벳 해야 코드에서 표시할 다른 휴대폰 문자 참조로 구성 된 앰퍼샌드 (&), 숫자 기호 (#), 유니코드 16 진수 또는 10 진수, 원하는 휴대폰 번호를 모두 뒤에 오는 세미콜론 (;) 및 합니다. 예를 들어, 한 schwa (&\#x0259;)을 표시 `&#x0259;`합니다.  
  
 사용자 지정 또는 새 발음 여러 단어를 추가 하려면 예를 들어 express 국가별 언어를 또는 적절 한 이름 또는 교육 또는 의료 분야에 관련 된 어휘를 추가 하려면 어휘 집을 빌드하고에 추가 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer> 를 사용 하 여 <xref:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는의 새 인스턴스를 초기화 합니다 <xref:System.Speech.Synthesis.PromptBuilder> 클래스입니다. 그 다음 텍스트 문자열 "My name is"의 인스턴스에 추가합니다. 마지막으로 "DuBois" 적절 한 이름을 포함 하는 문자열을 추가 하 고 이름의 발음을 지정 합니다.  
  
```csharp  
public void ProperName()  
{  
    PromptBuilder builder = new PromptBuilder();  
    builder.AppendText("My name is");  
  
    // Add a proper name and its pronunciation.  
    builder.AppendTextWithPronunciation("DuBois", "duˈbwɑ");     
}  
```  
  
 다음 태그는 SSML를 보여 줍니다.이 <xref:System.Speech.Synthesis.PromptBuilder> 개체를 생성 합니다.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us">  
  My name is <phoneme ph="duˈbwɑ"> DuBois </phoneme>  
</speak>  
```  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=58363">국제 윗주 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="promptBuilder.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 내용을 지웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.PromptBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Synthesis.PromptBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 대한 문화권 정보를 가져오거나 설정합니다.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer> 개체는 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고 합니다 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 프롬프트를 처리 하는 속성입니다. 지정된 된 문화권을 사용 하 여 음성 있으면 사용 됩니다. 지정된 된 문화권을 사용 하 여 음성을 찾을 수 없는 경우 기본 음성을 사용 됩니다.  
  
 문화권을 사용 하 여 내용을의 개별 섹션에 대 한 프롬프트 내에서 지정할 수도 있습니다는 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A>, <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A>, 및 <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A> 메서드. 위의 방법 중 하나를 사용 하 여 콘텐츠 부분 재정의 대해 지정 된 문화권의 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 동안 실제로 속성 및 <xref:System.Speech.Synthesis.SpeechSynthesizer> 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고는 `culture` 메서드의 매개 변수입니다.  
  
 올바르게 지정 된 언어의 단어 발음을 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 속성에는 언어를 지 원하는 음성 합성 (텍스트 음성 변환 또는 TTS) 엔진을 설치 해야 합니다. 설치 된 TTS 엔진 음성을 호출 됩니다. 사용 하 여 특정 문화권에 대 한 설치 된 음성에 대 한 정보를 가져오려고 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 Microsoft Windows 및 System.Speech API 값에 대해 유효한 모든 언어-국가 코드를 수락 `culture`합니다. Windows 7과 함께 제공 되는 TTS 엔진에는 다음 언어-국가 코드를 지원 합니다.  
  
-   EN-US입니다. 영어 (미국)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En"와 같은 두 문자 언어 코드도 허용 됩니다.  참조 [문자열과 언어 식별자 상수](https://msdn.microsoft.com/library/dd318693\(VS.85\).aspx) 언어 코드의 포괄적인 목록에 대 한 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndParagraph">
      <MemberSignature Language="C#" Value="public void EndParagraph ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndParagraph() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndParagraph ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndParagraph();" />
      <MemberSignature Language="F#" Value="member this.EndParagraph : unit -&gt; unit" Usage="promptBuilder.EndParagraph " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 단락의 끝을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다. 예제는 <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndSentence">
      <MemberSignature Language="C#" Value="public void EndSentence ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSentence() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndSentence" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSentence ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSentence();" />
      <MemberSignature Language="F#" Value="member this.EndSentence : unit -&gt; unit" Usage="promptBuilder.EndSentence " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 문장의 끝을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다. 예제는 <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndStyle">
      <MemberSignature Language="C#" Value="public void EndStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndStyle();" />
      <MemberSignature Language="F#" Value="member this.EndStyle : unit -&gt; unit" Usage="promptBuilder.EndStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 스타일의 끝을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> 메서드는 현재 말하기 스타일을 중지 합니다. 말하기 스타일 전에 적용 된 설정으로 되돌립니다는 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> 메서드는 새 말하기 스타일을 시작 합니다. 예제는 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A>을 참조하세요.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndVoice">
      <MemberSignature Language="C#" Value="public void EndVoice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndVoice() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndVoice" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndVoice ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndVoice();" />
      <MemberSignature Language="F#" Value="member this.EndVoice : unit -&gt; unit" Usage="promptBuilder.EndVoice " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 음성 사용의 끝을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A> 메서드 음성 출력에 대 한 현재 음성의 사용을 중지 합니다. 음성 전에 적용 된 설정으로 되돌립니다는 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 메서드는 새 음성을 시작 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.PromptBuilder.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Speech.Synthesis.PromptBuilder.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" />가 비어 있는지 여부를 가져옵니다.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartParagraph">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 단락의 시작을 지정하고 선택적으로 언어를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartParagraph">
      <MemberSignature Language="C#" Value="public void StartParagraph ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartParagraph() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartParagraph ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartParagraph();" />
      <MemberSignature Language="F#" Value="member this.StartParagraph : unit -&gt; unit" Usage="promptBuilder.StartParagraph " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 단락의 시작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder> 개체 콘텐츠를 추가 하 고 단락 및 문장으로 콘텐츠를 구성 합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content as paragraphs and sentences.  
        PromptBuilder parSent = new PromptBuilder();  
        parSent.StartParagraph();  
        parSent.StartSentence();  
        parSent.AppendText("Introducing the sentence element.");  
        parSent.EndSentence();  
        parSent.StartSentence();  
        parSent.AppendText("You can use it to mark individual sentences.");  
        parSent.EndSentence();  
        parSent.EndParagraph();  
        parSent.StartParagraph();  
        parSent.AppendText("Another simple paragraph. Sentence structure in this paragraph" +  
          "is not explicitly marked.");  
        parSent.EndParagraph();  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(parSent);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartParagraph">
      <MemberSignature Language="C#" Value="public void StartParagraph (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartParagraph(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartParagraph(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartParagraph (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartParagraph(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartParagraph : System.Globalization.CultureInfo -&gt; unit" Usage="promptBuilder.StartParagraph culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">해당 언어, 문화권의 이름, 쓰기 체계, 사용 달력과 날짜 서식 지정 및 문자열 정렬 방법 등 특정 문화권에 대한 정보를 제공합니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 지정된 문화권에서 단락의 시작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
 `culture` 단락에 대 한 매개 변수는 다를 수 있습니다 합니다 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 의 속성을 <xref:System.Speech.Synthesis.PromptBuilder> 포함 하는 개체. 하지만 실제로 값을 `culture` 매개 변수 재정의 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 속성. <xref:System.Speech.Synthesis.SpeechSynthesizer> 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고 합니다 `culture` 단락 문의 매개 변수입니다. 지정된 된 문화권을 사용 하 여 음성 있으면 사용 됩니다. 지정된 된 문화권을 사용 하 여 음성을 찾을 수 없는 경우 기본 음성을 사용 됩니다. 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A>, 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndParagraph%2A>합니다.  
  
 올바르게 지정 된 언어의 단어 발음을 `culture` 매개 변수를 지 원하는 언어는 음성 합성 (텍스트 음성 변환 또는 TTS) 엔진을 설치 해야 합니다. 설치 된 TTS 엔진 음성을 호출 됩니다. 사용 하 여 특정 문화권에 대 한 설치 된 음성에 대 한 정보를 가져오려고 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 Microsoft Windows 및 System.Speech API 값에 대해 유효한 모든 언어-국가 코드를 수락 `culture`합니다. Windows 7과 함께 제공 되는 TTS 엔진에는 다음 언어-국가 코드를 지원 합니다.  
  
-   EN-US입니다. 영어 (미국)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En"와 같은 두 문자 언어 코드도 허용 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartSentence">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 문장의 시작을 지정하고 선택적으로 언어를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartSentence">
      <MemberSignature Language="C#" Value="public void StartSentence ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartSentence() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartSentence" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartSentence ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartSentence();" />
      <MemberSignature Language="F#" Value="member this.StartSentence : unit -&gt; unit" Usage="promptBuilder.StartSentence " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 문장의 시작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder> 개체 콘텐츠를 추가 하 고 단락 및 문장으로 콘텐츠를 구성 합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content as paragraphs and sentences.  
        PromptBuilder parSent = new PromptBuilder();  
        parSent.StartParagraph();  
        parSent.StartSentence();  
        parSent.AppendText("Introducing the sentence element.");  
        parSent.EndSentence();  
        parSent.StartSentence();  
        parSent.AppendText("You can use it to mark individual sentences.");  
        parSent.EndSentence();  
        parSent.EndParagraph();  
        parSent.StartParagraph();  
        parSent.AppendText("Another simple paragraph. Sentence structure in this paragraph" +  
          "is not explicitly marked.");  
        parSent.EndParagraph();  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(parSent);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartSentence">
      <MemberSignature Language="C#" Value="public void StartSentence (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartSentence(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartSentence(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartSentence (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartSentence(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartSentence : System.Globalization.CultureInfo -&gt; unit" Usage="promptBuilder.StartSentence culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">해당 언어, 문화권의 이름, 쓰기 체계, 사용 달력과 날짜 서식 지정 및 문자열 정렬 방법 등 특정 문화권에 대한 정보를 제공합니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에 지정된 문화권에서 문장의 시작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 긴 프롬프트 문장과 단락으로 인해 이러한 끊어진 경우에 실제 음성 같은 자세한으로 렌더링할 수 있습니다.  
  
 `culture` 문장에 대 한 매개 변수는 다를 수 있습니다를 `culture` 문장이 있는 단락에 대 한 매개 변수 또는 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 의 속성을 <xref:System.Speech.Synthesis.PromptBuilder> 포함 된 개체입니다.  
  
 하지만 실제로 값을 `culture` 매개 변수 재정의 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 속성 및 `culture` 문장이 있는 단락에 대 한 매개 변수. <xref:System.Speech.Synthesis.SpeechSynthesizer> 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고 합니다 `culture` 문장을 말할 매개 변수입니다. 지정된 된 문화권을 사용 하 여 음성 있으면 사용 됩니다. 지정된 된 문화권을 사용 하 여 음성을 찾을 수 없는 경우 기본 음성을 사용 됩니다. 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A>, 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndSentence%2A>합니다.  
  
 올바르게 지정 된 언어의 단어 발음을 `culture` 매개 변수를 지 원하는 언어는 음성 합성 (텍스트 음성 변환 또는 TTS) 엔진을 설치 해야 합니다. 설치 된 TTS 엔진 음성을 호출 됩니다. 사용 하 여 특정 문화권에 대 한 설치 된 음성에 대 한 정보를 가져오려고 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 Microsoft Windows 및 System.Speech API 값에 대해 유효한 모든 언어-국가 코드를 수락 `culture`합니다. Windows 7과 함께 제공 되는 TTS 엔진에는 다음 언어-국가 코드를 지원 합니다.  
  
-   EN-US입니다. 영어 (미국)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En"와 같은 두 문자 언어 코드도 허용 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartStyle">
      <MemberSignature Language="C#" Value="public void StartStyle (System.Speech.Synthesis.PromptStyle style);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartStyle(class System.Speech.Synthesis.PromptStyle style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartStyle(System.Speech.Synthesis.PromptStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartStyle (style As PromptStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartStyle(System::Speech::Synthesis::PromptStyle ^ style);" />
      <MemberSignature Language="F#" Value="member this.StartStyle : System.Speech.Synthesis.PromptStyle -&gt; unit" Usage="promptBuilder.StartStyle style" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="style" Type="System.Speech.Synthesis.PromptStyle" />
      </Parameters>
      <Docs>
        <param name="style">시작할 스타일입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 스타일의 시작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> 메서드는 <xref:System.Speech.Synthesis.PromptStyle> 인수로 개체입니다. 속성을 사용할 수는 <xref:System.Speech.Synthesis.PromptStyle> 말하기 속도 및 볼륨 (크기) 음성 스타일 적용 되는 동안 출력에 적용할 강조를 설정할 개체입니다. 현재 스타일을 사용 하 여를 중지 하려면 호출을 <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> 메서드.  
  
> [!NOTE]
> -   Windows의 음성 합성 엔진 지금은 강조 매개 변수를 지원 하지 않습니다. 강조 매개 변수 값을 설정할 청각적 변하지 합성 된 음성 출력에서 생성 됩니다.  
> -   합니다 <xref:System.Speech.Synthesis.PromptVolume.Default> 에 대 한 설정 <xref:System.Speech.Synthesis.PromptVolume> 은 동일한 전체 볼륨으로 <xref:System.Speech.Synthesis.PromptVolume.ExtraLoud>입니다. 다른 설정은 전체 볼륨을 기준으로 음성 출력의 볼륨을 줄입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder> 개체 및 텍스트 문자열을 추가 합니다. 이 예제에서는 사용은 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> 주문의 내용을 열거 하는 문자열을 추가 하는 느린 말하는 지정 하는 방법 평가 합니다.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder style = new PromptBuilder();  
        style.AppendText("Your order for");  
        style.StartStyle(new PromptStyle(PromptRate.Slow));  
        style.AppendText("one kitchen sink and one faucet");  
        style.EndStyle();  
        style.AppendText("has been confirmed.");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(style);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartVoice">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 음성 설치 TTS 엔진을 나타냅니다. 사용 된 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드 및 <xref:System.Speech.Synthesis.VoiceInfo> 클래스 이름 및 특성을 선택할 수 있는 텍스트 음성 변환 (TTS) 음성을 설치 합니다.  
  
 응용 프로그램을 호출 하면 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A>, 최소 특정 조건에 맞는지 레지스트리에서 찾으면 음성의 각 메서드를 확인 합니다. 확인 하지 못한 모든 음성 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 설정 하는 해당 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 속성을 `False`입니다. 응용 프로그램 중 하나를 호출할 수 없습니다는 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 메서드는 음성입니다 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 속성은 `False`합니다. 일반적으로 응용 프로그램을 음성 설정 하지 것입니다 <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : System.Globalization.CultureInfo -&gt; unit" Usage="promptBuilder.StartVoice culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">해당 언어, 문화권의 이름, 쓰기 체계, 사용 달력과 날짜 서식 지정 및 문자열 정렬 방법 등 특정 문화권에 대한 정보를 제공합니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 사용할 음성의 문화권을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture` 에 대 한 매개 변수 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 다를 수 있습니다를 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 의 속성을 <xref:System.Speech.Synthesis.PromptBuilder> 포함 하는 개체.  하지만 실제로 값을 `culture` 매개 변수 재정의 <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> 속성. 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer> 지정 된 언어를 지 원하는 설치 된 음성 선택 하려고 합니다 `culture` 로 묶인 콘텐츠가 문의 매개 변수 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 및 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다. 지정된 된 문화권을 사용 하 여 음성 있으면 사용 됩니다. 지정된 된 문화권을 사용 하 여 음성을 찾을 수 없는 경우 기본 음성을 사용 됩니다. 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A>, 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 올바르게 지정 된 언어의 단어 발음을 `culture` 매개 변수를 지 원하는 언어는 음성 합성 (텍스트 음성 변환 또는 TTS) 엔진을 설치 해야 합니다. 설치 된 TTS 엔진 음성을 호출 됩니다. 사용 하 여 특정 문화권에 대 한 설치 된 음성에 대 한 정보를 가져오려고 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 Microsoft Windows 및 System.Speech API 값에 대해 유효한 모든 언어-국가 코드를 수락 `culture`합니다. Windows 7과 함께 제공 되는 TTS 엔진에는 다음 언어-국가 코드를 지원 합니다.  
  
-   EN-US입니다. 영어 (미국)  
  
-   zh-CN. 중국어 (중국)  
  
-   zh-TW. 중국어 (대만)  
  
 "En"와 같은 두 문자 언어 코드도 허용 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : System.Speech.Synthesis.VoiceGender -&gt; unit" Usage="promptBuilder.StartVoice gender" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
      </Parameters>
      <Docs>
        <param name="gender">사용할 음성의 성별입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 사용할 음성의 성별을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드 및 <xref:System.Speech.Synthesis.VoiceInfo> 클래스 이름 및 특성을 선택할 수 있는 텍스트 음성 변환 (TTS) 음성을 설치 합니다.  
  
 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceInfo voice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(class System.Speech.Synthesis.VoiceInfo voice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (voice As VoiceInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceInfo ^ voice);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : System.Speech.Synthesis.VoiceInfo -&gt; unit" Usage="promptBuilder.StartVoice voice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="voice" Type="System.Speech.Synthesis.VoiceInfo" />
      </Parameters>
      <Docs>
        <param name="voice">사용할 음성에 대한 기준입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 새 음성에 대한 기준을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드 및 <xref:System.Speech.Synthesis.VoiceInfo> 클래스 이름 및 특성을 선택할 수 있는 텍스트 음성 변환 (TTS) 음성을 설치 합니다.  
  
 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : string -&gt; unit" Usage="promptBuilder.StartVoice name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">사용할 음성의 이름입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 사용할 음성의 이름을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설치 된 음성에 대 한 정보를 얻으려면 중 하나를 사용 합니다 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드.  
  
 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender, age As VoiceAge)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : System.Speech.Synthesis.VoiceGender * System.Speech.Synthesis.VoiceAge -&gt; unit" Usage="promptBuilder.StartVoice (gender, age)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
      </Parameters>
      <Docs>
        <param name="gender">사용할 새 음성의 성별입니다.</param>
        <param name="age">사용할 음성의 연령입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 새 음성의 성별과 연령을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드 및 <xref:System.Speech.Synthesis.VoiceInfo> 클래스 이름 및 특성을 선택할 수 있는 텍스트 음성 변환 (TTS) 음성을 설치 합니다.  
  
 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age, int voiceAlternate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age, int32 voiceAlternate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender, age As VoiceAge, voiceAlternate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age, int voiceAlternate);" />
      <MemberSignature Language="F#" Value="member this.StartVoice : System.Speech.Synthesis.VoiceGender * System.Speech.Synthesis.VoiceAge * int -&gt; unit" Usage="promptBuilder.StartVoice (gender, age, voiceAlternate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
        <Parameter Name="voiceAlternate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="gender">사용할 음성의 성별입니다.</param>
        <param name="age">사용할 음성의 연령입니다.</param>
        <param name="voiceAlternate">두 개 이상의 음성이 <paramref name="gender" /> 및 <paramref name="age" /> 매개 변수와 일치할 경우 기본 음성을 지정하는 정수입니다.</param>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체의 음성을 변경하도록 신시사이저에 지시하고 해당 성별, 연령과 지정한 성별 및 연령에 맞는 기본 음성을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 음성 합성 엔진이 지정된 된 매개 변수를 찾아 음성 참조 횟수가 반환 된 일치 항목 개수를 `voiceAlternate` 매개 변수입니다.  
  
 사용 된 <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> 메서드 및 <xref:System.Speech.Synthesis.VoiceInfo> 클래스 이름 및 특성을 선택할 수 있는 텍스트 음성 변환 (TTS) 음성을 설치 합니다.  
  
 지정 된 음성 사용을 중지 하려면 <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> 호출 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge)" />
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public string ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToXml();" />
      <MemberSignature Language="F#" Value="member this.ToXml : unit -&gt; string" Usage="promptBuilder.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 생성된 SSML을 반환합니다.</summary>
        <returns><see cref="T:System.Speech.Synthesis.PromptBuilder" /> 개체에서 생성된 SSML을 한 줄로 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.ToXml%2A> 메서드에서는 어떤 방식으로 반환 된 SSML 형식을 지정 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Speech.Synthesis.PromptBuilder> 개체 텍스트를 추가 하 고 프롬프트의 내용을 하기 전에 프롬프트의 SSML 해당을 콘솔에 씁니다.  
  
```csharp  
  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder style = new PromptBuilder();  
        style.AppendText("Your order for");  
        style.StartStyle(new PromptStyle(PromptRate.Slow));  
        style.AppendText("one kitchen sink and one faucet");  
        style.EndStyle();  
        style.AppendText("has been confirmed.");  
  
        // Write the contents of the PromptBuilder object to the console as  
        // an SSML-compatible XML file.  
        string myXml = style.ToXml();  
        Console.WriteLine("This is the SSML equivalent of the PromptBuilder: \n\n" + myXml);  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(style);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>