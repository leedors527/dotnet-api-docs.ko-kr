<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="26b6e3e6ad44db4a25f71289e07f95f0bbd7071b" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875452" /></Metadata><TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>변경할 수 없는 정규식을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> 클래스는.NET Framework의 정규식 엔진을 나타냅니다. 신속 하 게 많은 양의 특정 문자 패턴; 찾을 텍스트를 구문 분석에 사용할 수 있습니다. 추출, 편집, 바꾸기 또는 텍스트 부분 문자열을 삭제 하려면 및 보고서를 생성 하려면 컬렉션에 추출된 된 문자열을 추가 합니다.  
  
> [!NOTE]
>  주요 관심사 인 문자열을 특정 패턴을 따르는지 확인 하 여 유효성을 검사 하는 경우 사용할 수 있습니다는 <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> 클래스입니다.  
  
 에 설명 된 구문을 사용 하 여 텍스트 스트림에 식별 하려고 하는 패턴을 정의 하면 정규식을 사용 하려면 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 필요에 따라 인스턴스화할 수 있습니다 다음으로 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 마지막으로, 정규식 패턴과 일치 하는 텍스트를 바꾸거나 식별 패턴 일치와 같은 일부 작업을 수행 하는 메서드를 호출 합니다.  
  
> [!NOTE]
>  몇 가지 일반적인 정규식 패턴에 대 한 참조 [정규식 예제](~/docs/standard/base-types/regular-expression-examples.md)합니다. 또한에 같은 정규식 패턴의 온라인 라이브러리는 여러 가지 [일반 Expressions.info](https://www.regular-expressions.info/examples.html)합니다.  
  
<a name="remarks"></a> 사용에 대 한 자세한 내용은 <xref:System.Text.RegularExpressions.Regex> 클래스,이 항목의 다음 섹션을 참조 하세요.  
  
-   [Regex vs입니다. 문자열 처리 메서드](#regex_vs_string)  
  
-   [정적 포트 대 인스턴스 메서드](#static_vs_instance)  
  
-   [정규식 작업을 수행합니다.](#regex_ops)  
  
-   [시간 제한 값을 정의합니다.](#define_timeout)  
  
 정규식 언어에 대한 자세한 내용은 [정규식 언어 - 빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)를 참조하거나, 다음 브로슈어 중 하나를 다운로드하여 인쇄하세요.  
  
 [Word(.docx) 형식의 빠른 참조](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [PDF(.pdf) 형식의 빠른 참조](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Regex vs입니다. 문자열 처리 메서드  
 <xref:System.String?displayProperty=nameWithType> 클래스는 텍스트를 사용한 패턴 일치를 수행 하는 데 사용할 수 있는 몇 가지 검색 및 비교 메서드를 포함 합니다. 예를 들어 합니다 <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, 및 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 메서드 문자열 인스턴스입니다; 지정된 된 부분 문자열에 포함 되는지 여부를 확인 및 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>를 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, 및 <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> 메서드 시작을 반환 문자열에서 지정된 된 부분 문자열의 위치입니다. 메서드를 사용 합니다 <xref:System.String?displayProperty=nameWithType> 특정 문자열 검색 하는 클래스입니다. 사용 된 <xref:System.Text.RegularExpressions.Regex> 문자열에서 특정 패턴을 검색 하는 클래스입니다. 자세한 내용 및 예제를 참조 하세요 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md)합니다.  
  
 [주의 돌아가기](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>정적 포트 대 인스턴스 메서드  
 정규식 패턴을 정의한 후에 두 가지 방법 중 하나로 정규식 엔진에 제공할 수 있습니다.  
  
-   인스턴스화하여는 <xref:System.Text.RegularExpressions.Regex> 정규식을 나타내는 개체입니다. 정규식 패턴을 전달 하면이 작업을 수행 하는 <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> 생성자입니다. A <xref:System.Text.RegularExpressions.Regex> 개체를 변경할 수 없는; 인스턴스화하는 경우는 <xref:System.Text.RegularExpressions.Regex> 개체는 정규식을 사용 하 여 개체의 정규식을 변경할 수 없습니다.  
  
-   정규식 및 검색 하 여 텍스트를 제공 하 여는 `static` (`Shared` Visual basic에서) <xref:System.Text.RegularExpressions.Regex> 메서드. 이렇게 하면 명시적으로 만들지 않고 정규식을 사용 하는 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 모든 <xref:System.Text.RegularExpressions.Regex> 패턴 식별 메서드 모두 정적 등 인스턴스 오버 로드 합니다.  
  
 정규식 엔진이 패턴을 사용 하려면 특정 패턴을 컴파일해야 합니다. 때문에 <xref:System.Text.RegularExpressions.Regex> 개체를 변경할 수 없는, 발생 하는 일회성 절차와 때를 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자 또는 정적 메서드 호출 됩니다. 반복 해 서 단일 정규식을 컴파일할 필요가 제거 하려면 정규식 엔진은 정적 메서드 호출에 사용 되는 컴파일된 정규식을 캐시 합니다. 결과적으로, 정규식 패턴 일치 메서드가 인스턴스 메서드와 정적 비슷한 성능을 제공합니다.  
  
> [!IMPORTANT]
>  .NET Framework 버전 1.0 및 1.1에서는 모든 컴파일된 정규식을 여부를 적이 인스턴스 또는 정적 메서드 호출에 캐시 된 합니다. .NET Framework 2.0부터 정규식만 정적 메서드 호출에 사용 되는 캐시 됩니다.  
  
 그러나 캐싱 저하 될 수 있습니다 다음 두 가지 경우에는 성능:  
  
-   때 많은 수의 정규식을 사용 하 여 정적 메서드 호출을 사용합니다. 기본적으로 정규식 엔진은 15 가장 최근에 사용된 된 정적 정규식을 캐시합니다. 15 개 이상의 정적 정규식을 사용 하는 응용 프로그램에서 일부 정규식을 컴파일해야 합니다. 이 재컴파일을 방지를 늘릴 수 있습니다는 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> 속성입니다.  
  
-   인스턴스화하는 경우 새 <xref:System.Text.RegularExpressions.Regex> 이전에 컴파일된 정규식을 사용 하 여 개체입니다. 예를 들어, 다음 코드는 텍스트 스트림에 중복 된 단어를 찾는 정규식을 정의 합니다. 이 예제에서는 단일 정규식을 사용 하지만 새 인스턴스화합니다 <xref:System.Text.RegularExpressions.Regex> 각 텍스트 줄을 처리 하는 개체입니다. 이 루프의 각 반복을 사용 하 여 정규식을 컴파일할 때에서 발생합니다.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     재컴파일을 방지 하려면 단일 인스턴스화해야 <xref:System.Text.RegularExpressions.Regex> 다시 쓴 다음 예제에서와 같이, 필요한 모든 코드에 액세스할 수 있는 개체입니다.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [주의 돌아가기](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>정규식 작업을 수행합니다.  
 인스턴스화를 업그레이드할지 여부를 <xref:System.Text.RegularExpressions.Regex> 개체 및 해당 메서드를 호출 하거나 정적 메서드를 호출 합니다 <xref:System.Text.RegularExpressions.Regex> 클래스에 다음 패턴 일치 하는 기능 제공:  
  
-   일치 하는 항목의 유효성을 검사 합니다. 호출 하 여 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 일치 하는 항목이 있는지 여부를 결정 하는 방법입니다.  
  
-   단일 일치 항목의 검색입니다. 호출 하는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 검색 하는 메서드를 <xref:System.Text.RegularExpressions.Match> 나 부분 문자열로 문자열의 첫 번째 일치 항목을 나타내는 개체입니다. 호출 하 여 후속 일치 항목을 검색할 수는 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드.  
  
-   모든 일치 항목의 검색입니다. 호출 하는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 검색 하는 메서드를 <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> 나 부분 문자열로 문자열에서 찾은 모든 일치 항목을 나타내는 개체입니다.  
  
-   일치 하는 텍스트를 대체 합니다. 호출 하 여 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 일치 하는 텍스트를 대체 하는 방법입니다. 정규식에 의해 대체 텍스트를 정의할 수도 있습니다. 또한 일부는 <xref:System.Text.RegularExpressions.Regex.Replace%2A> 메서드를 포함을 <xref:System.Text.RegularExpressions.MatchEvaluator> 매개 변수를 프로그래밍 방식으로 바꿀 텍스트를 정의할 수 있습니다.  
  
-   입력된 문자열의 부분에서 구성 되는 문자열 배열 생성 합니다. 호출 된 <xref:System.Text.RegularExpressions.Regex.Split%2A> 정규식에 정의 된 위치에 있는 입력된 문자열을 분할 하는 방법입니다.  
  
 패턴 일치 메서드에 해당 하는 것 외에도 <xref:System.Text.RegularExpressions.Regex> 클래스는 몇 가지 특수 한 용도의 메서드를 포함 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드는 정규식 또는 입력된 문자열에서 정규식 연산자로 해석 될 수 있는 모든 문자를 이스케이프 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드 이러한 이스케이프 문자를 제거 합니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 메서드는 미리 정의 된 정규식이 포함 된 어셈블리를 만듭니다. 이러한 특수 한 용도의 어셈블리의 예제를 포함 하는.NET Framework는 <xref:System.Web.RegularExpressions?displayProperty=nameWithType> 네임 스페이스입니다.  
  
 [주의 돌아가기](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>시간 제한 값을 정의합니다.  
 .NET Framework는 상당한 기능과 유연성에 패턴 일치를 제공 하는 모든 기능을 갖춘 정규식 언어를 지원 합니다. 그러나 강력 함과 유연성 대가가: 성능 저하 위험이 있습니다. 불완전 하 게 수행 하는 정규식은 매우 쉽게 만들 수 있습니다. 일부 경우에 정규식 패턴과 거의 일치 하는 텍스트를 처리할 때 응답 하지 않는 것 과도 한 역 추적에 의존 하는 정규식 작업 나타날 수 있습니다. .NET Framework 정규식 엔진에 대 한 자세한 내용은 참조 하세요. [세부 정보 정규식 동작](~/docs/standard/base-types/details-of-regular-expression-behavior.md)합니다. 과도 한 역 추적 하는 방법에 대 한 자세한 내용은 참조 하십시오 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], 일치 하는 정규식에 대 한 시간 제한 간격을 정의할 수 있습니다. 정규식 엔진이이 시간 간격 내에서 일치 하는 항목을 식별할 수 없습니다, 하는 경우 일치 하는 작업에서는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 대부분의 경우에서 이렇게 하면 정규식 엔진에서 정규식 패턴과 거의 일치 하는 텍스트와 일치 하 여 처리 능력을 낭비 됩니다. 그러나 것도 나타낼 수 있습니다, 시간 제한 간격을이 설정 되어 있는지를 너무 낮게 또는 현재 컴퓨터 부하에 저하는 전반적인 성능.  
  
 예외를 처리 하는 방법을 예외의 원인에 따라 달라 집니다. 시간 제한 간격이 너무 낮게 설정 되어 있기 때문에 예외가 발생 하는 경우, 과도 한 컴퓨터 부하로 인해 시간 제한 간격을 늘리고 일치 하는 작업을 다시 시도 수 있습니다. 예외는 정규식 과도 한 역 추적에 의존 하기 때문에 발생 하는 경우에 일치 하는 존재 하지 않는 하 고, 필요에 따라 정규식 패턴을 수정 하는 데 도움이 되는 정보를 기록할 수 있습니다를 가정할 수 있습니다.  
  
 호출 하 여 시간 제한 간격을 설정할 수 있습니다는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> regular expression 개체를 인스턴스화할 때 생성자입니다. 정적 메서드의 경우에 일치 하는 메서드 오버 로드를 호출 하 여 시간 제한 간격을 설정할 수 있습니다는 `matchTimeout` 매개 변수입니다. 시간 제한 값을 명시적으로 설정 하지 않으면 기본 시간 제한 값이 다음과 같이 결정 됩니다.  
  
-   응용 프로그램 수준 시간 제한을 사용 하 여 값 하나 있습니다. 이 응용 프로그램 도메인에 적용 되는 제한 시간 값 수는 <xref:System.Text.RegularExpressions.Regex> 개체가 인스턴스화되거나 정적 메서드를 호출 합니다. 호출 하 여 응용 프로그램 수준 시간 제한 값을 설정할 수 있습니다는 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> 의 문자열 표현에 할당할 메서드를 <xref:System.TimeSpan> "REGEX_DEFAULT_MATCH_TIMEOUT" 속성 값입니다.  
  
-   값을 사용 하 여 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>없는 응용 프로그램 수준 시간 제한 값이 설정 된 경우.  
  
> [!IMPORTANT]
>  모든 정규식 패턴 일치 작업의 제한 시간 값을 설정 하는 것이 좋습니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md)합니다.  
  
 [주의 돌아가기](#remarks)  
  
   
  
## Examples  
 다음 예제에서는 문자열에서 단어의 반복 된 발생에 대 한 확인 하려면 정규식을 사용 합니다. 정규식 `\b(?<word>\w+)\s+(\k<word>)\b` 다음 표와에서 같이 해석 될 수 있습니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작 합니다.|  
|`(?<word>\w+)`|단어 경계까지 하나 이상의 단어 문자를 찾습니다. 이 캡처된 그룹의 이름을 `word`입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|`(\k<word>)`|라는 캡처된 그룹을 일치 `word`합니다.|  
|`\b`|단어 경계를 찾습니다.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 다음 예제에서는 문자열에 통화 값을 나타내는 또는 통화 값을 나타내는 올바른 형식이 있는지 여부를 확인 하는 정규식을 사용을 하는 방법을 보여 줍니다. 이 경우 정규식에서 동적으로 작성 됩니다 합니다 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>를 <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, 및 <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> 사용자의 현재 문화권에 대 한 속성입니다. 시스템의 현재 문화권이 EN-US, 결과 정규식이 `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`합니다. 이 정규식은 다음 표와에서 같이 해석할 수 있습니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분부터 시작 합니다.|  
|`\s*`|0개 이상의 공백 문자가 일치하는지 확인합니다.|  
|`[\+-]?`|양수 부호 또는 음수 기호를 0 또는 1 개를 찾습니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`\$?`|달러 기호 0 또는 1 개를 찾습니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`\d*`|0번 이상 나오는 10진수를 찾습니다.|  
|`\.?`|0 개 이상의 소수점 기호를 찾습니다.|  
|`\d{2}?`|두 개의 10 진수를 0 번 이상 일치 합니다.|  
|`(\d*\.?\d{2}?){1}`|적어도 한 번 소수점 기호로 구분 된 정수 및 소수 자릿수 패턴과 일치 합니다.|  
|`$`|문자열의 끝을 찾습니다.|  
  
 정규식 유효한 통화 문자열로 그룹 구분 기호가 없습니다 및 현재 문화권에 의해 정의 된 소수 자릿수 또는 소수 자릿수 없이 있음을 가정 하는 예제의 경우 <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> 속성입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 이 예제에서 정규식을 동적으로 작성 하기 때문에 파악 하지 못해도 디자인 타임에 현재 문화권의 통화 기호, 소수점 기호 또는 양수 기호와 음수 기호를 정기적으로 정규식 엔진의 잘못 해석 될 수 있는지 여부를 식 언어 연산자입니다. 잘못 된 해석을 방지 하려면 예제는 각 동적으로 생성 된 문자열을 전달 합니다 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드.  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Text.RegularExpressions.Regex" /> 클래스를 변경할 수 없는 (읽기 전용) 및 스레드로부터 안전 합니다. <see cref="T:System.Text.RegularExpressions.Regex" /> 개체 모든 스레드에서 만들고 스레드 간에 공유할 수 있습니다. 자세한 내용은 [스레드 보안](~/docs/standard/base-types/thread-safety-in-regular-expressions.md)합니다.</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">.NET Framework 정규식</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">정규식 - 빠른 참조(Word 형식으로 다운로드)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">정규식 - 빠른 참조(PDF 형식으로 다운로드)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 하 게 보호; 참고 파생 된 클래스 에서만 호출할 수는 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 정규 식에 대해 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 호출을 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> 생성자 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 값을 사용 하 여 생성자 <xref:System.Text.RegularExpressions.RegexOptions.None> 에 대 한는 `options` 인수.  
  
 <xref:System.Text.RegularExpressions.Regex> 개체 변경할 수 없는 만들 때 정의한 일치 패턴에만 사용할 수 있음을 의미 합니다. 수 있지만 다시 컴파일하지 않고 임의의 횟수 만큼 사용 합니다.  
  
 이 생성자에 정의 된 모든 영문자의 대/소문자 구분 일치를 시도 하는 정규식 개체를 인스턴스화하고 `pattern`합니다. 대/소문자 일치 항목을 사용 하 여는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 생성자입니다.  
  
   
  
## Examples  
 다음 예제는 문자로 시작 하는 모든 단어와 일치 하는 정규식을 인스턴스화하기 위해이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 참고 정규식 패턴 이라는 단어를 일치할 수 없습니다 "The" 텍스트의 시작 부분에서 기본적으로 대/소문자 구분 비교 되어 있습니다. 대/소문자 구분 비교 예 참조는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />가 <see langword="null" />입니다.</exception>
        <block subset="none" type="usage"><para>이 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 는 만들어진 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다. 응용 프로그램 도메인에 대 한 제한 시간 값을 정의 되지 않은 경우는 <see cref="T:System.Text.RegularExpressions.Regex" /> 값을 사용 하는 개체 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 작업 시간 초과 방지 하는 합니다. 만들기에 대 한 권장 되는 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체가 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">serialize된 패턴과 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 정보가 포함된 개체입니다.</param>
        <param name="context">이 serialization의 대상입니다. 이 매개 변수는 사용되지 않으므로 <see langword="null" />을 지정하세요.</param>
        <summary>serialize된 데이터를 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />에 포함된 패턴이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="info" />에 잘못된 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 플래그가 포함된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">정규식을 수정하는 열거형 값의 비트 조합입니다.</param>
        <summary>패턴을 수정할 수 있는 옵션을 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 <xref:System.Text.RegularExpressions.Regex> 개체 변경할 수 없는 만들 때 정의한 일치 매개 변수에만 사용할 수 있음을 의미 합니다. 수 있지만 다시 컴파일하지 않고 임의의 횟수 만큼 사용 합니다.  
  
   
  
## Examples  
 다음 예제는 문자로 시작 하는 모든 단어와 일치 하는 정규식을 인스턴스화하기 위해이 생성자를 사용 하는 방법 "a" 또는 "t"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Match 컬렉션 때문에 텍스트를 시작 하는 "The" 라는 단어를 포함 하는 참고를 `options` 매개 변수가 대/소문자 구분 비교를 정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />에 잘못된 플래그가 포함된 경우</exception>
        <block subset="none" type="usage"><para>이 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 는 만들어진 응용 프로그램 도메인의 기본 제한 시간 값을 사용 하는 개체입니다. 응용 프로그램 도메인에 대 한 제한 시간 값을 정의 되지 않은 경우는 <see cref="T:System.Text.RegularExpressions.Regex" /> 값을 사용 하는 개체 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 작업 시간 초과 방지 하는 합니다. 만들기에 대 한 권장 되는 생성자는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체가 <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">정규식을 수정하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>시간이 초과되기 전에 패턴 일치 메서드가 일치하도록 시도해야 하는 시간을 지정한 패턴과 값을 수정할 수 있는 옵션을 사용하여 <see cref="T:System.Text.RegularExpressions.Regex" /> 클래스의 새 인스턴스를 지정된 정규식에 대해 초기화하고 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조는 [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md) 항목입니다.  
  
 <xref:System.Text.RegularExpressions.Regex> 개체 변경할 수 없는 만들 때 정의한 일치 패턴에만 사용할 수 있음을 의미 합니다. 수 있지만 다시 컴파일하지 않고 임의의 횟수 만큼 사용 합니다.  
  
 `matchTimeout` 매개 변수 지정 시간에 패턴 일치 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 패턴 일치 메서드가 throw 하는 해당 시간 간격에 일치 하는 항목이 있으면는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값 재정의 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 관찰 하는 인스턴스 패턴 일치 메서드를 `matchTimeout` 시간 제한 간격은 다음과 같습니다.  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 입력을 처리할 때 응답을 중지 하도록 표시에서 과도 한 역 추적에 의존 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 적절 한 시간 제한 간격을 설정 하려면 다음 요소를 고려 합니다.  
  
-   길이 복잡성 정규식 패턴입니다. 길고 복잡 한 정규식 짧고 간단 것 보다 더 많은 시간이 필요합니다.  
  
-   예상된 머신 로드 합니다. 처리 시간이 더 높은 CPU 및 메모리 사용률을 가진 시스템입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 인스턴스화하는 생성자를 <xref:System.Text.RegularExpressions.Regex> 1 초의 시간 제한 값을 가진 개체입니다. 줄의 끝에 하나 이상의 "a" 문자가 포함된 하나 이상의 시퀀스와 일치하는 정규식 패턴 `(a+)+$`는 과도한 역추적의 대상이 됩니다. 경우는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 는 throw 예제에서는 최대 3 초 값까지 제한 시간 값을 늘립니다. 이 고, 그렇지는 패턴 일치를 시도 중단 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="pattern" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />는 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">역추적</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컴파일된 정규식에 대한 현재 정적 캐시의 최대 엔트리 수를 가져오거나 설정합니다.</summary>
        <value>현재 정적 캐시의 최대 엔트리 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex> 클래스에 정적 메서드 호출에 사용 된 컴파일된 정규식의 내부 캐시를 유지 관리 합니다. Set 작업에서 지정 된 값을 사용 하면 현재 캐시 크기 보다 작으면, 캐시 크기를 지정 된 값과 같으면 될 때까지 캐시 항목 삭제 됩니다.  
  
 기본적으로 캐시 15 개의 컴파일된 정적 정규식을 포함 합니다. 응용 프로그램이 일반적으로 경우 캐시의 크기를 수정 하려면 사용 된 <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> 캐싱 나 매우 큰 캐시를 설치한 경우 해제 하려는 경우에 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Set 작업의 값이 0보다 작습니다.</exception>
        <block subset="none" type="usage"><para>이전에.NET framework는 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], 모두 정적에서 정규식 사용 및 캐시 된 인스턴스 메서드 호출 합니다. 부터는 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)]만 일반 정적 메서드 호출에 사용 되는 식은 캐시 됩니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</summary>
        <value>명명된 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 보호 되 고; 참고 파생 된 클래스에서 액세스할 수만 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 Set 작업에서 속성에 할당 된 값으로 변환 하려고를 <xref:System.Collections.Hashtable> 개체;이 변환에 실패 하면 호출 된 <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> 속성에 할당된 값은 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전을 가져오거나 설정합니다.</summary>
        <value>번호가 매겨진 캡처링 그룹을 인덱스 값에 매핑하는 사전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 보호 되 고; 참고 파생 된 클래스에서 액세스할 수만 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
 Set 작업에서 속성에 할당 된 값으로 변환 하려고를 <xref:System.Collections.Hashtable> 개체;이 변환에 실패 하면 호출 된 <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> 속성에 할당된 값은 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식을 컴파일하고 단일 어셈블리의 디스크에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

.NET Core에서 호출 된 `Regex.CompileToAssembly` 메서드가 throw를 <xref:System.PlatformNotSupportedException>; 어셈블리를 작성할 수 없습니다. 합니다.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <summary>하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> 메서드는 각에 정의 된 정규식에.NET Framework 어셈블리를 생성 합니다 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 것을 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 하 고 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 분리 된 응용 프로그램에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만듭니다. 어셈블리는 두 개의 컴파일된 정규식을 포함합니다. 첫 번째 `Utilities.RegularExpressions.DuplicatedString`, 동일한 두 개의 인접 한 단어를 찾습니다. 두 번째 `Utilities.RegularExpressions.EmailAddress`, 문자열에 올바른 형식으로 전자 메일 주소 수 있는지 여부를 확인 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 이 두 번째 예제의 컴파일이 성공 하면 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  
  
또는 
<paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage"><para>시스템에서 개발 하는 경우 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]를 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 컴파일된 정규식을 포함 하는 어셈블리를 만드는 방법. 에 시스템에서 어셈블리에 정규식 중 하나를 사용 하는 동안 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외를 throw 합니다. 이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다. 
-시스템에서 컴파일된 정규식을 포함 하는 어셈블리를 빌드 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전이 설치 된 대신 합니다.  
  
-대신 호출 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 하거나 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 사용 하 여 메서드를 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션을 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체 또는 정규식을 호출 패턴 일치 하는 메서드.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">컴파일 및 다시 사용</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <param name="attributes">어셈블리에 적용할 특성을 정의하는 배열입니다.</param>
        <summary>지정된 특성을 사용하여 하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> 메서드는 각에 정의 된 정규식에.NET Framework 어셈블리를 생성 합니다 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 것을 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 하 고 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 분리 된 응용 프로그램에 있습니다.  
  
 때문에 합니다 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 메서드는 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 합니다 (같은 `class` C# 또는 `Class`...`End Class` Visual basic의 경우)이 개발 언어의 표준 특성 구문을 사용 하 여 어셈블리에 할당 될.NET Framework 특성 허용 하지 않습니다. `attributes` 매개 변수는 어셈블리에 적용 되는 특성을 정의 하는 대체 방법을 제공 합니다. 어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.  
  
1.  배열을 만들어 <xref:System.Type> 호출 하려는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
2.  검색을 <xref:System.Type> 새 어셈블리에 적용 하려는 특성 클래스를 나타내는 개체입니다.  
  
3.  호출을 <xref:System.Type.GetConstructor%2A> 특성의 메서드 <xref:System.Type> 검색할 개체를 <xref:System.Reflection.ConstructorInfo> 호출 하려는 특성 생성자를 나타내는 개체입니다. 전달 된 <xref:System.Type.GetConstructor%2A> 메서드는 array의 <xref:System.Type> 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
4.  만들기는 <xref:System.Object> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.  
  
5.  인스턴스화하는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 생성자에 전달 하 여 개체를 <xref:System.Reflection.ConstructorInfo> 3 단계에서 개체 검색 및 <xref:System.Object> 4 단계에서 만든 배열 합니다.  
  
 이러한 배열을 전달할 수 있습니다 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체 대신 합니다 `attributes` 매개 변수는 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 RegexLib.dll 이라는 어셈블리를 만들고 적용 합니다 <xref:System.Reflection.AssemblyTitleAttribute> 특성을 합니다. 어셈블리는 두 개의 컴파일된 정규식을 포함합니다. 첫 번째 `Utilities.RegularExpressions.DuplicatedString`, 동일한 두 개의 인접 한 단어를 찾습니다. 두 번째 `Utilities.RegularExpressions.EmailAddress`, 문자열에 올바른 형식으로 전자 메일 주소 수 있는지 여부를 확인 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 중인지 확인할 수 있습니다는 <xref:System.Reflection.AssemblyTitleAttribute> 특성이 ILDasm 같은 리플렉션 유틸리티를 사용 하 여 해당 매니페스트를 검사 하 여 어셈블리에 적용 되었습니다.  
  
 중복 된 단어에 대 한 문자열을 검사 하는 정규식은 다음 의해 인스턴스화되어 사용 되며 다음 예제에서는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 이 두 번째 예제의 컴파일이 성공 하면 프로젝트에 추가할 RegexLib.dll (첫 번째 예제에서 생성 된 어셈블리)에 대 한 참조가 필요 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  
  
또는 
<paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage"><para>시스템에서 개발 하는 경우 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]를 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 컴파일된 정규식을 포함 하는 어셈블리를 만드는 방법. 에 시스템에서 어셈블리에 정규식 중 하나를 사용 하는 동안 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외를 throw 합니다. 이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다. 
-시스템에서 컴파일된 정규식을 포함 하는 어셈블리를 빌드 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전이 설치 된 대신 합니다.  
  
-대신 호출 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 하거나 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 사용 하 여 메서드를 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션을 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체 또는 정규식을 호출 패턴 일치 하는 메서드.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">컴파일 및 다시 사용</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="resourceFile" Type="System.String" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="regexinfos">컴파일할 정규식을 설명하는 배열입니다.</param>
        <param name="assemblyname">어셈블리의 파일 이름입니다.</param>
        <param name="attributes">어셈블리에 적용할 특성을 정의하는 배열입니다.</param>
        <param name="resourceFile">어셈블리에 포함될 Win32 리소스 파일의 이름입니다.</param>
        <summary>지정된 특성을 사용하여 하나 이상의 지정된 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체와 지정된 리소스 파일을 명명된 어셈블리로 컴파일합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 메서드는 각에 정의 된 정규식에.NET Framework 어셈블리를 생성 합니다 `regexinfos` 배열 클래스로 표현 됩니다. 일반적으로 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 컴파일된 정규식의 어셈블리를 생성 하는 별도 응용 프로그램에서 메서드를 호출 합니다. 어셈블리에 포함 된 각 정규식에는 다음과 같은 특징이 있습니다.  
  
-   파생 된 것을 <xref:System.Text.RegularExpressions.Regex> 클래스입니다.  
  
-   정의 된 정규화 된 이름이 할당 됩니다는 `fullnamespace` 하 고 `name` 해당 매개 변수 <xref:System.Text.RegularExpressions.RegexCompilationInfo> 개체입니다.  
  
-   (또는 매개 변수가 없는) 기본 생성자입니다.  
  
 일반적으로 코드를 인스턴스화하고 컴파일된 정규식을 사용 하는 어셈블리 또는 어셈블리를 만드는 코드에서 분리 된 응용 프로그램에 있습니다.  
  
 때문에 합니다 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> 메서드는 특정 언어의 클래스 정의 키워드를 사용 하는 대신 메서드 호출에서.NET Framework 어셈블리를 생성 합니다 (같은 `class` C# 또는 `Class`...`End Class` Visual basic의 경우)이 개발 언어의 표준 특성 구문을 사용 하 여 어셈블리에 할당 될.NET Framework 특성 허용 하지 않습니다. `attributes` 매개 변수는 어셈블리에 적용 되는 특성을 정의 하는 대체 방법을 제공 합니다. 어셈블리에 적용 하려는 각 특성에 대해 다음을 수행 합니다.  
  
1.  배열을 만들어 <xref:System.Type> 호출 하려는 특성 생성자의 매개 변수 형식을 나타내는 개체입니다.  
  
2.  검색을 <xref:System.Type> 새 어셈블리에 적용 하려는 특성 클래스를 나타내는 개체입니다.  
  
3.  호출을 <xref:System.Type.GetConstructor%2A> 특성의 메서드 <xref:System.Type> 검색할 개체를 <xref:System.Reflection.ConstructorInfo> 호출 하려는 특성 생성자를 나타내는 개체입니다. 전달 된 <xref:System.Type.GetConstructor%2A> 메서드는 array의 <xref:System.Type> 생성자의 매개 변수 형식을 나타내는 개체  
  
4.  만들기는 <xref:System.Object> 특성의 생성자에 전달할 매개 변수를 정의 하는 배열입니다.  
  
5.  인스턴스화하는 <xref:System.Reflection.Emit.CustomAttributeBuilder> 생성자에 전달 하 여 개체를 <xref:System.Reflection.ConstructorInfo> 3 단계에서 개체 검색 및 <xref:System.Object> 4 단계에서 만든 배열 합니다.  
  
 이러한 배열을 전달할 수 있습니다 <xref:System.Reflection.Emit.CustomAttributeBuilder> 개체 대신 합니다 `attributes` 매개 변수를 [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%2CSystem.String%29 > 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyname" /> 매개 변수의 <see cref="P:System.Reflection.AssemblyName.Name" /> 속성 값이 비어 있거나 null 문자열인 경우  
  
또는 
<paramref name="regexinfos" />에 있는 개체 중 하나 이상의 정규식 패턴에 잘못된 구문이 포함된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyname" /> 또는 <paramref name="regexinfos" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><paramref name="resourceFile" /> 매개 변수가 잘못된 Win32 리소스 파일을 지정합니다.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="resourceFile" /> 매개 변수가 지정된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core만 해당: 컴파일된 정규식의 어셈블리 만들기는 지원되지 않습니다.</exception>
        <block subset="none" type="usage"><para>시스템에서 개발 하는 경우 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 대상 설치 해당 포인트 릴리스 또는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]를 사용 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 컴파일된 정규식을 포함 하는 어셈블리를 만드는 방법. 에 시스템에서 어셈블리에 정규식 중 하나를 사용 하는 동안 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 예외를 throw 합니다. 이 문제를 해결하기 위해서는 다음 중 하나를 수행합니다. 
-시스템에서 컴파일된 정규식을 포함 하는 어셈블리를 빌드 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 이상 버전이 설치 된 대신 합니다.  
  
-대신 호출 하는 <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> 사용 하거나 정적 또는 인스턴스를 어셈블리에서 컴파일된 정규식을 검색 하 고 <see cref="T:System.Text.RegularExpressions.Regex" /> 사용 하 여 메서드를 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 인스턴스화할 때 옵션을 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체 또는 정규식을 호출 패턴 일치 하는 메서드.</para></block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">컴파일 및 다시 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">변환할 텍스트가 포함된 입력 문자열입니다.</param>
        <summary>문자(\\, *, +, ?, |, {, [, (,), ^, $,., # 및 공백)의 최소 집합을 자체 이스케이프 코드로 대체하여 이스케이프합니다. 이렇게 하면 정규식 엔진은 이러한 문자를 메타문자가 아니라 문자 그대로 해석합니다.</summary>
        <returns>메타문자가 이스케이프 서식으로 변환된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 정규식 엔진은 메타 문자 리터럴로 포함할 수 있는 모든 문자를 해석할 수 있도록 하는 문자열을 변환 합니다. 예를 들어, 정규식을 직접 열고 닫는 대괄호 ([및]) 텍스트에서 구분 되는 메모를 추출 하도록 디자인 된 것이 좋습니다. 다음 예제에서는 정규식에에서 "[(.*?)]"은 문자 클래스도 해석 됩니다. 정규식 입력된 텍스트에 포함 된 주석과 일치 하는 대신 각 열기 또는 닫는 괄호, 기간, 별표 또는 물음표를 찾습니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 그러나 전달 하 여 여는 대괄호는 이스케이프를 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드는 입력된 문자열에 포함 된 주석과 일치 하는 정규식 성공 합니다. 다음은 이에 대한 예입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 정적 텍스트를 사용 하 여 정의 된 정규식을 메타 문자가 아닌 문자 그대로 해석 될 수 있는 문자는 백슬래시 기호를 사용 하 여 앞에 이스케이프 될 수 있습니다 (\\) 및 호출 된 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드. 디자인 타임에 알 수 없는 문자를 사용 하 여 동적으로 정의 된 정규식의 호출을 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메서드는 정규식 엔진에서 해석 하는 개별 문자 리터럴로 대신 구하도록 보다 메타 문자가 있습니다.  
  
> [!NOTE]
>  정규식 패턴에서 숫자 기호 (#) 또는 리터럴 공백 문자를 포함 하는 경우 이스케이프 되어야 사용 하 여 입력된 텍스트 구문 분석 하는 경우는 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션을 사용 합니다.  
  
 하지만 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 직선을 이스케이프 하는 메서드 여는 대괄호 () 여는 중괄호 ({) 문자를 해당 이스케이프 하지 않으면 해당 문자를 닫는 (]}). 대부분의 경우에서 이러한 이스케이프 필요 하지 않습니다. 닫는 대괄호 또는 중괄호 앞에 여는 문자가 해당를 하는 경우 정규식 엔진이를 문자 그대로 해석. 여는 대괄호 또는 중괄호를 메타로 해석 됩니다, 정규식 엔진이 닫는 메타 문자는 첫 번째 해당 해석 합니다. 원하는 동작이 없는 경우 닫는 대괄호 또는 중괄호를 이스케이프 해야 백슬래시를 명시적으로 추가 하 여 (\\) 문자입니다. 아래 그림에 나온 예제 섹션을 참조 하세요.  
  
   
  
## Examples  
 다음 예제에서는 텍스트에서 의견을 추출합니다. 주석을 시작 주석 기호 및 사용자가 선택한 끝 주석 기호를 구분 되는 가정 합니다. 에 전달 되기 이기 때문에 주석 기호를 리터럴로 해석 되어야 하는 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 메타 문자가 해석 없습니다 것을 확인 하는 방법입니다. 또한 예제 닫는 대괄호 (]) 또는 중괄호 (}) 사용자가 입력 끝 주석 기호 인지 여부를 명시적으로 확인 합니다. 이 경우 백슬래시 문자 (\\) 문자 그대로 해석 됩니다 있도록 대괄호 또는 중괄호 앞에 추가 됩니다. 또한이 예제에서는 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 의 중괄호 및 닫는 주석 기호 함께 설명 하는 대신만 메모를 표시 하는 컬렉션입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">정규식의 문자 이스케이프</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버는 <see cref="M:System.Object.Finalize" />를 재정의합니다. 자세한 내용은 해당 항목을 참조하세요.

가비지 수집기에서 <see cref="T:System.Object" />를 회수하기 전에 <see cref="T:System.Object" />가 리소스를 해제하고 다른 정리 작업을 수행할 수 있게 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>정규식에 대한 캡처링 그룹 이름의 배열을 반환합니다.</summary>
        <returns>그룹 이름의 문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 식에서 캡처링 그룹의 이름 사용 하는 문자열 집합을 포함 하는 그룹 이름 컬렉션입니다. 숫자 이름을 캡처링 그룹에 명시적으로 이름이 지정 되지 않은, 경우에 자동으로 할당 됩니다 ("0", "1", "2", "3", 및 등). 그룹 나타내는 정규식 패턴이 일치 하는 모든 텍스트 변수의 이름이 "0"입니다. 컬렉션에 명시적으로 명명 된 그룹 앞에 번호가 매겨진된 그룹 및 명명 된 그룹은 정규식 패턴에서 정의 되는 순서 대로 표시 합니다.  
  
 사용할 수는 <xref:System.Array.Length%2A> 정규식에서 그룹의 수를 확인 하려면이 메서드에서 반환 된 배열에는 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 범용 `ShowMatches` 정규식 그룹과 일치 하는 텍스트의 이름을 표시 하는 메서드입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 이 경우 정규식 패턴에서에서 `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` 간단한 문장, 구문 분석 하 고 해당 첫 번째 단어, 마지막 단어 및 문장 끝을 식별 하는 합니다. 다음 표에서 정규식 패턴이 해석 되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`(?<FirstWord>\w+)`|하나 이상의 단어 문자를 찾습니다. 이 `FirstWord` 명명 된 그룹입니다.|  
|\s?|0회 이상 나오는 공백 문자를 찾습니다.|  
|(\w+)|하나 이상의 단어 문자를 찾습니다. 이 그룹은 두 번째 캡처링 그룹입니다.|  
|\s|공백 문자를 찾습니다.|  
|((\w+)\s)*|공백 뒤에 하나 이상의 단어 문자의 0 개 이상의 항목을 일치 합니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|(? \<LastWord > \w+)?|하나 이상의 단어 문자의 0 개 또는 1 번을 찾습니다. 이 `LastWord` 명명 된 그룹입니다.|  
|(? \<문장 부호 > \p{Po})|해당 유니코드 범주는 문장 부호 문자 다른 합니다. 이 `Punctuation` 명명 된 그룹입니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">정규식의 교체 그룹화 구문</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>배열 내의 그룹 이름에 해당하는 캡처링 그룹 번호의 배열을 반환합니다.</summary>
        <returns>그룹 번호의 정수 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 되지 않은 및 명명 된 캡처링 그룹 수로 액세스할 수 있습니다. 명명 되지 않은 그룹은 왼쪽에서 오른쪽 1부터에 번호가 지정 됩니다. (인덱스 0 (영)에서 캡처링 그룹 전체를 나타냅니다 일치를 합니다.)  명명 된 그룹은 다음 왼쪽에서 번호가 매겨진 한 큰 숫자를 오른쪽부터 수보다 명명 되지 않은 캡처링 그룹입니다.  
  
 문자열 이름으로 참조 하는 대신 해당 번호로 그룹 빠른 액세스를 제공할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\b((?<word>\w+)\s*)+(?<end>[.?!])`, 문장 일치 하는 합니다. 정규식 캡처링 그룹의 세 가지를 포함 합니다: 공백 문자, 따르고는 함께 개별 단어를 캡처하는 명명 되지 않은 그룹을 명명 된 그룹 `word` 문장;에서 개별 단어를 캡처하는 및 이라는 한 그룹 `end` 문장을 끝나는 문장 부호를 캡처하는 합니다. 예제에서는 호출을 <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> 모든 캡처의 숫자를 얻을 메서드 그룹과 다음 캡처된 해당 문자열을 표시 합니다. 또한는 <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 메서드는 특정 번호가 매겨진된 그룹 명명 된 그룹에 해당 하는지 여부를 나타내는 데 사용 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 정규식 패턴은 다음 테이블과 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`(?<word>\w+)`|하나 이상의 단어 문자 일치 및 일치 하는 문자열 이라는 그룹을 할당할 `word`합니다.|  
|`\s*`|0개 이상의 공백 문자가 일치하는지 확인합니다.|  
|`((?<word>\w+)\s*)`|할당 된 `word` 캡처된 그룹 뒤에 있는 캡처된 첫 번째 캡처 그룹에 공백 문자입니다.|  
|`((?<word>\w+)\s*)+`|한 번 이상 나오는 공백 문자가 뒤에 대 한 하나 이상의 단어 문자 패턴과 일치 합니다.|  
|`(?<end>[.?!])`|마침표, 물음표 또는 느낌표를 찾습니다. 일치 하는 문자를 할당 합니다 `end` 캡처링 그룹입니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">정규식의 교체 그룹화 구문</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">해당 그룹 이름으로 변환할 그룹 번호입니다.</param>
        <summary>지정된 그룹 번호에 해당하는 그룹 이름을 가져옵니다.</summary>
        <returns>지정된 그룹 번호에 연결되어 있는 그룹 이름이 포함된 문자열입니다. <paramref name="i" />에 해당하는 그룹 이름이 없는 경우 이 메서드는 <see cref="F:System.String.Empty" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함할 수 있습니다. 번호가 매겨진된 그룹 구문으로 구분 됩니다 (*subexpression*) 정규식에서의 순서에 따라 숫자를 할당 됩니다. 명명 된 그룹 구문으로 구분 됩니다 (?`<` *이름을*`>`*subexpression*) 또는 (?' *이름을*'*subexpression*), 여기서 *이름* 하위를 식별 하는 이름입니다. 자세한 내용은 [그룹화 구문](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)을 참조하세요. <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 메서드 명명 된 그룹 및 정규식에서 서 수 위치를 기준으로 번호가 매겨진된 그룹을 식별 합니다. 서 수 위치 0에는 항상 전체 정규식을 나타냅니다. 번호가 매겨진 모든 그룹은 다음 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 보다 먼저 계산 됩니다.  
  
 경우 `i` 입니다 메서드 명명 된 그룹의 그룹의 이름을 반환 합니다. 경우 `i` 입니다 명명 되지 않은 그룹의 메서드는 숫자의 문자열 표현을 반환 합니다. 예를 들어 경우 `i` 1 메서드를 "1"을 반환 합니다. 하는 경우 `i` 번호가 아닌 캡처링 그룹의 메서드가 반환 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 패턴 일치를 사용 하는 경우이 메서드에서 반환 되는 값 사용할 수를 검색 하는 <xref:System.Text.RegularExpressions.Group> 에서 캡처된 그룹을 나타내는 개체를 <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> 속성입니다. 합니다 <xref:System.Text.RegularExpressions.GroupCollection> 개체를 반환 합니다 <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 미국 도시 이름, 상태 이름 및 우편 번호를 포함 하는 주소 줄 일치 하는 정규식 패턴을 정의 합니다. 이 예제에서는 사용 된 <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> 캡처링 그룹의 이름을 검색 하는 방법입니다. 다음 일치 항목에 대 한 해당 캡처된 그룹을 검색 하려면 이러한 이름을 사용 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|하나 이상의 알파벳 문자 또는 공백 문자를 찾습니다. 이 캡처된 그룹의 이름을 할당 `city`합니다.|  
|`,`|쉼표 (,) 뒤에 공백 문자가 일치 합니다.|  
|`(?<state>[A-Za-z]{2})`|두 알파벳 문자를 찾습니다. 이 캡처된 그룹의 이름을 할당 `state`합니다. 이 그룹에 공백 문자가 따라야 합니다.|  
|`(?<zip>\d{5}(-\d{4})?)`|5 개 숫자 뒤에 하이픈과 4 자리 숫자로 0 개 또는 한 발생 합니다. 이 캡처된 그룹의 이름을 할당 `zip`합니다.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">그룹화 구문</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">해당 그룹 번호로 변환할 그룹 이름입니다.</param>
        <summary>지정된 그룹 이름에 해당하는 그룹 번호를 반환합니다.</summary>
        <returns>지정된 그룹 이름에 해당하는 그룹 번호이거나 <paramref name="name" />이 유효한 그룹 이름이 아닌 경우 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정규식 패턴에 명명 되거나 번호가 매겨진 캡처링 그룹 내의 패턴 일치를 사용 하는 하위 식을 나타내는 포함할 수 있습니다. 번호가 매겨진된 그룹 구문으로 구분 됩니다 (*subexpression*) 정규식에서의 순서에 따라 숫자를 할당 됩니다. 명명 된 그룹 구문으로 구분 됩니다 (?`<` *이름을*`>`*subexpression*) 또는 (?' *이름을*'*subexpression*), 여기서 *이름* 하위를 식별 하는 이름입니다. 자세한 내용은 [그룹화 구문](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)을 참조하세요. <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> 메서드 명명 된 그룹 및 정규식에서 서 수 위치를 기준으로 번호가 매겨진된 그룹을 식별 합니다. 서 수 위치 0에는 항상 전체 정규식을 나타냅니다. 번호가 매겨진 모든 그룹은 다음 정규식 패턴에서의 실제 위치에 관계 없이 명명 된 그룹 보다 먼저 계산 됩니다.  
  
 경우 `name` 메서드가 반환 되는 정규식 패턴에 존재 하는 그룹 번호의 문자열 표현입니다. 경우 `name` 에 따라 명명 된 캡처링 그룹은 정규식 패턴에 있는, 메서드가 해당 번호를 반환 합니다. 비교할 `name` 그룹과 이름은 대/소문자 구분 합니다. 경우 `name` 해당 하지 않는 캡처링 그룹의 이름 또는 메서드가 캡처링 그룹 수의 문자열 표현으로-1을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">그룹화 구문</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>패턴 일치 작업의 시간이 초과되지 않도록 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 클래스 생성자 및 다양 한 일치 하는 정적 메서드 사용은 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 상수 패턴 일치를 찾으려고 시도 시간이 초과 되지 없어야 함을 나타내는를 합니다.  
  
> [!WARNING]
>  정규식 엔진의 제한 시간 값을 설정 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 과도 한 역 추적 정규식 패턴과 거의 일치 하는 텍스트를 처리할 때는 응답 하지 않을에 의존 하는 정규식이 발생할 수 있습니다. 제한 시간을 해제 하는 경우에 과도 한 역 추적이 정규식을 사용 하 고 정규식 패턴과 거의 일치 하는 텍스트를 처리 해야 합니다.  
>   
>  역 추적을 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> 상수 값으로 제공 될 수 있습니다는 `matchTimeout` 다음 멤버의 인수:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">참조가 이미 초기화된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>작업 시간이 초과되기 전에 패턴 일치 작업에서 경과될 수 있는 최대 시간입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식이 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드 유효성을 검사 하는 문자열 또는 문자열 후속 조작에 대 한 해당 문자열을 검색 하지 않고 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 및 다음 후속 조작, 호출에 대 한 검색 되었는지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 문자열이 유효한 부품 번호 인지 확인 하는 방법입니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식의 권한이 있다고 가정 합니다. 4 개의 문자열을 포함 하는 첫 번째 집합에 두 개의 숫자 뒤에 오고 영숫자가 뒤에 영숫자 문자로 구성 되어야 합니다. 3 자로 구성 된 두 번째 집합에는 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에 3 개의 숫자 뒤에 영숫자 문자가 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`\d{2}`|두 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 3 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 뒤에 하이픈 찾고이 패턴의 두 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`$`|줄의 끝에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">검색을 시작할 문자 위치입니다.</param>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식이 지정된 입력 문자열의 지정된 시작 위치에서부터 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드 유효성을 검사 하는 문자열 또는 문자열 후속 조작에 대 한 해당 문자열을 검색 하지 않고 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 및 다음 후속 조작, 호출에 대 한 검색 되었는지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> 문자열이 유효한 부품 번호 인지 확인 하는 방법입니다. 문자열의 콜론 (:) 문자 뒤에 오는 부품 번호를 검색 합니다. <xref:System.String.IndexOf%28System.Char%29> 메서드 다음에 전달 되는 콜론의 위치를 결정 되는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> 메서드. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식의 권한이 있다고 가정 합니다. 4 개의 문자열을 포함 하는 첫 번째 집합에 두 개의 숫자 뒤에 오고 영숫자가 뒤에 영숫자 문자로 구성 되어야 합니다. 3 자로 구성 된 두 번째 집합에는 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에 3 개의 숫자 뒤에 영숫자 문자가 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`\d{2}`|두 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 3 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 뒤에 하이픈 찾고이 패턴의 두 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`$`|줄의 끝에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 정규식이 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드 유효성을 검사 하는 문자열 또는 문자열 후속 조작에 대 한 해당 문자열을 검색 하지 않고 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 및 다음 후속 조작, 호출에 대 한 검색 되었는지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체에 지정 된 정규식 패턴을 사용 하 여 `pattern` 호출 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드. 이 정규식 패턴은 정규식 엔진에서 빠른 검색을 위해 캐시 됩니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 문자열이 유효한 부품 번호 인지 확인 하는 방법입니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식의 권한이 있다고 가정 합니다. 4 개의 문자열을 포함 하는 첫 번째 집합에 두 개의 숫자 뒤에 오고 영숫자가 뒤에 영숫자 문자로 구성 되어야 합니다. 3 자로 구성 된 두 번째 집합에는 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에 3 개의 숫자 뒤에 영숫자 문자가 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|줄의 시작 부분에서 일치 항목 찾기를 시작 합니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`\d{2}`|두 숫자 문자를 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 3 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 뒤에 하이픈 찾고이 패턴의 두 찾습니다.|  
|`[a-zA-Z0-9]`|알파벳 문자 일치 (`a` 를 통해 `z` 또는 `A` 를 통해 `Z`) 또는 숫자입니다.|  
|`$`|줄의 끝에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 정규식이 지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드 유효성을 검사 하는 문자열 또는 문자열 후속 조작에 대 한 해당 문자열을 검색 하지 않고 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 및 다음 후속 조작, 호출에 대 한 검색 되었는지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체에 지정 된 정규식 패턴을 사용 하 여 `pattern` 및 지정 된 정규식 옵션 `options` 호출 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드입니다. 이 정규식 패턴은 정규식 엔진에서 빠른 검색을 위해 캐시 됩니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 문자열이 유효한 부품 번호 인지 확인 하는 방법입니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식의 권한이 있다고 가정 합니다. 4 개의 문자열을 포함 하는 첫 번째 집합에 두 개의 숫자 뒤에 오고 영숫자가 뒤에 영숫자 문자로 구성 되어야 합니다. 3 자로 구성 된 두 번째 집합에는 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에 3 개의 숫자 뒤에 영숫자 문자가 있어야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분에서 검색을 시작합니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`\d{2}`|두 숫자 문자를 찾습니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 3 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|하이픈과 3 개 숫자 문자를 찾아이 패턴의 2 개를 일치 시 키...|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`$`|문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.|  
  
 호출을 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 `options` 매개 변수 설정 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 다음 정규식을 정의 하는 것과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 반면에 대 한 예제를 참조 하세요.를 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />는 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 확인 하는 데 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 정규식이 지정된 일치 옵션 및 시간 제한 간격을 사용하여 지정된 입력 문자열에서 일치하는 항목을 찾을 것인지 여부를 나타냅니다.</summary>
        <returns>정규식에서 일치하는 항목을 찾으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> 메서드 유효성을 검사 하는 문자열 또는 문자열 후속 조작에 대 한 해당 문자열을 검색 하지 않고 특정 패턴을 준수 하는지 확인 하려면 일반적으로 사용 됩니다. 하나 이상의 문자열 정규식 패턴과 일치 및 다음 후속 조작, 호출에 대 한 검색 되었는지 확인 하려는 경우는 <xref:System.Text.RegularExpressions.Regex.Match%2A> 또는 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체에 지정 된 정규식 패턴을 사용 하 여 `pattern` 및 지정 된 정규식 옵션 `options` 호출 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> 인스턴스 메서드입니다. 이 정규식 패턴은 정규식 엔진에서 빠른 검색을 위해 캐시 됩니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `matchTimeout` 매개 변수를 지정 시간 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리할 때 응답을 중지 하도록 표시에서 과도 한 역 추적에 의존 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 해당 시간 간격의 일치 하는 항목이 없으면 메서드에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드를 실행 하는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
   
  
## Examples  
 다음 예제를 사용 하는 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 문자열이 유효한 부품 번호 인지 확인 하는 방법입니다. 정규식 부품 번호 세 개의 하이픈으로 구분 된 문자 집합으로 구성 된 특정 형식의 권한이 있다고 가정 합니다. 4 개의 문자열을 포함 하는 첫 번째 집합에 두 개의 숫자 뒤에 오고 영숫자가 뒤에 영숫자 문자로 구성 되어야 합니다. 3 자로 구성 된 두 번째 집합에는 숫자 여야 합니다. 4 자로 구성 된 세 번째 집합에 3 개의 숫자 뒤에 영숫자 문자가 있어야 합니다. 정규식 패턴과 일치 하는 메서드는 500 밀리초의 시간 제한 간격을 설정 하므로 입력된 문자열을 통해 최소한의 검색을 참여 시켜야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 정규식 패턴은 다음과 같습니다.  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|문자열의 시작 부분에서 검색을 시작합니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`\d{2}`|두 숫자 문자를 찾습니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`-`|하이픈을 찾습니다.|  
|`\d{3}`|정확히 3 개의 숫자 문자를 찾습니다.|  
|`(-\d{3}){2}`|세 자리 숫자로, 뒤에 하이픈 찾고이 패턴의 두 찾습니다.|  
|`[A-Z0-9]`|단일 문자와 일치 `A` 를 통해 `Z`, 문자 또는 숫자 문자입니다.|  
|`$`|문자열의 끝 부분에서 일치 항목 찾기를 끝냅니다.|  
  
 호출을 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드를 `options` 매개 변수 설정 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 다음 정규식을 정의 하는 것과 같습니다.  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 반면에 대 한 예제를 참조 하세요.를 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />는 유효한 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값이 아닙니다.  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다.</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>입력 문자열에서 정규식 패턴과 일치하는 부분 문자열을 검색하고 맨 처음 발견되는 항목을 단일 <see cref="T:System.Text.RegularExpressions.Match" /> 개체로 반환합니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 지정된 정규식의 처음 발견되는 항목을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드는 첫 번째 부분을 반환 `input` 정규식 패턴과 일치 하는 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출의 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식 패턴 일치 문자열에서 다음 일치 나열 그룹, 캡처 및 캡처 위치 합니다.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 정규식 패턴 `(\w+)\s+(car)` 함께 앞에 오는 단어 "car" 라는 단어와 일치 합니다. 다음 표와에서 같이 해석 됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`(\w+)`|하나 이상의 단어 문자를 찾습니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\s+`|하나 이상의 공백 문자를 찾습니다.|  
|(자동차)|리터럴 문자열 "car"와 일치 합니다. 이 그룹은 두 번째 캡처링 그룹입니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">검색을 시작할 문자 위치(0부터 시작)입니다.</param>
        <summary>문자열의 지정된 시작 위치에서 시작하여 입력 문자열에서 맨 처음 발견되는 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 또는 후에 시작 하는 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 하는 메서드는 `startat` 문자 입력된 문자열에서 위치 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴은 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 됩니다는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 설정할 수 있는 요소에 대 한 자세한 내용은 참조 하세요. [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 사용 하 여 문자열의 시작 위치를 지정할 수는 `startat` 매개 변수입니다. 정규식 엔진은 왼쪽에서 오른쪽 (기본값) 구문 분석 하는 경우 일치 및 검색은 이동, 패턴에 지정 된 문자에서 시작 `startat`합니다. 오른쪽에서 왼쪽으로 정규식 엔진은 구문 분석 하는 경우 (정규식 패턴을 사용 하 여 생성 되는 경우는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션), 일치 및 검색 반대 방향으로 이동 하 고 있는 문자를 사용 하 여 시작 `startat` -1입니다. 기본에서 검색이 시작 된 시작 위치를 지정 하지 않으면 경우 `startat` 위치 합니다. 정규식이 왼쪽에서 오른쪽, 기본 검색 하는 경우 `startat` 의 왼쪽 끝 위치가 `input`오른쪽에서 검색 하는 경우 왼쪽, 기본값 `startat` 의 오른쪽 끝 위치가 `input`합니다.  
  
 문자열에 특정 문자 위치에서 시작 하 고 정규식 엔진이 문자열의 나머지를 검사 하지 않습니다 있도록 일치 하는 항목을 제한 하려는 경우 고정 된 정규식을 `\G` (왼쪽-오른쪽에서 왼쪽 아래에 패턴 또는 오른쪽에서 왼쪽 패턴에 대 한 오른쪽). 시작 해야 하므로 일치 하는 제한 `startat`합니다.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드 또는 후에 찾을 첫 번째 부분 문자열을 반환 합니다 `startat` 에서 문자 위치 `input` 정규식 패턴과 일치 하는 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출의 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 호출 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드. 이 경우 정규식 엔진이 정규식 패턴을 캐시합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드는 첫 번째 부분을 반환 `input` 정규식 패턴과 일치 하는 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드. 호출 하 여 단일 메서드 호출의 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 메서드를 하나 이상 포함 하는 첫 번째 단어를 찾습니다 `z` 문자를 차례로 호출 합니다 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 추가 일치 항목을 찾을 방법.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 정규식 패턴 `\b\w*z+\w*\b` 는 다음 테이블과 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w*`|0 또는 하나 이상의 단어 문자 일치 합니다.|  
|`z+`|하나 이상의 일치는 `z` 문자입니다.|  
|`\w*`|0 또는 하나 이상의 단어 문자 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 검색 하기 위한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="beginning">검색되는 가장 왼쪽 지점을 정의하는 입력 문자열의 0부터 시작하는 문자 위치입니다.</param>
        <param name="length">검색에 포함시킬 부분 문자열의 문자 수입니다.</param>
        <summary>지정된 시작 위치에서 시작하고 지정된 수의 문자만 검색하여 입력 문자열에서 첫 번째 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는 입력된 문자열의 일부에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정규식 패턴은 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 됩니다는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 설정할 수 있는 요소에 대 한 자세한 내용은 참조 하세요. [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> 부분을 검색 하는 방법 `input` 정의한 합니다 `beginning` 및 `length` 정규식 패턴에 대 한 매개 변수입니다. `beginning` 항상 검색에 포함할 가장 왼쪽 문자 인덱스를 정의 하 고 `length` 검색할 문자의 최대 수를 정의 합니다. 함께 검색의 범위를 정의합니다. 검색 진행 왼쪽에서 오른쪽 (기본값), 정규식 엔진은 인덱스에 있는 문자가에서 찾습니다 `beginning` 문자 인덱스 `beginning`  +  `length` -1입니다. 정규식 엔진을 사용 하 여 인스턴스화된 경우 합니다 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 옵션을 유지 하 고 인덱스에 있는 문자가에서 정규식 엔진에서 검색할 오른쪽에서 검색이 진행 됩니다 `beginning`  +  `length` -1에 문자 인덱스 `beginning`합니다. 이 메서드는이 범위 내에서 발견 되는 첫 번째 일치 항목을 반환 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 메서드.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 값을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="beginning" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우  
  
또는 
 <paramref name="length" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우  
  
또는 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" />이 <paramref name="input" /> 범위 밖에 있는 위치를 식별하는 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 일치 옵션을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체를 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 생성자와 인스턴스 호출 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환 있는 첫 번째 부분 `input` 정규식 패턴과 일치 하는 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 메서드. 호출 하 여 단일 메서드 호출의 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 일치 하는 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
   
  
## Examples  
 문자로 시작 하는 단어와 일치 하는 정규식을 정의 하는 다음 예제에서는 "a"입니다. 사용 된 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 정규식 "a" 및 소문자 모두 대문자를 사용 하 여 시작 하는 단어를 둔다는 옵션 "a"입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 정규식 패턴 `\ba\w*\b` 는 다음 테이블과 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`a`|문자 "a"입니다.|  
|`\w*`|0 또는 하나 이상의 단어 문자 일치 합니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 검색 하기 위한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 일치 옵션 및 제한 시간 간격을 사용하여 입력 문자열에서 첫 번째 지정된 정규식을 검색합니다.</summary>
        <returns>일치에 대한 정보가 포함된 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드는 입력된 문자열에서 정규식 패턴과 일치 하는 첫 번째 부분 문자열을 반환 합니다. 정규식 패턴을 빌드하는 데 언어 요소에 대 한 자세한 내용은 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 정적 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 를 생성 하는 것과 같습니다는 <xref:System.Text.RegularExpressions.Regex> 개체를 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 생성자와 인스턴스 호출 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 반환 된 값을 확인 하 여 입력된 문자열에서 정규식 패턴을 발견 되었는지를 있는지 여부를 확인할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Group.Success%2A> 속성입니다. 일치 하는 항목이 없는 경우 반환 된 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Capture.Value%2A> 속성에서 부분 문자열이 포함 `input` 정규식 패턴과 일치 하는 합니다. 해당 값이 일치 하는 항목이 없으면 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 이 메서드가 반환 있는 첫 번째 부분 `input` 정규식 패턴과 일치 하는 합니다. 반복적으로 반환 된를 호출 하 여 후속 일치 항목을 검색할 수 있습니다 <xref:System.Text.RegularExpressions.Match> 개체의 <xref:System.Text.RegularExpressions.Match.NextMatch%2A> 메서드. 호출 하 여 단일 메서드 호출의 모든 일치 항목을 검색할 수도 있습니다는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드.  
  
 `matchTimeout` 매개 변수를 지정 시간 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리할 때 응답을 중지 하도록 표시에서 과도 한 역 추적에 의존 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 해당 시간 간격의 일치 하는 항목이 없으면 메서드에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드를 실행 하는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>입력 문자열에 있는 정규식을 모두 검색하고 일치 항목을 모두 반환합니다.</summary>
        <block subset="none" type="usage"><para>일치 시도 호출 하 여 반복 되는 경우는 <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> 메서드를 정규식 엔진이 제공 빈 일치 항목 특별 하 게 처리 합니다. 일반적으로 정규식 엔진은 이전 일치 하는 중단 될를 정확 하 게 하 여 다음 일치 항목에 대 한 검색을 시작 합니다. 그러나 빈 일치, 정규식 엔진이 일치 하는 다음을 시도 하기 전에 하나의 문자로 이동 합니다. 이 동작은 문자열을 통해 정규식 엔진은 진행 되는 것을 보장 합니다. 이 고, 그렇지 빈 일치 항목 앞으로 모든 이동 발생 하지 않은, 때문에 일치 하는 다음 이전 일치 항목을 정확히 동일한 위치에서 시작 및 찾게 동일한 빈 문자열입니다.  
  
다음 예제의 정규식 패턴 <c>는 *</c> 문자의 0 개 이상의 항목에 대 한 검색 "abaabb" 문자열에 "a"입니다. 결과 예제에서 출력으로 <see cref="T:System.Text.RegularExpressions.MatchCollection" /> 개체에 포함 되어 6 <see cref="T:System.Text.RegularExpressions.Match" /> 개체입니다. 첫 번째 일치 시도 찾은 첫 번째 "a"입니다. 첫 번째는 첫 번째 b 전에 종료를 일치 하는 위치에 정확 하 게 하는 두 번째 일치 시작 0 개 "a"을 찾아 빈 문자열을 반환 합니다. 두 번째 일치 하는 빈 문자열을 반환 하기 때문에 세 번째 일치는 정확 하 게 일치 하는 두 번째 끝난 지점에서 시작 되지 않습니다. 대신 문자 "b" 첫 번째 후 나중에 시작 합니다. 세 번째 일치 하는 "a"의 두 항목을 찾아 "aa"를 반환 합니다. 네 번째 일치 시도 앞의 두 번째 "b", 세 번째 일치 하는 종료를 시작 하 고 빈 문자열을 반환 합니다. 다섯 번째 일치 시도 다시 진행 한 문자 "b" 세 번째 전에 시작 되 고 빈 문자열을 반환 합니다. 여섯 번째 일치 하는 마지막 "b" 다음에 시작 하 고 빈 문자열을 다시 반환 합니다.  
  
[! 코드 csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! 코드 vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <summary>지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드와 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 단일 일치 하는 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드는 동일 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 컬렉션 일치만을 포함 하 고 첫 번째 비-일치에서 종료 합니다.  
  
 정규식 패턴은 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드 검색 중 하나를 호출 하 여 정의 됩니다는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 설정할 수 있는 요소에 대 한 자세한 내용은 참조 하세요. [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 즉시 채워집니다 컬렉션 발생 시킵니다. 지연 평가 활용 하려면 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 평가 인해 호출을 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> 메서드가 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 경우이 메서드에서 반환 된 개체를 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 속성이 아닙니다 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 하는 작업이 시간 제한 간격을 초과 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> "es"로 끝나는 문장에서 단어를 식별 하는 방법입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 정규식 패턴 `\b\w+es\b` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"을 찾습니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>문자열의 지정된 시작 위치에서 시작하여 지정된 입력 문자열에 있는 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드와 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> 단일 일치 하는 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드는 동일 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 정규식 패턴은 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드 검색 중 하나를 호출 하 여 정의 됩니다는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자입니다. 정규식 패턴을 설정할 수 있는 요소에 대 한 자세한 내용은 참조 하세요. [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 즉시 채워집니다 컬렉션 발생 시킵니다. 지연 평가 활용 하려면 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 평가 인해 호출을 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> 메서드가 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 경우이 메서드에서 반환 된 개체를 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 속성이 아닙니다 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 하는 작업이 시간 제한 간격을 초과 합니다. 
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 메서드를 호출 해 "es" 등으로 끝나는 문장에 첫 번째 단어를는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> "es"로 끝나는 모든 추가 단어를 식별 하는 방법입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 정규식 패턴 `\b\w+es\b` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"을 찾습니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드와 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> 단일 일치 하는 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드는 동일 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Matches`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 즉시 채워집니다 컬렉션 발생 시킵니다. 지연 평가 활용 하려면 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 평가 인해 호출을 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드가 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업을 수행 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> "es"로 끝나는 문장에서 단어를 식별 하는 방법입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 정규식 패턴 `\b\w+es\b` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"을 찾습니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 정적 여러 패턴을 검색 하 게 일치 하는 것이 좋습니다 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 지정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 일치 옵션을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드와 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 단일 일치 하는 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드는 동일 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Matches`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 즉시 채워집니다 컬렉션 발생 시킵니다. 지연 평가 활용 하려면 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 평가 인해 호출을 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드가 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업을 수행 하면 예외가 throw 됩니다는 <xref:System.Text.RegularExpressions.MatchCollection> 시간 제한 간격을 현재 응용 프로그램 도메인 및 일치 작업의 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 의해 정의 된 경우이 메서드에서 반환 된 개체 이 시간 제한 간격을 초과합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 메서드를 호출 해 "es" 등으로 끝나는 문장에는 모든 단어를 식별 하는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 입력된 문자열을 사용 하 여 패턴의 대/소문자 구분 비교를 수행 하는 방법. 출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 정규식 패턴 `\b\w+es\b` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"을 찾습니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 정적 여러 패턴을 검색 하 게 일치 하는 것이 좋습니다 <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 지정하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 일치 옵션 및 제한 시간 간격을 사용하여 지정된 입력 문자열에서 지정된 정규식을 모두 검색합니다.</summary>
        <returns>검색에서 찾은 <see cref="T:System.Text.RegularExpressions.Match" /> 개체의 컬렉션입니다. 일치 항목이 없으면 메서드가 빈 컬렉션 개체를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드와 비슷합니다는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 단일 일치 하는 대신 입력된 문자열에서 모든 일치 항목에 대 한 정보를 반환 한다는 점을 제외 하 고 메서드를 찾을 수 있습니다. 다음 코드는 동일 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 정적 `Matches` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Matches`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드 지연 평가 사용 하 여 반환 된 채우는 <xref:System.Text.RegularExpressions.MatchCollection> 개체입니다. 이 컬렉션의 멤버와 같은 액세스 <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> 및 <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> 즉시 채워집니다 컬렉션 발생 시킵니다. 지연 평가 활용 하려면 같은 구문을 사용 하 여 컬렉션을 반복 해야 하면 `foreach` C# 및 `For Each`...`Next` Visual Basic  
  
 해당 지연 평가 인해 호출을 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 메서드가 throw 하지 않습니다는 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. 그러나 작업에서 수행 될 때 예외가 throw 됩니다 합니다 <xref:System.Text.RegularExpressions.MatchCollection> 일치 하는 작업을 지정 하 여이 시간 제한 간격을 초과 하는 경우이 메서드에서 반환 된 개체는`matchTimeout` 매개 변수입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> "es"로 끝나는 문장에서 단어와 일치 하는 대/소문자 구분 비교를 수행 하는 방법입니다. 그런 다음 호출 하 여 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 입력된 문자열을 사용 하 여 패턴의 대/소문자 구분 비교를 수행 하는 방법입니다. 두 경우 모두에서 시간 제한 간격을 1 초로 설정 됩니다. 출력에서 볼 수 있듯이 두 메서드는 다른 결과 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 정규식 패턴 `\b\w+es\b` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\b`|단어 경계에서 일치 항목 찾기를 시작합니다.|  
|`\w+`|하나 이상의 단어 문자를 찾습니다.|  
|`es`|리터럴 문자열 "es"을 찾습니다.|  
|`\b`|단어 경계에서 일치 항목 찾기를 끝냅니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스의 시간 제한 간격을 가져옵니다.</summary>
        <value><see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" />이 throw되기 전에 패턴 일치 작업에서 경과할 수 있는 최대 시간 간격이며, 제한 시간이 비활성화된 경우는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> 에 대 한 대략적인 최대 시간 간격을 정의 하는 속성을 <xref:System.Text.RegularExpressions.Regex> 작업 시간이 초과 되기 전에 단일 일치 작업을 실행 하는 인스턴스. 정규식 엔진은 throw를 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 에서 다음 타이밍 검사 시간 제한 간격이 경과 하는 동안 예외입니다. 이 정규식 엔진은 과도 한 역 추적 해야 하는 입력된 문자열 처리 되지 않도록 방지 합니다. 자세한 내용은 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md) 하 고 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md)합니다.  
  
 이 속성은 읽기 전용입니다. 개인에 대 한 해당 값을 명시적으로 설정할 수 있습니다 <xref:System.Text.RegularExpressions.Regex> 호출 하 여 개체를 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자; 하 고 모든 해당 값을 설정할 수 있습니다 <xref:System.Text.RegularExpressions.Regex> 호출 하 여 일치 하는 응용 프로그램 도메인에서 작업은 <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> 메서드 제공 하는 <xref:System.TimeSpan> 다음 예제와 같이 "REGEX_DEFAULT_MATCH_TIMEOUT" 속성에 대 한 값입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 시간 제한 간격, 기본 값을 명시적으로 설정 하지 않으면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> 사용 및 일치 하는 작업은 시간 초과 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에 전달된 옵션을 가져옵니다.</summary>
        <value><see cref="T:System.Text.RegularExpressions.RegexOptions" /> 생성자에게 전달된 옵션을 나타내는 하나 이상의 <see cref="T:System.Text.RegularExpressions.Regex" /> 열거형 멤버입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Text.RegularExpressions.Regex.Options%2A> 속성의 하나 이상의 멤버로 구성는 <xref:System.Text.RegularExpressions.RegexOptions> 열거형입니다. 옵션 없이 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 클래스 생성자에 해당 값은 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>합니다. 사용 가능한 옵션에서 자세히 설명 합니다 [Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md) 항목입니다.  
  
 <xref:System.Text.RegularExpressions.Regex.Options%2A> 속성 자체 인라인 옵션은 정규식에 정의 된 패턴을 반영 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 만든 정규식의 기본 클래스를 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드. 이러한 컴파일된 정규식의 기본 클래스 구현을 사용 합니다 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성입니다. 파생된 클래스에서 호출 된 경우는 <see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 전달 된 옵션을 반환 합니다 <paramref name="options" /> 의 매개 변수는 <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 는 정규식을 정의 하는 데 사용 된 클래스 생성자입니다.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">정규식 옵션</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다. 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 합니다 `replacement` 매개 변수 문자열에서 일치 하는 것을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\s+`, 하나 이상의 공백 문자를 일치 하는 합니다. 바꾸기 문자열 "", 단일 공백 문자로 바꿉니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 다음 예제에서는 정규식을 정의 `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`, 및 바꾸기 패턴에서 `$2`를 숫자 값에서 선행 또는 후행 통화 기호를 제거 하는 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 정규식은 다음 표와 같이 해석됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\p{Sc}`|통화 기호를 찾습니다. `{Sc}` 유니코드 기호와 통화 범주의 구성원 인 모든 문자를 나타냅니다.|  
|`\s?`|0번 이상 나오는 공백 문자를 찾습니다.|  
|`(\p{Sc}\s?)?`|0 개 또는 한 개의 조합에 통화 기호 뒤에 0 개 이상의 공백 문자가 일치 합니다. 이 그룹은 첫 번째 캡처링 그룹입니다.|  
|`\d+`|하나 이상의 10진수 숫자가 일치하는지 확인합니다.|  
|`\.?`|마침표 (소수 구분 기호 문자로 사용) 0 개 또는 1 번을 찾습니다.|  
|`((?<=\.)\d+)?`|이전 문자는 기간을 사용 하는 경우 하나 이상의 10 진수를 찾습니다. 이 패턴은 0 개 또는 한 번 일치할 수 있습니다.|  
|`(\d+\.?((?<=\.)\d+)?)`|하나 이상의 10 진수 뒤에 마침표와 추가 10 진수가 패턴과 일치 합니다. 이 그룹은 두 번째 캡처링 그룹입니다. 에 대 한 호출을 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> 메서드가 캡처된 그룹의 값과 일치 하는 전체를 바꿉니다.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|첫 번째 캡처된 그룹이 있는 경우 빈 문자열을 일치 합니다. 그렇지 않은 경우 통화 기호 뒤에 0 개 이상의 공백 문자를 일치 합니다.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에 의해 쉽게 지정할 수 없습니다.  
  
-   대체 문자열은 일치 하는 문자열에서 수행 되는 일부 처리에서 발생 합니다.  
  
-   조건부 처리의 대체 문자열 결과입니다.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션을는 `evaluator` 대리자입니다.  
  
 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제는 원래 문자열을 표시, 원래 문자열에서 각 단어와 일치, 첫 번째 문자의 각 일치 항목을 표시 한 다음 대문자로 변환된 된 문자열을 변환 합니다.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일치 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다. 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 경우 `count` 가 음수 이면 대체 문자열의 끝까지 계속 합니다. 경우 `count` 일치 항목 수를 초과 하면, 일치 하는 모든 대체 됩니다.  
  
 합니다 `replacement` 첫 번째를 대체 하는 문자열을 지정 하는 매개 변수 `count` 에서 일치 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 단일 문자를 사용 하 여 중복 된 문자의 처음 5 개 항목을 바꿉니다. 정규식 패턴 `(\w)\1` 연속 발견 되는 단일 문자를 일치 하 고 첫 번째로 나타나는 첫 번째 캡처링 그룹에 할당 합니다. 바꾸기 패턴 `$1` 처음으로 캡처된 그룹에 일치 하는 전체를 바꿉니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Replace`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 일치 항목에 대 한 검색의 시작 부분에서 시작 된 `input` 문자열입니다.  
  
 합니다 `replacement` 매개 변수 문자열에서 일치 하는 것을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 정의 `\s+`, 하나 이상의 공백 문자를 일치 하는 합니다. 바꾸기 문자열 "", 단일 공백 문자로 바꿉니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> 메서드를 로컬 파일 경로가 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식을 사용 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 논리 드라이브의 이름을 포함 하는 방법입니다. 예제를 성공적으로 실행 하려면 리터럴 문자열 "MyMachine" 로컬 컴퓨터 이름으로 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\\\\`|일치 두 명의 연속 된 백슬래시 (`\`) 문자입니다. 백슬래시는 이스케이프 문자로 해석 하기 때문에 각 백슬래시는 다른 백슬래시로 이스케이프 되어야 합니다.|  
|`(?i:" + Environment.MachineName + ")`|반환 되는 문자열의 대/소문자 구분 일치를 수행 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|마침표 (`.`) 하나 이상의 단어 문자 뒤에 문자입니다. 이 일치 항목 0 번 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시와 일치 (`\`) 문자입니다.|  
|`((?i:[" + driveNames + "]))`|개별 드라이브 문자를 구성 하는 문자 클래스의 대/소문자 구분 일치를 수행 합니다. 이 항목은 첫 번째 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자입니다.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 사용 하 여 UNC 컴퓨터 및 드라이브 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 대체 하는 것에 대 한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에 의해 쉽게 지정할 수 없습니다.  
  
-   대체 문자열은 일치 하는 문자열에서 수행 되는 일부 처리에서 발생 합니다.  
  
-   조건부 처리의 대체 문자열 결과입니다.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션을는 `evaluator` 대리자입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치 항목의 문자가 포함 된 배열을 만듭니다. 또한 병렬 배열을 채우는 임의의 부동 소수점 숫자를 사용 하 여 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드 및 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열에서 다음 반환 되는 `WordScramble` 메서드. 정규식 패턴 `\w+` 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자와 같은 단어가 아닌 문자를 발견할 때까지 문자 일치 항목으로 추가 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 평가 및 패턴 일치를 대체 하기 위한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <summary>지정된 입력 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에 의해 쉽게 지정할 수 없습니다.  
  
-   대체 문자열은 일치 하는 문자열에서 수행 되는 일부 처리에서 발생 합니다.  
  
-   조건부 처리의 대체 문자열 결과입니다.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> 메서드 및 첫 번째 전달 `count` <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션은 `evaluator` 대리자입니다.  
  
 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예에서는 의도적으로 잘못 입력 목록의 단어의 절반에 정규식을 사용 합니다. 정규식을 사용 하 여 `\w*(ie|ei)\w*` "ie" 또는 "ei" 문자를 포함 하는 단어를 찾습니다. 첫 번째 일치 하는 단어 중 절반 전달 합니다 `ReverseLetter` 메서드를 사용 하는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> "i"와 일치 하는 문자열에 "e"를 반대로 하는 방법. 나머지 단어 그대로 유지 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 `\w*(ie|ei)\w*` 정규식은 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\w*`|0개 이상의 단어 문자를 찾습니다.|  
|<code>(ie&#124;ei)</code>|"예" 또는 "ei"를 찾습니다.|  
|`\w*`|0개 이상의 단어 문자를 찾습니다.|  
  
 정규식 패턴 `([ie])([ie])` 에 `ReverseLetter` 메서드 첫 번째 "i" 또는 "e" 이중 "ie" 또는 "ei"에서 일치 하 고 첫 번째 캡처링 그룹에는 문자를 할당 합니다. 두 번째 "i" 또는 "e"와 일치 하 고 두 번째 캡처링 그룹에는 문자를 할당 합니다. 호출 하 여 두 문자 되돌려서 합니다 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> 바꾸기 패턴을 사용 하 여 메서드 `$2$1`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 지정된 대체 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 부터 일치 항목에 대 한 검색을 시작 합니다 `input` 문자열에 지정 된 위치에는 `startat` 매개 변수입니다. 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다. 경우 `count` 가 음수 이면 대체 문자열의 끝까지 계속 합니다. 경우 `count` 일치 항목 수를 초과 하면, 일치 하는 모든 대체 됩니다.  
  
 합니다 `replacement` 매개 변수 문자열에서 일치 하는 것을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열의 첫 번째 줄을 제외한 모든 double-spaces 합니다. 정규식 패턴을 정의 `^.*$`, 호출 텍스트의 줄에 일치 하는 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> 문자열 및 사용 하 여 첫 번째 줄과 일치 하는 방법 합니다 `Match.Index` 및 `Match.Count` 두 번째의 시작 위치를 결정 하는 속성 선입니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 정규식 패턴 `^.*$` 는 다음 테이블과 같이 정의됩니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`^`|줄의 시작을 찾습니다. (유의 <xref:System.Text.RegularExpressions.Regex> 개체를 사용 하 여 인스턴스화한를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 이 문자 클래스는 입력된 문자열의 시작 부분 일치만 고, 그렇지 않으면 옵션.)|  
|`.*`|모든 문자 0 회 이상 찾습니다.|  
|`$`|줄의 끝을 찾습니다. (유의 <xref:System.Text.RegularExpressions.Regex> 개체를 사용 하 여 인스턴스화한를 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 이 문자 클래스는 입력된 문자열의 시작 부분 일치만 고, 그렇지 않으면 옵션.)|  
  
 대체 문자열 (`vbCrLf + "$&"` Visual basic에서는 `"\n$&"` C#) 일치 하는 문자열 앞에 새 줄을 추가 합니다. `\n` C# 예제로 해석 됩니다 줄 바꿈 문자는 C# 컴파일러; 정규식 문자 이스케이프를 나타내지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="replacement" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Replace`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽으로 이동 하 고이 고, 그렇지 검색 입력된 문자열의 시작 부분에서 시작은 오른쪽으로 이동 합니다.  
  
 합니다 `replacement` 매개 변수 문자열에서 일치 하는 것을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 로컬 파일 경로가 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식을 사용 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 논리 드라이브의 이름을 포함 하는 방법입니다. 모든 정규식 문자열 비교가 대/소문자를 구분 하지 않습니다. 예제를 성공적으로 실행 하려면 리터럴 문자열 "MyMachine" 로컬 컴퓨터 이름으로 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\\\\`|일치 두 명의 연속 된 백슬래시 (`\`) 문자입니다. 백슬래시는 이스케이프 문자로 해석 하기 때문에 각 백슬래시는 다른 백슬래시로 이스케이프 되어야 합니다.|  
|`+ Environment.MachineName +`|반환 되는 문자열과 일치 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|마침표 (`.`) 하나 이상의 단어 문자 뒤에 문자입니다. 이 일치 항목 0 번 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시와 일치 (`\`) 문자입니다.|  
|`([" + driveNames + "])`|개별 드라이브 문자도 이루어진 문자 클래스와 일치 합니다. 이 항목은 첫 번째 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자입니다.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 사용 하 여 UNC 컴퓨터 및 드라이브 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치를 대체 하는 것에 대 한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에 의해 쉽게 지정할 수 없습니다.  
  
-   대체 문자열은 일치 하는 문자열에서 수행 되는 일부 처리에서 발생 합니다.  
  
-   조건부 처리의 대체 문자열 결과입니다.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션을는 `evaluator` 대리자입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽으로 이동 하 고이 고, 그렇지 검색 입력된 문자열의 시작 부분에서 시작은 오른쪽으로 이동 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치 항목의 문자가 포함 된 배열을 만듭니다. 또한 병렬 배열을 채우는 임의의 부동 소수점 숫자를 사용 하 여 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드 및 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열에서 다음 반환 되는 `WordScramble` 메서드. 정규식 패턴 `\w+` 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자와 같은 단어가 아닌 문자를 발견할 때까지 문자 일치 항목으로 추가 됩니다. 에 대 한 호출을 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 포함 합니다 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션 있도록 정규식 패턴에서 주석을 `\w+  # Matches all the characters in a word.` 정규식 엔진에 의해 무시 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="count">바꾸기를 하는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>지정된 입력 부분 문자열에서 정규식 패턴과 일치하는 지정된 최대 개수의 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 정규식 패턴이 현재 인스턴스에서 일치하지 않는 경우 메서드는 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열은 정규식 대체 패턴에 의해 쉽게 지정할 수 없습니다.  
  
-   대체 문자열은 일치 하는 문자열에서 수행 되는 일부 처리에서 발생 합니다.  
  
-   조건부 처리의 대체 문자열 결과입니다.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> 메서드 및 첫 번째 전달 `count` <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션은 `evaluator` 대리자입니다.  
  
 정규식은 현재의 생성자에 의해 정의 된 패턴과 <xref:System.Text.RegularExpressions.Regex> 개체입니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 바꾸기 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="evaluator" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="replacement" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="replacement">대체 문자열입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 문자열을 지정된 대체 문자열로 바꿉니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 `Replace` 메서드는 구성에 해당 하는 <xref:System.Text.RegularExpressions.Regex> 지정 된 정규식 패턴을 사용 하 여 개체 및 인스턴스 메서드를 호출 `Replace`합니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다. 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽으로 이동 하 고이 고, 그렇지 검색 입력된 문자열의 시작 부분에서 시작은 오른쪽으로 이동 합니다.  
  
 합니다 `replacement` 매개 변수 문자열에서 일치 하는 것을 지정 `input`합니다. `replacement` 리터럴 텍스트의 조합으로 구성 될 수 있습니다 하 고 [대체](~/docs/standard/base-types/substitutions-in-regular-expressions.md)합니다. 예를 들어 바꾸기 패턴 `a*${test}b` 문자열을 삽입 합니다 "를 *" 일치 하는 부분 문자열 뒤에 `test` 문자열이 "b" 뒤에 있는 경우 그룹 캡처. * 문자는 메타 바꾸기 패턴으로 인식 되지 않습니다.  
  
> [!NOTE]
>  대체는 바꾸기 패턴에서 인식 되는 유일한 정규식 언어 요소입니다. 모든 다른 정규식 언어 요소를 포함 하 여 [이스케이프 문자](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), 정규식 패턴에 허용 됩니다 및 바꾸기 패턴에서 인식 되지 않습니다.  
  
 `matchTimeout` 매개 변수를 지정 시간 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리할 때 응답을 중지 하도록 표시에서 과도 한 역 추적에 의존 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 해당 시간 간격의 일치 하는 항목이 없으면 메서드에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드를 실행 하는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> 메서드를 로컬 파일 경로가 UNC 경로 로컬 컴퓨터 및 드라이브 이름을 바꿉니다. 정규식을 사용 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 로컬 컴퓨터의 이름을 포함 하는 속성 및 <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> 논리 드라이브의 이름을 포함 하는 방법입니다. 모든 정규식 문자열 비교는 대/소문자 및 0.5 초에서 일치 하는 항목을 찾을 수 없는 경우 모든 단일 교체 작업 시간이 초과 됩니다. 예제를 성공적으로 실행 하려면 리터럴 문자열 "MyMachine" 로컬 컴퓨터 이름으로 바꿔야 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 정규식 패턴은 다음 식으로 정의 됩니다.  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 다음 테이블은 정규식 패턴이 해석되는 방법을 보여 줍니다.  
  
|무늬|설명|  
|-------------|-----------------|  
|`\\\\`|일치 두 명의 연속 된 백슬래시 (`\`) 문자입니다. 백슬래시는 이스케이프 문자로 해석 하기 때문에 각 백슬래시는 다른 백슬래시로 이스케이프 되어야 합니다.|  
|`+ Environment.MachineName +`|반환 되는 문자열과 일치 합니다 <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> 속성입니다.|  
|`(?:\.\w+)*`|마침표 (`.`) 하나 이상의 단어 문자 뒤에 문자입니다. 이 일치 항목 0 번 이상 발생할 수 있습니다. 일치 하는 하위 식이 캡처되지 않습니다.|  
|`\\`|백슬래시와 일치 (`\`) 문자입니다.|  
|`([" + driveNames + "])`|개별 드라이브 문자도 이루어진 문자 클래스와 일치 합니다. 이 항목은 첫 번째 캡처된 하위 식입니다.|  
|`\$`|일치 리터럴 달러 기호 (`$`) 문자입니다.|  
  
 바꾸기 패턴 `$1` 처음 캡처된 하위 식에 일치 하는 전체를 바꿉니다. 즉, 드라이브 문자를 사용 하 여 UNC 컴퓨터 및 드라이브 이름을 대체합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="replacement" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">역추적</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">.NET Framework의 정규식에 대한 유용한 정보</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">일치 항목을 검색할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="evaluator">각각의 일치 항목을 검사하여 원래 일치하는 문자열 또는 대체 문자열을 반환하는 사용자 지정 메서드입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 입력 문자열에서 지정된 정규식과 일치하는 모든 부분 문자열을 <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> 대리자가 반환한 문자열로 바꿉니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>입력 문자열과 동일한 새 문자열입니다. 단, 대체 문자열은 일치하는 각 문자열을 대체합니다. 현재 인스턴스에서 <paramref name="pattern" />이 일치하지 않으면 메서드가 변경되지 않은 현재 인스턴스를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드는 다음 조건 중 하나라도 참인 경우에 정규식 일치 항목을 대체 하는 데 유용 합니다.  
  
-   대체 문자열을 지정 하 여 정규식 대체 패턴에 의해 쉽게 수 없습니다.  
  
-   대체 문자열에서 발생 하는 경우 일치 하는 문자열에서 일부 처리 수행 합니다.  
  
-   대체 문자열 조건부 처리에서 발생 하는 경우.  
  
 메서드 호출에 해당 하는 합니다 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 메서드와 각각 전달 <xref:System.Text.RegularExpressions.Match> 반환 된 개체 <xref:System.Text.RegularExpressions.MatchCollection> 컬렉션을는 `evaluator` 대리자입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 `evaluator` 매개 변수는 사용자가 정의한 사용자 지정 메서드에 대 한 대리자 및 각 일치 항목을 검사 하는 합니다. 사용자 지정 메서드는 일치 하는 다음 서명이 있어야 합니다.는 <xref:System.Text.RegularExpressions.MatchEvaluator> 위임 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 사용자 지정 메서드는 일치 하는 입력을 대체 하는 문자열을 반환 합니다.  
  
 지정 하는 경우 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 에 대 한는 `options` 매개 변수를 일치 항목 검색 입력된 문자열의 끝에서 시작 하 고 왼쪽으로 이동 하 고이 고, 그렇지 검색 입력된 문자열의 시작 부분에서 시작은 오른쪽으로 이동 합니다.  
  
 `matchTimeout` 매개 변수를 지정 시간 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 정규식에 나타나지 않도록 과도 한 역 추적에 의존 하는 것을 금지 시간 제한 간격을 설정 "입력을 처리할 때 응답 하지 일치 거의 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 해당 시간 간격의 일치 하는 항목이 없으면 메서드에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드를 실행 하는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 메서드 반환 하므로 `input` 일치 하는 경우 변경 하지 않고 사용할 수는 <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> 메서드 입력된 문자열에 대체 설정한 여부를 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 정규식을 사용 하 여 문자열에서 개별 단어를 추출 하 고 사용 하 여는 <xref:System.Text.RegularExpressions.MatchEvaluator> 라는 메서드를 호출 하는 대리자 `WordScramble` 단어의 개별 문자를 스크램블입니다. 이 작업을 수행 하는 `WordScramble` 메서드는 일치 항목의 문자가 포함 된 배열을 만듭니다. 또한 병렬 배열을 채우는 임의의 부동 소수점 숫자를 사용 하 여 만듭니다. 호출 하 여 배열 정렬 되는 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> 메서드 및 정렬 된 배열에 대 한 인수로 제공 됩니다는 <xref:System.String> 클래스 생성자입니다. 새로 만든된이 문자열에서 다음 반환 되는 `WordScramble` 메서드. 정규식 패턴 `\w+` 하나 이상의 단어 문자 일치 정규식 엔진은 계속 공백 문자와 같은 단어가 아닌 문자를 발견할 때까지 문자 일치 항목으로 추가 됩니다. 에 대 한 호출을 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> 메서드를 포함 합니다 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 옵션 있도록 정규식 패턴에서 주석을 `\w+  # Matches all the characters in a word.` 정규식 엔진에 의해 무시 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />, <paramref name="pattern" /> 또는 <paramref name="evaluator" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">대체</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">역추적</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">.NET Framework의 정규식에 대한 유용한 정보</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>정규식을 사용하여 오른쪽에서 왼쪽으로 검색하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>정규식을 사용하여 오른쪽에서 왼쪽으로 검색하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> 됩니다 `true` 경우는 <xref:System.Text.RegularExpressions.Regex> 인스턴스를 사용 하 여 만든는 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> 옵션입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>정규식 일치에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <summary><see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식 패턴에 의해 정의된 위치에서 입력 문자열을 부분 문자열의 배열로 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열 수 만큼 분할 됩니다. 구분 기호가 없습니다 있으면 반환 값은 하나의 요소 값은 원래 입력된 문자열을 포함 합니다.  
  
 여러 일치 항목이 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어, 단일 하이픈에서 문자열을 분할 하면 반환된 된 배열에 있는 인접 한 하이픈을 두 개 발견 되 면 다음 코드와 같이 위치에 빈 문자열을 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 입력된 문자열의 끝 또는 시작 부분에서 일치 하는 경우 빈 문자열 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴 `\d+` 숫자에서 입력된 문자열을 분할 합니다. 시작 하 고 숫자 문자를 일치 하는 종료 하는 문자열, 반환 된 배열의 첫 번째 및 마지막 요소의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 캡처링 괄호를 사용 하는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 캡처된 텍스트는 결과 문자열 배열에 포함 된 식입니다. 예를 들어, "진한 보라-pear" 하이픈에서 캡처링 괄호 내에서 문자열을 분할 하는 경우 반환된 된 배열에는 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서 캡처링 괄호의 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어, 다음 코드는 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 두 캡처링 괄호를 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우; 슬래시 문자 제외 이 컴파일 및.NET Framework 2.0 이상 버전에서 실행 하는 경우 이러한 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다. 예:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 반환 된 배열은 배열의 시작과 끝에 빈 문자열을 포함 하는 참고 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">분할될 문자열입니다.</param>
        <param name="count">분할할 수 있는 최대 횟수입니다.</param>
        <summary>입력 문자열을 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. 합니다 `count` 매개 변수는 부분 문자열의 최대 수를 지정 합니다 `input` 문자열의 분할 되지 않은 나머지를 포함 하는 마지막 문자열; 문자열을 분할할 수 있습니다. `count` 값이 0 이면 가능한 만큼 분할의 기본 동작을 제공 합니다.  
  
 여러 일치 항목이 서로 인접 한 경우 또는 시작 이나 끝 일치 하는 경우 `input`, 발견 된 일치 레코드 수는 2 이상 및 보다 작은 `count`, 빈 문자열 배열에 삽입 됩니다. 일치 하는 부분 문자열 같음 여부를 결정 하에서 시작 또는 입력된 문자열의 끝에서 일치 항목 또는 인접 한 일치 항목에서 발생 하는 빈 문자열 계산 되는, `count`합니다. 다음 예제에서는 정규식에에서 `/d+` 최대 세 가지 부분에 하나 이상의 10 진수를 포함 하는 입력된 문자열을 분할 하는 데 사용 됩니다. 첫 번째 배열 요소를 포함 하는 정규식 패턴과 일치 하는 입력된 문자열의 시작 부분에 있으므로 <xref:System.String.Empty?displayProperty=nameWithType>, 영문자 입력된 문자열에서 첫 번째 집합을 포함 하는 두 번째 및 세 번째 문자열의 나머지를 포함 합니다. 세 번째 일치 항목을 따릅니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 정규식에서 캡처링 괄호를 사용 하면 캡처된 텍스트는 분할 된 문자열의 배열에 포함 됩니다. 그러나 캡처된 텍스트가 들어 있는 배열 요소 계산 되지 않습니다 결정 된 일치 레코드 수에 도달 하는지 여부를 `count`입니다. 예를 들어 분할을 최대를 7 요소 배열에는 다음 코드와의 네 가지 부분 문자열이 결과 문자열 "apple-장의-진한 보라-pear-banana" 보여 줍니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서는 캡처 괄호의 첫 번째 집합에서 캡처된 텍스트만 반환된 된 배열에 포함 됩니다. .NET Framework 2.0 부터는 모든 캡처된 텍스트 반환된 된 배열에 추가 됩니다. 그러나 캡처된 텍스트를 포함 하는 반환된 된 배열에 요소가 계산 되지 않습니다 결정 하는 데 수에 부분 문자열 equals와 일치 하는지 여부 `count`합니다. 예를 들어, 다음 코드에서는 정규식 날짜 문자열에서 날짜의 요소를 추출 하려면 두 캡처링 괄호 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 에 대 한 호출을 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> 메서드 다음 반환된 된 배열에는 최대 두 개의 요소를 지정 합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 메서드를 두 개의 요소로 문자열 배열을 반환 합니다. 컴파일된 이며.NET Framework 2.0 또는 이상 버전에서 실행 되며, 메서드는 세 개의 요소로 문자열 배열을 반환 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다. 다음 예제에서는 입력된 문자열에 있는 요소 수 만큼에 "문자" 문자열을 분할 합니다. 입력된 문자열의 시작과 일치 하는 null 문자열을 하기 때문에 null 문자열이 반환 되는 배열의 시작 부분에 삽입 됩니다. 그러면 열 번째 요소의 입력된 문자열의 끝에 두 개의 문자로 구성 됩니다.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <summary>정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. `input` 가능한 만큼 문자열을 분할 합니다. 경우 `pattern` 에 없는 합니다 `input` 문자열을 반환 값에 포함 한 요소 값은 원래 `input` 문자열입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  정적 호출에 사용 된 정규식 컴파일 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 일치 항목이 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어, 단일 하이픈에서 문자열을 분할 하면 반환된 된 배열에 있는 인접 한 하이픈을 두 개 발견 되 면 다음 코드와 같이 위치에 빈 문자열을 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 입력된 문자열의 끝 또는 시작 부분에서 일치 하는 경우 빈 문자열 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴 `\d+` 숫자에서 입력된 문자열을 분할 합니다. 시작 하 고 숫자 문자를 일치 하는 종료 하는 문자열, 반환 된 배열의 첫 번째 및 마지막 요소의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 캡처링 괄호를 사용 하는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 캡처된 텍스트는 결과 문자열 배열에 포함 된 식입니다. 예를 들어, "진한 보라-pear" 하이픈에서 캡처링 괄호 내에서 문자열을 분할 하는 경우 반환된 된 배열에는 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서 캡처링 괄호의 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어, 다음 코드는 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 두 캡처링 괄호를 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우; 슬래시 문자 제외 이 컴파일 및.NET Framework 2.0 이상 버전에서 실행 하는 경우 이러한 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다. 예:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 반환 된 배열은 배열의 시작과 끝에 빈 문자열을 포함 하는 참고 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치에 텍스트를 분할 하는 것에 대 한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">분할될 문자열입니다.</param>
        <param name="count">분할할 수 있는 최대 횟수입니다.</param>
        <param name="startat">입력 문자열에서 검색을 시작할 문자 위치입니다.</param>
        <summary>입력 문자열을 <see cref="T:System.Text.RegularExpressions.Regex" /> 생성자에서 지정된 정규식에 의해 정의된 위치에서 지정된 최대 수만큼 부분 문자열의 배열로 분할합니다. 입력 문자열에서 지정된 문자 위치부터 정규식 패턴을 검색합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%2A?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. `count` 매개 변수는 부분 문자열의 최대 수를 지정 합니다 `input` 문자열은 분할; 마지막 문자열이 문자열의 분할 되지 않은 나머지를 포함 합니다. `count` 값이 0 이면 가능한 만큼 분할의 기본 동작을 제공 합니다. `startat` 매개 변수는 첫 번째 구분 기호에 대 한 검색을 시작할 지점을 정의 합니다. (이 용도로 사용할 수 있습니다 선행 공백은 건너뛰도록).  
  
 일치 하는 경우는 `count`+ 1 위치를 표시, 메서드를 포함 하는 요소가 하나인 배열 반환을 `input` 문자열입니다. 하나 이상의 일치 항목 발견 되 면 반환 된 배열의 첫 번째 요소는 한 문자 일치 항목 앞까지 첫 번째 문자에서 문자열의 첫 번째 부분을 포함 합니다.  
  
 여러 일치 항목이 서로 인접 한 두 개 이상 발견 된 일치 레코드 수는 경우 보다 작은 `count`, 빈 문자열 배열에 삽입 됩니다. 마찬가지로,에서 일치 하는 경우 `startat`을 문자열의 첫 번째 문자는 반환 된 배열의 첫 번째 요소는 빈 문자열입니다. 수에 부분 문자열 equals와 일치 하는지 여부를 결정 하에서 일치 하는 인접 한 항목에서 발생 하는 빈 문자열 계산 되는, `count`합니다. 다음 예제에서는 정규식에에서 `\d+` 문자열에서 숫자의 첫 번째 부분 문자열의 시작 위치를 찾는 데 사용 됩니다 및 문자열을 분할 최대 세 번 해당 위치에서 시작 합니다. 빈 문자열, 5-영문자 문자열이 및 문자열의 나머지 부분에서는 반환 된 문자열 배열 구성 입력된 문자열의 시작 부분 일치 하는 정규식 패턴이 있으므로  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 정규식에서 캡처링 괄호를 사용 하면 캡처된 텍스트는 분할 된 문자열의 배열에 포함 됩니다. 그러나 캡처된 텍스트가 들어 있는 배열 요소 계산 되지 않습니다 결정 된 일치 레코드 수에 도달 하는지 여부를 `count`입니다. 예를 들어 문자열을 분할 ' 다음 코드와 같이 7 요소 배열에 문자열 결과에 15 문자부터 최대 4 개에 "apple-apricot-plum-pear-pomegranate-pineapple-peach" 부분입니다.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서 캡처링 괄호의 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어, 다음 코드는 문자열에서 개별 단어를 추출 하려면 캡처 괄호의 두 집합을 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합은 세로 막대를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우 제외 세로 막대 문자 이 컴파일 및.NET Framework 2.0 이상 버전에서 실행 하는 경우 이러한 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다. 다음 예제에서는 입력된 문자열에, 문자로 시작 하는 대로 만큼 요소를 "문자" 문자열을 분할 "a"입니다. Null 문자열 일치는 입력된 문자열의 끝, 때문에 null 문자열이 반환 되는 배열의 끝에 삽입 됩니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간에서 지정한 시간 제한 간격을 초과 하는 경우 예외가 발생 합니다 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 생성자입니다. 생성자를 호출할 때 시간 제한 간격을 설정 하지 않으면, 작업이 있는 응용 프로그램 도메인에 설정 된 제한 시간 값을 초과 하면 예외가 throw 되는 <xref:System.Text.RegularExpressions.Regex> 개체가 만들어집니다. 제한 시간에 정의 된 경우는 <xref:System.Text.RegularExpressions.Regex> 생성자 호출 또는 응용 프로그램 도메인의 속성 또는 시간 제한 값이 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startat" />이 0보다 작거나 <paramref name="input" />의 길이보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <summary>지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다. 지정한 옵션에 따라 일치 작업이 수정됩니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열 수 만큼 분할 됩니다. 반환 값은 원래 값인 요소가 하나 포함 구분 기호가 없습니다 있으면 `input` 문자열입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  정적 호출에 사용 된 정규식 컴파일 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 일치 항목이 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어, 단일 하이픈에서 문자열을 분할 하면 반환 된 배열이 인접 한 하이픈을 두 개 있는 위치에 빈 문자열을 포함 합니다.  
  
 입력된 문자열의 끝 또는 시작 부분에서 일치 하는 경우 빈 문자열 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴 `[a-z]+` 대문자나 소문자 알파벳 문자에서 입력된 문자열을 분할 합니다. 시작 하 고 알파벳 문자를 일치 하는 종료 하는 문자열, 반환 된 배열의 첫 번째 및 마지막 요소의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 캡처링 괄호를 사용 하는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 캡처된 텍스트는 결과 문자열 배열에 포함 된 식입니다. 예를 들어, "진한 보라-pear" 하이픈에서 캡처링 괄호 내에서 문자열을 분할 하는 경우 반환된 된 배열에는 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서 캡처링 괄호의 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어, 다음 코드는 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 두 캡처링 괄호를 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우; 슬래시 문자 제외 이 컴파일 및.NET Framework 2.0 이상 버전에서 실행 하는 경우 이러한 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다.  
  
 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> split 작업의 실행 시간이 메서드가 호출 되는 응용 프로그램 도메인에 대 한 지정 된 시간 제한 간격을 초과 하는 경우 예외가 throw 됩니다. 시간 제한이 없으며 응용 프로그램 도메인의 속성에 정의 된 제한 시간 값이 아니면 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, 예외가 throw 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>이 메서드는 메서드가 호출 되는 응용 프로그램 도메인의 기본 제한 시간 값에 해당 간격이 지난 후 시간이 합니다. 응용 프로그램 도메인에 값에 대 한 제한 시간 값을 정의 되지 않은 경우 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 메서드 시간 초과 방지 하는는 데 사용 됩니다. 패턴 일치에 텍스트를 분할 하는 것에 대 한 권장 되는 정적 메서드는 <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, 시간 제한 간격을 설정할 수 있습니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">분할할 문자열입니다.</param>
        <param name="pattern">일치 항목을 찾을 정규식 패턴입니다.</param>
        <param name="options">일치 옵션을 제공하는 열거형 값의 비트 조합입니다.</param>
        <param name="matchTimeout">시간 제한 간격이거나, 메서드에 시간 제한이 없어야 함을 나타내는 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />입니다.</param>
        <summary>지정된 정규식 패턴에 의해 정의된 위치에서 부분 문자열로 이루어진 배열로 입력 문자열을 분할합니다. 추가 매개 변수는 일치하는 항목이 없는 경우 제한 시간 간격과 일치 작업을 수정하는 옵션을 지정합니다.</summary>
        <returns>문자열 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 메서드는 비슷합니다는 <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> 메서드 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 구분 기호 문자 집합이 아니라 정규식에 의해 결정에서 문자열을 분할 합니다. 문자열 수 만큼 분할 됩니다. 반환 값은 원래 값인 요소가 하나 포함 구분 기호가 없습니다 있으면 `input` 문자열입니다.  
  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
> [!IMPORTANT]
>  정적 호출에 사용 된 정규식 컴파일 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드 자동으로 캐시 됩니다. 컴파일된 정규식의 수명을 직접 관리 하려면 인스턴스를 사용 하 여 <xref:System.Text.RegularExpressions.Regex.Split%2A> 메서드.  
  
 여러 일치 항목이 서로 인접 한 경우 빈 문자열 배열에 삽입 됩니다. 예를 들어, 단일 하이픈에서 문자열을 분할 하면 반환 된 배열이 인접 한 하이픈을 두 개 있는 위치에 빈 문자열을 포함 합니다.  
  
 입력된 문자열의 끝 또는 시작 부분에서 일치 하는 경우 빈 문자열 시작 이나 반환 된 배열의 끝에 포함 됩니다. 다음 예제에서는 정규식 패턴 `[a-z]+` 대문자나 소문자 알파벳 문자에서 입력된 문자열을 분할 합니다. 시작 하 고 알파벳 문자를 일치 하는 종료 하는 문자열, 반환 된 배열의 첫 번째 및 마지막 요소의 값은 <xref:System.String.Empty?displayProperty=nameWithType>합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 캡처링 괄호를 사용 하는 경우는 <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> 캡처된 텍스트는 결과 문자열 배열에 포함 된 식입니다. 예를 들어, "진한 보라-pear" 하이픈에서 캡처링 괄호 내에서 문자열을 분할 하는 경우 반환된 된 배열에는 하이픈을 포함 하는 문자열 요소를 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 그러나 정규식 패턴에서 캡처링 괄호의 여러 집합을 포함 하는 경우이 메서드의 동작은.NET Framework의 버전에 따라 다릅니다. .NET Framework 1.0 및 1.1에서 캡처링 괄호의 첫 번째 집합에 일치 하는 항목이 없는 경우 추가 캡처링 괄호에서 캡처된 텍스트가 포함 되지 않습니다 반환된 된 배열에. .NET Framework 2.0 부터는 모든 캡처된 텍스트에도 추가 됩니다 반환된 된 배열입니다. 예를 들어, 다음 코드는 날짜 문자열에서 날짜 구분 기호를 포함 하 여 날짜의 요소를 추출 두 캡처링 괄호를 사용 합니다. 캡처 괄호의 첫 번째 집합 하이픈을 캡처하고 두 번째 집합 슬래시를 캡처합니다. 예제 코드를 컴파일 및.NET Framework 1.0 또는 1.1에서 실행 하는 경우; 슬래시 문자 제외 이 컴파일 및.NET Framework 2.0 이상 버전에서 실행 하는 경우 이러한 포함 합니다.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 정규식에는 빈 문자열이 면과 일치할 수 있으면 <xref:System.Text.RegularExpressions.Regex.Split%2A> 모든 위치에 빈 문자열 구분 기호를 찾을 수 있으므로 문자열 단일 문자 문자열 배열로 분할 합니다.  
  
 `matchTimeout` 매개 변수를 지정 시간 패턴 일치 하는 방법을 메서드 시간이 초과 되기 전에 일치를 찾으려고 시도 합니다. 입력을 처리할 때 응답을 중지 하도록 표시에서 과도 한 역 추적에 의존 하는 정규식 시간 제한 간격을 설정 하면 유사 항목 포함 하는 합니다. 자세한 내용은 [정규식에 대 한 모범 사례](~/docs/standard/base-types/best-practices.md) 하 고 [역 추적](~/docs/standard/base-types/backtracking-in-regular-expressions.md)합니다. 해당 시간 간격의 일치 하는 항목이 없으면 메서드에서 throw 한 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 예외입니다. `matchTimeout` 메서드를 실행 하는 응용 프로그램 도메인에 대해 정의 된 모든 기본 제한 시간 값을 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">정규식 구문 분석 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 또는 <paramref name="pattern" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" />가 <see cref="T:System.Text.RegularExpressions.RegexOptions" /> 값의 유효한 비트 조합이 아닌 경우  
  
또는 
 <paramref name="matchTimeout" />이 음수, 0 또는 약 24일보다 큰 경우</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">시간이 초과되었습니다. 시간 제한에 대한 자세한 내용은 설명 섹션을 참조하세요.</exception>
        <block subset="none" type="usage"><para>설정 하는 것이 좋습니다는 <paramref name="matchTimeout" /> 2 초 등의 값으로 적절 한 매개 변수입니다. 제한 시간을 사용 하지 않도록 지정 하 여 <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, 정규식 엔진은 약간 더 나은 성능을 제공 합니다. 그러나 다음 조건 에서만 제한 시간을 비활성화 해야 합니다. 
-정규식에 의해 처리 된 입력 알려져 있고 신뢰할 수 있는 원본에서 파생 되거나는 정적 텍스트로 구성 됩니다. 이 제외 된 동적으로 사용자가 입력 텍스트입니다.  
  
-정규식 패턴을 효율적으로 처리 되도록 철저히 테스트 하는 경우 일치 하지 않는, 일치 하 고 가까운 일치 합니다.  
  
-정규식 패턴과 거의 일치 하는 처리 하는 경우 과도 한 역 추적을 일으키는 것으로 알려진 언어 요소가 없는 포함 합니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 요소</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="si">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialize된 데이터를 저장 및 검색할 위치입니다. 이 매개 변수는 나중에 사용하기 위해 예약되어 있습니다.</param>
        <summary>현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 deserialize하는 데 필요한 데이터로 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체를 채웁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="Regex" /> 생성자로 전달된 정규식 패턴을 반환합니다.</summary>
        <returns><see langword="Regex" /> 생성자로 전달된 <paramref name="pattern" /> 매개 변수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `pattern` 상징적으로 일치 하는 문자열을 설명 하는 정규식 언어 요소의 매개 변수를 구성 합니다. 정규식에 대 한 자세한 내용은 참조 하세요. [.NET Framework 정규식](~/docs/standard/base-types/regular-expressions.md) 하 고 [정규식 언어-빠른 참조](~/docs/standard/base-types/regular-expression-language-quick-reference.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> 만든 정규식의 기본 클래스를 <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드. 이러한 컴파일된 정규식 사용을 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 구현의 기본 클래스입니다. 파생된 클래스에서 호출 된 경우는 <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> 에 전달 된 문자열을 반환 하는 메서드를 <paramref name="pattern" /> 의 매개 변수를 <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> 는 정규식을 정의 하는 데 사용 된 클래스 생성자입니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">변환할 텍스트가 포함된 입력 문자열입니다.</param>
        <summary>입력 문자열에서 이스케이프된 문자를 변환합니다.</summary>
        <returns>이스케이프된 문자가 이스케이프 해제된 형식으로 변환된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드는 다음 두 개의 변환 중 하나를 수행 합니다.  
  
-   변환을 수행 하 여 취소 합니다 <xref:System.Text.RegularExpressions.Regex.Escape%2A> 이스케이프 문자를 제거 하 여 메서드 ("\\") 메서드에 의해 이스케이프 된 각 문자에서. 여기에 포함 됩니다는 \\, *, +,?, &#124;, {, [, (,), ^, $., # 및 공백 문자입니다. 또한는 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 닫는 대괄호 (])와 닫는 중괄호 (}) 메서드 이스케이프 해제 합니다.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 되돌릴 수 없습니다 이스케이프 된 문자열을 완벽 하 게 되는 문자 이스케이프 되었는지 정확 하 게 추론할 수 없습니다.  
  
-   축 자 문자열 리터럴의 16 진수 값은 실제 인쇄 가능한 문자를 사용 하 여 대체합니다. 예를 들어 바뀝니다 @"\x07" "\a"를 사용 하 여 또는 @"\x0A" "\n"입니다. 지원 되는 이스케이프 문자 \a, \b, \e, \n, \r, \f, \t, \v와 같은 영숫자 문자를 변환합니다.
  
 경우는 <xref:System.Text.RegularExpressions.Regex.Unescape%2A> 메서드를 변환할 수 없는 다른 이스케이프 시퀀스가 발생 throw \w 등 \s는 <xref:System.ArgumentException>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="str" />에는 인식할 수 없는 이스케이프 시퀀스가 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" />가 <see langword="null" />입니다.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">정규식 언어 - 빠른 참조</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <returns><see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> 옵션이 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> 메서드에서 생성되는 <see cref="T:System.Text.RegularExpressions.Regex" /> 개체에서 사용됩니다.</summary>
        <returns><see cref="P:System.Text.RegularExpressions.Regex.Options" /> 속성에 <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> 옵션이 포함되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">확인할 시간 제한 간격입니다.</param>
        <summary>시간 제한 간격이 허용 범위 내에 있는지 여부를 확인합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>