<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76d4d835f6dce4521d61c90bd9496531e320c717" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58701886" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>문자 인코딩을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인코딩은 유니코드 문자 집합을 바이트 시퀀스로 변환하는 프로세스입니다. 반면, 디코딩은 유니코드 문자 집합으로 인코딩된 바이트 시퀀스로 변환 하는 프로세스입니다. 유니코드 변환 형식 (Utf) 및에서 지 원하는 다른 인코딩에 대 한 내용은 <xref:System.Text.Encoding>를 참조 하세요 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.Encoding> 바이트 배열과 같은 임의의 이진 데이터 대신 유니코드 문자에 대해 수행 됩니다. 텍스트로 임의의 이진 데이터를 인코딩해야 하는 경우에와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 .NET의 다음 구현을 제공 합니다 <xref:System.Text.Encoding> 현재 유니코드 인코딩 및 다른 인코딩을 지원 하기 위해 클래스:  
  
-   <xref:System.Text.ASCIIEncoding> 단일 7 비트 ASCII 문자를 유니코드 문자를 인코딩합니다. 이 인코딩 U + 사이의 문자 값만 지원 0000 및 U + 007F 합니다. 코드 페이지 20127입니다. 통해 사용 가능한는 <xref:System.Text.Encoding.ASCII%2A> 속성입니다.  
  
-   <xref:System.Text.UTF7Encoding> utf-7 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. 이 인코딩은 모든 유니코드 문자 값을 지원합니다. 코드 페이지 65000입니다. 통해 사용 가능한는 <xref:System.Text.Encoding.UTF7%2A> 속성입니다.  
  
-   <xref:System.Text.UTF8Encoding> utf-8 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. 이 인코딩은 모든 유니코드 문자 값을 지원합니다. 코드 페이지 65001입니다. 통해 사용 가능한는 <xref:System.Text.Encoding.UTF8%2A> 속성입니다.  
  
-   <xref:System.Text.UnicodeEncoding> utf-16 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. Little endian 및 big endian 바이트 순서가 둘 다 지원 됩니다. 통해 사용 가능한 합니다 <xref:System.Text.Encoding.Unicode%2A> 속성 및 <xref:System.Text.Encoding.BigEndianUnicode%2A> 속성입니다.  
  
-   <xref:System.Text.UTF32Encoding> UTF-32 인코딩을 사용 하 여 유니코드 문자를 인코딩합니다. Little endian (코드 페이지 12000) 및 big endian (코드 페이지 12001) 바이트 순서가 지원 됩니다. 통해 사용 가능한는 <xref:System.Text.Encoding.UTF32%2A> 속성입니다.  
  
 <xref:System.Text.Encoding> 클래스는 주로 다른 인코딩과 유니코드 간 변환 합니다. 앱에 적합 한 경우가 파생 중 하나입니다.  
  
 사용 하 여는 <xref:System.Text.Encoding.GetEncoding%2A> 다른 인코딩을 얻는 메서드를 호출는 <xref:System.Text.Encoding.GetEncodings%2A> 모든 인코딩 목록을 가져오기 위한 메서드를 합니다.  
  
 다음 표에서.NET Framework 및.NET Core에서 지 원하는 인코딩은 나열 합니다. 각 인코딩의 코드 페이지 번호 및 인코딩의 값 나열 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 고 <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> 속성입니다. 에 확인 표시가 합니다 **.NET Framework 지원** 하 고 **.NET Core 지원** 열 코드 페이지는 기본 플랫폼에 관계 없이 해당.NET 구현에서 지원 고유 하 게 나타냅니다. .NET Framework에 대 한 테이블에 나열 된 다른 인코딩을 가용성 운영 체제에 따라 달라 집니다. .NET Core에 대 한 다른 인코딩을 통해 이용할 수는 <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> 나 클래스에서 파생 하는 <xref:System.Text.EncodingProvider?displayProperty=nameWithType> 클래스입니다.  

> [!NOTE]
> 해당 코드 페이지 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 국제 표준에 해당 하는 속성 전체 해당 표준을 준수 하지 않는 합니다. 

|코드 페이지|name|표시 이름|.NET framework 지원| .NET Core 지원 | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (미국-캐나다)|||  
|437|IBM437|OEM United States|||  
|500|IBM500|IBM EBCDIC (국제)|||  
|708|ASMO-708|아랍어 (ASMO 708)|||  
|720|DOS-720|아랍어 (DOS)|||  
|737|ibm737|그리스어 (DOS)|||  
|775|ibm775|발트어 (DOS)|||  
|850|ibm850|서유럽어 (DOS)|||  
|852|ibm852|중앙 유럽어 (DOS)|||  
|855|IBM855|OEM 키릴 자모|||  
|857|ibm857|터키어 (DOS)|||  
|858|IBM00858|OEM 다국 라틴 문자 I|||  
|860|IBM860|포르투갈어 (DOS)|||  
|861|ibm861|아이슬란드어 (DOS)|||  
|862|DOS-862|히브리어 (DOS)|||  
|863|IBM863|프랑스어 (캐나다) (DOS)|||  
|864|IBM864|아랍어 (864)|||  
|865|IBM865|북유럽어 (DOS)|||  
|866|cp866|키릴 자모 (DOS)|||  
|869|ibm869|(DOS) 현대 그리스어|||  
|870|IBM870|IBM EBCDIC (다국어 라틴어-2)|||  
|874|windows-874|태국어 (Windows)|||  
|875|cp875|IBM EBCDIC (현대 그리스어)|||  
|932|shift_jis|일본어 (SHIFT-JIS)|||  
|936|gb2312|중국어 간체 (GB2312)|✓||  
|949|ks_c_5601-1987|한국어|||  
|950|big5|중국어 번체 (Big5)|||  
|1026|IBM1026|IBM EBCDIC (터키어 라틴어-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (미국-캐나다-유럽)|||  
|1141|IBM01141|IBM EBCDIC (독일-Euro)|||  
|1142|IBM01142|IBM EBCDIC (덴마크-노르웨이-유럽)|||  
|1143|IBM01143|IBM EBCDIC (핀란드-스웨덴-유럽)|||  
|1144|IBM01144|IBM EBCDIC (이탈리아-유럽)|||  
|1145|IBM01145|IBM EBCDIC (스페인-Euro)|||  
|1146|IBM01146|IBM EBCDIC (영국-유럽)|||  
|1147|IBM01147|IBM EBCDIC (프랑스-Euro)|||  
|1148|IBM01148|IBM EBCDIC (국제-유럽)|||  
|1149|IBM01149|IBM EBCDIC (아이슬란드어-Euro)|||  
|1200|utf-16|유니코드(Unicode)|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|중앙 유럽어 (Windows)|||  
|1251|windows-1251|키릴 자모 (Windows)|||  
|1252|Windows-1252|서유럽어 (Windows)|✓||  
|1253|windows-1253|그리스어 (Windows)|||  
|1254|windows-1254|터키어 (Windows)|||  
|1255|windows-1255|히브리어 (Windows)|||  
|1256|windows-1256|아랍어 (Windows)|||  
|1257|windows-1257|발트어 (Windows)|||  
|1258|windows-1258|베트남어 (Windows)|||  
|1361|조합|한국어 (Johab)|||  
|10000|macintosh|서유럽어 (Mac)|||  
|10001|x-mac-일본어|일본어 (Mac)|||  
|10002|중국어--번체 mac x|중국어 번체 (Mac)|||  
|10003|x-mac-한국어|한국어 (Mac)|✓||  
|10004|x-mac-아랍어|아랍어 (Mac)|||  
|10005|x-mac-히브리어|히브리어 (Mac)|||  
|10006|x-mac-그리스어|그리스어 (Mac)|||  
|10007|x-mac-cyrillic|키릴 자모 (Mac)|||  
|10008|x-mac-chinesesimp|중국어 간체 (Mac)|✓||  
|10010|x-mac-루마니아어|루마니아어 (Mac)|||  
|10017|ukrainian-x-mac|우크라이나어 (Mac)|||  
|10021|x-mac-태국어|태국어 (Mac)|||  
|10029|x-mac-ce|중앙 유럽어 (Mac)|||  
|10079|icelandic-x-mac|아이슬란드어 (Mac)|||  
|10081|x-mac-터키어|터키어 (Mac)|||  
|10082|croatian-x-mac|크로아티아어 (Mac)|||  
|12000|utf-32|유니코드 (UTF-32)|✓|✓|  
|12001|utf-32BE|유니코드 (UTF-32 Big endian)|✓|✓|  
|20000|x-중국어-CN|중국어 번체 (CNS)|||  
|20001|x-cp20001|Tca|||  
|20002|x-중국어-Eten|중국어 번체 (Eten)|||  
|20003|x-cp20003|Ibm5550|||  
|20004|x-cp20004|Teletext|||  
|20005|x-cp20005|Wang 대만|||  
|20105|x-IA5|서유럽어 (IA5)|||  
|20106|x-IA5-독일어|독일어 (IA5)|||  
|20107|x-IA5-Swedish|스웨덴어 (IA5)|||  
|20108|--노르웨이어 IA5 x|노르웨이어 (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (독일)|||  
|20277|IBM277|IBM EBCDIC (덴마크-노르웨이)|||  
|20278|IBM278|IBM EBCDIC (핀란드-스웨덴)|||  
|20280|IBM280|IBM EBCDIC (이탈리아)|||  
|20284|IBM284|IBM EBCDIC (스페인)|||  
|20285|IBM285|IBM EBCDIC (영국)|||  
|20290|IBM290|IBM EBCDIC (일본어 가타카나)|||  
|20297|IBM297|IBM EBCDIC (프랑스)|||  
|20420|IBM420|IBM EBCDIC (아랍어)|||  
|20423|IBM423|IBM EBCDIC (그리스어)|||  
|20424|IBM424|IBM EBCDIC (히브리어)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (한국어 확장)|||  
|20838|IBM-태국어|IBM EBCDIC (태국어)|||  
|20866|koi8-r|키릴 자모 (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (아이슬란드어)|||  
|20880|IBM880|IBM EBCDIC (키릴 자모 러시아어)|||  
|20905|IBM905|IBM EBCDIC (터키어)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|일본어 (JIS 0208 1990 및 0212 1990)|||  
|20936|x-cp20936|중국어 간체 (GB2312-80)|✓||  
|20949|x-cp20949|한국어 (완성)|✓||  
|21025|cp1025|IBM EBCDIC (키릴 자모 세르비아어-불가리아어)|||  
|21866|koi8-u|키릴 자모 (KOI8-U)|||  
|28591|iso-8859-1|서유럽어 (ISO)|✓|✓|  
|28592|iso-8859-2|중앙 유럽어 (ISO)|||  
|28593|iso-8859-3|라틴어 3 (ISO)|||  
|28594|iso-8859-4|발트어 (ISO)|||  
|28595|iso-8859-5|키릴 자모 (ISO)|||  
|28596|iso-8859-6|아랍어 (ISO)|||  
|28597|iso-8859-7|그리스어 (ISO)|||  
|28598|iso-8859-8|히브리어 (Iso-visual)|✓||  
|28599|iso-8859-9|터키어 (ISO)|||  
|28603|iso-8859-13|에스토니아어 (ISO)|||  
|28605|iso-8859-15|라틴어 9 (ISO)|||  
|29001|x-유럽어|유럽어|||  
|38598|iso-8859-8-i|히브리어 (Iso-logical)|✓||  
|50220|iso-2022-jp|일본어 (JIS)|✓||  
|50221|csISO2022JP|일본어 (JIS-허용 1 바이트 일본어가 나 구분)|✓||  
|50222|iso-2022-jp|일본어 (JIS-허용 1 바이트 Kana-따라서 / SI)|✓||  
|50225|iso-2022-한국|한국어 (ISO)|✓||  
|50227|x-cp50227|중국어 간체 (ISO-2022)|✓||  
|51932|euc-jp|일본어 (EUC)|✓||  
|51936|EUC-CN|중국어 간체 (EUC)|✓||  
|51949|euc kr|한국어 (EUC)|✓||  
|52936|hz-gb-2312|중국어 간체 (HZ)|✓||  
|54936|GB18030|중국어 간체 (GB18030)|✓||  
|57002|x-iscii-de|ISCII 데바나가리어|✓||  
|57003|iscii-수 x|ISCII 벵골어|✓||  
|57004|x-iscii-ta|Iscii-타밀어|✓||  
|57005|x-iscii-te|Iscii-텔루구어|✓||  
|57006|x-iscii-으로|ISCII 아삼 어|✓||  
|57007|x-iscii 또는|Iscii-오리야어|✓||  
|57008|x-iscii-ka|Iscii-카나다어|✓||  
|57009|--ma iscii x|ISCII 말라얄람어|✓||  
|57010|x-iscii-gu|ISCII 구자라트어|✓||  
|57011|x-iscii-pa|ISCII 펀잡어|✓||  
|65000|utf-7|유니코드 (utf-7)|✓|✓|  
|65001|utf-8|유니코드(UTF-8)|✓|✓|  
  
 다음 예제에서는 합니다 <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> 고 <xref:System.Text.Encoding.GetEncoding%28System.String%29> 그리스어 (Windows)를 가져오는 메서드를 코드 페이지 인코딩. 비교는 <xref:System.Text.Encoding> 를 표시 하 고, 동일 맵 그리스어 알파벳의 유니코드 코드 포인트 및 각 문자에 대해 해당 코드 페이지 값을을 표시 한 다음 메서드 호출에서 반환 된 개체입니다.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 Utf-16 및 UTF-32 인코더 big endian 바이트 순서를 사용할 수 있습니다 (최상위 바이트 첫 번째) 또는 little endian 바이트 순서 (최하위 바이트 먼저). 예를 들어, 영문 대문자를 (u+0041)으로 serialize 됩니다 (16 진수)에서 다음과 같습니다.  
  
-   Utf-16 big endian 바이트 순서: 00 41  
  
-   Utf-16 little endian 바이트 순서: 41 00  
  
-   UTF-32 big endian 바이트 순서: 00 00 00 41  
  
-   UTF-32 little endian 바이트 순서: 41 00 00 00  
  
 이 기본 바이트 순서를 사용 하 여 유니코드 문자를 저장 하려면 일반적으로 더 효율적입니다. 예를 들어 Intel 컴퓨터 같은 little endian 플랫폼에서 little endian 바이트 순서를 사용 하는 것이 좋습니다.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> 메서드는 바이트 순서 표시 (BOM)를 포함 하는 바이트의 배열을 검색 합니다. 이 바이트 배열은 인코딩된 스트림으로 접두사가 사용 된 인코딩 형식을 식별 하는 디코더 수 있습니다.  
  
 바이트 순서에서 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조 합니다 [유니코드 홈페이지](https://go.microsoft.com/fwlink/?LinkId=37123)합니다.  
  
 인코딩 클래스 오류를 허용 하는 참고 합니다.  
  
-   자동으로 변경 하는 "?" 문자입니다.  
  
-   "최적" 문자를 사용 합니다.  
  
-   사용 하 여 응용 프로그램별 동작을 변경 합니다 <xref:System.Text.EncoderFallback> 및 <xref:System.Text.DecoderFallback> U + FFFD 유니코드 대체 문자로 클래스입니다.  
  
 모든 데이터 스트림 오류에서 예외를 throw 해야 합니다. 앱을 해당 하는 경우 "throwonerror" 플래그를 사용 하거나 사용 합니다 <xref:System.Text.EncoderExceptionFallback> 고 <xref:System.Text.DecoderExceptionFallback> 클래스입니다. 데이터 손실 또는 혼동 될 수 있습니다 하 고 단순한 문자 대체 보다 느린 있기 때문에 최상의 대체 (fallback) 것이 좋습니다 없는 경우가 많습니다. ANSI 인코딩을 자동 맞춤된 동작이 기본값입니다.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.  
  
> [!NOTE]
>  Byte 배열 유형만 인코딩된 데이터를 포함 하는이 예제의 경우 .NET 문자 및 문자열 형식은 유니코드 자체 이므로 <xref:System.Text.Encoding.GetChars%2A> 호출 유니코드 데이터를 다시 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스는이 생성자를 재정의 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">기본 설정 인코딩의 코드 페이지 식별자입니다.  
  
또는 
기본 인코딩을 사용하려면 0을 사용합니다.</param>
        <summary>지정한 코드 페이지에 해당하는 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스는이 생성자를 재정의 합니다.  
  
 파생된 클래스에서이 생성자를 호출 만들기는 <xref:System.Text.Encoding> 인코딩 및 디코딩 작업 모두에 대 한 최적된 대체 (fallback)를 사용 하는 개체입니다. 모두를 <xref:System.Text.Encoding.DecoderFallback%2A> 고 <xref:System.Text.Encoding.EncoderFallback%2A> 속성 읽기 전용 이며 수정할 수 없습니다. 파생 된 클래스에 대 한 대체 (fallback) 전략을 제어 하려면 <xref:System.Text.Encoding>를 호출 합니다 <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 생성자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">인코딩 코드 페이지 식별자입니다.</param>
        <param name="encoderFallback">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <param name="decoderFallback">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <summary>지정된 인코더 및 디코더 대체 전략을 사용하여 지정된 코드 페이지에 해당하는 <see cref="T:System.Text.Encoding" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 `protected`; 파생 클래스에서 재정의 합니다.  
  
 인코딩 및 디코딩 전략 대체를 제어 하는 파생된 클래스에서이 생성자를 호출 합니다. <xref:System.Text.Encoding> 클래스 생성자 인코더 또는 디코더가 대체 (fallback) 개체를 만든 후에 설정할 수를 허용 하지 않는 읽기 전용으로 인코딩 개체를 만듭니다.  
  
 이면 `encoderFallback` 또는 `decoderFallback` 이 null 이면 최적된 대체 (fallback) 해당 대체 (fallback) 전략으로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" />가 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASCII(7비트) 문자 집합에 대한 인코딩을 가져옵니다.</summary>
        <value>ASCII(7비트) 문자 집합에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII 문자 u+0000 ~ U + 007F에서에서 가장 낮은 128 유니코드 문자로 제한 됩니다.  
  
 앱에 대 한 ASCII 인코딩을 선택할 때 다음 사항을 고려 합니다.  
  
-   ASCII 인코딩 ASCII를 필요로 하는 프로토콜에 대 한 일반적으로 적합 합니다.  
  
-   8 비트 인코딩 (라고 하는 경우에 따라 올바르게 하지에 "ASCII")에 필요한 경우 u t F-8 인코딩 것이 좋습니다 ascii 인코딩. 문자 0-7F에 대 한 결과 동일 하지만 u t F-8을 사용 하 여 표현한 것으로 표현할 수 있는 모든 유니코드 문자를 허용 하 여 데이터 손실을 방지 합니다. ASCII 인코딩 8 번째에 비트 악의적인 사용을 허용할 수 있는 모호성 하지만 u t F-8 인코딩 8 번째 비트에 대 한 모호성을 제거 합니다.  
  
-   .NET Framework 버전 2.0 이전의.NET Framework 8 번째 비트를 무시 하 여 스푸핑 허용 합니다. .NET Framework 2.0 부터는 ASCII가 아닌 코드 포인트 대체 디코딩하는 동안.  
  
 <xref:System.Text.ASCIIEncoding> 이 속성에 의해 반환 되는 개체는 앱에 대 한 적절 한 동작 있을 수 없습니다. 교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다. 대신 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 인스턴스화하기 위한 메서드를 <xref:System.Text.ASCIIEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 다음 예에서는 ASCII 문자를 ASCII 범위를 벗어나는에 인코딩의 효과 보여 줍니다.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>big endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩을 가져옵니다.</summary>
        <value>Big-Endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다. 대신, 호출할 수 있습니다는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> big endian를 인스턴스화하는 생성자 <xref:System.Text.UnicodeEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 반환 된 <xref:System.Text.UnicodeEncoding> 개체에 <xref:System.Text.Encoding.BodyName%2A>를 <xref:System.Text.Encoding.HeaderName%2A>, 및 <xref:System.Text.Encoding.WebName%2A> unicodeFFFE"이름"을 생성 하는 속성입니다. Utf-16 big endian 바이트 순서 표시를 16 진수 FEFF 경우에 "이름"unicodeFFFE 바이트 순서 표시가 little endian Windows 컴퓨터에서 16 진수 FFFE로 표시 되기 때문에 선택 되었습니다.  
  
   
  
## Examples  
 다음 예에서는 u t F-16으로 인코딩된 big endian 바이트 순서를 사용 하 여 텍스트 파일을 읽습니다.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 메일 에이전트 본문 태그에 사용할 수 있는 현재 인코딩의 이름을 가져옵니다.</summary>
        <value>메일 에이전트 본문 태그에 사용할 수 있는 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.  
  
또는 
현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 본문 이름에 대 한 인코딩을 해야 하는 경우 호출 해야 <xref:System.Text.Encoding.GetEncoding%2A> 사용 하 여는 <xref:System.Text.Encoding.BodyName%2A> 속성입니다. 종종 메서드 호출에 제공 된 인코딩을 테스트에서 다른 인코딩을 검색 합니다. 일반적으로 전자 메일 응용 프로그램만 그러한 인코딩을; 검색 해야 인코딩을 설명 해야 하는 다른 대부분의 응용 프로그램을 사용할지는 <xref:System.Text.Encoding.WebName%2A>합니다.  
  
 경우에 따라 값을 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다. 구현 표준에 사용 하 여 전체에서 준수는 것은 아닙니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 <see cref="T:System.Text.Encoding" /> 개체의 부분 복사본을 만듭니다.</summary>
        <returns>현재 <see cref="T:System.Text.Encoding" /> 개체의 복사본입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복제본은 쓰기 가능한 경우에 원래 <xref:System.Text.Encoding> 개체가 읽기 전용입니다. 따라서 복제본의 속성을 수정할 수 있습니다.  
  
 개체의 단순 복사본에만 개체의 복사본이입니다. 개체가 다른 개체에 대 한 참조를 포함 하는 경우 단순 복사를 참조 된 개체의 복사본을 만들지 않습니다. 참조 된 원래 개체 대신 합니다. 반면, 개체의 전체 복사본을 만들고 개체의 복사본 개체에서 직접 또는 간접적으로 참조 하는 모든 대상을 복사 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 <see cref="T:System.Text.Encoding" />의 코드 페이지 식별자를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />의 코드 페이지 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>바이트 배열을 한 인코딩에서 다른 인코딩으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><paramref name="bytes" />의 인코딩 형식입니다.</param>
        <param name="dstEncoding">대상 인코딩 형식입니다.</param>
        <param name="bytes">변환할 바이트입니다.</param>
        <summary>전체 바이트 배열의 인코딩을 변환합니다.</summary>
        <returns><see cref="T:System.Byte" />를 <paramref name="bytes" />에서 <paramref name="srcEncoding" />으로 변환한 결과를 포함하는 <paramref name="dstEncoding" /> 형식의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 ASCII로 인코드된 문자열을 유니코드로 인코딩된 문자열로 변환 합니다. ASCII 인코딩 개체를 반환 하므로 <xref:System.Text.Encoding.ASCII%2A> 교체 대체 (fallback)를 사용 하는 속성 및 Pi 문자는 ASCII 문자 집합의 일부가 아닌, Pi 문자는 출력은 예제에서 물음표를 사용 하 여 대체 됩니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="dstEncoding" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">소스 배열 <paramref name="bytes" />의 인코딩입니다.</param>
        <param name="dstEncoding">출력 배열의 인코딩입니다.</param>
        <param name="bytes">변환할 바이트 배열입니다.</param>
        <param name="index">변환할 <paramref name="bytes" />에 있는 첫 번째 요소의 인덱스입니다.</param>
        <param name="count">변환할 바이트 수입니다.</param>
        <summary>바이트 배열의 바이트 범위를 한 인코딩에서 다른 인코딩으로 변환합니다.</summary>
        <returns><see cref="T:System.Byte" />의 바이트 범위를 <paramref name="bytes" />에서 <paramref name="srcEncoding" />으로 변환한 결과를 포함하는 <paramref name="dstEncoding" /> 형식의 배열입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="dstEncoding" />가 <see langword="null" />인 경우  
  
또는 
 <paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 및 <paramref name="count" />가 바이트 배열의 유효한 범위를 지정하지 않는 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Text.DecoderFallback" /> 개체에 대한 <see cref="T:System.Text.Encoding" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 디코더 대체 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> 개체 문자를 인코딩된 바이트 시퀀스를 디코딩할 수 없는 경우 호출 되는 오류 처리기를 나타냅니다. 다음 처리기 형식 중 하나로 사용할 수 있습니다.  
  
-   최적된 대체 (fallback) 처리기를 몇 가지 적절 한 대체 문자를 사용 하 여 디코딩할 수 없는 바이트를 대체 하는 합니다.  
  
-   교체 대체 (fallback) 처리기를 일부 임의의 대체 문자를 사용 하 여 디코딩할 수 없는 바이트를 대체 하는입니다. .NET 포함 한 교체 대체 (fallback) 처리기를 <xref:System.Text.DecoderFallback>를 디코딩할 수 없는 바이트 물음표로 대체 하는 기본적으로는 ("?") 문자입니다.  
  
-   예외 대체 (fallback) 처리기 바이트를 디코딩할 수 없는 경우 예외를 throw 합니다. .NET 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.DecoderExceptionFallback>를 throw 하는 <xref:System.Text.DecoderFallbackException> 바이트를 디코딩할 수 없는 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Text.Encoding" /> 개체가 읽기 전용이기 때문에 set 작업에 값을 할당할 수 없습니다.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 .NET 구현을 위한 기본 인코딩을 가져옵니다.</summary>
        <value>이.NET 구현에 대 한 인코딩 기본입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  서로 다른 컴퓨터는 기본적으로 다른 인코딩을 사용할 수 및 기본 인코딩을 단일 컴퓨터에서 변경할 수 있습니다. 사용 하는 경우는 <xref:System.Text.Encoding.Default%2A> 인코딩을 인코딩 및 디코딩 스트리밍할 컴퓨터 간에 또는 동일한 컴퓨터에서 서로 다른 시간에 검색 데이터를 변환할 수도 있습니다 하지 해당 데이터 올바르게 합니다. 또한 인코딩을 반환한는 <xref:System.Text.Encoding.Default%2A> 속성 최적된 대체 (fallback)를 사용 하 여 지원 되지 않는 문자 코드 페이지에서 지 원하는 문자에 매핑합니다. 이러한 이유로, 기본 인코딩을 사용 하 여 권장 되지 않습니다. 인코딩된 바이트 디코딩되는 유니코드 인코딩 등을 사용 해야 되도록 하려면 <xref:System.Text.UTF8Encoding> 또는 <xref:System.Text.UnicodeEncoding>합니다. 또한 동일한 형식을 인코딩 및 디코딩을 위한 사용 되는지 확인 하는 상위 수준 프로토콜을 사용할 수 있습니다.  

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework의 기본 속성

Windows 바탕 화면에서.NET framework에서는 <xref:System.Text.Encoding.Default%2A> 속성 항상 시스템의 활성 코드 페이지를 가져오고 만듭니다는 <xref:System.Text.Encoding> 것에 해당 하는 개체입니다. 현재 코드 페이지에는 ASCII 문자 코드 페이지에서 함께 달라 지는 추가 문자 집합을 포함 하는 ANSI 코드 페이지를 수 있습니다. 때문에 모든 <xref:System.Text.Encoding.Default%2A> 인코딩은 ANSI 코드 페이지에 따라 데이터가 손실, 사용 하는 것이 좋습니다는 <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> 대신 인코딩. U t F-8에서 U + 00에서 U + 7F 범위와 동일 하지만 손실 없이 ASCII 범위 밖의 문자를 인코딩할 수 있습니다.

## <a name="the-default-property-on-net-core"></a>.NET Core의 기본 속성

.NET Core에서의 <xref:System.Text.Encoding.Default%2A> 속성은 항상 반환 된 <xref:System.Text.UTF8Encoding>합니다. U t F-8은 모든 운영 체제 (Windows, Linux 및 OS X 최대) 실행 하는.NET Core 응용 프로그램에서 지원 됩니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Text.EncoderFallback" /> 개체에 대한 <see cref="T:System.Text.Encoding" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" /> 개체에 대한 인코더 대체 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> 개체 문자를 인코딩된 바이트 시퀀스로 변환할 수 없을 때 호출 되는 오류 처리기를 나타냅니다. 다음 처리기 형식 중 하나로 사용할 수 있습니다.  
  
-   최적된 대체 (fallback) 처리기를 몇 가지 적절 한 대체 문자를 사용 하 여 인코딩할 수 없는 문자를 대체 하는 합니다.  
  
-   교체 대체 (fallback) 처리기를 일부 임의의 대체 문자를 사용 하 여 인코딩할 수 없는 문자를 대체 하는입니다. .NET 포함 한 교체 대체 (fallback) 처리기를 <xref:System.Text.EncoderFallback>를 인코딩할 수 없는 문자는 물음표를 사용 하 여 대체 하는 기본적으로는 ("?") 문자입니다.  
  
-   예외 대체 (fallback) 처리기 문자를 인코딩할 수 없는 경우 예외를 throw 합니다. .NET 포함 한 예외 대체 (fallback) 처리기 <xref:System.Text.EncoderExceptionFallback>를 throw 하는 <xref:System.Text.EncoderFallbackException> 문자를 디코딩할 수 없는 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">집합 작업의 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">현재 <see cref="T:System.Text.Encoding" /> 개체가 읽기 전용이기 때문에 set 작업에 값을 할당할 수 없습니다.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩에 대해 사람이 읽을 수 있는 설명을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />에 대해 사람이 읽을 수 있는 설명입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> 속성을 표시 하기 위한 것입니다. 에 전달 될 수 있는 이름을 찾으려면 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드를 사용 하 여는 <xref:System.Text.Encoding.WebName%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">현재 인스턴스와 비교할 <see cref="T:System.Object" />입니다.</param>
        <summary>지정한 <see cref="T:System.Object" />가 현재 인스턴스와 같은지를 확인합니다.</summary>
        <returns><see langword="true" />가 <paramref name="value" />의 인스턴스이고 현재 인스턴스와 같으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 인스턴스 <xref:System.Text.Encoding> 동일한 코드 페이지에 해당 하는 경우 같은 것으로 간주 됩니다 및 해당 `EncoderFallback` 및 `DecoderFallback` 개체는 동일 합니다. 특히 모든 파생 된 코드 페이지에는 0의 코드 페이지가 하 고 해당 대체는 일반적으로 `null` (`Nothing` Visual Basic.net에서). 따라서 이러한 모든 것으로 간주 됩니다 서로 합니다. 결과 때 <xref:System.Text.Encoding.Equals%2A> 해시 테이블을 채우는 데 사용 됩니다 하 고 모든 파생 인코딩이 같으며 동일한 해시 테이블 슬롯에 속합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 인스턴스가 동일한 인코딩 (각각 하나) 및 다른 이름으로,와 서로 같은지 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되면 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 문자가 포함된 문자 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 배열의 모든 문자를 인코딩하여 생성되는 바이트 수를 계산합니다.</summary>
        <returns>지정한 문자 배열의 모든 문자를 인코딩하여 생성되는 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">인코딩할 문자 집합이 포함된 문자열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정된 문자열의 문자를 인코딩하여 생성되는 바이트 수를 계산합니다.</summary>
        <returns>지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   앱이 사용자 입력 문자열의 문자열 버전을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 첫 번째 문자를 가리키는 포인터입니다.</param>
        <param name="count">인코딩할 문자 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 포인터에서 시작하는 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</summary>
        <returns>지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하려면 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드를 사용 하는 것에 대 한 몇 가지 고려 사항입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%2A> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 문자 집합이 포함된 문자 배열입니다.</param>
        <param name="index">인코딩할 첫 번째 문자의 인덱스입니다.</param>
        <param name="count">인코딩할 문자 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 인코딩하여 생성되는 바이트 수를 계산합니다.</summary>
        <returns>지정한 문자를 인코딩할 경우 생성되는 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다.  
  
-   앱이 사용자 입력 문자열의 문자열 버전을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A> 것이 좋습니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되면 문자 집합을 바이트 시퀀스로 인코딩합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 문자가 포함된 문자 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 배열의 모든 문자를 바이트 시퀀스로 인코딩합니다.</summary>
        <returns>지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 호출 해야 앱 문자열 입력을 처리 하는 경우는 <xref:System.Text.Encoding.GetBytes%2A> 메서드.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">인코딩할 문자가 포함된 문자열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자열의 모든 문자를 바이트 시퀀스로 인코딩합니다.</summary>
        <returns>지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 문자 집합이 포함된 문자 배열입니다.</param>
        <param name="index">인코딩할 첫 번째 문자의 인덱스입니다.</param>
        <param name="count">인코딩할 문자 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 바이트 시퀀스로 인코딩합니다.</summary>
        <returns>지정한 문자 집합을 인코딩한 결과가 포함된 바이트 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 첫 번째 문자를 가리키는 포인터입니다.</param>
        <param name="charCount">인코딩할 문자 수입니다.</param>
        <param name="bytes">결과 바이트 시퀀스를 쓰기 시작할 위치를 가리키는 포인터입니다.</param>
        <param name="byteCount">쓸 최대 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 포인터에서 시작하는 문자 집합을 지정한 바이트 포인터에서 시작하여 저장되는 바이트 시퀀스로 인코딩합니다.</summary>
        <returns><paramref name="bytes" /> 매개 변수가 가리키는 위치에 쓴 실제 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 필요한 결과 바이트를 저장 하려면 호출을 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 또는 <paramref name="byteCount" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" />가 결과 바이트 수보다 작은 경우</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">인코딩할 문자 집합이 포함된 문자 배열입니다.</param>
        <param name="charIndex">인코딩할 첫 번째 문자의 인덱스입니다.</param>
        <param name="charCount">인코딩할 문자 수입니다.</param>
        <param name="bytes">결과 바이트 시퀀스를 포함할 바이트 배열입니다.</param>
        <param name="byteIndex">결과 바이트 시퀀스를 쓰기 시작할 인덱스입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 배열의 문자 집합을 지정한 바이트 배열로 인코딩합니다.</summary>
        <returns><paramref name="bytes" />에 쓴 실제 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 세 문자는 문자 배열에서 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> 또는 <paramref name="byteIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="charIndex" /> 및 <paramref name="charCount" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.  
  
또는 
 <paramref name="byteIndex" />가 <paramref name="bytes" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" />의 용량(<paramref name="byteIndex" /> ~ 배열 끝)이 부족해서 결과 바이트를 수용할 수 없는 경우</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">인코딩할 문자 집합이 포함된 문자열입니다.</param>
        <param name="charIndex">인코딩할 첫 번째 문자의 인덱스입니다.</param>
        <param name="charCount">인코딩할 문자 수입니다.</param>
        <param name="bytes">결과 바이트 시퀀스를 포함할 바이트 배열입니다.</param>
        <param name="byteIndex">결과 바이트 시퀀스를 쓰기 시작할 인덱스입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자열의 문자 집합을 지정한 바이트 배열로 인코딩합니다.</summary>
        <returns><paramref name="bytes" />에 쓴 실제 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 호출 해야 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면 호출을 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 유니코드 문자 집합 인코딩의 바이트 수 결과 확인 및 <xref:System.Text.Encoding.GetBytes%2A> 메서드에서는 실제 인코딩을 수행 합니다. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 단일 입력된 스트림 여러 변환을 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetByteCount%2A> 고 <xref:System.Text.Encoding.GetBytes%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에 많은 입력된 문자를 인코딩 및 여러 호출을 사용 하 여 문자를 처리 해야 합니다. 이 경우 아마도 해야에서 유지 되는 상태를 고려 하는 호출 간에 상태를 유지 관리는 <xref:System.Text.Encoder> 사용 중인 개체입니다. (예를 들어: 서로게이트 쌍을 포함 하는 문자 시퀀스 수 high surrogate로 끝나야 함. <xref:System.Text.Encoder> 다음 호출의 시작 부분에 하위 서로게이트와 결합할 수 있도록 해당 상위 서로게이트에 저장 됩니다. <xref:System.Text.Encoding> 상태를 유지 하기 위해 문자를 보낼 수 없습니다는 <xref:System.Text.EncoderFallback>.)  
  
-   문자열 버전을 사용 해야 앱 문자열 입력을 처리 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>합니다.  
  
-   유니코드 문자 버퍼 버전 <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> 특히 사용 하 여 여러 호출을 사용 하 여 일부 빠른 기법은 허용을 <xref:System.Text.Encoder> 개체나 기존 버퍼에 삽입 합니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 <xref:System.Text.Encoding.GetBytes%2A> 바이트 배열이 지 원하는 버전을는 것이 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetByteCount%2A>합니다. 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 하는 하는 변환 메서드. 연속 스트림의 인코딩의 경우이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 또는 문자열의 범위를 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" /> 또는 <paramref name="byteIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="charIndex" /> 및 <paramref name="charCount" />가 <paramref name="chars" />에서 올바른 범위를 나타내지 않습니다.  
  
또는 
 <paramref name="byteIndex" />가 <paramref name="bytes" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" />의 용량(<paramref name="byteIndex" /> ~ 배열 끝)이 부족해서 결과 바이트를 수용할 수 없는 경우</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되면 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 디코딩하여 생성되는 문자 수를 계산합니다.</summary>
        <returns>지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드. 최대 배열 크기를 계산 하려면 사용 해야는 <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.  
  
-   앱에서 문자열 출력을 처리 하는 경우 사용 해야는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 첫 번째 바이트를 가리키는 포인터입니다.</param>
        <param name="count">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 포인터에서 시작하는 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</summary>
        <returns>지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.  
  
-   사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <param name="index">디코딩할 첫 번째 바이트의 인덱스입니다.</param>
        <param name="count">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 디코딩하여 생성되는 문자 수를 계산합니다.</summary>
        <returns>지정한 바이트 시퀀스를 디코딩할 경우 생성되는 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 아마도 해야 호출 간에 상태를 유지 관리 합니다.  
  
-   사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되면 바이트 시퀀스를 문자 집합으로 디코딩합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 문자 집합으로 디코딩합니다.</summary>
        <returns>지정한 바이트 시퀀스의 디코딩 결과가 포함된 문자 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다. (예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)  
  
-   사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <param name="index">디코딩할 첫 번째 바이트의 인덱스입니다.</param>
        <param name="count">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 문자 집합으로 디코딩합니다.</summary>
        <returns>지정한 바이트 시퀀스의 디코딩 결과가 포함된 문자 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다. (예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)  
  
-   사용 하도록 권장 되는 앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 첫 번째 바이트를 가리키는 포인터입니다.</param>
        <param name="byteCount">디코딩할 바이트 수입니다.</param>
        <param name="chars">결과 문자 집합을 쓰기 시작할 위치를 가리키는 포인터입니다.</param>
        <param name="charCount">쓸 최대 문자 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 포인터에서 시작하는 바이트 시퀀스를 지정한 문자 포인터에서 시작하여 저장되는 문자 집합으로 디코딩합니다.</summary>
        <returns><paramref name="chars" /> 매개 변수가 가리키는 위치에 쓴 실제 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 필요한 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 입력된 바이트 시퀀스에서 문자를 가져옵니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 분리 된 변환이 필요 하는 동안 <xref:System.Text.Decoder> 단일 입력 스트림에 대 한 패스가 여러 개에 대 한 설계 되었습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 크기가 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 는 에서제공하는개체<xref:System.Text.Encoding.GetDecoder%2A> 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다. (예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 <xref:System.Text.Encoding.GetChars%2A> 호출 하 고 다음의 시작 부분에 계속 <xref:System.Text.Encoding.GetChars%2A> 호출 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)  
  
-   앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> 또는 <paramref name="charCount" />가 0보다 작습니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" />가 결과 문자 수보다 작은 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <param name="byteIndex">디코딩할 첫 번째 바이트의 인덱스입니다.</param>
        <param name="byteCount">디코딩할 바이트 수입니다.</param>
        <param name="chars">결과 문자 집합을 포함할 문자 배열입니다.</param>
        <param name="charIndex">결과 문자 집합을 쓰기 시작할 인덱스입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 지정한 문자 배열로 디코딩합니다.</summary>
        <returns><paramref name="chars" />에 쓴 실제 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 입력된 바이트 시퀀스에서 문자를 가져옵니다. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 다릅니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 하므로 <xref:System.Text.Encoding> 불연속 변환이 필요 하는 동안 <xref:System.Text.Decoder> 용인지 여러 단일 입력된 스트림을 전달합니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 **참고** 바이트 배열과 같은 임의의 이진 데이터에 없는 유니코드 문자에서 작동 하도록이 메서드를 사용 합니다. 와 같은 방법으로 구현 하는 uuencode와 같은 프로토콜을 사용 해야 임의의 이진 데이터를 텍스트로 인코딩할 경우 <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>합니다.  
  
 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 바이트 시퀀스를 디코딩할에서 디코딩될 문자 확인 및 <xref:System.Text.Encoding.GetChars%2A> 메서드는 실제 디코딩을 수행 합니다. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 메서드는 달리 불연속 변환을 필요로 합니다 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 단일 입력 스트림에 대 한 패스가 여러 개를 처리 하는 메서드를 합니다.  
  
 여러 버전의 <xref:System.Text.Encoding.GetCharCount%2A> 고 <xref:System.Text.Encoding.GetChars%2A> 지원 됩니다. 다음은 이러한 메서드의 사용에 대 한 프로그래밍 고려할입니다.  
  
-   앱 코드 페이지에서 여러 입력된 바이트를 디코딩 및 여러 호출을 사용 하 여 바이트를 처리 해야 합니다. 이 경우 시켜야 호출 간에 상태를 유지 하므로 일괄 처리 하는 경우에 바이트 시퀀스를 중단 될 수 있습니다. (예를 들어 ISO-2022 shift 시퀀스의 일부로 하나 종료 될 수 있습니다 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > 호출 하 고 다음의 시작 부분에 계속 [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > 호출 합니다. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 이러한 불완전 한 시퀀스에 대 한 대체는 호출 되지만 <xref:System.Text.Decoder> 다음 호출에 대 한 해당 시퀀스에 저장 됩니다.)  
  
-   앱에서 문자열 출력을 처리 하는 경우는 <xref:System.Text.Encoding.GetString%2A> 메서드를 사용 하는 것이 좋습니다. 이 메서드는 문자열 길이 확인 해야 하며 버퍼를 할당, 이므로 약간 더 느려집니다 결과 <xref:System.String> 형식은 것이 좋습니다.  
  
-   바이트 버전의 <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> 특히 큰 버퍼를 여러 번 호출을 사용 하 여 빠른 기법도 있습니다. 그러나이 메서드 버전 아님을 때로는 안전 포인터가 필요 하므로 점에 주의 해야 합니다.  
  
-   앱 많은 양의 데이터를 변환 해야 하는 경우 출력 버퍼를 다시 사용 해야 합니다. 이 경우에 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 지원 문자를 출력 하는 버전 버퍼는 것이 가장 좋습니다.  
  
-   사용을 고려 합니다 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드 대신 <xref:System.Text.Encoding.GetCharCount%2A>합니다. 변환 메서드는 최대한 많은 데이터를 변환 하 고 출력 버퍼가 너무 작은 경우 예외를 throw 합니다. 연속 스트림 디코딩에에 대 한이 메서드는 종종 것이 가장 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 한 인코딩에서 다른 문자열로 변환 합니다.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 다음 예제에서는 문자열을 바이트 배열로 인코딩합니다 및 다음 문자 배열로 바이트의 범위를 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="chars" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />, <paramref name="byteCount" /> 또는 <paramref name="charIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="byteindex" /> 및 <paramref name="byteCount" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.  
  
또는 
 <paramref name="charIndex" />가 <paramref name="chars" />의 유효한 인덱스가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" />의 용량(<paramref name="charIndex" /> ~ 배열 끝)이 부족해서 결과 문자를 수용할 수 없는 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 인코딩된 바이트 시퀀스를 문자 시퀀스로 변환하는 디코더를 가져옵니다.</summary>
        <returns>인코딩된 바이트 시퀀스를 문자 시퀀스로 변환하는 <see cref="T:System.Text.Decoder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> 메서드를 비슷한 방식으로 문자의 순차 블록 순차 블록 바이트 변환 된 <xref:System.Text.Encoding.GetChars%2A> 이 클래스의 메서드. 그러나는 <xref:System.Text.Decoder> 블록으로 확장 되는 바이트 시퀀스를 디코딩하고 올바르게 있도록 호출 간의 상태 정보를 유지 관리 합니다. <xref:System.Text.Decoder> 도 데이터 블록의 끝에 후행 바이트를 유지 하 고 디코딩 작업은 다음에 후행 바이트를 사용 합니다. 따라서 <xref:System.Text.Encoding.GetDecoder%2A> 고 <xref:System.Text.Encoding.GetEncoder%2A> 있으므로 아주 유용 네트워크 전송 및 파일 작업에 대 한 전체 데이터 스트림 대신 데이터 블록을 처리 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>기본 구현은 반환을 <see cref="T:System.Text.Decoder" /> 를 호출 하는 합니다 <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> 및 <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다. 반환 하려면이 메서드를 재정의 해야 합니다는 <see cref="T:System.Text.Decoder" /> 호출 간에 상태를 유지 하 합니다.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 유니코드 문자 시퀀스를 인코딩된 바이트 시퀀스로 변환하는 인코더를 가져옵니다.</summary>
        <returns>유니코드 문자 시퀀스를 인코딩된 바이트 시퀀스로 변환하는 <see cref="T:System.Text.Encoder" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> 메서드를 비슷한 방식으로 바이트 순차 블록 문자의 순차 블록 변환는 <xref:System.Text.Encoding.GetBytes%2A> 이 클래스의 메서드. 그러나는 <xref:System.Text.Encoder> 블록으로 확장 되는 문자 시퀀스 올바르게 인코딩하기 호출 간의 상태 정보를 유지 관리 합니다. <xref:System.Text.Encoder> 또한 후행 유지 되는 데이터 블록의 끝 문자 하 고 다음 인코딩 작업에서 후행 문자를 사용 합니다. 예를 들어 데이터 블록 수는 일치 하지 않는 상위 서로게이트를 사용 하 여 종료 및 다음 데이터 블록에 일치 하는 하위 서로게이트 있을 수 있습니다. 따라서 <xref:System.Text.Encoding.GetDecoder%2A> 고 <xref:System.Text.Encoding.GetEncoder%2A> 있으므로 아주 유용 네트워크 전송 및 파일 작업에 대 한 전체 데이터 스트림 대신 데이터 블록을 처리 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>기본 구현은 반환을 <see cref="T:System.Text.Encoder" /> 를 호출 하는 합니다 <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> 및 <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> 현재 메서드 <see cref="T:System.Text.Encoding" />합니다. 반환 하려면이 메서드를 재정의 해야 합니다는 <see cref="T:System.Text.Encoder" /> 호출 간에 상태를 유지 하 합니다.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정한 코드 페이지에 대한 인코딩을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">기본 설정 인코딩의 코드 페이지 식별자입니다. 가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 코드 페이지 열에 나열됩니다.  
  
또는 
기본 인코딩을 사용하려면 0을 사용합니다.</param>
        <summary>지정한 코드 페이지 식별자와 관련된 인코딩을 반환합니다.</summary>
        <returns>지정한 코드 페이지와 관련된 인코딩입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대체 (fallback) 처리기의 인코딩 형식을 종속 `codepage`합니다. 경우 `codepage` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을 최적된 대체 (fallback) 처리기 사용 됩니다. 그렇지 않은 경우 교체 대체 (fallback) 처리기가 사용 됩니다. 이러한 대체 (fallback) 처리기는 앱에 대 한 적합 하지 않을 수 있습니다. 으로 지정 된 인코딩을 사용 하 여 대체 (fallback) 처리기를 지정 `codepage`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.  
  
 .NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다. 그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다. 코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. .NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다. 두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다. 

 .NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.  

0 값을 제공할 수도 있습니다는 `codepage` 인수입니다. 정확한 동작은 해당 여부 모든 인코딩을 사용할 수 있게 된 등록 하 여 종속는 <xref:System.Text.EncodingProvider> 개체:

- 하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 때 인코딩을 반환할 하기로 등록 된 공급자의 인코딩을 반환 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0 인수.     

- .NET Framework에서 인코딩 없이 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자에는 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 운영 체제의 활성 코드 페이지 0을 반환 합니다. Windows 시스템에서 활성 코드 페이지를 확인 하는 Windows를 호출 [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.

- .NET Core, 인코딩 공급자가 등록 또는 등록 된 인코딩 공급자가 없습니다를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 합니다는 <xref:System.Text.UTF8Encoding>합니다.
  
> [!NOTE]
>  일부 지원 되지 않는 코드 페이지 원인을 <xref:System.ArgumentException> 다른 반면 throw 되는 <xref:System.NotSupportedException>합니다. 따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.  
  
> [!NOTE]
>  ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 이러한 이유로 현재 코드 페이지는 ANSI 코드 페이지를 사용 하는 경우 인코딩 및 기본 코드 페이지를 사용 하 여 데이터를 디코딩 반환한 `Encoding.GetEncoding(0)` 권장 되지 않습니다. 가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고 같은 특정 코드 페이지를 대신 사용 해야 합니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다. 인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  

   
  
## Examples  
 다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스와 서로 같은지 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" />가 0보다 작거나 65535보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">기본 설정 인코딩의 코드 페이지 이름입니다. <see cref="P:System.Text.Encoding.WebName" /> 속성에서 반환된 값이 유효합니다. 가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 이름 열에 나열됩니다.</param>
        <summary>지정한 코드 페이지 이름과 관련된 인코딩을 반환합니다.</summary>
        <returns>지정한 코드 페이지와 관련된 인코딩입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대체 (fallback) 처리기의 인코딩 형식을 종속 `name`합니다. 경우 `name` 코드 페이지 또는 더블 바이트 문자 집합 (DBCS) 인코딩을 최적된 대체 (fallback) 처리기 사용 됩니다. 그렇지 않은 경우 교체 대체 (fallback) 처리기가 사용 됩니다. 이러한 대체 (fallback) 처리기는 앱에 대 한 적합 하지 않을 수 있습니다. 으로 지정 된 인코딩을 사용 하 여 대체 (fallback) 처리기를 지정 `name`를 호출할 수 있습니다는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> 오버 로드 합니다.  

.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다. 그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다. 코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. .NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다. 두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다. 

 .NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.  
   
> [!NOTE]
>  ANSI 코드 페이지를 다른 컴퓨터에 다른 수 또는 단일 컴퓨터의 경우 데이터가 손상에 대 한 변경할 수 있습니다. 가장 일관 된 결과 특정 코드 페이지 대신 유니코드 u t F-16이 고 u t F-8 (코드 페이지 65001) 등을 사용 해야 합니다.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다. 인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
## Examples  
 다음 예제에서는 같은 인코딩 (코드 페이지에서 하나) 및 다른 이름으로, 두 인스턴스와 서로 같은지 검사 합니다.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 올바른 코드 페이지 이름이 아닌 경우  
  
또는 
<paramref name="name" />으로 표시된 코드 페이지가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">기본 설정 인코딩의 코드 페이지 식별자입니다. 가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 코드 페이지 열에 나열됩니다.  
  
또는 
기본 인코딩을 사용하려면 0을 사용합니다.</param>
        <param name="encoderFallback">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <param name="decoderFallback">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <summary>지정한 코드 페이지 식별자와 관련된 인코딩을 반환합니다. 매개 변수는 인코딩할 수 없는 문자 및 디코딩할 수 없는 바이트 시퀀스에 대한 오류 처리기를 지정합니다.</summary>
        <returns>지정한 코드 페이지와 관련된 인코딩입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  일부 지원 되지 않는 코드 페이지는 예외를 발생 시킬 <xref:System.ArgumentException> throw 될 다른 반면 <xref:System.NotSupportedException>합니다. 따라서 코드 모든 catch 해야 예외 섹션에 표시 된 예외입니다.  

.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다. 그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다. 코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. .NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다. 두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다. 

 .NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.  

0 값을 제공할 수도 있습니다는 `codepage` 인수입니다. 정확한 동작은 해당 여부 모든 인코딩을 사용할 수 있게 된 등록 하 여 종속는 <xref:System.Text.EncodingProvider> 개체:

- 하나 이상의 인코딩 공급자를 등록 한 경우 마지막으로 때 인코딩을 반환할 하기로 등록 된 공급자의 인코딩을 반환 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드에 전달 됩니다는 `codepage` 0 인수.     

- .NET Framework에서 인코딩 없이 공급자가 등록을 하는 경우는 <xref:System.Text.CodePagesEncodingProvider> 등록 된 인코딩 공급자에는 등록 된 인코딩 공급자가 없습니다 처리 하는 경우 또는 `codepage` 값 활성 코드 페이지 0을 반환 합니다.

- .NET Core, 인코딩 공급자가 등록 또는 등록 된 인코딩 공급자가 없습니다를 처리 하는 경우에 없는 경우에 `codepage` 값 0을 반환 합니다는 <xref:System.Text.UTF8Encoding> 인코딩.

> [!NOTE]
>  ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 이러한 이유로 현재 코드 페이지는 ANSI 코드 페이지를 사용 하는 경우 인코딩 및 기본 코드 페이지를 사용 하 여 데이터를 디코딩 반환한 `Encoding.GetEncoding(0)` 권장 되지 않습니다. 가장 일관 된 결과 특정 코드 페이지 대신 유니코드 u t F-16이 고 u t F-8 (코드 페이지 65001) 등을 사용 해야 합니다. 
  
 활성 코드 페이지와 관련 된 인코딩을 가져오려면 제공할 수 있습니다 하거나 값 0에 대 한 합니다 `codepage` 인수 또는 Windows 바탕 화면에서.NET Framework에서 코드를 실행 하는 경우의 값을 검색 합니다 <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> 속성입니다. 현재 활성 코드 페이지를 확인 하는 Windows를 호출 [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows 바탕 화면에서.NET Framework에서 함수입니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다. 인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" />가 0보다 작거나 65535보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" />가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">기본 설정 인코딩의 코드 페이지 이름입니다. <see cref="P:System.Text.Encoding.WebName" /> 속성에서 반환된 값이 유효합니다. 가능한 값은 <see cref="T:System.Text.Encoding" /> 클래스 항목에 나타나는 테이블의 이름 열에 나열됩니다.</param>
        <param name="encoderFallback">현재 인코딩으로 문자를 인코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <param name="decoderFallback">현재 인코딩으로 바이트 시퀀스를 디코딩할 수 없는 경우 오류 처리 프로시저를 제공하는 개체입니다.</param>
        <summary>지정한 코드 페이지 이름과 관련된 인코딩을 반환합니다. 매개 변수는 인코딩할 수 없는 문자 및 디코딩할 수 없는 바이트 시퀀스에 대한 오류 처리기를 지정합니다.</summary>
        <returns>지정한 코드 페이지와 관련된 인코딩입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

.NET framework에서 <xref:System.Text.Encoding.GetEncoding%2A> 방법은 대부분의 코드 페이지를 지원 하려면 기본 플랫폼에 의존 합니다. 그러나.NET Framework에는 기본적으로 일부 인코딩은 지원합니다. 코드 페이지 목록을 보려면 참조는 <xref:System.Text.Encoding> 클래스 항목입니다. .NET core에서는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 기본적으로.NET Core에서 지 원하는 인코딩을 반환 합니다. 두.NET 구현에서 호출할 수 있습니다 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 배열을 가져오는 방법 <xref:System.Text.EncodingInfo> 사용할 수 있는 모든 인코딩에 대 한 정보를 포함 하는 개체입니다. 

 .NET Core에서 고유 하 게 사용할 수 있는 또는.NET Framework의 특정 플랫폼 버전에서 기본적으로 지원 되는 인코딩은 외에도 <xref:System.Text.Encoding.GetEncoding%2A> 를등록하여사용할수있는모든추가인코딩을메서드<xref:System.Text.EncodingProvider> 개체입니다. 인코딩과 같은 여러 등록 되어 있으면 <xref:System.Text.EncodingProvider> 개체를이 메서드가 반환 개가 등록 됩니다.  
  
> [!NOTE]
>  ANSI 코드 페이지가 서로 다른 컴퓨터에 다른 수 있으며 데이터가 손상, 단일 컴퓨터에서 변경할 수 있습니다. 가장 일관 된 결과 유니코드 인코딩인 u t F-8 (코드 페이지 65001) 또는 u t F-16이 고 같은 특정 코드 페이지를 대신 사용 해야 합니다.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 기본 설정 사용 하 여 캐시 된 인스턴스를 반환합니다. 인스턴스를 가져오는 다른 설정을 사용 하 여 파생된 클래스의 생성자를 사용 해야 합니다. 예를 들어를 <xref:System.Text.UTF32Encoding> 클래스 오류 검색 기능을 사용할 수 있는 생성자를 제공 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> 메서드.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 올바른 코드 페이지 이름이 아닌 경우  
  
또는 
<paramref name="name" />으로 표시된 코드 페이지가 내부 플랫폼에서 지원되지 않는 경우</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 인코딩을 포함하는 배열을 반환합니다.</summary>
        <returns>모든 인코딩을 포함하는 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코드 페이지에서 고유 하 게 구분 하는 지원 되는 인코딩 목록을 반환 합니다. 지원 되는 인코딩을 나열 하는 테이블에 대 한 참조를 <xref:System.Text.Encoding> 클래스 항목입니다.  
  
> [!NOTE]
>  반환한 지원 되는 인코딩 목록은 합니다 <xref:System.Text.Encoding.GetEncodings%2A> 메서드는 제공 된 모든 추가 인코딩을 포함 하지 <xref:System.Text.EncodingProvider> 구현을 호출 하 여 등록 된는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드.  
  
 .NET Framework에서 50220 및 50222 인코딩은 둘 다 이름과 연결 된 "iso-2022-jp" 있지만 같지는있지 않습니다. 인코딩 50220 반자 가타카나 반자 가타카나 문자를 변환, 인코딩 50222 반면 반자 가타카나 문자를 인코딩할 shift-/ 시프트 아웃 시퀀스를 사용 합니다. 50222 인코딩에 대 한 표시 이름은 "일본어 (JIS-1 바이트 Kana-허용 하므로 / SI)" 인코딩에서 구분 하기 위해 표시 된 50220 이름을 "일본어 (JIS)".  
  
 요청 된 인코딩 이름 "iso-2022-jp",.NET Framework는 50220 인코딩. 그러나 앱에 대 한 적합 한 인코딩을 종속 반자 가타카나 문자가 기본 처리 합니다.  
  
 특정 인코딩의 가져오려면 사용할지는 <xref:System.Text.Encoding.GetEncoding%2A> 메서드.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> 사용자 파일의 인코딩 목록으로 제공할 수 사용 되기도 **다른 이름으로 저장** 대화 상자. 그러나 여러 비유니코드 인코딩을은 불완전 한 많은 문자를 및 "?", 또는 다른 플랫폼에서 동작이 약간 다릅니다. 기본적으로 utf-8 또는 u t F-16을 사용 하는 것이 좋습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 인스턴스의 해시 코드를 반환합니다.</summary>
        <returns>현재 인스턴스에 대한 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">인코딩할 문자 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 문자 수의 문자를 인코딩하여 만들 바이트 수를 계산합니다.</summary>
        <returns>지정한 수의 문자를 인코딩할 경우 생성되는 최대 바이트 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `charCount` 매개 변수 개수를 실제로 지정 <xref:System.Char> .NET 유니코드 문자를 나타내기 위해 내부적으로 u t F-16을 사용 하기 때문에, 인코딩할 유니코드 문자를 나타내는 개체입니다. 따라서 씩 대부분의 유니코드 문자를 표현할 수 있습니다 <xref:System.Char> 개체가 아니라 예를 들어, 서로게이트 쌍을 나타내는 유니코드 문자는 두 개가 필요 <xref:System.Char> 개체입니다.  
  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetBytes%2A> 바이트를 저장 하는 결과 사용할지를 <xref:System.Text.Encoding.GetByteCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetByteCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxByteCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 현재 선택 된 최악의 경우를 비롯 한 최악의 숫자 검색 <xref:System.Text.EncoderFallback>합니다. 잠재적으로 큰 문자열을 사용 하 여 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A> 여기서 인코딩에 최악의 경우 전환 해야 하는 모든 문자에 대 한 모드의 경우에 특히 큰 값을 검색 합니다. 예를 들어이 값은 ISO-2022-JP에 발생할 수 있습니다. 자세한 내용은 블로그 항목을 참조 하세요. "[Encoding.GetMaxByteCount()와 Encoding.GetMaxCharCount() 란?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 대부분의 경우이 메서드는 작은 문자열에 대 한 적절 한 값을 검색합니다. 큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 및 보다 적절 한 크기 버퍼가 너무 작은 경우 드문 경우에서 오류를 catch 하는 중 하나를 선택 해야 합니다. 사용 하는 다른 방법을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetByteCount%2A> 또는 <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>합니다.  
  
 사용 하는 경우 <xref:System.Text.Encoding.GetMaxByteCount%2A>, 입력된 버퍼의 최대 크기를 기준으로 출력 버퍼를 할당 해야 합니다. 출력 버퍼 크기에 제한 되는 경우 사용할 수 있습니다는 <xref:System.Text.Encoding.Convert%2A> 메서드.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 이전 디코더 작업에서 잠재적인 남겨진 서로게이트를 고려 합니다. 디코더를 인해 인코딩에 싱글바이트 ASCII와 같은 2를 검색 방법 1의 값을 전달 합니다. 기능을 사용할지는 <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> 이 정보가 필요한 경우 속성입니다.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 동일한 값은 반드시 `N* GetMaxByteCount(1)`입니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Text.EncoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.EncoderFallback" />이 <see cref="T:System.Text.EncoderExceptionFallback" />로 설정됩니다.</exception>
        <block subset="none" type="overrides"><para>모든 <see cref="T:System.Text.Encoding" /> 구현에서 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산의 결과 따라 크기가 결정 하는 경우를 보장 해야 합니다.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 수의 바이트를 디코딩하여 생성되는 최대 문자 수를 계산합니다.</summary>
        <returns>지정한 수의 바이트를 디코딩할 경우 생성되는 최대 문자 수입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 필요한 정확한 배열 크기를 계산 하려면 <xref:System.Text.Encoding.GetChars%2A> 결과 문자를 저장 하려면 사용할지는 <xref:System.Text.Encoding.GetCharCount%2A> 메서드. 최대 배열 크기를 계산 하려면를 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드. 합니다 <xref:System.Text.Encoding.GetCharCount%2A> 메서드는 일반적으로 적은 메모리의 할당을 통해 동안는 <xref:System.Text.Encoding.GetMaxCharCount%2A> 메서드는 일반적으로 더 빠르게 실행 합니다.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 현재 선택 된 최악의 경우를 비롯 한 최악의 숫자 검색 <xref:System.Text.DecoderFallback>합니다. 잠재적으로 큰 문자열을 사용 하 여 대체를 선택한 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A> 큰 값을 검색 합니다.  
  
 대부분의 경우이 메서드는 작은 문자열에 대해 적합 한 숫자를 검색합니다. 큰 문자열에 대 한 매우 큰 버퍼를 사용 하 여 및 보다 적절 한 크기의 버퍼가 너무 작아서 드문 경우에서 오류를 catch 하는 중 하나를 선택 해야 합니다. 사용 하는 다른 방법을 고려해 야 할 수도 있습니다 <xref:System.Text.Encoding.GetCharCount%2A> 또는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>합니다.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 관계가 없으며 <xref:System.Text.Encoding.GetBytes%2A>합니다. 비슷한 기능을 사용 해야 하는 경우 <xref:System.Text.Encoding.GetBytes%2A>를 사용 해야 <xref:System.Text.Encoding.GetMaxByteCount%2A>합니다.  
  
 사용 하는 경우 <xref:System.Text.Encoding.GetMaxCharCount%2A>, 입력된 버퍼의 최대 크기를 기준으로 출력 버퍼를 할당 해야 합니다. 출력 버퍼 크기에 제한 되는 경우 사용할 수 있습니다는 <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> 메서드.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 이전 인코더 작업에서 남아 있는 바이트에 대 한 최악의 경우를 고려 합니다. 대부분의 코드 페이지에 대 한 값을 1 보다 크거나 검색 값이 0이 메서드에 전달 합니다.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 동일한 값은 반드시 `N* GetMaxCharCount(1)`입니다.  
  
   
  
## Examples  
 다음 예제에서는 문자열 바이트 배열로 인코딩하고 바이트 문자 배열로 디코딩합니다.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <block subset="none" type="overrides"><para>모든 <see cref="T:System.Text.Encoding" /> 구현에서 버퍼 오버플로 예외가 발생 하지 않는지 버퍼는이 메서드의 계산의 결과 따라 크기가 결정 하는 경우를 보장 해야 합니다.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되면 사용되는 인코딩을 지정하는 바이트 시퀀스를 반환합니다.</summary>
        <returns>사용되는 인코딩을 지정하는 바이트 시퀀스가 포함된 바이트 배열입니다.  
  
또는 
프리앰블이 필요하지 않으면 길이가 0인 바이트 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 필요에 따라는 <xref:System.Text.Encoding> 개체는 인코딩 프로세스에서 발생 하는 바이트 시퀀스를 붙일 수 있습니다 하는 바이트 배열이 프리앰블을 제공 합니다. 머리말 (유니코드 코드 포인트 U + FEFF)에서 바이트 순서 표시가 들어 디코더에서 바이트 순서와 변환 형식 또는 u t F를 결정 하는 데 도움이 됩니다.  
  
 유니코드 바이트 순서 표시 (BOM) (16 진수)에서 다음과 같이 serialize 됩니다.  
  
-   UTF-8: EF BB BF  
  
-   Utf-16 big endian 바이트 순서: FE FF  
  
-   Utf-16 little endian 바이트 순서: FF FE  
  
-   UTF-32 big endian 바이트 순서: 00 00 FE FF  
  
-   UTF-32 little endian 바이트 순서: FF FE 00 00  
  
 거의 손실에 대 한 참조는 파일에 대 한 인코딩 특정 식별을 제공 하기 때문에 BOM을 사용 해야는 <xref:System.Text.Encoding> 않았을 때 비즈니스를 저장 하는 임의 텍스트 파일 또는 개체, 예를 들어 부적절 하 게 웹 데이터를 태그가 있거나 없는 가 국제 문제 또는 기타 데이터. 데이터는 일관 되 게 제대로 태그 지정, 가급적 utf-8 또는 u t F-16에서 종종 사용자 문제를 방지할 수 있는 합니다.  
  
 인코딩 형식을 제공 하는 표준에 대 한 BOM 다소 중복 됩니다. 그러나 올바른 인코딩 헤더를 보내도록 서버를 사용할 수 있습니다. 또는 사용할 수 있습니다 대체 방법으로 인코딩을 분실할 그렇지 않은 경우.  
  
 BOM을 사용 하 여 몇 가지 단점이 있습니다. 예를 들어 BOM을 사용 하는 데이터베이스 필드를 제한 하는 방법을 알면 어려울 수 있습니다. 파일의 연결 문제가 될 수 또한 예를 들어, 파일 등에서 병합 될 때는 데이터 중간에 불필요 한 문자가 포함 될 수 있도록 합니다. 몇 가지 단점에도 불구 하 고 있지만 bom을 사용 하 여 것이 좋습니다.  
  
 바이트 순서에서 바이트 순서 표시에 대 한 자세한 내용은 유니코드 표준을 참조 합니다 [유니코드 홈페이지](https://go.microsoft.com/fwlink/?LinkId=37123)합니다.  
  
> [!CAUTION]
>  인코딩된 바이트 제대로 디코딩 하도록 인코딩된 바이트 프리앰블 붙여야 합니다. 그러나 대부분의 인코딩 프리앰블을 제공 하지 않습니다. 인코딩된 바이트 디코딩되을 사용할지는 유니코드 인코딩을, 되도록 <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, 또는 <xref:System.Text.UTF32Encoding>, 프리앰블을 사용 하 여 합니다.  
  
   
  
## Examples  
 다음 예제에서는 머리말 기반 인코딩의 바이트 순서를 결정 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파생 클래스에서 재정의되면 바이트 시퀀스를 문자열로 디코딩합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 모든 바이트를 문자열로 디코딩합니다.</summary>
        <returns>지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 를 파생 메서드 ved 클래스입니다.  
  
 설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.  
  
 정확 하 게 동작 합니다 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현에 대 한 정의 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다. 자세한 내용은 "대체 (fallback) 전략 선택" 섹션을 참조 합니다 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.  
  
   
  
## Examples  
 다음 예제에서는 나타내는 이진 파일을 u t F-8로 인코딩된 문자열을 읽습니다.는 <xref:System.IO.FileStream> 개체입니다. 2,048 바이트 보다 작은 파일에 대 한 호출 하는 바이트 배열에 전체 파일의 내용을 읽고는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> 디코딩을 수행 하는 방법입니다. 더 큰 파일에 대 한 바이트를 읽습니다 2,048 동시 호출을 바이트 배열로 합니다 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 결정 하는 방법 배열에 포함 되어 있으며 다음 호출을 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 방법.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 이 예제에서는 라는 Utf8Example.txt u t F-8로 인코딩된 파일에 저장 해야 하는 다음 텍스트를 사용 합니다.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">바이트 배열에 잘못된 유니코드 코드 포인트가 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">바이트 배열에 대한 포인터입니다.</param>
        <param name="byteCount">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의할 때 지정된 주소에서 시작하는 지정된 바이트 수를 문자열로 디코딩합니다.</summary>
        <returns>지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> 메서드는 바이트 배열에 대 한 네이티브 포인터를 해야 하는 경우 성능을 최적화 하도록 디자인 되었습니다. 관리 되는 바이트 배열을 만들고 다음이 디코딩하는 대신 중간 개체를 작성 하지 않고 대신이 메서드를 호출할 수 있습니다.  
  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 에서 반환 된 개체는 <xref:System.Text.Encoding.GetDecoder%2A> 를 파생 메서드 ved 클래스입니다.  
  
 설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.  
  
 정확 하 게 동작 합니다 <xref:System.Text.Encoding.GetString%2A> 특정 메서드 <xref:System.Text.Encoding> 구현에 대 한 정의 대체 (fallback) 전략에 따라 달라 집니다 <xref:System.Text.Encoding> 개체입니다. 자세한 내용은 "대체 (fallback) 전략 선택" 섹션을 참조 합니다 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />이(가) null 포인터입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />가 0보다 작은 경우</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">디코딩할 바이트 시퀀스를 포함하는 바이트 배열입니다.</param>
        <param name="index">디코딩할 첫 번째 바이트의 인덱스입니다.</param>
        <param name="count">디코딩할 바이트 수입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 바이트 배열의 바이트 시퀀스를 문자열로 디코딩합니다.</summary>
        <returns>지정된 바이트 시퀀스에 대한 디코딩 결과가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변환할 데이터 (예: 데이터 스트림에서 읽은) 순차 블록에만 사용할 수 있거나 데이터 양이 너무 커서 작은 블록으로 나눌 수 하는 데 필요한 사용 해야 하는 경우는 <xref:System.Text.Decoder> 또는 <xref:System.Text.Encoder> 에서 제공 된 <xref:System.Text.Encoding.GetDecoder%2A> 메서드 또는 <xref:System.Text.Encoding.GetEncoder%2A> 메서드를 각각 파생된 클래스입니다.  
  
 설명 섹션을 참조 합니다 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 디코딩 기술 및 고려 사항에 대 한 설명은 대 한 참조 항목입니다.  
  
   
  
## Examples  
 다음 예제에서는 나타내는 이진 파일을 u t F-8로 인코딩된 문자열을 읽습니다.는 <xref:System.IO.FileStream> 개체입니다. 2,048 바이트 보다 작은 파일에 대 한 호출 하는 바이트 배열에 전체 파일의 내용을 읽고는 <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 디코딩을 수행 하는 방법입니다. 더 큰 파일에 대 한 바이트를 읽습니다 2,048 동시 호출을 바이트 배열로 합니다 <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 문자 개수를 결정 하는 방법 배열에 포함 되어 있으며 다음 호출을 <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> 디코딩을 수행 하는 방법.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 이 예제에서는 라는 Utf8Example.txt u t F-8로 인코딩된 파일에 저장 해야 하는 다음 텍스트를 사용 합니다.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">바이트 배열에 잘못된 유니코드 코드 포인트가 포함되어 있습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" /> 및 <paramref name="count" />가 <paramref name="bytes" />에서 올바른 범위를 나타내지 않습니다.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">대체가 발생했습니다(전체 설명은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md) 참조). 
및 
 <see cref="P:System.Text.Encoding.DecoderFallback" />이 <see cref="T:System.Text.DecoderExceptionFallback" />로 설정됩니다.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 메일 에이전트 헤더 태그에 사용할 수 있는 현재 인코딩의 이름을 가져옵니다.</summary>
        <value>메일 에이전트 헤더 태그에 사용할 현재 <see cref="T:System.Text.Encoding" />의 이름입니다.  
  
또는 
현재 <see cref="T:System.Text.Encoding" />을 사용할 수 없으면 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 헤더 이름에 대 한 인코딩을 해야 하는 경우 호출 해야 합니다 <xref:System.Text.Encoding.GetEncoding%2A> 메서드는 <xref:System.Text.Encoding.HeaderName%2A> 속성입니다. 종종 메서드 호출에 제공 된 인코딩을 테스트에서 다른 인코딩을 검색 합니다. 일반적으로 전자 메일 응용 프로그램만 그러한 인코딩을 검색 해야 합니다.  
  
 경우에 따라 값을 <xref:System.Text.Encoding.BodyName%2A> 속성은 해당 인코딩을 정의 하는 국제 표준에 해당 합니다. 구현 표준에 사용 하 여 전체에서 준수는 것은 아닙니다.  
  
 <xref:System.Text.Encoding.WebName%2A> 을 사용 하는 인코딩을 설명 이름을 반환 합니다. <xref:System.Text.Encoding.HeaderName%2A> 속성 더 적합할 수 있는 전자 메일 응용 프로그램에 대 한 예를 들어 다른 인코딩을 정의 합니다. 그러나 인코딩을 정의 하는 속성의 사용은 권장 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>기본 정규화 형식을 사용하여 현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</summary>
        <returns>현재 <see cref="T:System.Text.Encoding" />이 항상 정규화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 정규화는 <xref:System.Text.NormalizationForm.FormC>, 완전 한 정식 분해를 해당 기본 복합으로 시퀀스를 대체 하 여 가능한 경우 사용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form"><see cref="T:System.Text.NormalizationForm" /> 값 중 하나입니다.</param>
        <summary>파생 클래스에서 재정의되면 지정한 정규화 형식을 사용하여 현재 인코딩이 항상 정규화되는지를 나타내는 값을 가져옵니다.</summary>
        <returns>현재 <see langword="true" /> 개체가 항상 지정한 <see cref="T:System.Text.Encoding" /> 값을 사용하여 정규화되면 <see cref="T:System.Text.NormalizationForm" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 정규화는 <xref:System.Text.NormalizationForm.FormC>, 완전 한 정식 분해를 해당 기본 복합으로 시퀀스를 대체 하 여 가능한 경우 사용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩을 브라우저 클라이언트가 내용을 표시하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />을 브라우저 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩을 브라우저 클라이언트가 내용을 저장하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />을 브라우저 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩을 메일 및 뉴스 클라이언트가 내용을 표시하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />을 메일 및 뉴스 클라이언트가 내용을 표시하는 데 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩을 메일 및 뉴스 클라이언트가 내용을 저장하는 데 사용할 수 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see langword="true" />을 메일 및 뉴스 클라이언트가 내용을 저장하는 데 사용할 수 있으면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩이 읽기 전용인지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see langword="true" />가 읽기 전용이면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩이 단일 바이트 코드 포인트를 사용하는지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 <see langword="true" />이 단일 바이트 코드 포인트를 사용하면 <see cref="T:System.Text.Encoding" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 싱글바이트 인코딩, 예를 들어 <xref:System.Text.ASCIIEncoding>,이 속성을 검색 `true`합니다.  
  
> [!CAUTION]
>  에 대 한 값을 사용 하 여 응용 프로그램은 주의 해 서 해야 <xref:System.Text.Encoding.IsSingleByte%2A>합니다. 인코딩 진행 하는 방법의 가정은 잘못 된 수 있습니다. 예를 들어 Windows-1252에 값 `true` 에 대 한 <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, 하지만 Encoding.GetMaxByteCount(1) 2를 반환 합니다. 이 메서드는 이전 decoder 작업에서 잠재적인 남겨진 서로게이트를 고려 때문입니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩 부울 속성 값을 확인 합니다.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">추가 문자 인코딩에 대한 액세스를 제공하는 <see cref="T:System.Text.EncodingProvider" />의 하위 클래스입니다.</param>
        <summary>인코딩 공급자를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드를 사용 하면에서 파생 된 클래스를 등록할 수 있습니다 <xref:System.Text.EncodingProvider> 는 그렇지 않은 경우 지원 하지 않는 플랫폼에서 사용할 수 있는 인코딩 문자는 합니다. 지원 되는 인코딩은 인코딩 공급자 등록 되 면 하나를 호출 하 여 검색할 수 있습니다 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 오버 로드 합니다. 여러 인코딩 공급자에 있는 경우는 <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> 메서드 가장 최근에 등록 된 것으로 시작 하는 각 공급자에서 지정 된 인코딩을 검색 하려고 시도 합니다.

인코딩 공급자를 사용 하 여 등록 합니다 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드는 또한의 동작을 수정 합니다 [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) 및 [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) 메서드는 인수를 전달 하는 경우 `0`:

- 등록 된 공급자가는 <xref:System.Text.CodePagesEncodingProvider>, 메서드는 Windows 운영 체제를 실행 하는 경우 시스템 활성 코드 페이지와 일치 하는 인코딩을 반환 합니다.

- 사용자 지정 인코딩 공급자를 반환할 때 인코딩을 선택할 수 있습니다 이러한 <xref:System.Text.Encoding.GetEncoding%2A> 메서드 오버 로드의 인수로 전달 됩니다 `0`합니다. 공급자 함으로써 인코딩을 반환 하지 하도록 선택할 수도 있습니다는 <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> 메서드가 반환 `null`합니다. 
  
.NET Framework 4.6 부터는.NET Framework에 하나의 인코딩 공급자 <xref:System.Text.CodePagesEncodingProvider>, 전체.NET Framework에는 유니버설 Windows 플랫폼에서 사용할 수 없는 인코딩을 사용할 수 있도록 합니다. 유니버설 Windows 플랫폼을 기본적으로 유니코드, ASCII 인코딩과 코드 페이지 28591만 지원합니다.  
  
 동일한 인코딩 공급자에 대 한 여러 호출에 사용 되 면는 <xref:System.Text.Encoding.RegisterProvider%2A> 공급자를 등록 하는 메서드를 첫 번째 메서드 호출 합니다. 후속 호출은 무시 됩니다.  
  
 경우는 <xref:System.Text.Encoding.RegisterProvider%2A> 메서드 같은 인코딩을 처리 하는 여러 공급자를 등록 하는, 마지막으로 등록 된 공급자가 모든 인코딩 및 디코딩 작업에 사용 합니다. 이전에 등록 된 모든 공급자는 무시 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>little endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩을 가져옵니다.</summary>
        <value>little-endian 바이트 순서를 사용하는 UTF-16 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.UnicodeEncoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트는 물음표를 바꿉니다 ("?") 문자입니다. 대신 호출할 수 있습니다는 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 생성자를 인스턴스화하는 little endian의 약자 <xref:System.Text.UnicodeEncoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>little endian 바이트 순서를 사용하는 UTF-32 형식에 대한 인코딩을 가져옵니다.</summary>
        <value>little-endian 바이트 순서를 사용하는 UTF-32 형식에 대한 인코딩 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> 이 속성에 의해 반환 된 개체를 앱에 대 한 적절 한 동작에 없을 수 있습니다. 교체 대체 (fallback)를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트 유니코드 REPLACEMENT CHARACTER (U + FFFE)으로 바꿉니다. 대신, 호출할 수 있습니다는 <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 인스턴스화하는 생성자를 <xref:System.Text.UTF32Encoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Little endian 바이트 순서 내용은 참조는 <xref:System.Text.Encoding> 클래스 항목입니다.  
  
 .NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-7 형식에 대한 인코딩을 가져옵니다.</summary>
        <value>UTF-7 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utf-7 인코딩이 지금까지 7 비트, NNTP 등 일부 전자 메일 응용 프로그램을 제한 된 된 환경에서 주로 사용 됩니다. 견고성 및 보안 문제로 인해 사용 하지 않아야 UTF7 8 비트 환경에서 인코딩 u t F-8 인코딩을 사용할 수 있는 대신 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 배열을 인코딩하는 데 필요한 바이트 수를 결정 문자를 인코딩하고 결과 바이트 수를 표시 합니다.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-8 형식에 대한 인코딩을 가져옵니다.</summary>
        <value>UTF-8 형식에 대한 인코딩입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 반환을 <xref:System.Text.UTF8Encoding> 문자당 1 ~ 4 바이트 시퀀스를 유니코드 (u t F-16으로 인코딩된) 문자를 인코딩하는 유니코드 (u t F-16으로 인코딩된) 문자는 u t F-8로 인코딩된 바이트 배열 디코드 하는 개체입니다. .NET 및 인코딩을 사용 하는 유니코드에 대 한 설명은에서 지 원하는 문자 인코딩에 대 한 내용은 [.NET의 문자 인코딩](~/docs/standard/base-types/character-encoding.md)합니다.  
  
 <xref:System.Text.UTF8Encoding> 이 속성에 의해 반환 되는 개체는 앱에 대 한 적절 한 동작 있을 수 없습니다.  
  
-   반환 된 <xref:System.Text.UTF8Encoding> 유니코드 바이트 순서 표시 (BOM)를 제공 하는 개체입니다. BOM을 제공 하지 않는 한 UTF8 인코딩을 인스턴스화 호출의 오버 로드는 <xref:System.Text.UTF8Encoding.%23ctor%2A> 생성자입니다.  
  
-   반환 된 <xref:System.Text.UTF8Encoding> 물음표를 사용 하 여 각 인코딩할 수 없는 문자열과 디코딩할 수 없는 각 바이트를 바꾸려면 교체 대체 (fallback)를 사용 하는 개체 ("?") 문자입니다. 대신, 호출할 수 있습니다는 <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 인스턴스화하는 생성자를 <xref:System.Text.UTF8Encoding> 인 대체 (fallback)는 개체를 <xref:System.Text.EncoderFallbackException> 또는 <xref:System.Text.DecoderFallbackException>다음 예제와 같이, 합니다.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 다음 예제에서는 다음 문자로 구성 된 배열을 정의 합니다.  
  
-   라틴어 소문자 Z (U + 007A)  
  
-   라틴어 작은 문자는 (단어로)  
  
-   결합 에스프레소 (U + 0306)  
  
-   예 (U + 01FD)를 사용 하 여 영문 소문자 AE  
  
-   그리스어 소문자 베타 (U + 03B2)  
  
-   서로게이트 쌍 (u+d800부터 U + DD54) 그리스어 ACROPHONIC ATTIC 하나 천 STATERS (U + 10154)를 구성 합니다.  
  
 각 문자의 utf-16 코드 단위를 표시 하 고 문자 배열을 인코딩하는 데는 utf-8 인코더에 필요한 바이트 수를 결정 합니다. 다음 문자를 인코딩하고 결과 u t F-8로 인코딩된 바이트 수를 표시 합니다.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">인코딩 이해</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩에 대해 IANA(Internet Assigned Numbers Authority)에 등록된 이름을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />에 대한 IANA 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.Encoding.WebName%2A> 속성은 동일 합니다 <xref:System.Text.EncodingInfo.Name%2A> 속성입니다.  
  
 <xref:System.Text.Encoding.WebName%2A> 인코딩에 대해 IANA에 등록 된 이름을 반환 합니다. 해당 값은 표준의 이름, 인코딩 구현 표준에 전체에서 따르지 않을 수도 있습니다. <xref:System.Text.Encoding.HeaderName%2A> 속성은 전자 메일 헤더에 더 적합할 수 있는 다른 인코딩을 정의 합니다. 그러나 대부분의 앱을 사용 해야 <xref:System.Text.Encoding.WebName%2A> 대신 합니다.  
  
 IANA에 대 한 자세한 내용은 이동 [www.iana.org](https://www.iana.org/)합니다.  
  
 합니다 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> 동일 합니다 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> 반환한 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>합니다. 웹 이름 중 일부는 중복 되었습니다. 에 대 한 설명을 참조 <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> 자세한 내용은 합니다.  
  
   
  
## Examples  
 다음 예제를 포함 합니다 <xref:System.Text.Encoding.WebName%2A> HTML 헤더에서입니다.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 다음 예제에서는 각 인코딩에 다른 이름을 검색 하 고 하나 이상의 이름으로 다른 인코딩을 표시 <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>합니다. 표시 <xref:System.Text.Encoding.EncodingName%2A> 있지만 대해 비교 하지 않습니다.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>파생 클래스에서 재정의되면 현재 인코딩과 가장 비슷한 Windows 운영 체제 코드 페이지를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Text.Encoding" />과 가장 비슷한 Windows 운영 체제 코드 페이지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 글꼴 패밀리를 결정 하는 데 예를 들어 Windows 다국어 (MLang) Api 사용 하 여 호환성을 위해 제공 됩니다. 세계화를 위한 유니코드 인코딩 중 하나를 사용 하는 것이 좋습니다 대신. 사용 하는 것은 권장 수도 <xref:System.Text.Encoding.WebName%2A> 대신 <xref:System.Text.Encoding.WindowsCodePage%2A> 코드 페이지를 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 각 인코딩에 해당 하는 가장 근접 하 게는 Windows 코드 페이지를 결정 합니다.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>