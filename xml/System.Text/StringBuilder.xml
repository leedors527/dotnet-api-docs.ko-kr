<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d75769fba72ba4165ce31fa609759964ea3d8189" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52607115" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>변경할 수 있는 문자열을 나타냅니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 문자 시퀀스로 변경할 수 있는 값인 문자열 같은 개체를 나타냅니다.  
  
 섹션 내용  
  
-   [String 및 StringBuilder 형식](#StringAndSB)  
  
-   [StringBuilder의 작동 원리](#HowWorks)  
  
-   [메모리 할당](#Memory)  
  
-   [StringBuilder 개체 인스턴스화](#Instantiating)  
  
-   [StringBuilder 메서드 호출](#Calling)  
  
-   [StringBuilder 작업 수행](#Operations)  
  
    -   [StringBuilder 문자를 반복합니다.](#Iterating)  
  
    -   [StringBuilder 개체에 텍스트 추가](#Adding)  
  
    -   [StringBuilder 개체의 텍스트를 삭제 하는 중](#Deleting)  
  
    -   [StringBuilder 개체의 텍스트를 수정합니다.](#Modifying)  
  
-   [StringBuilder 개체의 텍스트를 검색합니다.](#Searching)  
  
-   [StringBuilder 개체를 문자열로 변환](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>String 및 StringBuilder 형식  
 하지만 <xref:System.Text.StringBuilder> 및 <xref:System.String> 둘 다 시퀀스를 나타내는 문자를 다르게 구현 되는 합니다. <xref:System.String> 변경할 수 없는 형식이입니다. 수정 하려면 표시 되는 각 작업 즉, 한 <xref:System.String> 개체는 실제로 새 문자열을 만듭니다.  
  
 예를 들어 호출 된 <xref:System.String.Concat%2A?displayProperty=nameWithType> 라는 문자열 변수 값을 변경 하려면 다음 C# 예제에서 메서드가 나타납니다 `value`. 실제로 <xref:System.String.Concat%2A> 메서드가 반환 되는 `value` 에서 주소를 다른 값을 가진 개체를는 `value` 메서드에 전달 된 개체입니다. 사용 하 여 예제를 컴파일해야는 참고를 `/unsafe` 컴파일러 옵션입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 광범위 한 문자열 조작 (예: 여러 번 루프에서에서 문자열을 수정 하는 앱)를 수행 하는 루틴에 대 한 문자열을 반복적으로 수정 하면 성능이 크게 저하를 정확한 수 있습니다. 대신 사용 하는 <xref:System.Text.StringBuilder>를 변경할 수 있는 문자열 클래스인 합니다. 가변성은 클래스의 인스턴스를 만든 후 수정할 수 있습니다 추가, 제거, 바꾸기 또는 문자를 삽입 하 여 의미 합니다. <xref:System.Text.StringBuilder> 개체는 문자열에 대 한 확장을 수용 하기 위해 버퍼를 유지 합니다. 대화방; 사용 가능한 경우 버퍼에 새 데이터가 추가 됩니다. 이 고, 그렇지 새로운, 더 큰 버퍼를 할당 하 고 원래 버퍼의 데이터 새 버퍼에 복사 되 고 새 데이터는 그런 다음 새 버퍼에 추가 됩니다.  
  
> [!IMPORTANT]
>  하지만 합니다 <xref:System.Text.StringBuilder> 클래스에는 일반적으로 보다 더 나은 성능을 제공 합니다 <xref:System.String> 클래스를 자동으로 대체 <xref:System.String> 사용 하 여 <xref:System.Text.StringBuilder> 문자열을 조작 하려는 때마다. 성능은 새 문자열, 앱을 실행 하는 시스템 및 작업의 형식에 대해 할당할 메모리의 양 문자열의 크기에 따라 달라 집니다. 확인 하려면 앱을 테스트할 준비가 되어 있어야 하는지 여부를 <xref:System.Text.StringBuilder> 실제로 성능이 크게 향상을 제공 합니다.  
  
 사용 하는 것이 좋습니다는 <xref:System.String> 이러한 조건에서 클래스:  
  
-   경우는 앱은 문자열로 변경의 수가 작습니다. 이러한 경우 <xref:System.Text.StringBuilder> 수 무시할 제품 또는 성능 향상을 통해 <xref:System.String>합니다.  
  
-   경우는 고정된 된 수의 문자열 리터럴 사용 하 여 특히 연결 작업을 수행 합니다. 이 경우 컴파일러는 단일 작업으로 연결 작업을 결합할 수 있습니다.  
  
-   경우에 문자열을 빌드하는 동안 광범위 한 검색 작업을 수행 해야 합니다. 합니다 <xref:System.Text.StringBuilder> 클래스에 메서드를 같은 검색 `IndexOf` 또는 `StartsWith`합니다. 변환 해야 합니다 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 이러한 작업과이 사용 하 여 성능이 부정할 수에 대 한 <xref:System.Text.StringBuilder>합니다. 자세한 내용은 참조는 [StringBuilder 개체에서 텍스트 검색](#Searching) 섹션입니다.  
  
 사용 하는 것이 좋습니다는 <xref:System.Text.StringBuilder> 이러한 조건에서 클래스:  
  
-   예상 하는 앱 (예: 사용자 입력을 포함 하는 문자열의 임의 숫자로 연결할 루프를 사용 하는 경우) 디자인 타임에 문자열로 변경 내용의 수 알된 수 있도록 합니다.  
  
-   예상 하는 많은 수의 변경 내용 문자열로 있도록 앱.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder의 작동 원리  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> 속성의 문자 수를 나타냅니다는 <xref:System.Text.StringBuilder> 현재 개체를 포함 합니다. 문자를 추가 하는 경우는 <xref:System.Text.StringBuilder> 길이가 증가 크기과 같을 때까지 개체를 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 개체를 포함할 수 있는 문자 수를 정의 하는 속성입니다. 추가 문자 수의 길이 경우는 <xref:System.Text.StringBuilder> 개체의 현재 용량, 새 메모리를 초과 하는 할당의 값을 <xref:System.Text.StringBuilder.Capacity%2A> 속성 두 배로 증가, 새 문자가 추가 되어를 <xref:System.Text.StringBuilder> 개체 및 해당 <xref:System.Text.StringBuilder.Length%2A>속성이 조정 됩니다. 에 대 한 추가 메모리를 <xref:System.Text.StringBuilder> 개체에 정의 된 값에 도달할 때까지 동적으로 할당 되는 <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> 속성입니다. 최대 용량에 도달 하면 추가 메모리가 없습니다.에 할당 될 수는 <xref:System.Text.StringBuilder> 개체 및 문자를 추가 하거나 해당 최대 용량을 초과 확장 하려고 하거나 throw를 <xref:System.ArgumentOutOfRangeException> 또는 <xref:System.OutOfMemoryException> 예외입니다.  
  
 다음 예제에서는 어떻게를 <xref:System.Text.StringBuilder> 개체 새 메모리 할당 및 개체에 할당 된 문자열을 확장 하는 대로 해당 용량을 동적으로 증가 합니다. 이 코드에서는 만듭니다는 <xref:System.Text.StringBuilder> 기본 (매개 변수가 없는) 생성자를 호출 하 여 개체입니다. 이 개체의 기본 용량 16 자 이며 최대 용량 2 십억 개 이상의 문자입니다. 추가 문자열 "This is 문장." 문자열 길이 (19 자)의 기본 용량을 초과 하기 때문에 새 메모리 할당의 결과 <xref:System.Text.StringBuilder> 개체입니다. 32 자로 개체의 용량을 두 배로 만듭니다, 그리고 새 문자열 추가 되 고 개체의 길이 19 자과 같습니다. 코드를 다음 추가 문자열 "This is 추가 문장." 값에는 <xref:System.Text.StringBuilder> 11 번 개체입니다. 때마다 작업을 추가 하면 기간을 <xref:System.Text.StringBuilder> 용량과 해당 기존 용량을 초과 하는 개체의 두 배가 됩니다 및 <xref:System.Text.StringBuilder.Append%2A> 작업이 성공 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>메모리 할당  
 기본 용량을 <xref:System.Text.StringBuilder> 개체는 16 자 이며 최대 기본 용량 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 호출 하는 경우 이러한 기본 값을 사용 합니다 <xref:System.Text.StringBuilder.%23ctor> 고 <xref:System.Text.StringBuilder.%23ctor%28System.String%29> 생성자입니다.  
  
 초기 용량을 명시적으로 정의할 수 있습니다는 <xref:System.Text.StringBuilder> 다음과 같은 방법으로 개체:  
  
-   중 하나를 호출 하 여 합니다 <xref:System.Text.StringBuilder> 포함 하는 생성자를 `capacity` 개체를 만들 때 매개 변수입니다.  
  
-   새 값을 명시적으로 할당 하 여 합니다 <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> 속성을 기존 확장 <xref:System.Text.StringBuilder> 개체입니다. 참고 새 용량을 사용 하면 기존 보다 크거나 용량 보다 작으면 속성 예외를 throw 하는 <xref:System.Text.StringBuilder> 개체의 최대 용량입니다.  
  
-   호출 하 여는 <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> 새 용량을 사용 하 여 메서드. 새 용량 보다 크지 않아야 합니다 <xref:System.Text.StringBuilder> 개체의 최대 용량입니다. 할당할 달리 합니다 <xref:System.Text.StringBuilder.Capacity%2A> 속성인 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 경우 예외를 throw 하지 않습니다 원하는 새 용량을 사용 하면 기존 용량 보다 작습니다; 여기에서 메서드 호출의 영향을 주지 않습니다.  
  
 문자열의 길이에 할당 하는 경우는 <xref:System.Text.StringBuilder> 기본 용량 또는 지정된 된 용량을 초과 하는 생성자 호출에서 개체를 <xref:System.Text.StringBuilder.Capacity%2A> 속성은 사용 하 여 지정 된 문자열의 길이 `value` 매개 변수.  
  
 최대 용량을 명시적으로 정의할 수 있습니다는 <xref:System.Text.StringBuilder> 를 호출 하 여 개체를 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자입니다. 새 값을 할당 하 여 최대 용량을 변경할 수 없습니다는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성을 읽기 전용 이기 때문입니다.  
  
 이전 섹션과 기존 용량에 메모리가 부족 하 여, 추가 될 때마다 표시를 할당의 용량을 <xref:System.Text.StringBuilder> 개체에 정의 된 값까지 double는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다.  
  
 일반적으로 기본 용량 및 최대 용량은 대부분의 앱에 적합 합니다. 다음 조건에서 이러한 값을 설정 하는 것이 좋습니다.  
  
-   하는 경우의 최종 크기를 <xref:System.Text.StringBuilder> 개체는 몇 메가바이트를 초과 일반적으로 매우 큰 증가할 수 있습니다. 이 경우 있을 초기 설정에서 성능상의 이점을 <xref:System.Text.StringBuilder.Capacity%2A> 너무 많은 메모리 재할당에 대 한 필요성을 제거 하려면 상대적으로 높은 값으로 속성입니다.  
  
-   앱 제한 된 메모리를 사용 하 여 시스템에서 실행 되는 합니다. 설정을 고려해 야 할 수 있습니다이 경우에 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성을 보다 작은 <xref:System.Int32.MaxValue?displayProperty=nameWithType> 앱 메모리 사용이 제한 된 환경에서 실행 되도록를 일으킬 수 있는 큰 문자열을 처리 하는 경우.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>StringBuilder 개체 인스턴스화  
 인스턴스화하는 <xref:System.Text.StringBuilder> 중 다음 표에 나열 된 6 개 오버 로드 된 클래스 생성자를 호출 하 여 개체입니다. 생성자의 세 가지 인스턴스화를 <xref:System.Text.StringBuilder> 값인 빈 문자열인 경우 개체는 설정 하지만 해당 <xref:System.Text.StringBuilder.Capacity%2A> 및 <xref:System.Text.StringBuilder.MaxCapacity%2A> 다르게 값입니다. 나머지 3 개 생성자는 정의 <xref:System.Text.StringBuilder> 용량 및 특정 문자열 값을 가진 개체입니다. 기본 최대 용량을 사용 하 여 3 개 생성자 중 두 가지 <xref:System.Int32.MaxValue?displayProperty=nameWithType>반면 세 번째를 사용 하면 최대 용량을 설정할 수 있습니다.  
  
|생성자|문자열 값|용|최대 용량|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|정의 된 `capacity` 매개 변수|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|정의 된 `capacity` 매개 변수|정의 된 `maxCapacity` 매개 변수|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|정의 된 `value` 매개 변수|16 또는 `value`합니다. <xref:System.String.Length%2A>에서 더 큰 쪽|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|정의 된 `value` 매개 변수|정의 된 `capacity` 매개 변수 또는 `value`합니다. <xref:System.String.Length%2A>에서 더 큰 쪽입니다.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|정의한 `value`합니다. <xref:System.String.Substring%2A>(`startIndex`, `length`)|정의 된 `capacity` 매개 변수 또는 `value`합니다. <xref:System.String.Length%2A>에서 더 큰 쪽입니다.|정의 된 `maxCapacity` 매개 변수|  
  
 다음 예제에서는 이러한 생성자 오버 로드 중 3 개를 사용 하 여 인스턴스화할 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>StringBuilder 메서드 호출  
 문자열을 수정 하는 메서드 중 대부분을 <xref:System.Text.StringBuilder> 인스턴스는 동일한 인스턴스에 대 한 참조를 반환 합니다. 이렇게 하면 호출 <xref:System.Text.StringBuilder> 두 가지 방법으로 메서드:  
  
-   개별 메서드를 호출할 수 있으며 다음 예제와 같이 반환 값을 무시할 수 있습니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   단일 문에서 일련의 메서드 호출을 만들 수 있습니다. 연속 작업을 연결 하는 단일 문으로 작성 하려는 경우에 편리할 수 있습니다. 다음 예제에서는 코드 한 줄으로 이전 예제에서 세 개의 메서드 호출을 통합합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>StringBuilder 작업 수행  
 메서드를 사용할 수는 <xref:System.Text.StringBuilder> 반복, 추가, 삭제 또는 수정에 문자 클래스는 <xref:System.Text.StringBuilder> 개체입니다.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>StringBuilder 문자를 반복합니다.  
 문자를 액세스할 수 있습니다는 <xref:System.Text.StringBuilder> 사용 하 여 개체를 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성입니다. C#에서는 <xref:System.Text.StringBuilder.Chars%2A> 인덱서;는 Visual Basic에서는 기본 속성을는 <xref:System.Text.StringBuilder> 클래스입니다. 이렇게 하면 명시적으로 참조 하지 않고 해당 인덱스에만 사용 하 여 개별 문자를 검색 하는 <xref:System.Text.StringBuilder.Chars%2A> 속성입니다. 문자를 <xref:System.Text.StringBuilder> 개체는 인덱스 (0)에서 시작 하 고 인덱스 계속 <xref:System.Text.StringBuilder.Length%2A> -1입니다.  
  
 다음 예제는 <xref:System.Text.StringBuilder.Chars%2A> 속성입니다. 10 개 난수를 추가 하는 <xref:System.Text.StringBuilder> 개체를 다음 각 문자를 반복 합니다. 문자의 유니코드 범주 이면 <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, 수를 1 씩 감소 (또는 해당 값이 0 이면 숫자 9로 변경). 내용을 표시 하는 예제는 <xref:System.Text.StringBuilder> 전과 개별 문자 값이 변경 된 후 두 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>StringBuilder 개체에 텍스트 추가  
 합니다 <xref:System.Text.StringBuilder> 클래스의 내용을 확장 하기 위해 다음 메서드를 포함 한 <xref:System.Text.StringBuilder> 개체:  
  
-   합니다 <xref:System.Text.StringBuilder.Append%2A> 메서드는 추가 부분 문자열, 문자열, 문자 배열, 문자 배열의 일부 단일 문자를 여러 번 반복 하거나 기본 데이터의 문자열 표현을 입력 하 여를 <xref:System.Text.StringBuilder> 개체입니다.  
  
-   합니다 <xref:System.Text.StringBuilder.AppendLine%2A> 줄 종결자 또는 줄 종결자가 오는와 함께 문자열을 추가 하는 메서드를 <xref:System.Text.StringBuilder> 개체입니다.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드를 추가를 <xref:System.Text.StringBuilder> 개체입니다. 결과 문자열에 포함 된 개체의 문자열 표현에는 현재 시스템 문화권 또는 지정된 된 문화권의 서식 규칙 반영할 수 있습니다.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> 메서드 삽입 문자열을 부분 문자열, 문자열의 여러 반복 문자 배열, 문자 배열의 일부 또는 기본 데이터의 문자열 표현에서 지정된 된 위치에서 입력을 <xref:System.Text.StringBuilder> 개체입니다. 위치는 0부터 시작 인덱스에 의해 정의 됩니다.  
  
 다음 예제에서는 합니다 <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, 및 <xref:System.Text.StringBuilder.Insert%2A> 의 텍스트를 확장 하는 방법을 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>StringBuilder 개체의 텍스트를 삭제 하는 중  
 합니다 <xref:System.Text.StringBuilder> 클래스의 현재 크기를 줄일 수 있는 메서드가 포함 됩니다 <xref:System.Text.StringBuilder> 인스턴스. <xref:System.Text.StringBuilder.Clear%2A> 메서드는 모든 문자를 제거 하 고 설정를 <xref:System.Text.StringBuilder.Length%2A> 속성을 0. <xref:System.Text.StringBuilder.Remove%2A> 메서드는 지정 된 개수의 문자를 특정 인덱스 위치부터 삭제 합니다. 또한 끝에서 문자를 제거할 수 있습니다는 <xref:System.Text.StringBuilder> 개체를 설정 하 여 해당 <xref:System.Text.StringBuilder.Length%2A> 현재 인스턴스의 길이 보다 작은 값으로 속성.  
  
 다음 예제에서 텍스트의 일부를 제거는 <xref:System.Text.StringBuilder> 개체, 해당 결과 용량, 최대 용량 및 길이 속성 값을 표시 하 고 호출 합니다 <xref:System.Text.StringBuilder.Clear%2A> 에서 모든 문자를 제거 하는 방법을 <xref:System.Text.StringBuilder> 개체.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>StringBuilder 개체의 텍스트를 수정합니다.  
 합니다 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> 메서드는 문자 또는 문자열 전체에 있는 모든 항목을 대체 <xref:System.Text.StringBuilder> 개체 또는 특정 문자 범위입니다. 다음 예제에서는 합니다 <xref:System.Text.StringBuilder.Replace%2A> 에서 물음표 (?)를 사용 하 여 모든 느낌표 (!)를 대체 하는 방법의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder 개체의 텍스트를 검색합니다.  
 <xref:System.Text.StringBuilder> 클래스와 비슷한 메서드를 포함 되지 않습니다는 <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, 및 <xref:System.String.StartsWith%2A?displayProperty=nameWithType> 에서 제공 하는 메서드는 <xref:System.String> 클래스를 특정 문자 또는 부분 문자열에 대 한 개체를 검색할 수 있습니다. 존재 여부를 확인 하거나 부분 문자열의 문자 위치 시작을 검색 하는 필요는 <xref:System.String> 문자열 검색 방법 또는 정규식 메서드 중 하나를 사용 하 여 값입니다. 다음 표에서 보여 주듯이 이러한 검색을 구현 하는 방법은 네 가지입니다.  
  
|기술|전문가|단점|  
|---------------|----------|----------|  
|추가 하기 전에 문자열 값을 검색 합니다 <xref:System.Text.StringBuilder> 개체입니다.|부분 문자열이 있는지 여부를 결정 하는 데 유용 합니다.|부분 문자열의 인덱스 위치는 중요 한 경우 사용할 수 없습니다.|  
|호출 <xref:System.Text.StringBuilder.ToString%2A> 반환 된 검색 및 <xref:System.String> 개체입니다.|사용 하기 쉬운 모든 텍스트를 할당 하는 경우는 <xref:System.Text.StringBuilder> 개체를 선택한 다음 수정 하기 시작 합니다.|반복적으로 호출 하기가 불편 <xref:System.Text.StringBuilder.ToString%2A> 하는 경우 수정 해야 모든 텍스트에 추가 되기 전에 <xref:System.Text.StringBuilder> 개체입니다.<br /><br /> 끝에서 작동 하도록 설정 해야 합니다 <xref:System.Text.StringBuilder> 개체의 텍스트 내용을 변경 하려는 경우.|  
|사용 된 <xref:System.Text.StringBuilder.Chars%2A> 순차적으로 문자 범위를 검색 하는 속성입니다.|개별 문자 또는 작은 부분 문자열을 사용 하 여 유지 하려는 경우에 유용 합니다.|검색할 문자 수가 큰 경우 또는 검색 논리는 복잡 한 경우 번거롭습니다.<br /><br />반복 된 메서드 호출을 통해 매우 큰 증가 하는 개체에 대 한 성능이 매우 저하 결과입니다.  |  
|변환를 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체를에 수정 작업을 수행 합니다 <xref:System.String> 개체.|수정 횟수가 작은 경우에 유용 합니다.|성능 이점은 부정 합니다 <xref:System.Text.StringBuilder> 클래스의 수정 번호 큰 경우.|  
  
 이러한 기술을 자세히 살펴보겠습니다.  
  
-   검색 목표에 저장 하기 전에 문자열을 검색할 수 있습니다 (즉, 필요가 없는 경우 부분 문자열의 위치에 있는) 특정 하위 문자열이 있는지 확인 하는 경우는 <xref:System.Text.StringBuilder> 개체입니다. 다음 예제에서는 한 가지 구현을 제공 합니다. 정의 `StringBuilderFinder` 클래스의 생성자에 대 한 참조를 전달 되는 <xref:System.Text.StringBuilder> 개체 및 문자열에서 찾을 부분 문자열입니다. 이 예제에서는 예제의 경우 기록 된 온도가 화씨 또는 섭씨로와 적절 한 소개 텍스트의 시작 부분에 추가 하는지 여부를 결정 하려고 합니다 <xref:System.Text.StringBuilder> 개체입니다. 난수 생성기를 섭씨 또는 화씨 데이터가 들어 있는 배열을 선택 하는 데 사용 됩니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   호출을 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 변환할 메서드는 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체. 와 같은 메서드를 사용 하 여 문자열을 검색할 수 있습니다 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> 나 <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, 또는 정규식을 사용할 수 있습니다 및 <xref:System.Text.RegularExpressions.Regex> 패턴을 검색 하는 클래스입니다. 때문에 둘 다 <xref:System.Text.StringBuilder> 고 <xref:System.String> 문자, 문자, 부분 문자열의 인덱스 위치를 저장 하기 위해 인코딩을 u t F-16을 사용 하 여 개체와 일치 하는 정규식 개체를 모두에서 동일 합니다. 사용할 수 있습니다 <xref:System.Text.StringBuilder> 텍스트에서 발견 되는 동일한 위치에 있는 변경 하는 방법의 <xref:System.String> 개체입니다.  
  
    > [!NOTE]
    >  이 접근 방식을 채택 하면, 하는 경우의 끝에서 작업 해야 합니다 <xref:System.Text.StringBuilder> 반복적으로 변환 하지 않아도 되도록 해당 시작 개체는 <xref:System.Text.StringBuilder> 개체를 문자열입니다.  
  
     다음 예제에서 이 방법을 보여 줍니다. 4 개에서 영어 알파벳의 각 문자를 저장 하는 <xref:System.Text.StringBuilder> 개체입니다. 다음에 텍스트를 변환 하는 <xref:System.String> 개체 및 각 4 자리 시퀀스의 시작 위치를 식별 하는 정규식을 사용 합니다. 마지막으로, 첫 번째 시퀀스를 제외 하 고 각 네 자리 시퀀스 앞에 밑줄을 추가 하 고 대문자 시퀀스의 첫 번째 문자를 변환 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   사용 된 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성에 있는 문자의 범위를 순차적으로 검색을 <xref:System.Text.StringBuilder> 개체. 검색할 문자의 수 크거나 검색 논리는 특히 복잡 한 경우에이 방법은 실제 수 없습니다. 문자 단위로 인덱스 기반 액세스에 대 한 성능에 미치는 영향에 대 한 매우 큰, chunked <xref:System.Text.StringBuilder> 개체에 대 한 설명서를 참조 하십시오.는 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 속성입니다. 
  
     다음 예제에서는 이전 예제 기능에서와 동일 하지만 구현에서 다릅니다. 사용 된 <xref:System.Text.StringBuilder.Chars%2A> 문자 값이 변경 하는 시기를 감지 하는 속성의 해당 위치에 밑줄을 삽입 하 고 새 시퀀스에서 첫 번째 문자를 대문자로 변환 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   에 수정 되지 않은 모든 텍스트를 저장할를 <xref:System.Text.StringBuilder> 개체를 호출 합니다 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 변환 하는 방법을 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체를에 수정 작업을 수행는 <xref:System.String> 개체. 몇 가지 수정 사항만;에 있는 경우이 방법을 사용할 수 있습니다. 변경할 수 없는 문자열을 사용 하는 비용 사용의 성능 이점 없어질 수 있습니다이 고, 그렇지는 <xref:System.Text.StringBuilder> 개체입니다.  
  
     다음 예제에서는 이전 두 예제 기능에서 동일 하지만 구현에서 다릅니다. 만듭니다는 <xref:System.Text.StringBuilder> 개체를 변환 하는 <xref:System.String> 개체를 다음 정규식을 사용 하 여 문자열에서 모든 나머지 수정 작업을 수행 하 합니다. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> 메서드 람다 식을 사용 하 여 각 일치 항목에 대체를 수행 합니다.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>StringBuilder 개체를 문자열로 변환  
 <xref:System.Text.StringBuilder> 개체에 표시되는 문자열을 <xref:System.String> 매개 변수를 가진 메서드에 전달하거나 사용자 인터페이스에 표시하려면 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 개체로 변환해야 합니다. 호출 하 여이 변환을 수행 합니다 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 메서드. 예시의 경우 호출 하는 이전 예제를 참조 하세요. 합니다 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 메서드를 <xref:System.Text.StringBuilder> 정규식 메서드에 전달할 수 있도록 하는 문자열 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 대부분의 정의한 메서드를 호출 하는 방법을 보여 줍니다는 <xref:System.Text.StringBuilder> 클래스입니다.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 인스턴스의 문자열 값 설정할지 <xref:System.String.Empty?displayProperty=nameWithType>, 용량 구현 별 기본 용량으로 설정 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 매개 변수가 없는 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">이 인스턴스의 제안된 시작 크기입니다.</param>
        <summary>지정된 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값을 <xref:System.Text.StringBuilder> 개체를 저장할 추가 메모리를 할당 합니다.  
  
 이 인스턴스의 문자열 값 설정할지 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 경우 `capacity` 이 0 인 구현 별 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 생성자는 지정 된 용량을 사용 합니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">인스턴스 값을 초기화하는 데 사용되는 문자열입니다. <paramref name="value" />가 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <summary>지정된 문자열을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`가 `null`이면 새 <xref:System.Text.StringBuilder>에 빈 문자열(<xref:System.String.Empty>)이 포함됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 지정된 된 문자열을 사용 하 여 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <param name="maxCapacity">현재 문자열에 포함할 수 있는 최대 문자 수입니다.</param>
        <summary>지정된 용량으로 시작되어 지정된 최대 용량까지 커질 수 있는 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값을 <xref:System.Text.StringBuilder> 개체를 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 이 0 인 구현 별 기본 용량을 사용 합니다.  
  
 `maxCapacity` 속성은 현재 인스턴스가 보유할 수 있는 문자의 최대 수를 정의 합니다. 해당 값이 할당 된 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `maxCapacity` 값을 <xref:System.Text.StringBuilder> 개체 추가 메모리를 할당 하지 않습니다 하지만 대신 예외가 throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 지정 된 용량 및 최대 용량을 사용 하 여 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" />가 1보다 작거나, <paramref name="capacity" />가 0보다 작거나, <paramref name="capacity" />가 <paramref name="maxCapacity" />보다 큽니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">인스턴스 값을 초기화하는 데 사용되는 문자열입니다. <paramref name="value" />가 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <summary>지정된 문자열과 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값을 <xref:System.Text.StringBuilder> 개체를 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 이 0 인 구현 별 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 초기 문자열과 지정 된 용량을 사용 하 여 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">이 인스턴스 값을 초기화하는 데 사용된 부분 문자열이 포함된 문자열입니다. <paramref name="value" />가 <see langword="null" />이면 새 <see cref="T:System.Text.StringBuilder" />에 빈 문자열(<see cref="F:System.String.Empty" />)이 포함됩니다.</param>
        <param name="startIndex"><paramref name="value" /> 내에서 부분 문자열이 시작되는 위치입니다.</param>
        <param name="length">부분 문자열에 있는 문자의 수입니다.</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" />의 제안된 시작 크기입니다.</param>
        <summary>지정된 부분 문자열과 용량을 사용하여 <see cref="T:System.Text.StringBuilder" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` 매개 변수는 현재 인스턴스에 의해 할당 된 메모리에 저장할 수 있는 문자의 최대 수를 정의 합니다. 해당 값이 할당 된 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다. 현재 인스턴스에 저장 될 문자 수가이 초과 하는 경우 `capacity` 값을 <xref:System.Text.StringBuilder> 개체를 저장할 추가 메모리를 할당 합니다.  
  
 경우 `capacity` 이 0 인 구현 별 기본 용량을 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법에 설명 합니다 <xref:System.Text.StringBuilder.%23ctor%2A> 지정된 된 문자열을 사용 하 여 생성자입니다.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" />+<paramref name="length" />가 <paramref name="value" /> 내의 위치가 아닙니다.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">추가할 Boolean 값입니다.</param>
        <summary>지정된 부울 값의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> 메서드 호출을 <xref:System.Boolean.ToString?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value`합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 8비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Byte%29> 메서드 호출을 <xref:System.Byte.ToString%28System.IFormatProvider%29> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">추가할 UTF-16 인코딩된 코드 단위입니다.</param>
        <summary>지정된 <see cref="T:System.Char" /> 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자 배열입니다.</param>
        <summary>지정된 배열의 유니코드 문자에 대한 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 나타나는 순서에서 현재 인스턴스를 지정 된 배열의 모든 문자를 추가 `value`합니다. 하는 경우 `value` 는 `null`, 변경 되지 않습니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 10진수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> 메서드 호출을 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 배정밀도 부동 소수점 숫자의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Double%29> 메서드 호출을 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 16비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Int16%29> 메서드 호출을 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 32비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Int32%29> 메서드 호출을 <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 64비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> 메서드 호출을 <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져올 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">추가할 개체입니다.</param>
        <summary>지정된 개체의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다. 정의 `Dog` 클래스를 만들고는 `Dog` 개체를 세 번 호출 하는 <xref:System.Text.StringBuilder.Append%2A> dog의 이름 및 종류를 포함 하는 문자열을 만드는 방법.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Object%29> 메서드 호출을 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value`합니다. 경우 `value` 됩니다 `null`를 변경 되지 않습니다는 <xref:System.Text.StringBuilder> 개체입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 8비트 부호 있는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.SByte%29> 메서드 호출을 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 단정밀도 부동 소수점 숫자의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.Single%29> 메서드 호출을 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자열입니다.</param>
        <summary>지정된 문자열의 복사본을 이 인스턴스의 끝에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 하는 경우 `value` 는 `null`, 변경 되지 않습니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 16비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> 메서드 호출을 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value`합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 32비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 호출을 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">추가할 값입니다.</param>
        <summary>지정된 64비트 부호 없는 정수의 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 합니다 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> 메서드 호출을 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 의 문자열 표현을 가져오는 방법 `value` 현재 문화권에 대 한 합니다. 서식을 제어 하려면 `value`를 호출 합니다 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자입니다.</param>
        <param name="repeatCount"><paramref name="value" />를 추가할 횟수입니다.</param>
        <summary>유니코드 문자에 대한 문자열 표현의 지정된 복사본 수를 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" />가 0보다 작은 경우  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <exception cref="T:System.OutOfMemoryException">메모리가 부족합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">문자의 배열에 대한 포인터입니다.</param>
        <param name="valueCount">배열에 있는 문자의 수입니다.</param>
        <summary>지정된 주소에서 시작하는 유니코드 문자의 배열을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 추가 `valueCount` 주소에서 시작 하는 문자 `value` 현재 인스턴스를 합니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" />가 0보다 작은 경우  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" />이(가) null 포인터입니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">문자 배열입니다.</param>
        <param name="startIndex"><paramref name="value" />의 시작 위치입니다.</param>
        <param name="charCount">추가할 문자 수입니다.</param>
        <summary>유니코드 문자의 지정된 하위 배열에 대한 문자열 표현을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정된 된 범위에 있는 문자의 추가 `value` 현재 인스턴스를 합니다. 하는 경우 `value` 됩니다 `null` 및 `startIndex` 및 `count` 둘 다 0, 아니요 변경 내용이 적용 합니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="charCount" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" />가 0보다 작은 경우  
  
또는 
 <paramref name="startIndex" /> + <paramref name="charCount" />이 <paramref name="value" />의 길이보다 큽니다.  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">추가할 부분 문자열이 포함된 문자열입니다.</param>
        <param name="startIndex"><paramref name="value" />에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="count"><paramref name="value" />에서 추가할 문자 수입니다.</param>
        <summary>지정된 부분 문자열의 복사본을 이 인스턴스에 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지정된 된 범위에 있는 문자의 추가 `value` 현재 인스턴스를 합니다. 하는 경우 `value` 됩니다 `null` 및 `startIndex` 및 `count` 둘 다 0, 아니요 변경 내용이 적용 합니다.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> 메서드는이 클래스의 기존 인스턴스를 수정, 새 클래스 인스턴스를 반환 하지 않습니다. 이 인해에서 호출 하 여 메서드 또는 속성을 기존 참조 및 반환 값을 할당할 필요가 없습니다를 <xref:System.Text.StringBuilder> 개체에 다음 예제를 보여 줍니다.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="count" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="startIndex" />가 0보다 작습니다.  
  
또는 
 <paramref name="startIndex" /> + <paramref name="count" />이 <paramref name="value" />의 길이보다 큽니다.  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 단일 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns><paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목이 <paramref name="arg0" />의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 자세한 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 서식 항목 이라고 함 또는 매개 변수 0으로 구성 됩니다. 형식 항목의 인덱스 0에 해당 하도록 해야 합니다. `arg0`,이 메서드의 매개 변수 목록에 있는 단일 개체입니다. 서식 지정 프로세스는 각 형식 항목의 문자열 표현으로 대체 `arg0`합니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0`합니다. 형식 항목에 포함 된 경우 `formatString` 및 `arg0` 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 `arg0.ToString(formatString, null)` 서식을 정의 합니다. 그렇지 않으면 `arg0.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 는 "해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 정수가 10 이라는 값을 사용 하 여 반환 값이 됩니다 "10 캔을 저희 자선 기구에 기부에 대 한 감사 합니다."  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0 (영) 보다 작은 또는 1 보다 크거나 합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="args">형식을 지정할 개체의 배열입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 형식 항목은 매개 변수 배열에 있는 해당 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns><paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 자세한 텍스트로 0 개 이상의 인덱싱된 자리 표시 자가 있는,이 메서드의 매개 변수 목록의 개체에 해당 하는 서식 항목 이라고 함 또는 매개 변수가 0으로 구성 됩니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `args` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 해당 개체의 문자열 표현으로 바뀝니다 `args`합니다. 형식 항목에 포함 된 경우 `formatString` 및 해당 개체 `args` 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 `args[index].ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `args[index].ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 는 "해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 정수가 10 이라는 값을 사용 하 여 반환 값이 됩니다 "10 캔을 저희 자선 기구에 기부에 대 한 감사 합니다."  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 또는 <paramref name="args" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">형식을 지정할 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 서식 항목이 단일 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 <paramref name="format" />의 문자열 표현으로 바뀐  <paramref name="arg0" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값으로 변환 하기 위해.NET 프레임 워크의 `arg0` 텍스트 표현으로 현재에서 표현을 포함 하 고 <xref:System.Text.StringBuilder> 개체.  
  
 `format` 자세한 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 서식 항목 이라고 함 또는 매개 변수 0으로 구성 됩니다. 이 메서드는 단일 인수를 사용 하 여 인수 목록이 포함 각 서식 항목의 인덱스 (0) 여야 합니다. 서식 지정 프로세스는 각 형식 항목의 문자열 표현으로 대체 `arg0`합니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 이 경우 이후 합니다 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 메서드 인수 목록의 값에 대 한 단일 인수 *인덱스* 항상 0 이어야 합니다. 그렇지 않을 경우는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 합니다 `provider` 매개 변수 지정를 <xref:System.IFormatProvider> 개체에 대 한 서식 지정 정보를 제공할 수 있는 구현 `args`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 숫자 값인 경우.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공 하는 `arg0`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`서식 지정, 현재 문화권에서 정보를 가져옵니다.  
  
 `arg0` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0`합니다. 형식 항목에 포함 된 경우 `formatString` 및 `arg0` 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 `arg0.ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `arg0.ToString()` 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 두 호출이 포함 된 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> 메서드. 둘 다 영어-영국 (EN-GB) 문화권의 서식 규칙을 사용 합니다. 첫 번째 삽입의 문자열 표현을 <xref:System.Decimal> 결과 문자열에 통화 값입니다. 두 번째 삽입을 <xref:System.DateTime> 결과의 두 위치에서 문자열 값에는 첫 번째만 포함 하는 짧은 날짜 문자열 및 두 번째 짧은 시간 문자열입니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나, 1보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">방법: 사용자 지정 숫자 형식 공급자 정의 및 사용</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="args">형식을 지정할 개체의 배열입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목은 지정된 서식 공급자를 사용하여 매개 변수 배열에 있는 해당 인수의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 자세한 텍스트로 0 개 이상의 인덱싱된 자리 표시 자가 있는,이 메서드의 매개 변수 목록의 개체에 해당 하는 서식 항목 이라고 함 또는 매개 변수가 0으로 구성 됩니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 합니다 `provider` 매개 변수 지정를 <xref:System.IFormatProvider> 개체에 대 한 서식 지정 정보를 제공할 수 있는 구현 `args`합니다. `provider`는 다음과 같을 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 숫자 값에 대 한 문화권별 서식 지정 정보를 제공 하는 개체 `args`합니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 날짜 및 시간 값에 대 한 문화권별 서식 지정 정보를 제공 하는 개체 `args`합니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 하나 이상의 개체에 대 한 서식 지정 정보를 제공 하는 구현 `args`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다. 다음 섹션에서 두 번째 예제는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 사용자 지정을 사용 하 여 메서드 호출 <xref:System.IFormatProvider> 구현 합니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `args` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 해당 개체의 문자열 표현으로 바뀝니다 `args`합니다. 형식 항목에 포함 된 경우 `formatString` 및 해당 개체 `args` 구현 하는 <xref:System.IFormattable> 인터페이스를 다음 `args[index].ToString(formatString, provider)` 서식을 정의 합니다. 그렇지 않으면 `args[index].ToString()` 서식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 다음 예제에서는 사용자 지정 정의 <xref:System.IFormatProvider> 라는 구현 `CustomerFormatter` 서식을 지정 하는 하이픈을 사용 하 여 숫자 10 자리 고객 이후에 네 번째 및 일곱 번째 내선 번호입니다. 에 전달 되는 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> 메서드 형식이 지정 된 고객 및 고객 이름을 포함 하는 문자열을 만듭니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 <paramref name="args" /> 배열의 길이보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">방법: 사용자 지정 숫자 형식 공급자 정의 및 사용</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 두 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns><paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 합니다 `format` 매개 변수 0 구성 되거나 자세한 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 해당 하는 서식 항목 이라고 함 `arg0` 및 `arg1`,이 메서드의 매개 변수 목록에서 두 개체입니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0` 및 `arg1` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0` 또는 `arg1`합니다. 형식 항목에 포함 된 경우 `formatString` 하 고 해당 개체를 구현 합니다 <xref:System.IFormattable> 인터페이스를 한 다음 `arg` *x* `.ToString(formatString, provider)` 서식 지정, 여기서 정의 *x* 인수의 인덱스가입니다. 그렇지 않으면 `arg` *x* `.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 는 "해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 정수가 10 이라는 값을 사용 하 여 반환 값이 됩니다 "10 캔을 저희 자선 기구에 기부에 대 한 감사 합니다."  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 2보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 형식 항목이 두 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 자세한 텍스트로 0 개 이상의 인덱싱된 자리 표시 자가 있는,이 메서드의 매개 변수 목록의 개체에 해당 하는 서식 항목 이라고 함 또는 매개 변수가 0으로 구성 됩니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수를 지정 된 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공할 수 있는 `arg0` 및 `arg1`. `provider`는 다음과 같을 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 숫자 값입니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 에 대 한 서식 지정 정보를 제공 하는 구현 `arg0` 고 `arg1`입니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `arg0` 및 `arg1` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 해당 인덱스를 가진 개체의 문자열 표현으로 바뀝니다. 형식 항목에 포함 된 경우 `formatString` 해당 인수를 구현 하 고는 <xref:System.IFormattable> 인터페이스를 인수 `ToString(formatString, provider)` 메서드 형식을 정의 합니다. 그렇지 않으면 인수 `ToString()` 메서드 형식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> 제네릭에 저장 하는 시간 및 온도 데이터를 표시 하는 방법 <xref:System.Collections.Generic.Dictionary%602> 개체입니다. 형식 문자열에 세 개의 형식 항목이 있더라도 형식을 지정 하는 개체에만 참고 합니다. (날짜 및 시간 값) 목록에서 첫 번째 개체를 사용 하는 두 형식 항목 이므로: 첫 번째 형식 항목 표시 하는 시간 및 두 번째 날짜를 표시 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 2보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>프로그램과.NET Core 및.NET Framework 4.0 및 이후 버전에서 인스턴스화할 때를 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자의 용량 및 길이 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">방법: 사용자 지정 숫자 형식 공급자 정의 및 사용</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 각 서식 항목이 세 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns><paramref name="format" />이 추가된 이 인스턴스에 대한 참조입니다. <paramref name="format" />의 각 서식 항목은 해당 개체 인수의 문자열 표현으로 바뀝니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 합니다 `format` 매개 변수 0 구성 되거나 자세한 텍스트로와 0 개 이상의 인덱싱된 자리 표시자를 해당 하는 서식 항목 이라고 함 `arg0` 를 통해 `arg2`,이 메서드의 매개 변수 목록에 있는 개체입니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `arg0`를 `arg1`, 및 `arg2` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 의 문자열 표현으로 바뀝니다 `arg0`를 `arg1`, 또는 `arg2`형식 항목의 인덱스에 따라 합니다. 형식 항목에 포함 된 경우 `formatString` 및 해당 개체 `args` 구현 합니다 <xref:System.IFormattable> 인터페이스를 한 다음 `arg` *x* `.ToString(formatString, null)` 서식 지정, 여기서 정의  *x* 인수의 인덱스입니다. 그렇지 않으면 `arg` *x* `.ToString()` 서식을 정의 합니다.  
  
 에 할당 된 문자열이 `format` 는 "해 주셔서 {0: # # #} 캔을 저희 자선 기구 음식." 및 `arg0` 정수가 10 이라는 값을 사용 하 여 반환 값이 됩니다 "10 캔을 저희 자선 기구에 기부에 대 한 감사 합니다."  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendFormat%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나, 3보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">문화권별 서식 지정 정보를 제공하는 개체입니다.</param>
        <param name="format">복합 형식 문자열입니다.</param>
        <param name="arg0">서식을 지정할 첫 번째 개체입니다.</param>
        <param name="arg1">서식을 지정할 두 번째 개체입니다.</param>
        <param name="arg2">서식을 지정할 세 번째 개체입니다.</param>
        <summary>서식 항목이 0개 이상 포함된 복합 서식 문자열을 처리하여 반환된 문자열을 이 인스턴스에 추가합니다. 지정된 형식 공급자를 사용하여 각 형식 항목이 세 인수 중 하나의 문자열 표현으로 바뀝니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다. 추가 작업 후, 이 인스턴스에는 추가 작업 이전부터 있던 데이터가 포함되고 그 뒤에 형식 사양이 해당하는 개체 인수의 문자열 표현으로 바뀐 <paramref name="format" />의 복사본이 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 합니다 [복합 서식 지정 기능](~/docs/standard/base-types/composite-formatting.md) 값 개체의 텍스트 표현으로 변환 하 고 현재 표현을 포함할.NET Framework의 <xref:System.Text.StringBuilder> 개체입니다.  
  
 `format` 자세한 텍스트로 0 개 이상의 인덱싱된 자리 표시 자가 있는,이 메서드의 매개 변수 목록의 개체에 해당 하는 서식 항목 이라고 함 또는 매개 변수가 0으로 구성 됩니다. 포맷 프로세스는 해당 개체의 문자열 표현으로 각 서식 항목을 바꿉니다.  
  
 형식 항목의 구문은 다음과 같습니다.  
  
 {*index*[,*length*][:*formatString*]}  
  
 대괄호 안의 요소는 선택 사항입니다. 다음 표에서는 각 요소에 대해 설명합니다.  
  
|요소|설명|  
|-------------|-----------------|  
|*index*|서식을 지정할 개체의 0부터 시작 위치 매개 변수 목록에서입니다. 지정 된 개체가 *인덱스* 됩니다 `null`, 형식 항목으로 바뀝니다 <xref:System.String.Empty?displayProperty=nameWithType>합니다. 매개 변수가 없는 경우는 *인덱스* 위치는 <xref:System.FormatException> throw 됩니다.|  
|*길이*|매개 변수의 문자열 표현에 있는 문자의 최소 수입니다. 양수의 매개 변수는 오른쪽에 맞춰집니다. 음수 이면를 왼쪽에 맞춥니다.|  
|:*formatString*|매개 변수에서 지원 되는 표준 또는 사용자 지정 서식 문자열입니다.|  
  
> [!NOTE]
>  날짜 및 시간 값을 사용 하는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [표준 날짜 및 시간 서식 문자열](~/docs/standard/base-types/standard-date-and-time-format-strings.md) 하 고 [사용자 지정 날짜 및 시간 형식 문자열](~/docs/standard/base-types/custom-date-and-time-format-strings.md)합니다. 숫자 값으로 사용 되는 표준 및 사용자 지정 형식 문자열을 참조 하세요 [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) 하 고 [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md)합니다. 열거형과 함께 사용 되는 표준 형식 문자열을 참조 하세요 [열거형 형식 문자열](~/docs/standard/base-types/enumeration-format-strings.md)합니다.  
  
 `provider` 매개 변수를 지정 된 <xref:System.IFormatProvider> 구현에 대 한 서식 지정 정보를 제공할 수 있는 `arg0` 및 `arg1`. `provider`는 다음과 같을 수 있습니다.  
  
-   <xref:System.Globalization.CultureInfo> culture 별 서식 지정 정보를 제공 하는 개체입니다.  
  
-   A <xref:System.Globalization.NumberFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0` 또는 `arg1` 경우 숫자 값입니다.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> 개체에 대 한 문화권별 서식 지정 정보를 제공 하는 `arg0`를 `arg1`, 또는 `arg2` 경우 날짜 및 시간 값입니다.  
  
-   사용자 지정 <xref:System.IFormatProvider> 에 대 한 서식 지정 정보를 제공 하는 구현 `arg0`를 `arg1`, 및 `arg2`합니다. 일반적으로 이러한 구현도 구현 하는 <xref:System.ICustomFormatter> 인터페이스입니다.  
  
 경우는 `provider` 매개 변수는 `null`, 현재 문화권에서 형식 공급자 정보를 가져옵니다.  
  
 `arg0`를 `arg1`, 및 `arg2` 서식을 지정할 개체를 나타냅니다. 각 서식 항목 `format` 해당 인덱스를 가진 개체의 문자열 표현으로 바뀝니다. 형식 항목에 포함 된 경우 `formatString` 해당 인수를 구현 하 고는 <xref:System.IFormattable> 인터페이스를 인수 `ToString(formatString, provider)` 메서드 형식을 정의 합니다. 그렇지 않으면 인수 `ToString()` 메서드 형식을 정의 합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> 메서드는 부울 결과 보여 주기 위해 `And` 정수 값을 사용 하 여 작업 합니다. 두 가지 방법으로 각 항목 형식이 있으므로 형식 문자열에 6 개의 형식 항목이 포함 되지만 메서드 인수 목록에서 세 개의 항목이 note 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.FormatException"><paramref name="format" />이 잘못되었습니다.  
  
또는 
형식 항목의 인덱스가 0보다 작거나 3보다 크거나 같습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">확장된 문자열의 길이가 <see cref="P:System.Text.StringBuilder.MaxCapacity" />를 초과합니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET의 서식 지정 형식</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">복합 형식 지정</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">방법: 사용자 지정 숫자 형식 공급자 정의 및 사용</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">표준 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">사용자 지정 숫자 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">표준 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">사용자 지정 날짜 및 시간 형식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">표준 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">사용자 지정 TimeSpan 서식 문자열</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">열거형 형식 문자열</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스의 끝에 기본 줄 종결자 또는 지정한 문자열의 복사본과 기본 줄 종결자를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 끝에 기본 줄 종결자를 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 값인 기본 줄 종결자를 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 속성입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.AppendLine%2A> 메서드.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">추가할 문자열입니다.</param>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 끝에 지정한 문자열의 복사본과 기본 줄 종결자를 차례로 추가합니다.</summary>
        <returns>추가 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 값인 기본 줄 종결자를 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> 속성입니다.  
  
 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <see cref="T:System.Text.StringBuilder" /> 호출 하 여 개체를 <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> 생성자, 길이 및 용량을 합니다 <see cref="T:System.Text.StringBuilder" /> 인스턴스 값 이상으로 증가할 수 해당 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <see cref="M:System.Text.StringBuilder.Append(System.String)" /> 고 <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> 작은 문자열을 추가 하는 방법입니다.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 인스턴스에 의해 할당된 메모리에 포함할 수 있는 최대 문자 수를 가져오거나 설정합니다.</summary>
        <value>현재 인스턴스에 의해 할당된 메모리에 포함할 수 있는 최대 문자 수입니다. 값 범위는 <see cref="P:System.Text.StringBuilder.Length" />에서 <see cref="P:System.Text.StringBuilder.MaxCapacity" />까지일 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> 현재 인스턴스의 문자열 값에 영향을 주지 않습니다. <xref:System.Text.StringBuilder.Capacity%2A> 되지 않았으므로 축소 보다 작은 <xref:System.Text.StringBuilder.Length%2A>합니다.  
  
 합니다 <xref:System.Text.StringBuilder> 동적으로 필요한 경우 더 많은 공간을 할당 하 고 증가 <xref:System.Text.StringBuilder.Capacity%2A> 적절 하 게 합니다. 성능상의 이유로 <xref:System.Text.StringBuilder> 필요한 것 보다 더 많은 메모리를 할당할 수 있습니다. 할당 된 메모리 양이 구현 별입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Capacity%2A> 속성입니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Set 작업에 지정된 값이 이 인스턴스의 현재 길이보다 작습니다.  
  
또는 
Set 작업에 지정된 값이 최대 용량보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">문자의 위치입니다.</param>
        <summary>이 인스턴트에서 특정 위치에 있는 문자를 가져오거나 설정합니다.</summary>
        <value><paramref name="index" /> 위치에 있는 유니코드 문자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `index` 매개 변수는 내 문자 위치를 <xref:System.Text.StringBuilder>입니다. 문자열의 첫 번째 문자는 인덱스 0에 있습니다. 문자열의 길이가 포함 된 문자의 수입니다. 마지막 액세스할 수 있는 문자를 <xref:System.Text.StringBuilder> 인스턴스가 인덱스 <xref:System.Text.StringBuilder.Length%2A> -1입니다.  
  
 <xref:System.Text.StringBuilder.Chars%2A> 기본 속성을 <xref:System.Text.StringBuilder> 클래스입니다. C#에서는 인덱서 것입니다. 즉,에서 개별 문자를 검색할 수 있습니다는 <xref:System.Text.StringBuilder.Chars%2A> 공백, 영문자의 개수에 다음 예제에 표시 된 대로 속성과 문자열의 문장 부호 문자입니다.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>성능 및 문자 기반 인덱싱을

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">문자를 설정하는 동안 <paramref name="index" />가 이 인스턴스의 범위를 벗어납니다.</exception>
        <exception cref="T:System.IndexOutOfRangeException">문자를 가져오는 동안 <paramref name="index" />가 이 인스턴스의 범위를 벗어납니다.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 인스턴스에서 모든 문자를 제거합니다.</summary>
        <returns><see cref="P:System.Text.StringBuilder.Length" />가 0인 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> 설정에 해당 하는 메서드는 <xref:System.Text.StringBuilder.Length%2A> 0 (영) 현재 인스턴스의 속성입니다.  
  
 호출 된 <xref:System.Text.StringBuilder.Clear%2A> 메서드는 현재 인스턴스를 수정 하지 않습니다 <xref:System.Text.StringBuilder.Capacity%2A> 또는 <xref:System.Text.StringBuilder.MaxCapacity%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 한 <xref:System.Text.StringBuilder> 문자열로 호출을 사용 하 여 개체를 <xref:System.Text.StringBuilder.Clear%2A> 메서드를 한 다음 새 문자열을 추가 합니다.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">이 인스턴스에서 문자가 복사되기 시작하는 위치입니다. 인덱스는 0부터 시작합니다.</param>
        <param name="destination">문자가 복사될 배열입니다.</param>
        <param name="destinationIndex"><paramref name="destination" />에서 문자가 복사될 위치입니다. 인덱스는 0부터 시작합니다.</param>
        <param name="count">복사될 문자 수입니다.</param>
        <summary>이 인스턴스에서 지정한 세그먼트의 문자를 대상 <see cref="T:System.Char" /> 배열에서 지정한 세그먼트에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Text.StringBuilder.CopyTo%2A> 효과적으로 연속 된 부분을 복사 해야 할 때 특수 한 상황에서 사용할 메서드를 <xref:System.Text.StringBuilder> 개체 배열입니다. 배열에는 고정된 크기를 미리 할당 되 고 재사용 가능한 전역 액세스가 가능 해야 합니다.  
  
 예를 들어, 응용 프로그램을 채울 수도 있었습니다를 <xref:System.Text.StringBuilder> 많은 수의 문자를 사용 하 여 개체를 사용 하 여는 <xref:System.Text.StringBuilder.CopyTo%2A> 소규모의 연속 정보를 복사 하는 메서드는 <xref:System.Text.StringBuilder> 조각이 처리 되는 배열 개체입니다. 경우에 있는 모든 데이터를 <xref:System.Text.StringBuilder> 개체를 처리의 크기를 <xref:System.Text.StringBuilder> 개체가 0으로 설정 되 고 주기가 반복 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.CopyTo%2A> 메서드.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="sourceIndex" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
 <paramref name="destinationIndex" /> + <paramref name="count" />이 <paramref name="destination" />의 길이보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">확보할 최소 용량입니다.</param>
        <summary>이 <see cref="T:System.Text.StringBuilder" /> 인스턴스의 용량이 최소한 지정된 값이 되도록 합니다.</summary>
        <returns>이 인스턴스의 새 용량입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 용량이 보다 작은 `capacity` 매개 변수를 이상을 보유할 수 다시이 인스턴스에 대 한 메모리를 할당 합니다 `capacity` 문자 수가 않으면 메모리는 그대로 유지 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.EnsureCapacity%2A> 메서드.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />가 0보다 작은 경우  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">이 인스턴스와 비교할 개체 또는 <see langword="null" />입니다.</param>
        <summary>이 인스턴스가 지정된 개체와 같은지를 나타내는 값을 반환합니다.</summary>
        <returns>이 인스턴스와 <see langword="true" />에 같은 문자열, <paramref name="sb" /> 및 <see cref="P:System.Text.StringBuilder.Capacity" /> 값이 있으면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드에서는 합니다 <xref:System.Text.StringBuilder.Equals%2A> 두 여부를 확인 하는 메서드 <xref:System.Text.StringBuilder> 개체. 각 개체에 작은 변경 내용이 후 결과 콘솔에 표시 된 메서드를 반복적으로 호출 됩니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 문자 위치에 있는 이 인스턴스에 부울 값의 문자열 표현을 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 필요에 따라 용량이 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 8비트 부호 없는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 유니코드 문자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자 배열입니다.</param>
        <summary>지정된 유니코드 문자 배열의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 하는 경우 `value` 됩니다 `null`는 <xref:System.Text.StringBuilder> 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>10진수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>배정밀도 부동 소수점 숫자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 16비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 32비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 있는 64비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 개체이거나 <see langword="null" />입니다.</param>
        <summary>개체의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 하는 경우 `value` 는 `null`를이 인스턴스의 값이 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>지정된 8비트 부호 있는 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 필요에 따라 용량이 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>단정밀도 부동 소수점 숫자의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <summary>문자열을 지정한 인덱스에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 필요에 따라 용량이 조정 됩니다.  
  
 이 인스턴스의 <xref:System.Text.StringBuilder> 경우 변경 되지 않습니다 `value` 됩니다 `null`, 또는 `value` 아닙니다 `null` 이지만 해당 길이 0입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작거나 이 인스턴스의 현재 길이보다 큽니다.  
  
또는 
이 <see cref="T:System.Text.StringBuilder" /> 개체의 현재 길이에 <paramref name="value" />의 길이를 더한 값이 <see cref="P:System.Text.StringBuilder.MaxCapacity" />보다 큽니다.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 16비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 32비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 값입니다.</param>
        <summary>부호 없는 64비트 정수의 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 문자열 표현을 가져오는 데 사용 됩니다 `value`합니다. 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />이 0보다 작거나 이 인스턴스 길이보다 큰 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <block subset="none" type="usage"><para>에 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 및 이전 버전에서는이 메서드를 호출 했습니다는 <see cref="T:System.ArgumentOutOfRangeException" /> 삽입 하는 경우 <paramref name="value" /> 개체의 총 길이를 초과 하면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />합니다. 로 시작 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], 메서드에서 throw는 <see cref="T:System.OutOfMemoryException" />합니다.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">삽입할 문자열입니다.</param>
        <param name="count"><paramref name="value" />를 삽입할 횟수입니다.</param>
        <summary>지정된 하나 이상의 문자열의 복사본을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료한 후에 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
 이 <xref:System.Text.StringBuilder> 경우 개체는 변경 되지 않습니다 `value` 됩니다 `null`, `value` 아닙니다 `null` 이지만 해당 길이 0 또는 `count` 0입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작거나 이 인스턴스의 현재 길이보다 큽니다.  
  
또는 
 <paramref name="count" />가 0보다 작은 경우</exception>
        <exception cref="T:System.OutOfMemoryException">이 <see cref="T:System.Text.StringBuilder" /> 개체의 현재 길이에 <paramref name="value" />의 길이를 더한 다음 <paramref name="count" />를 곱한 값이 <see cref="P:System.Text.StringBuilder.MaxCapacity" />보다 큽니다.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">삽입을 시작할 인스턴스 내의 위치입니다.</param>
        <param name="value">문자 배열입니다.</param>
        <param name="startIndex"><paramref name="value" /> 내의 시작 인덱스입니다.</param>
        <param name="charCount">삽입할 문자 수입니다.</param>
        <summary>유니코드 문자의 지정된 하위 배열에 대한 문자열 표현을 지정된 문자 위치에 있는 이 인스턴스에 삽입합니다.</summary>
        <returns>삽입 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 텍스트에 대 한 공간을 만들기 위해 기존 문자를 이동 합니다. 이 인스턴스의 용량에는 필요에 따라 조정 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Insert%2A> 메서드.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />가 <see langword="null" />이고 <paramref name="startIndex" /> 및 <paramref name="charCount" />는 0이 아닙니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" /> 또는 <paramref name="charCount" />가 0보다 작습니다.  
  
또는 
 <paramref name="index" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
 <paramref name="startIndex" />+<paramref name="charCount" />가 <paramref name="value" /> 내의 위치가 아닙니다.  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Text.StringBuilder" /> 개체의 길이를 가져오거나 설정합니다.</summary>
        <value>이 인스턴스의 길이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 길이 <xref:System.Text.StringBuilder> 개체의 해당 번호로 정의 됩니다 <xref:System.Char> 개체입니다.  
  
 같은 합니다 <xref:System.String.Length%2A?displayProperty=nameWithType> 속성을 <xref:System.Text.StringBuilder.Length%2A> 속성을 현재 문자열 개체의 길이 나타냅니다. 달리 합니다 <xref:System.String.Length%2A?displayProperty=nameWithType> 속성은 읽기 전용 합니다 <xref:System.Text.StringBuilder.Length%2A> 속성에 저장 된 문자열의 길이 수정할 수 있습니다는 <xref:System.Text.StringBuilder> 개체.  
  
 지정 된 길이 현재 현재 길이 보다 작은 경우 <xref:System.Text.StringBuilder> 개체는 지정 된 길이로 잘립니다. 지정 된 길이 현재 문자열 값의 끝, 현재 길이 보다 큰 경우 <xref:System.Text.StringBuilder> 개체 유니코드 NULL 문자로 채워집니다 (U + 0000)입니다.  
  
 지정 된 길이 현재 용량 보다 큰 경우 <xref:System.Text.StringBuilder.Capacity%2A> 것이 보다 크거나 같은 지정 된 길이 늘립니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Length%2A> 속성입니다.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">설정 작업에 지정된 값이 0보다 작거나 <see cref="P:System.Text.StringBuilder.MaxCapacity" />보다 큽니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 인스턴스의 최대 용량을 가져옵니다.</summary>
        <value>이 인스턴스가 보유할 수 있는 최대 문자 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현에 대 한 최대 용량은 <xref:System.Int32.MaxValue?displayProperty=nameWithType>합니다. 그러나이 값은 구현 별로 및 다른 개 이상 구현에서 다를 수 있습니다. 최대 용량을 명시적으로 설정할 수는 <xref:System.Text.StringBuilder> 를 호출 하 여 개체를 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> 생성자입니다.  
  
.NET Core 및.NET Framework 4.0 및 이후 버전에서는 인스턴스화할 때 합니다 <xref:System.Text.StringBuilder> 호출 하 여 개체를 <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> 생성자, 길이 및 용량을 합니다 <xref:System.Text.StringBuilder> 인스턴스 값 이상으로 증가할 수 해당 <xref:System.Text.StringBuilder.MaxCapacity> 속성입니다. 특히 호출 하는 경우 발생할 수 있습니다 합니다 <xref:System.Text.StringBuilder.Append(System.String)> 고 <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> 작은 문자열을 추가 하는 방법입니다.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스 내에서 제거를 시작할 0에서 시작하는 위치입니다.</param>
        <param name="length">제거할 문자 수입니다.</param>
        <summary>이 인스턴스에서 지정된 문자 범위를 제거합니다.</summary>
        <returns>삭제 작업이 완료된 후 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 메서드는 현재 인스턴스에서 지정된 된 범위의 문자를 제거합니다. 에 있는 문자 (`startIndex` + `length`)으로 이동 됩니다 `startIndex`, 및 현재 인스턴스의 문자열 값으로 단축 됩니다 `length`합니다. 현재 인스턴스의 용량을 받지 않습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Text.StringBuilder.Remove%2A> 현재 값을 수정 하는 메서드 <xref:System.Text.StringBuilder> 인스턴스 및 해당 인스턴스를 반환 합니다. 만들기 및 새 반환 되지 않습니다 <xref:System.Text.StringBuilder> 개체입니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Remove%2A> 메서드.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작거나 <paramref name="startIndex" /> + <paramref name="length" />가 이 인스턴스의 길이보다 큽니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 인스턴스에서 발견되는 지정된 문자 또는 문자열을 지정된 다른 문자 또는 문자열로 모두 바꿉니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 문자입니다.</param>
        <param name="newChar"><paramref name="oldChar" />를 바꾸는 문자입니다.</param>
        <summary>이 인스턴스에서 발견되는 지정된 문자를 지정된 다른 문자로 모두 바꿉니다.</summary>
        <returns><paramref name="oldChar" />가 <paramref name="newChar" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 식별 하는 서 수, 대/소문자 구분 비교를 수행 하는이 메서드 `oldChar` 현재 인스턴스에 있습니다. 현재 크기 <xref:System.Text.StringBuilder> 인스턴스는 교체 후 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue"><paramref name="oldValue" />를 바꾸는 문자열이거나 <see langword="null" />입니다.</param>
        <summary>이 인스턴스에서 발견되는 지정된 문자열을 지정된 다른 문자열로 모두 바꿉니다.</summary>
        <returns><paramref name="oldValue" />의 모든 인스턴스가 <paramref name="newValue" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 식별 하는 서 수, 대/소문자 구분 비교를 수행 하는이 메서드 `oldValue` 현재 인스턴스에 있습니다. 하는 경우 `newValue` 됩니다 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>, 모든 `oldValue` 제거 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" />의 길이가 0입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">바꿀 문자입니다.</param>
        <param name="newChar"><paramref name="oldChar" />를 바꾸는 문자입니다.</param>
        <param name="startIndex">부분 문자열이 시작되는 인스턴스 내의 위치입니다.</param>
        <param name="count">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 발견되는 지정된 문자를 지정된 다른 문자로 모두 바꿉니다.</summary>
        <returns><paramref name="oldChar" />가 <paramref name="startIndex" />에서부터 <paramref name="startIndex" /> + <paramref name="count" /> -1의 범위에 있는 <paramref name="newChar" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 식별 하는 서 수, 대/소문자 구분 비교를 수행 하는이 메서드 `oldChar` 현재 인스턴스에 있습니다. 현재 크기 <xref:System.Text.StringBuilder> 개체는 교체 후 변경 되지 않습니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" />가 이 인스턴스의 길이보다 큽니다.  
  
또는 
 <paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">바꿀 문자열입니다.</param>
        <param name="newValue"><paramref name="oldValue" />를 바꾸는 문자열이거나 <see langword="null" />입니다.</param>
        <param name="startIndex">부분 문자열이 시작되는 인스턴스 내의 위치입니다.</param>
        <param name="count">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열에서 발견되는 지정된 문자열을 지정된 다른 문자열로 모두 바꿉니다.</summary>
        <returns><paramref name="oldValue" />의 모든 인스턴스가 <paramref name="startIndex" />에서 <paramref name="startIndex" /> + <paramref name="count" /> - 1 범위에 있는 <paramref name="newValue" />로 바뀐 이 인스턴스에 대한 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 식별 하는 서 수, 대/소문자 구분 비교를 수행 하는이 메서드 `oldValue` 에서 지정된 된 부분 문자열입니다. 하는 경우 `newValue` 됩니다 `null` 또는 <xref:System.String.Empty?displayProperty=nameWithType>, 모든 `oldValue` 제거 됩니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Text.StringBuilder.Replace%2A> 메서드.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" />의 길이가 0인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 또는 <paramref name="count" />가 0보다 작습니다.  
  
또는 
 <paramref name="startIndex" /> + <paramref name="count" />는 문자 위치가 이 인스턴스 안에 없음을 나타냅니다.  
  
또는 
이 인스턴스의 값이 커지면 <see cref="P:System.Text.StringBuilder.MaxCapacity" />가 초과됩니다.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">serialization 정보로 채울 개체입니다.</param>
        <param name="context">serialize된 데이터를 저장 및 검색할 위치입니다. 나중에 사용하기 위해 예약되어 있습니다.</param>
        <summary>현재 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 개체를 deserialize하는 데 필요한 데이터로 <see cref="T:System.Text.StringBuilder" /> 개체를 채웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` 매개 변수는 나중에 사용 하도록 예약 되어 및이 작업에 참여 하지 않습니다.  
  
 자세한 내용은 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 메서드를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />가 <see langword="null" />인 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" />의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 인스턴스의 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
        <returns>이 인스턴스와 같은 값을 가진 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 합니다는 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 방법을 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 표시 되는 문자열을 전달 하기 전에 개체를 <xref:System.Text.StringBuilder> 개체 변수가 있는 메서드를를 <xref:System.String> 매개 변수 또는 사용자 인터페이스에 표시 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Text.StringBuilder.ToString%2A> 메서드를 호출하는 방법을 보여 줍니다. 이 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Text.StringBuilder> 클래스입니다.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">이 인스턴스에 있는 부분 문자열의 시작 위치입니다.</param>
        <param name="length">부분 문자열의 길이입니다.</param>
        <summary>이 인스턴스의 부분 문자열 값을 <see cref="T:System.String" />으로 변환합니다.</summary>
        <returns>이 인스턴스의 지정된 부분 문자열과 같은 값을 가진 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 해야 합니다는 <xref:System.Text.StringBuilder.ToString%2A> 변환 하는 방법을 <xref:System.Text.StringBuilder> 개체를 <xref:System.String> 표시 되는 문자열을 전달 하기 전에 개체를 <xref:System.Text.StringBuilder> 개체 변수가 있는 메서드를를 <xref:System.String> 매개 변수 또는 사용자 인터페이스에 표시 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 또는 <paramref name="length" />가 0보다 작습니다.  
  
또는 
<paramref name="startIndex" /> 및 <paramref name="length" />의 합계가 현재 인스턴스의 길이보다 큽니다.</exception>
      </Docs>
    </Member>
  </Members>
</Type>