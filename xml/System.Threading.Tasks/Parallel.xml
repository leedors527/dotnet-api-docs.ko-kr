<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9400e38d0e86f78825a1539468c98397e83c3420" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236285" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="89101-101">병렬 루프 및 영역에 대한 지원을 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="89101-101">Provides support for parallel loops and regions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-102"><xref:System.Threading.Tasks.Parallel> 클래스는 각 루프 및 문 집합의 실행에 대 한 루프와 같은 일반적인 작업에 대 한 병렬 대체 라이브러리 기반 데이터를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-103">이 예제에는 여러 언어 구문을 사용 하 여 병렬 루프를 구현 하는 데 몇 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="89101-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="89101-104">모든 public 및 protected 멤버만 <see cref="T:System.Threading.Tasks.Parallel" /> 는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="89101-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">
      <span data-ttu-id="89101-105">데이터 병렬 처리(작업 병렬 라이브러리)</span>
      <span class="sxs-lookup">
        <span data-stu-id="89101-105">Data Parallelism (Task Parallel Library)</span>
      </span>
    </related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">
      <span data-ttu-id="89101-106">.NET Framework 사용한 병렬 프로그래밍 샘플</span>
      <span class="sxs-lookup">
        <span data-stu-id="89101-106">Samples for Parallel Programming with the .NET Framework</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89101-107">반복이 병렬로 실행될 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-107">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-108">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-108">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-109">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-109">The end index, exclusive.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-110">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-110">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-111">반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-111">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-112">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-112">A  structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-113">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-114">두 개의 인수를 사용 하 여 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="89101-115"><xref:System.Int32> 반복 횟수를 나타내는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="89101-116"><xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="89101-117"><xref:System.Threading.Tasks.ParallelLoopState> 컴파일러에서 개체를 만들; 사용자 코드에서 인스턴스화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="89101-118">호출을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드 알립니다는 `for` 후 현재 반복 실행할 수 없는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="89101-119">그러나 현재 모든 반복 하나 아직 아직 하지 않은 경우 실행 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="89101-120">따라서 호출 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 기존 내 중단 작업을 사용 하는 것과 비슷합니다 `for` 언어로 루프와 같은 C#, 완벽 하 게 대체 하는 것만: 예를 들어,은 현재 반복 것입니다 확실 하 게 아닙니다 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="89101-121">현재 필요 하지 않습니다. 전에 모든 반복을 실행 하는 경우 사용 합니다 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 사용 하는 대신 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="89101-122">호출 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 알립니다는 `for` 루프 작업은 이미 완료 하는 데 필요한 여부에 상관 전이나 후 현재 반복 하므로 모든 나머지 모든 반복을 중단할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="89101-123">그러나 사용 하 여 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, 결정에 다른 반복 실행 되지 것입니다 보장은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="89101-124">루프는 너무 일찍 종료 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopResult> 반환 되는 구조체에는 루프의 완료에 대 한 관련 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="89101-125">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-126">다음 예제에서는 동시에 최대 100 개의 루프 반복을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="89101-127">1에서 1,000 밀리초 임의의 간격에 대 한 각 반복 일시 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="89101-128">루프는 반복에서 결정 하는 임의로 생성 된 값을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="89101-129">예제 인덱스 보다 큽니다. 반복의에서 출력으로는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 호출 후 시작 하는 속성 값을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="89101-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="89101-130">루프의 반복 될 때 실행 되는 것도 가능성이 있으므로 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드가 호출 되 면 반복 될 때마다 호출 합니다 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> 다른 반복에 호출할지 여부를 확인 하는 속성을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="89101-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="89101-131">속성 값이 `true`의 값을 확인 하는 반복을 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 속성을 현재 반복의 인덱스 값 보다 큰 경우 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-132">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-132">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-133">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-133">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-134">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-134">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-135">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-135">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-136">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-136">The end index, exclusive.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-137">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-137">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-138">반복이 병렬로 실행될 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-138">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-139">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-139">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-140">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-141">반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int32>) 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="89101-142">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-143">다음 예제에서는 <xref:System.Threading.Tasks.Parallel.For%2A> 임의 바이트를 생성 하는 대리자의 100 호출에 대 한 값 메서드와 해당 합계를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-144">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-144">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-145">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-145">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-146">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-146">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-147">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-147">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-148">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-148">The end index, exclusive.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-149">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-149">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-150">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-150">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-151">완료된 루프의 부분에 대한 정보가 포함된 <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-152">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-153">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="89101-154">호출 된 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드 알립니다는 `for` 후 현재 반복을 실행할 필요는 없지만 현재 하기 전에 모든 반복을 수행 하는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don’t have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="89101-155">따라서 중단 호출 비슷합니다는 기존의 내 중단 작업을 사용 하 여 `for` 언어로 루프와 같은 C#, 완벽 하 게 대체 하는 것만: 예를 들어 보장이 없습니다 해당 반복 후 현재 실행 확실 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="89101-156">현재 필요 하지 않습니다. 전에 모든 반복을 실행 하는 경우 사용 합니다 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 사용 하는 대신 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="89101-157">호출 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 알립니다는 `for` 루프 작업은 이미 완료 하는 데 필요한 여부에 상관 전이나 후 현재 반복 하므로 모든 나머지 모든 반복을 중단할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="89101-158">그러나 사용 하 여 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, 결정에 다른 반복 실행 되지 것입니다 보장은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="89101-159">루프는 너무 일찍 종료 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopResult> 반환 되는 구조체에는 루프의 완료에 대 한 관련 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="89101-160">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-161">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-161">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-162">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-162">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-163">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-163">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-164">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-164">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-165">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-165">The end index, exclusive.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-166">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-166">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-167">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-167">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-168">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-168">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-169">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-170">반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int64>) 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="89101-171">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-172">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-172">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-173">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-173">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-174">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-174">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-175">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-175">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-176">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-176">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-177">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-177">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-178">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-178">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-179">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 작업을 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-179">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-180">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-180">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-181">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-182">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="89101-183">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-184">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-185">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-185">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-186">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-186">-or-</span>
          </span>
          <span data-ttu-id="89101-187">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-188">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-188">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-189">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-190">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-190">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-191">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-191">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-192">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-192">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-193">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-193">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-194">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-194">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-195">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="for" />(Visual Basic에서는 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-195">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop in which iterations may run in parallel and loop options can be configured.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-196">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-196">A  structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-197">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-198">반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int32>) 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="89101-199">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-200">다음 예제에서는 병렬 루프를 취소 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="89101-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-201">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-202">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-202">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-203">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-203">-or-</span>
          </span>
          <span data-ttu-id="89101-204">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-205">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-205">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-206">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-207">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-207">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-208">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-208">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-209">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-209">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-210">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-210">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-211">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-211">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-212">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-212">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-213">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-213">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-214">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-215">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="89101-216">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-217">다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드는 <xref:System.Threading.Tasks.ParallelOptions> 개체:</span><span class="sxs-lookup"><span data-stu-id="89101-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-218">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-219">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-219">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-220">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-220">-or-</span>
          </span>
          <span data-ttu-id="89101-221">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-222">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-222">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-223">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-224">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-224">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="89101-225">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-225">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-226">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-226">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-227">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-227">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-228">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-228">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-229">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-229">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-230">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-230">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-231">64 비트 인덱스를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="89101-232">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-233">반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int64>) 매개 변수로 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="89101-234">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-235">다음 예제에서는 사용 하는 방법을 보여 줍니다 <xref:System.Threading.Tasks.ParallelOptions> 사용자 지정 작업 스케줄러 지정 하려면:</span><span class="sxs-lookup"><span data-stu-id="89101-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-236">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-237">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-237">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-238">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-238">-or-</span>
          </span>
          <span data-ttu-id="89101-239">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-240">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-240">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-241">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-242">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-242">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-243">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-243">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="fromInclusive">
          <span data-ttu-id="89101-244">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-244">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-245">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-245">The end index, exclusive.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-246">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-246">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-247">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-247">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-248">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-248">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-249">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-249">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-250">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-250">A  structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-251">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-252">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-253">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-254">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-255">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-256">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-257">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-258">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-259"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-260">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="89101-261">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="89101-262">이 메서드를 사용 하는 예제를 보려면 [방법: 스레드 로컬 변수를 사용 하는 Parallel.For 루프 작성](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-263">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-263">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-264">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-264">-or-</span>
          </span>
          <span data-ttu-id="89101-265">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-266">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-266">-or-</span>
          </span>
          <span data-ttu-id="89101-267">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-268">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-268">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-269">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-269">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-270">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-270">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="fromInclusive">
          <span data-ttu-id="89101-271">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-271">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-272">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-272">The end index, exclusive.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-273">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-273">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-274">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-274">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-275">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-275">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-276">64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-276">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-277">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-277">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-278">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-279">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 작업에서 실행 되는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="89101-280">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-281">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-282">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-283">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-284">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-285">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-286"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-287">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="89101-288">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="89101-289">이 메서드를 사용 하는 예제를 보려면 [방법: 스레드 로컬 변수를 사용 하는 Parallel.For 루프 작성](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-290">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-290">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-291">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-291">-or-</span>
          </span>
          <span data-ttu-id="89101-292">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-293">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-293">-or-</span>
          </span>
          <span data-ttu-id="89101-294">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-295">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-295">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-296">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-296">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-297">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-297">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="fromInclusive">
          <span data-ttu-id="89101-298">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-298">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-299">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-299">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-300">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-300">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-301">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-301">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-302">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-302">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-303">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-303">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-304">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-304">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic)  loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-305">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-305">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-306">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-307">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 작업에서 실행 되는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="89101-308">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-309">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-310">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-311">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-312">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-313">이 대리자; 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-314"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-315">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="89101-316">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-317">다음 예제에서는 스레드 지역 변수를 사용 하 여 많은 시간이 오래 걸리는 작업의 결과의 합계를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="89101-318">이 예제에서는 병렬 처리 수준이 4 개로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-319">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-319">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-320">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-320">-or-</span>
          </span>
          <span data-ttu-id="89101-321">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-322">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-322">-or-</span>
          </span>
          <span data-ttu-id="89101-323">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-324">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-324">-or-</span>
          </span>
          <span data-ttu-id="89101-325">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-326">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-327">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-328">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-328">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-329">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-329">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-330">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-330">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="fromInclusive">
          <span data-ttu-id="89101-331">시작 인덱스(포함)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-331">The start index, inclusive.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="89101-332">끝 인덱스(제외)입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-332">The end index, exclusive.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-333">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-333">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-334">각 스레드에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-334">The function delegate that returns the initial state of the local data for each thread.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-335">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-335">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-336">각 스레드의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-336">The delegate that performs a final action on the local state of each thread.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-337">64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" />(Visual Basic의 경우 <see langword="For" />) 루프를 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-337">Executes a <see langword="for" /> (<see langword="For" /> in Visual Basic) loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-338">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-338">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-339">합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="89101-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="89101-340">다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-341">`localInit` 대리자가 루프의 실행에 참여 하 고 각 스레드에 대 한 초기 로컬 상태를 반환 하는 각 스레드에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="89101-342">이러한 초기 상태는 첫 번째 전달할 `body` 각 스레드에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="89101-343">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-344">각 스레드의 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-345">`localFinally` 대리자가 각 스레드의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="89101-346">이 대리자; 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-347"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-348">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="89101-349">하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-350">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-350">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-351">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-351">-or-</span>
          </span>
          <span data-ttu-id="89101-352">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-353">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-353">-or-</span>
          </span>
          <span data-ttu-id="89101-354">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-355">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-355">-or-</span>
          </span>
          <span data-ttu-id="89101-356">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-357">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-358">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-359">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-359">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-360">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-360">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89101-361">반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each " />) 작업을 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-362">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-362">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-363">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-363">The orderable partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-364">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-364">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-365">반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-366">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-366">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-367">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-368">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-369"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-370">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-371">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-371">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-372">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-372">-or-</span>
          </span>
          <span data-ttu-id="89101-373">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-373">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-374">
            <paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-375">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-375">-or-</span>
          </span>
          <span data-ttu-id="89101-376">소스에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-377">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-377">-or-</span>
          </span>
          <span data-ttu-id="89101-378">소스 정렬 가능 파티셔너의 모든 메서드는 <see langword="null" />을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-378">Any methods in the source orderable partitioner return <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-379">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-379">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-380">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-380">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-381">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-381">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-382">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-382">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-383">반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-383">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-384">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-384">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-385">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-385">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-386">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-386">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-387"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-387">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-388">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-388">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-389">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-389">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-390">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-390">-or-</span>
          </span>
          <span data-ttu-id="89101-391">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-391">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-392">
            <paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-392">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-393">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-393">-or-</span>
          </span>
          <span data-ttu-id="89101-394">
            <paramref name="source" /> Partitioner의 메서드는 <see langword="null" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-394">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-395">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-395">-or-</span>
          </span>
          <span data-ttu-id="89101-396">
            <paramref name="source" /> Partitioner의 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 메서드가 올바른 파티션 수를 반환하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-396">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-397">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-397">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-398">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-398">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-399">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-399">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-400">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-400">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-401">반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-401">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-402">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-402">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-403">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-403">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-404">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-404">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-405"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-405">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-406">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-406">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-407">다음 예제에서는 사용에 대 한 범위 파티 셔 너를 구현 하는 방법을 보여 줍니다 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="89101-407">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-408">
            <paramref name="source" /> 인수가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-408">The <paramref name="source" /> argument is  <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-409">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-409">-or-</span>
          </span>
          <span data-ttu-id="89101-410">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-410">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-411">
            <paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-411">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-412">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-412">-or-</span>
          </span>
          <span data-ttu-id="89101-413">
            <paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-413">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-414">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-414">-or-</span>
          </span>
          <span data-ttu-id="89101-415">
            <paramref name="source" /> Partitioner의 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 메서드가 올바른 파티션 수를 반환하지 않습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-415">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-416">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-416">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-417">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-417">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-418">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-418">An enumerable data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-419">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-419">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-420">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-420">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-421">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-421">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-422">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-422">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-423">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 현재 요소의 인덱스 (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="89101-423">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-424">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-424">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-425">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-425">-or-</span>
          </span>
          <span data-ttu-id="89101-426">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-426">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-427">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-427">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-428">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-428">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-429">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-429">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-430">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-430">An enumerable data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-431">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-431">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-432">반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-432">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-433">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-433">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-434">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-434">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-435">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-435">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-436">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-436">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-437">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-437">-or-</span>
          </span>
          <span data-ttu-id="89101-438">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-438">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-439">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-439">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-440">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-440">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-441">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-441">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-442">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-442">An enumerable data source.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-443">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-443">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-444">반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-444">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-445">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-445">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-446">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-446">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-447">현재 요소를 사용 하 여 매개 변수로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-447">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-448">다음 예제에서는 <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> 모음 및 텍스트 파일에 공백이 아닌 문자 수를 계산 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-448">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="89101-449">이 경우에 <xref:System.Threading.Tasks.ParallelLoopResult> 메서드에서 반환 된 값은 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-449">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="89101-450">참고, 작업을 병렬로 실행할 수 있으므로 확인 해야 한다는 카운터 변수가 증가 원자성 작업 및 다중 스레드 카운터 변수를 동시에 액세스 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="89101-450">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="89101-451">이 예제에서는이 목적을 위해 사용 합니다 `lock` 문 (C#) 및 `SyncLock` 문 (Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="89101-451">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-452">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-452">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-453">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-453">-or-</span>
          </span>
          <span data-ttu-id="89101-454">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-454">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-455">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-455">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-456">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-456">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-457">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-457">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-458">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-458">The orderable partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-459">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-459">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-460">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-460">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-461">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-461">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-462">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-462">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-463">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-463">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-464">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-464">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-465"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-465">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-466">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-466">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-467">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-467">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-468">
            <paramref name="source" /> 인수가 <see langword="null" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-468">The <paramref name="source" /> argument is  <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-469">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-469">-or-</span>
          </span>
          <span data-ttu-id="89101-470">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-470">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-471">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-471">-or-</span>
          </span>
          <span data-ttu-id="89101-472">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-472">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-473">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-473">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-474">
            <paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-474">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-475">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-475">-or-</span>
          </span>
          <span data-ttu-id="89101-476">
            <paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-476">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-477">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-477">-or-</span>
          </span>
          <span data-ttu-id="89101-478">
            <paramref name="source" /> 정렬할 수 있는 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-478">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-479">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-479">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-480">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-480">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-481">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-481">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-482">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-482">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-483">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-483">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-484">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-484">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-485">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-485">A  structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-486">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-486">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-487">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-487">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-488"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-488">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-489">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-489">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-490">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-490">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-491">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-491">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-492">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-492">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-493">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-493">-or-</span>
          </span>
          <span data-ttu-id="89101-494">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-494">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-495">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-495">-or-</span>
          </span>
          <span data-ttu-id="89101-496">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-496">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-497">
            <paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-497">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-498">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-498">-or-</span>
          </span>
          <span data-ttu-id="89101-499">
            <paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-499">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-500">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-500">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-501">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-501">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-502">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-502">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-503">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-503">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-504">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-504">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-505">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-505">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-506">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-506">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-507">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-507">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-508">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-508">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-509"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-509">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-510">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-510">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-511">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-511">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-512">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-512">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-513">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-513">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-514">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-514">-or-</span>
          </span>
          <span data-ttu-id="89101-515">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-515">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-516">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-516">-or-</span>
          </span>
          <span data-ttu-id="89101-517">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-517">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-518">
            <paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-518">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span>
          </span>
          <span data-ttu-id="89101-519">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-519">-or-</span>
          </span>
          <span data-ttu-id="89101-520">
            <paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-520">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-521">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-521">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-522">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-522">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-523">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-523">An enumerable data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-524">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-524">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-525">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-525">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-526">64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-526">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-527">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-527">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-528">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-528">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-529">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 현재 요소의 인덱스 (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="89101-529">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-530">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-530">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-531">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-531">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-532">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-532">-or-</span>
          </span>
          <span data-ttu-id="89101-533">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-533">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-534">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-534">-or-</span>
          </span>
          <span data-ttu-id="89101-535">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-535">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-536">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-536">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-537">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-537">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-538">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-538">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-539">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-539">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-540">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-540">An enumerable data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-541">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-541">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-542">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-542">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-543">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-543">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-544">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-544">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-545">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-545">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-546">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="89101-546">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-547">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-547">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-548">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-548">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-549">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-549">-or-</span>
          </span>
          <span data-ttu-id="89101-550">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-550">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-551">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-551">-or-</span>
          </span>
          <span data-ttu-id="89101-552">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-552">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-553">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-553">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-554">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-554">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-555">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-555">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-556">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-556">The type of the data in the source.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-557">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-557">An enumerable data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-558">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-558">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-559">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-559">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-560">반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-560">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-561">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-561">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-562">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-562">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-563">현재 요소를 사용 하 여 매개 변수로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-563">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-564">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-564">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-565">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-565">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-566">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-566">-or-</span>
          </span>
          <span data-ttu-id="89101-567">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-567">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-568">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-568">-or-</span>
          </span>
          <span data-ttu-id="89101-569">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-569">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-570">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-570">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-571">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-571">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-572">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-572">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-573">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-573">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-574">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-574">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-575">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-575">The orderable partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-576">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-576">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-577">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-577">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-578">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-578">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-579">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-579">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-580">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-580">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-581">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-581">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-582">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-582">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-583"><xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-583">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-584">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-584">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="89101-585">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-585">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-586">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-586">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-587">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-587">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-588">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-588">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-589">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-589">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-590">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-590">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-591"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-591">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-592">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-592">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-593">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-593">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-594">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-594">-or-</span>
          </span>
          <span data-ttu-id="89101-595">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-595">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-596">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-596">-or-</span>
          </span>
          <span data-ttu-id="89101-597">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-597">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-598">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-598">-or-</span>
          </span>
          <span data-ttu-id="89101-599">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-599">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-600">
            <paramref name="source" />
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-600">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-601">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-601">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-602">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-602">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-603">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-603">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-604">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-604">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-605">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-605">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-606">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-606">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-607">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-607">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-608">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-608">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-609">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-609">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-610">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-610">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-611">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-611">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-612">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-612">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-613"><xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-613">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-614">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-614">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="89101-615">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 스레드에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-615">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-616">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-616">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-617">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-617">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-618">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-618">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-619">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-619">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-620">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-620">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-621"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-621">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-622">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-622">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-623">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-623">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-624">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-624">-or-</span>
          </span>
          <span data-ttu-id="89101-625">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-625">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-626">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-626">-or-</span>
          </span>
          <span data-ttu-id="89101-627">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-627">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-628">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-628">-or-</span>
          </span>
          <span data-ttu-id="89101-629">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-629">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-630">
            <paramref name="source" />
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-630">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-631">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-631">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-632">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-632">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-633">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-633">The type of the data in the source.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-634">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-634">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-635">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-635">An enumerable data source.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-636">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-636">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-637">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-637">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-638">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-638">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-639">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-639">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-640">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-640">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-641">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-641">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-642">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스, 현재 요소의 인덱스 (<xref:System.Int64>), 및 실행 하는 반복 간에 공유 될 수 있는 일부 로컬 상태 동일한 스레드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-642">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-643">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-643">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-644">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-644">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-645">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-645">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-646">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-646">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-647">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-647">The `localFinally` delegate is invoked once per task to perform a final action on each task’s local state.</span></span> <span data-ttu-id="89101-648">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-648">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-649"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-649">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-650">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-650">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-651">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-651">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-652">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-652">-or-</span>
          </span>
          <span data-ttu-id="89101-653">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-653">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-654">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-654">-or-</span>
          </span>
          <span data-ttu-id="89101-655">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-655">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-656">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-656">-or-</span>
          </span>
          <span data-ttu-id="89101-657">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-657">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-658">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-658">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-659">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-659">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-660">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-660">The type of the data in the source.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-661">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-661">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-662">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-662">An enumerable data source.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-663">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-663">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-664">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-664">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-665">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-665">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-666">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-666">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-667">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-667">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-668">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-668">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-669">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-669">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-670">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-670">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-671">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-671">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-672">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-672">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-673">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-673">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-674">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-674">The `localFinally` delegate is invoked once per thread to perform a final action on each task’s local state.</span></span> <span data-ttu-id="89101-675">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-675">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-676"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-676">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-677">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-677">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-678">다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 로컬 상태를 사용 하 여 메서드:</span><span class="sxs-lookup"><span data-stu-id="89101-678">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-679">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-679">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-680">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-680">-or-</span>
          </span>
          <span data-ttu-id="89101-681">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-681">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-682">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-682">-or-</span>
          </span>
          <span data-ttu-id="89101-683">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-683">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-684">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-684">-or-</span>
          </span>
          <span data-ttu-id="89101-685">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-685">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-686">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-686">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-687">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-687">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-688">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-688">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-689">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-689">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-690">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-690">The orderable partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-691">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-691">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-692">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-692">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-693">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-693">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-694">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-694">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-695">64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-695">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-696">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-696">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-697">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-697">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-698">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-698">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-699"><xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-699">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-700">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-700">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="89101-701">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-701">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-702">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-702">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-703">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-703">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-704">각 스레드의 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-704">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-705">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-705">The `localFinally` delegate is invoked once per task to perform a final action on each task’s local state.</span></span> <span data-ttu-id="89101-706">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-706">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-707"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-707">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-708">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-708">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-709">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-709">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-710">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-710">-or-</span>
          </span>
          <span data-ttu-id="89101-711">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-711">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-712">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-712">-or-</span>
          </span>
          <span data-ttu-id="89101-713">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-713">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-714">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-714">-or-</span>
          </span>
          <span data-ttu-id="89101-715">
            <paramref name="localInit" /> 또는 <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-715">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-716">
            <paramref name="source" />
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-716">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-717">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-717">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-718">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-718">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-719">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-719">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-720">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-720">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-721">
            <paramref name="source" />의 요소 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-721">The type of the elements in <paramref name="source" />.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-722">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-722">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-723">원래 데이터 소스가 포함된 파티셔너입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-723">The partitioner that contains the original data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-724">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-724">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-725">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-725">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-726">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-726">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-727">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-727">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-728">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-728">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-729">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-729">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-730">이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-730">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="89101-731">예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-731">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="89101-732"><xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-732">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="89101-733">이 오버 로드는 정적 범위 분할의 이점을 얻을 수 있는 작은 루프 본문의 시나리오에 대해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-733">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="89101-734">파티 셔 너는 동적 파티션을 지원 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-734">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="89101-735">자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 하 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-735">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="89101-736">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-736">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-737">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-737">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-738">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-738">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-739">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-739">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-740">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-740">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="89101-741">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-741">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-742"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-742">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-743">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-743">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-744">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-744">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-745">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-745">-or-</span>
          </span>
          <span data-ttu-id="89101-746">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-746">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-747">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-747">-or-</span>
          </span>
          <span data-ttu-id="89101-748">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-748">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-749">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-749">-or-</span>
          </span>
          <span data-ttu-id="89101-750">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-750">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-751">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-751">-or-</span>
          </span>
          <span data-ttu-id="89101-752">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-752">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="89101-753">
            <paramref name="source" />
            <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-753">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-754">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-754">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-755">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-755">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-756">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-756">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-757">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-757">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-758">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-758">The type of the data in the source.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-759">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-759">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-760">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-760">An enumerable data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-761">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-761">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-762">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-762">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-763">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-763">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-764">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-764">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-765">스레드 로컬 데이터와 64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-765">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-766">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-766">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-767">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-767">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-768">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스, 현재 요소의 인덱스 (<xref:System.Int64>), 및 실행 하는 반복 간에 공유 될 수 있는 일부 로컬 상태 동일한 스레드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-768">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-769">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-769">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-770">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-770">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-771">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-771">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-772">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-772">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-773">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-773">The `localFinally` delegate is invoked once per thread to perform a final action on each task’s local state.</span></span> <span data-ttu-id="89101-774">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-774">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-775"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-775">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-776">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-776">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-777">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-777">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-778">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-778">-or-</span>
          </span>
          <span data-ttu-id="89101-779">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-779">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-780">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-780">-or-</span>
          </span>
          <span data-ttu-id="89101-781">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-781">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-782">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-782">-or-</span>
          </span>
          <span data-ttu-id="89101-783">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-783">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-784">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-784">-or-</span>
          </span>
          <span data-ttu-id="89101-785">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-785">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-786">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-786">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-787">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-787">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-788">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-788">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-789">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-789">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          <span data-ttu-id="89101-790">소스의 데이터 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-790">The type of the data in the source.</span>
          </span>
        </typeparam>
        <typeparam name="TLocal">
          <span data-ttu-id="89101-791">스레드 로컬 데이터의 형식입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-791">The type of the thread-local data.</span>
          </span>
        </typeparam>
        <param name="source">
          <span data-ttu-id="89101-792">열거 가능한 데이터 소스입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-792">An enumerable data source.</span>
          </span>
        </param>
        <param name="parallelOptions">
          <span data-ttu-id="89101-793">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-793">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="localInit">
          <span data-ttu-id="89101-794">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-794">The function delegate that returns the initial state of the local data for each task.</span>
          </span>
        </param>
        <param name="body">
          <span data-ttu-id="89101-795">반복당 한 번씩 호출되는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-795">The delegate that is invoked once per iteration.</span>
          </span>
        </param>
        <param name="localFinally">
          <span data-ttu-id="89101-796">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-796">The delegate that performs a final action on the local state of each task.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-797">스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-797">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated..</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89101-798">완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-798">A structure that contains information about which portion of the loop completed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-799">`body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-799">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="89101-800">다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="89101-800">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="89101-801">`localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-801">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="89101-802">이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-802">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="89101-803">그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-803">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="89101-804">각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-804">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="89101-805">`localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-805">The `localFinally` delegate is invoked once per thread to perform a final action on each task’s local state.</span></span> <span data-ttu-id="89101-806">여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-806">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="89101-807"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-807">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="89101-808">이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-808">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-809">
            <paramref name="source" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-809">The <paramref name="source" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-810">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-810">-or-</span>
          </span>
          <span data-ttu-id="89101-811">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-811">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-812">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-812">-or-</span>
          </span>
          <span data-ttu-id="89101-813">
            <paramref name="body" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-813">The <paramref name="body" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-814">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-814">-or-</span>
          </span>
          <span data-ttu-id="89101-815">
            <paramref name="localInit" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-815">The <paramref name="localInit" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-816">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-816">-or-</span>
          </span>
          <span data-ttu-id="89101-817">
            <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-817">The <paramref name="localFinally" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-818">
            <paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-818">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-819">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-819">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-820">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-820">The exception that contains all the individual exceptions thrown on all threads.</span>
          </span>
        </exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">
          <span data-ttu-id="89101-821">병렬 루프</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-821">Parallel Loops</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="89101-822">각각의 제공된 동작을 가능하면 병렬로 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-822">Executes each of the provided actions, possibly in parallel.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">
          <span data-ttu-id="89101-823">실행할 <see cref="T:System.Action" />의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-823">An array of <see cref="T:System.Action" /> to execute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-824">각각의 제공된 동작을 가능하면 병렬로 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-824">Executes each of the provided actions, possibly in parallel.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-825">이 메서드는 작업의 집합을 잠재적으로 병렬로 실행 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-825">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="89101-826">병렬로 실행 되는지 여부 또는 작업이 실행 되는 순서에 대 한 보장 되지 않습니다 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-826">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="89101-827">이 메서드는 완료 될 때까지 각 제공 된 작업, 완료 정상 또는 예외 종료로 인해 발생 하는 여부에 관계 없이 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-827">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="89101-828">자세한 내용은 [방법: Parallel.Invoke를 사용하여 병렬 작업 실행](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="89101-828">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="89101-829">이 예제를 사용 하는 방법에 설명 합니다 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 다른 메서드, 익명 대리자 및 람다 식을 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="89101-829">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-830">
            <paramref name="actions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-830">The <paramref name="actions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-831">
            <paramref name="actions" /> 배열에 있는 모든 작업이 예외를 throw하는 경우 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-831">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89101-832">
            <paramref name="actions" /> 배열에 <see langword="null" /> 요소가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-832">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">
          <span data-ttu-id="89101-833">이 작업의 동작을 구성하는 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-833">An object that configures the behavior of this operation.</span>
          </span>
        </param>
        <param name="actions">
          <span data-ttu-id="89101-834">실행할 동작의 배열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-834">An array of actions to execute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89101-835">사용자가 작업을 취소하지 않는다면 제공된 각 작업을 가능한 한 병렬로 실행합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-835">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89101-836">이 메서드는 작업의 집합을 잠재적으로 병렬로 실행 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-836">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="89101-837">에 전달 된 취소 토큰이 <xref:System.Threading.Tasks.ParallelOptions> 구조 전체 작업을 취소 하려면 호출자에 게 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="89101-837">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="89101-838">자세한 내용은 [관리되는 스레드의 취소](~/docs/standard/threading/cancellation-in-managed-threads.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="89101-838">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="89101-839">병렬로 실행 되는지 여부 또는 작업이 실행 되는 순서에 대 한 보장 되지 않습니다 됩니다.</span><span class="sxs-lookup"><span data-stu-id="89101-839">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="89101-840">이 메서드는 완료 될 때까지 각 제공 된 작업, 완료 정상 또는 예외 종료로 인해 발생 하는 여부에 관계 없이 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="89101-840">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="89101-841">자세한 내용은 [방법: Parallel.Invoke를 사용하여 병렬 작업 실행](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="89101-841">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <span data-ttu-id="89101-842">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationToken" />이 설정됩니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-842">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="89101-843">
            <paramref name="actions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-843">The <paramref name="actions" /> argument is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="89101-844">또는</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-844">-or-</span>
          </span>
          <span data-ttu-id="89101-845">
            <paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-845">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AggregateException">
          <span data-ttu-id="89101-846">
            <paramref name="actions" /> 배열에 있는 모든 작업이 예외를 throw하는 경우 throw되는 예외입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-846">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="89101-847">
            <paramref name="actions" /> 배열에 <see langword="null" /> 요소가 포함되어 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-847">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="89101-848">
            <paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89101-848">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>