<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="53ac17ab6443b9650b8e9acf8ee50cc6bf4113af" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58683076" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>병렬 루프 및 영역에 대한 지원을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> 클래스는 각 루프 및 문 집합의 실행에 대 한 루프와 같은 일반적인 작업에 대 한 병렬 대체 라이브러리 기반 데이터를 제공 합니다.  
  
   
  
## Examples  
 이 예제에는 여러 언어 구문을 사용 하 여 병렬 루프를 구현 하는 데 몇 가지 방법을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>모든 public 및 protected 멤버만 <see cref="T:System.Threading.Tasks.Parallel" /> 는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">데이터 병렬 처리(작업 병렬 라이브러리)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework 사용한 병렬 프로그래밍 샘플</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>반복이 병렬로 실행될 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 두 개의 인수를 사용 하 여 제공 됩니다.  
  
-   <xref:System.Int32> 반복 횟수를 나타내는 값입니다.  
  
-   <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 인스턴스. <xref:System.Threading.Tasks.ParallelLoopState> 컴파일러에서 개체를 만들; 사용자 코드에서 인스턴스화할 수 없습니다.  
  
 호출을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드 알립니다는 `for` 후 현재 반복 실행할 수 없는 작업입니다. 그러나 현재 모든 반복 하나 아직 아직 하지 않은 경우 실행 되어야 합니다.  
  
 따라서 호출 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 기존 내 중단 작업을 사용 하는 것과 비슷합니다 `for` 루프와 같은 언어로 C#, 완전히 대체 하지 않습니다. 예를 들어 보장이 없습니다 해당 반복 후 현재 실행 확실 하 게 됩니다.  
  
 현재 필요 하지 않습니다. 전에 모든 반복을 실행 하는 경우 사용 합니다 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 사용 하는 대신 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>합니다. 호출 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 알립니다는 `for` 루프 작업은 이미 완료 하는 데 필요한 여부에 상관 전이나 후 현재 반복 하므로 모든 나머지 모든 반복을 중단할 수는 있습니다. 그러나 사용 하 여 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, 결정에 다른 반복 실행 되지 것입니다 보장은 없습니다.  
  
 루프는 너무 일찍 종료 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopResult> 반환 되는 구조체에는 루프의 완료에 대 한 관련 정보가 포함 됩니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 동시에 최대 100 개의 루프 반복을 실행합니다. 1에서 1,000 밀리초 임의의 간격에 대 한 각 반복 일시 중지합니다. 루프는 반복에서 결정 하는 임의로 생성 된 값을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드가 호출 됩니다. 예제 인덱스 보다 큽니다. 반복의에서 출력으로는 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 호출 후 시작 하는 속성 값을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 루프의 반복 될 때 실행 되는 것도 가능성이 있으므로 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드가 호출 되 면 반복 될 때마다 호출 합니다 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> 다른 반복에 호출할지 여부를 확인 하는 속성을 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> 메서드. 속성 값이 `true`의 값을 확인 하는 반복을 <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> 속성을 현재 반복의 인덱스 값 보다 큰 경우 즉시 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복이 병렬로 실행될 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int32>) 매개 변수로 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Tasks.Parallel.For%2A> 임의 바이트를 생성 하는 대리자의 100 호출에 대 한 값 메서드와 해당 합계를 계산 합니다.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프의 부분에 대한 정보가 포함된 <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.  
  
 호출 된 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 메서드 알립니다는 `for` 후 현재 반복을 실행할 필요는 없지만 현재 하기 전에 모든 반복을 수행 하는 작업입니다.  
  
 따라서 중단 호출 비슷합니다는 기존의 내 중단 작업을 사용 하 여 `for` 루프와 같은 언어로 C#를 완전히 대체 하지 않습니다. 예를 들어 보장이 없습니다 해당 반복 후 현재 실행 확실 하 게 됩니다.  
  
 현재 필요 하지 않습니다. 전에 모든 반복을 실행 하는 경우 사용 합니다 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 메서드를 사용 하는 대신 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>합니다. 호출 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 알립니다는 `for` 루프 작업은 이미 완료 하는 데 필요한 여부에 상관 전이나 후 현재 반복 하므로 모든 나머지 모든 반복을 중단할 수는 있습니다. 그러나 사용 하 여 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, 결정에 다른 반복 실행 되지 것입니다 보장은 없습니다.  
  
 루프는 너무 일찍 종료 하는 경우는 <xref:System.Threading.Tasks.ParallelLoopResult> 반환 되는 구조체에는 루프의 완료에 대 한 관련 정보가 포함 됩니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int64>) 매개 변수로 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 작업을 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int32>) 매개 변수로 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 병렬 루프를 취소 하는 방법을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드가 모든 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드는 <xref:System.Threading.Tasks.ParallelOptions> 개체:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 64 비트 인덱스를 지원합니다. 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 반복 횟수를 사용 하 여 제공 됩니다 (<xref:System.Int64>) 매개 변수로 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 <xref:System.Threading.Tasks.ParallelOptions> 사용자 지정 작업 스케줄러 지정 하려면:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 이 메서드를 사용 하는 예제를 참조 하세요. [방법: 스레드 로컬 변수를 사용하는 Parallel.For 루프 작성](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 작업에서 실행 되는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 이 메서드를 사용 하는 예제를 참조 하세요. [방법: 스레드 로컬 변수를 사용하는 Parallel.For 루프 작성](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 작업에서 실행 되는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 이 대리자; 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 스레드 지역 변수를 사용 하 여 많은 시간이 오래 걸리는 작업의 결과의 합계를 계산 합니다. 이 예제에서는 병렬 처리 수준이 4 개로 제한합니다.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="fromInclusive">시작 인덱스(포함)입니다.</param>
        <param name="toExclusive">끝 인덱스(제외)입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 스레드에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 스레드의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="for" /> 루프를 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `body` 대리자는 반복 범위에서 각 값에 대해 한 번씩 호출 됩니다 (`fromInclusive`, `toExclusive`). 다음 매개 변수를 사용 하 여 제공 됩니다: 반복 횟수 (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 스레드에 대 한 초기 로컬 상태를 반환 하는 각 스레드에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 스레드에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 스레드의 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 스레드의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다. 이 대리자; 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 하는 경우 `fromInclusive` 보다 크거나 같음 `toExclusive`, 메서드는 반복을 수행 하지 않고 즉시 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each " />) 작업을 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
소스에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
소스 정렬 가능 파티셔너의 모든 메서드는 <see langword="null" />을 반환합니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" /> Partitioner의 메서드는 <see langword="null" />를 반환합니다.  
  
또는 
<paramref name="source" /> Partitioner의 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 메서드가 올바른 파티션 수를 반환하지 않습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" /> 작업을 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 사용에 대 한 범위 파티 셔 너를 구현 하는 방법을 보여 줍니다 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />입니다.  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.  
  
또는 
<paramref name="source" /> Partitioner의 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 메서드가 올바른 파티션 수를 반환하지 않습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 현재 요소의 인덱스 (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복이 병렬로 실행될 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" /> 작업을 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 현재 요소를 사용 하 여 매개 변수로 제공 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> 모음 및 텍스트 파일에 공백이 아닌 문자 수를 계산 하는 방법입니다. 이 경우에 <xref:System.Threading.Tasks.ParallelLoopResult> 메서드에서 반환 된 값은 무시 됩니다. 참고, 작업을 병렬로 실행할 수 있으므로 확인 해야 한다는 카운터 변수가 증가 원자성 작업 및 다중 스레드 카운터 변수를 동시에 액세스 하지 마세요. 이 예제에서는이 목적을 위해 사용 합니다 `lock` 문 (C#) 및 `SyncLock` 문 (Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />입니다.  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" />에서 정렬할 수 있는 파티셔너의 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" /> 정렬할 수 있는 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</summary>
        <returns>완료된 루프의 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> Partitioner의 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 속성은 <see langword="false" />를 반환합니다.  
  
또는 
<paramref name="source" /> 파티셔너에 있는 모든 메서드가 <see langword="null" />을 반환할 때 throw되는 예외입니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>64비트 인덱스를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 현재 요소의 인덱스 (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소 및 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <summary>반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 현재 요소를 사용 하 여 매개 변수로 제공 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 스레드에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스, 현재 요소의 인덱스 (<xref:System.Int64>), 및 실행 하는 반복 간에 공유 될 수 있는 일부 로컬 상태 동일한 스레드에 있습니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.Threading.Tasks.Parallel.ForEach%2A> 로컬 상태를 사용 하 여 메서드:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 정렬할 수 있는 파티셔너입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 스레드의 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 또는 <paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" />의 요소 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">원래 데이터 소스가 포함된 Partitioner입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.Concurrent.Partitioner" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 파티션 구성표는 기본값을 재정의 하려는 시나리오에 대 한 제공 됩니다. 예를 들어 작은 루프 본문 범위 분할의 장점을 활용할 수 있습니다. <xref:System.Threading.Tasks.Parallel.ForEach%2A> 메서드에 사용자 지정 파티 셔 너는 동적 분할을 지원 하기 위해 필요 합니다. 이 오버 로드는 정적 범위 분할의 이점을 얻을 수 있는 작은 루프 본문의 시나리오에 대해 제공 됩니다. 파티 셔 너는 동적 파티션을 지원 해야 합니다.  자세한 내용은 [PLINQ 및 TPL에 대 한 사용자 지정 파티 셔 너](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 고 [방법: 동적 파티션 구현](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)을 참조하세요.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 동작을 수행 하는 태스크 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />의 <see cref="T:System.Collections.Concurrent.Partitioner" /> 속성은 <see langword="false" />를 반환하거나 파티셔너가 <see langword="null" /> 파티션을 반환합니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>64비트 인덱스와 스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간 루프를 중단 하는 데 사용할 수 있는 인스턴스, 현재 요소의 인덱스 (<xref:System.Int64>), 및 실행 하는 반복 간에 공유 될 수 있는 일부 로컬 상태 동일한 스레드에 있습니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">소스의 데이터 형식입니다.</typeparam>
        <typeparam name="TLocal">스레드 로컬 데이터의 형식입니다.</typeparam>
        <param name="source">열거 가능한 데이터 소스입니다.</param>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="localInit">각 작업에 대한 로컬 데이터의 초기 상태를 반환하는 함수 대리자입니다.</param>
        <param name="body">반복당 한 번씩 호출되는 대리자입니다.</param>
        <param name="localFinally">각 작업의 로컬 상태에 대해 최종 동작을 수행하는 대리자입니다.</param>
        <summary>스레드 로컬 데이터를 사용하여 반복을 병렬로 실행할 수 있고 루프 옵션을 구성할 수 있으며 루프 상태를 모니터링 및 조작할 수 있는 <see langword="foreach" />(Visual Basic의 경우 <see langword="For Each" />) 작업을 <see cref="T:System.Collections.IEnumerable" />에 대해 실행합니다.</summary>
        <returns>완료된 루프 부분에 대한 정보가 포함된 구조체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` 대리자의 각 요소에 대해 한 번씩 호출 되는 `source` 열거 가능 합니다. 다음 매개 변수를 사용 하 여 제공 됩니다: 현재 요소를 <xref:System.Threading.Tasks.ParallelLoopState> 중간에서 루프를 중단 하는 데 사용할 수 있는 인스턴스 및 동일한 스레드에서 실행 하는 반복 간에 공유 될 수 있는 몇 가지 로컬 상태입니다.  
  
 `localInit` 대리자가 루프의 실행에 참여 하 고 각 해당 작업에 대 한 초기 로컬 상태를 반환 하는 각 작업에 대해 한 번 호출 합니다. 이러한 초기 상태는 첫 번째 전달할 `body` 각 작업에서 호출 합니다. 그런 다음 모든 후속 본문 호출은 다음 본문 호출에 전달 되는 가능한 경우 수정 된 상태 값을 반환 합니다. 각 작업에 대해 마지막 본문 호출에 전달 되는 상태 값을 반환 하는 마지막으로 `localFinally` 위임 합니다. `localFinally` 대리자가 각 작업의 로컬 상태에서 최종 작업을 수행 하는 스레드 당 한 번 호출 합니다. 여러 작업에이 대리자를 동시에 호출 될 수 있습니다. 따라서 모든 공유 변수에 대 한 액세스를 동기화 해야 합니다.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 메서드 기존 작업이 완료로 실행 기간 동안 스레드 보다 더 많은 작업을 사용할 수 있으며 새 작업으로 대체 됩니다. 이렇게 하면 기본 <xref:System.Threading.Tasks.TaskScheduler> 변경 가능성을 추가 하려면 개체 또는 루프를 제공 하는 스레드를 제거 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="body" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localInit" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="localFinally" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" /> 인수의 <see cref="T:System.Threading.CancellationToken" />이 취소된 경우</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
        <exception cref="T:System.AggregateException">모든 개별 예외를 포함하는 예외는 스레드에서 throw됩니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">병렬 루프</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>각각의 제공된 동작을 가능하면 병렬로 실행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">실행할 <see cref="T:System.Action" />의 배열입니다.</param>
        <summary>각각의 제공된 동작을 가능하면 병렬로 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 작업의 집합을 잠재적으로 병렬로 실행 데 사용할 수 있습니다.  
  
 병렬로 실행 되는지 여부 또는 작업이 실행 되는 순서에 대 한 보장 되지 않습니다 됩니다. 이 메서드는 완료 될 때까지 각 제공 된 작업, 완료 정상 또는 예외 종료로 인해 발생 하는 여부에 관계 없이 반환 하지 않습니다.  
  
 자세한 내용은 [방법: Parallel.Invoke를 사용하여 병렬 작업 실행](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)을 참조하세요.  
  
   
  
## Examples  
 이 예제를 사용 하는 방법에 설명 합니다 <xref:System.Threading.Tasks.Parallel.Invoke%2A> 다른 메서드, 익명 대리자 및 람다 식을 사용 하 여 메서드.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException"><paramref name="actions" /> 배열에 있는 모든 작업이 예외를 throw하는 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> 배열에 <see langword="null" /> 요소가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">이 작업의 동작을 구성하는 개체입니다.</param>
        <param name="actions">실행할 동작의 배열입니다.</param>
        <summary>사용자가 작업을 취소하지 않는다면 제공된 각 작업을 가능한 한 병렬로 실행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 작업의 집합을 잠재적으로 병렬로 실행 데 사용할 수 있습니다. 에 전달 된 취소 토큰이 <xref:System.Threading.Tasks.ParallelOptions> 구조 전체 작업을 취소 하려면 호출자에 게 사용 하도록 설정 합니다. 자세한 내용은 [관리되는 스레드의 취소](~/docs/standard/threading/cancellation-in-managed-threads.md)를 참조하세요.  
  
 병렬로 실행 되는지 여부 또는 작업이 실행 되는 순서에 대 한 보장 되지 않습니다 됩니다. 이 메서드는 완료 될 때까지 각 제공 된 작업, 완료 정상 또는 예외 종료로 인해 발생 하는 여부에 관계 없이 반환 하지 않습니다.  
  
 자세한 내용은 [방법: Parallel.Invoke를 사용하여 병렬 작업 실행](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationToken" />이 설정됩니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="parallelOptions" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.AggregateException"><paramref name="actions" /> 배열에 있는 모든 작업이 예외를 throw하는 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> 배열에 <see langword="null" /> 요소가 포함되어 있습니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="parallelOptions" />의 <see cref="T:System.Threading.CancellationTokenSource" />과 연결된 <see cref="T:System.Threading.CancellationToken" />가 삭제되었습니다.</exception>
      </Docs>
    </Member>
  </Members>
</Type>