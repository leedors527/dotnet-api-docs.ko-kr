<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9098e4d02a13797d5e7e75781d3dab43b4e226f4" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58716327" /></Metadata><TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><see cref="T:System.Threading.Tasks.Task" /> 개체를 만들고 예약하도록 지원합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework는 만들기 및 작업 예약에 대 한 두 팩터리를 제공 합니다.  
  
-   합니다 <xref:System.Threading.Tasks.TaskFactory> 클래스를 만듭니다 <xref:System.Threading.Tasks.Task> 고 <xref:System.Threading.Tasks.Task%601> 개체입니다. 만들고 기본이 아닌 인수를 필요로 하는 작업 실행이 메서드의 오버 로드를 호출할 수 있습니다.  
  
    > [!WARNING]
    >  로 시작 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 구성 값 이며 기본값은 태스크를 만드는 즉시 시작 하는 가장 쉬운 방법은 제공 합니다.  
  
-   합니다 <xref:System.Threading.Tasks.TaskFactory%601> 클래스를 만드는 <xref:System.Threading.Tasks.Task%601> 개체입니다.  
  
 <xref:System.Threading.Tasks.TaskFactory> 클래스를 사용 하면 다음을 수행할 수 있습니다.  
  
-   작업을 만들고 호출 하 여 즉시 시작 합니다 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 메서드.  
  
    > [!WARNING]
    >  로 시작 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 구성 값 이며 기본값은 태스크를 만드는 즉시 시작 하는 가장 쉬운 방법은 제공 합니다.  
  
-   배열에서 작업 중 하나를 호출 하 여 완료 될 때 시작 되는 작업 만들기를 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> 메서드.  
  
-   호출 하 여 배열에는 모든 작업이 완료 될 때 시작 되는 작업 만들기를 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 메서드.  
  
 정적 <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> 속성을 기본 반환 <xref:System.Threading.Tasks.TaskFactory%601> 개체입니다. 중 하나를 호출할 수도 있습니다는 <xref:System.Threading.Tasks.TaskFactory> 클래스 생성자를 구성 하는 <xref:System.Threading.Tasks.Task> 개체는 <xref:System.Threading.Tasks.TaskFactory> 클래스를 만듭니다. 다음 예제에서는 새 구성 <xref:System.Threading.Tasks.TaskFactory> 지정 된 취소 토큰, 작업 생성 옵션, 연속 옵션 및 사용자 지정된 작업 스케줄러는 작업을 만드는 개체입니다.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 대부분의 경우에서 수행 하면 새 <xref:System.Threading.Tasks.TaskFactory> 인스턴스. 대신 사용할 수는 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> 기본값을 사용 하는 팩터리 개체를 반환 하는 속성입니다. 새 작업을 시작 하거나 작업 연속을 정의 하려면 해당 메서드를 호출할 수 있습니다. 예시의 경우에 대 한 예제를 참조 하세요.  
  
   
  
## Examples  
 다음 예제에서는 정적 <xref:System.Threading.Tasks.Task.Factory%2A> 속성에 대 한 두 호출을는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> 메서드. 첫 번째 두 번째 사용자의 내 문서 디렉터리의 하위 디렉터리 이름의 배열을 채웁니다 하는 동안 사용자의 내 문서 디렉터리에 있는 파일 이름의 배열을 채웁니다. 그런 다음 호출 하는 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> 처음 두 개의 작업 실행 완료 후 두 배열에서 파일 및 디렉터리의 수에 대 한 정보를 표시 하는 메서드.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>모든 public 및 protected 멤버만 <see cref="T:System.Threading.Tasks.TaskFactory" /> 는 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework 사용한 병렬 프로그래밍 샘플</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskFactory" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>기본 구성을 사용하여 <see cref="T:System.Threading.Tasks.TaskFactory" /> 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Threading.Tasks.TaskFactory> 기본 구성 사용 하 여 인스턴스. 합니다 <xref:System.Threading.Tasks.TaskCreationOptions> 속성은 초기화 <xref:System.Threading.Tasks.TaskCreationOptions.None>의 <xref:System.Threading.Tasks.TaskContinuationOptions> 속성으로 초기화 됩니다 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 및 <xref:System.Threading.Tasks.TaskScheduler> 속성은 현재 스케줄러로 초기화 (참조 <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">팩터리 메서드를 호출할 때 다른 CancellationToken을 명시적으로 지정하지 않는 경우 이 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에서 만든 작업에 할당할 <see cref="T:System.Threading.Tasks.TaskFactory" />입니다.</param>
        <summary>지정된 구성을 사용하여 <see cref="T:System.Threading.Tasks.TaskFactory" /> 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 <xref:System.Threading.Tasks.TaskFactory> 기본 구성 사용 하 여 인스턴스. 합니다 <xref:System.Threading.Tasks.TaskCreationOptions> 속성은 초기화 <xref:System.Threading.Tasks.TaskCreationOptions.None>의 <xref:System.Threading.Tasks.TaskContinuationOptions> 속성으로 초기화 됩니다 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 및 <xref:System.Threading.Tasks.TaskScheduler> 속성은 현재 스케줄러로 초기화 (참조 <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">취소</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">이 TaskFactory를 사용하여 만든 작업을 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다. null 값은 현재 TaskScheduler를 사용함을 나타냅니다.</param>
        <summary>지정된 구성을 사용하여 <see cref="T:System.Threading.Tasks.TaskFactory" /> 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여는 <xref:System.Threading.Tasks.TaskCreationOptions> 속성은 초기화 <xref:System.Threading.Tasks.TaskCreationOptions.None>의 <xref:System.Threading.Tasks.TaskContinuationOptions> 속성으로 초기화 됩니다 <xref:System.Threading.Tasks.TaskContinuationOptions.None>, 및 <xref:System.Threading.Tasks.TaskScheduler> 속성은 초기화 `scheduler`아닌 경우 null 인 경우,를 속성은 현재 스케줄러로 초기화 됩니다 (참조 <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">이 TaskFactory를 사용하여 작업을 만들 때 사용할 기본 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</param>
        <param name="continuationOptions">이 TaskFactory를 사용하여 연속 작업을 만들 때 사용할 기본 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />입니다.</param>
        <summary>지정된 구성을 사용하여 <see cref="T:System.Threading.Tasks.TaskFactory" /> 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여는 <xref:System.Threading.Tasks.TaskCreationOptions> 속성은 초기화 `creationOptions`의 <xref:System.Threading.Tasks.TaskContinuationOptions> 속성은 초기화 `continuationOptions`, 및 <xref:System.Threading.Tasks.TaskScheduler> 속성은 현재 스케줄러로 초기화 (참조 <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수에서 잘못된 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 값을 지정합니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하세요.  
  
또는 
<paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory" Usage="new System.Threading.Tasks.TaskFactory (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">팩터리 메서드를 호출할 때 다른 CancellationToken을 명시적으로 지정하지 않는 경우 이 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에서 만든 작업에 할당할 기본 <see cref="T:System.Threading.Tasks.TaskFactory" />입니다.</param>
        <param name="creationOptions">이 TaskFactory를 사용하여 작업을 만들 때 사용할 기본 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />입니다.</param>
        <param name="continuationOptions">이 TaskFactory를 사용하여 연속 작업을 만들 때 사용할 기본 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />입니다.</param>
        <param name="scheduler">이 TaskFactory를 사용하여 만든 작업을 예약하는 데 사용할 기본 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다. null 값은 TaskScheduler.Current를 사용함을 나타냅니다.</param>
        <summary>지정된 구성을 사용하여 <see cref="T:System.Threading.Tasks.TaskFactory" /> 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여는 <xref:System.Threading.Tasks.TaskCreationOptions> 속성은 초기화 `creationOptions`의 <xref:System.Threading.Tasks.TaskContinuationOptions> 속성으로 초기화 됩니다 `continuationOptions`, 및 <xref:System.Threading.Tasks.TaskScheduler> 속성은 초기화 `scheduler`아닌 경우 null 인 경우,를 속성은 현재 스케줄러로 초기화 됩니다 (참조 <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수에서 잘못된 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 값을 지정합니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하세요.  
  
또는 
<paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 작업 팩터리에 대한 기본 취소 토큰을 가져옵니다.</summary>
        <value>이 작업 팩터리에 대한 기본 작업 취소 토큰입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 기본 반환 <xref:System.Threading.CancellationToken> 할당 된이 팩터리에서 만든 모든 작업을 하지 않는 한 다른 <xref:System.Threading.CancellationToken> 팩터리 메서드를 호출 하는 동안 값을 명시적으로 지정 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 작업 팩터리에 대한 기본 작업 연속 옵션을 가져옵니다.</summary>
        <value>이 작업 팩터리에 대한 기본 작업 연속 옵션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값을 다른 옵션은이 팩터리의 메서드를 호출 하는 동안 명시적으로 지정 하지 않는 한 모든 연속 작업을 만드는 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework 사용한 병렬 프로그래밍 샘플</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 메서드가 실행 합니다 `continuationAction` 시 모든 작업이 대리자는 `tasks` 그 완료 상태에 관계 없이 배열을 완료 합니다.  
  
 작업에서 throw 된 예외는 `tasks` 구조적된 예외 처리를 통해 연속 작업에 사용할 수 없는 배열입니다. 예외를 검사 하 여 throw 된 것을 확인할 수 있습니다는 <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> 에서 각 태스크의 속성을 `tasks` 배열입니다. 구조적된 예외 처리의 작업에서 throw 된 예외를 처리 하는 데는 `tasks` 배열, 호출 된 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 텍스트 파일 집합의 단어 수를 계산 하는 정규식을 사용 하는 별도 작업을 시작 합니다. <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> 메서드를 사용 하는 모든 선행 작업이 완료 되 면 전체 단어 수를 표시 하는 작업을 시작 합니다.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 연속 작업의 호출 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드 예제 검사 되므로 선행 작업에서 throw 된 예외를 처리 하도록 허용 하지 않습니다는 <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> 작업에 성공 했는지 여부를 확인 하려면 각 선행 작업의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [\], Action(Task\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%2CSystem.Threading.CancellationToken%29> method executes the `continuationAction` delegate when all tasks in the `tasks` array have completed, regardless of their completion status.  
  
   
  
## Examples  
 다음 예제에서는 구분 텍스트 파일 집합의 단어 수를 계산 하는 정규식을 사용 하는 작업에 전달 된 취소 토큰을 만듭니다. 취소 토큰 파일을 찾을 수 없는 경우에 설정 됩니다. [\], 작업 (작업\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A > 메서드를 사용 하는 모든 선행 작업이 완료 되 면 전체 단어 수를 표시 하는 작업을 시작 합니다. 취소 토큰으로 설정 된 경우 나타내는 하나 이상의 작업이 취소 되었으면을 처리는 <xref:System.AggregateException> 예외 및 오류 메시지를 표시 합니다.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.  
  
또는 
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationAction As Action(Of Task()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다.</param>
        <param name="scheduler">새 연속 작업을 예약하는 데 사용할 개체입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)())) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.  
  
또는 
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)()), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[]&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAll (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <param name="scheduler">새 연속 작업을 예약하는 데 사용할 개체입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.  
  
또는 
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <param name="scheduler">새 연속 작업을 예약하는 데 사용할 개체입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.  
  
또는 
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 작업과 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열의 모든 작업이 완료되었을 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 취소 토큰입니다.</param>
        <param name="continuationOptions">새 연속 작업 동작을 제어하는 열거형 값의 비트 조합입니다. NotOn* 및 OnlyOn* 멤버는 지원되지 않습니다.</param>
        <param name="scheduler">새 연속 작업을 예약하는 데 사용할 개체입니다.</param>
        <summary>지정된 일련의 작업을 완료하면 시작되는 연속 작업을 만듭니다.</summary>
        <returns>새 연속 작업입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationFunction" /> 인수가 <see langword="null" />인 경우  
  
또는 
<paramref name="scheduler" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 null 값이 있거나 비어 있습니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수에서 잘못된 값을 지정합니다.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 하나가 삭제되었습니다.  
  
또는 
<paramref name="cancellationToken" />을 만든 <see cref="T:System.Threading.CancellationTokenSource" />가 이미 삭제되었습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework 사용한 병렬 프로그래밍 샘플</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 `ContinueWhenAny` 고 `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 중 하나가 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 <see langword="null" /> 값이 포함된 경우  
  
또는 
<paramref name="tasks" /> 배열이 비어 있는 경우</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열에 있는 요소 중 하나가 삭제되었습니다.  
  
또는 
 <paramref name="cancellationToken" />가 이미 삭제되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 <see langword="null" />인 경우  
  
또는 
<paramref name="continuationAction" /> 인수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 <see langword="null" /> 값이 포함된 경우  
  
또는 
<paramref name="tasks" /> 배열이 비어 있습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task" /> 값입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수가 유효하지 않은 TaskContinuationOptions 값을 지정할 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task" /> 값입니다.</param>
        <param name="scheduler">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.  
  
또는 
제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationAction As Action(Of Task(Of TAntecedentResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task" /> 값입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수가 유효하지 않은 TaskContinuationOptions 값을 지정할 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Action&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Action&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.ContinueWhenAny (tasks, continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationAction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task" /> 값입니다.</param>
        <param name="scheduler">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationAction" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.  
  
또는 
제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TResult) (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task`1" /> 값입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수가 유효하지 않은 TaskContinuationOptions 값을 지정할 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task`1" /> 값입니다.</param>
        <param name="scheduler">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.  
  
또는 
제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult, TResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task`1" /> 값입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><paramref name="tasks" /> 배열의 요소 중 하나가 삭제된 경우 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> 인수가 유효하지 않은 TaskContinuationOptions 값을 지정할 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">선행 <paramref name="tasks" />의 결과 형식입니다.</typeparam>
        <typeparam name="TResult"><paramref name="continuationFunction" /> 대리자가 반환하고 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />와 연결되는 결과의 형식입니다.</typeparam>
        <param name="tasks">작업이 완료될 때 계속할 작업의 배열입니다.</param>
        <param name="continuationFunction"><paramref name="tasks" /> 배열에서 작업이 완료될 때 비동기로 실행할 함수 대리자입니다.</param>
        <param name="cancellationToken">새 연속 작업에 할당할 <see cref="T:System.Threading.CancellationToken" />입니다.</param>
        <param name="continuationOptions">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />의 동작을 제어하는 <see cref="T:System.Threading.Tasks.Task`1" /> 값입니다.</param>
        <param name="scheduler">만들어진 연속 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</param>
        <summary>제공된 집합에서 작업이 완료될 때 시작할 연속 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>새 연속 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 NotOn * 및 OnlyOn * <xref:System.Threading.Tasks.TaskContinuationOptions>를 제한 하는 <xref:System.Threading.Tasks.TaskStatus> 연속 실행 되 고, 상태는 ContinueWhenAny를 사용 하 여 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> 배열이 null인 경우 throw되는 예외입니다.  
  
또는 
<paramref name="continuationFunction" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> 배열에 Null 값이 있을 때 throw되는 예외입니다.  
  
또는 
<paramref name="tasks" /> 배열이 비어 있을 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 작업 팩터리에 대한 기본 작업 만들기 옵션을 가져옵니다.</summary>
        <value>이 작업 팩터리에 대한 기본 작업 만들기 옵션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값을 다른 옵션은이 팩터리의 메서드를 호출 하는 동안 명시적으로 지정 하지 않는 한 모든 작업을 만드는 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 동작 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 End 메서드 작업을 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다.  이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 동작 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 End 메서드 작업을 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다. <xref:System.Threading.Tasks.TaskCreationOptions> 값 <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> 고 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> 는 모두 함께 사용할 수 없습니다. FromAsync 메서드에서 중 하나 `LongRunning` 또는 `AttachedToParent` 자체적으로 하면는 <xref:System.ArgumentOutOfRangeException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Action(Of IAsyncResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FromAsync(IAsyncResult ^ asyncResult, Action&lt;IAsyncResult ^&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Action&lt;IAsyncResult&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 동작 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">End 메서드를 실행하는 작업을 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task" />가 완료될 때 End 메서드 작업을 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 함수 대리자입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 End 메서드 함수를 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 함수 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 End 메서드 함수를 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TResult) (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="asyncResult">완료될 때 <paramref name="endMethod" />의 처리를 트리거하는 IAsyncResult입니다.</param>
        <param name="endMethod">완료된 <paramref name="asyncResult" />를 처리하는 함수 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">End 메서드를 실행하는 작업을 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</param>
        <summary>지정된 <see cref="T:System.Threading.Tasks.Task`1" />가 완료될 때 End 메서드 함수를 실행하는 <see cref="T:System.IAsyncResult" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 사용 하는 오버 로드는 `asyncResult` 매개 변수 오버 로드 만큼 효율적이 지 않습니다.를 `beginMethod` 매개 변수입니다. 성능이 문제일 경우 제공 하는 오버 로드를 사용 합니다 `beginMethod` / `endMethod` 패턴입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TResult) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg3"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="arg3"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Action(Of IAsyncResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Action&lt;IAsyncResult ^&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Action&lt;IAsyncResult&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg3"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="arg3"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TResult) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg3"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="arg3"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3, TResult) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3, typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg2"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TArg3"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수의 형식입니다.</typeparam>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="beginMethod">비동기 작업을 시작하는 대리자입니다.</param>
        <param name="endMethod">비동기 작업을 종료하는 대리자입니다.</param>
        <param name="arg1"><paramref name="beginMethod" /> 대리자에 전달되는 첫 번째 인수입니다.</param>
        <param name="arg2"><paramref name="beginMethod" /> 대리자에 전달되는 두 번째 인수입니다.</param>
        <param name="arg3"><paramref name="beginMethod" /> 대리자에 전달되는 세 번째 인수입니다.</param>
        <param name="state"><paramref name="beginMethod" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary>비동기 프로그래밍 모델 패턴을 따르는 Begin 및 End 메서드 쌍을 나타내는 <see cref="T:System.Threading.Tasks.Task`1" />를 만듭니다.</summary>
        <returns>비동기 작업을 나타내는 만들어진 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `beginMethod` 대리자 스레드에서 시작 되는 <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> 에서 실행 되 고 있습니다. 이 메서드에 의해 throw 된 예외 throw를 `beginMethod`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="beginMethod" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="endMethod" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">TPL과 기타 비동기 패턴 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 작업 팩터리에 대한 기본 작업 스케줄러를 가져옵니다.</summary>
        <value>이 작업 팩터리에 대한 기본 작업 스케줄러입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값을 다른 스케줄러가이 팩터리의이 메서드를 호출 하는 동안 명시적으로 지정 되지 않은 경우 모든 작업을 예약 하려면 사용 됩니다.  
  
 이 속성 값이 `null`의 값을 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로 시작 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 컴퓨트 바운드 작업을 시작 하는 것이 좋습니다. 사용 된 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 메서드 계산에 바인딩된 장기 실행 작업에 대 한 세분화 된 제어 해야 하는 경우에 합니다. 다음을 제어 하려는 시나리오를 포함 합니다.  
  
-   작업 생성 옵션입니다. 만든 작업은 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 기본적으로 메서드를 사용 하 여 만들어진는 <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType> 옵션입니다. 다른 제공 하기 위해 또는이 동작을 재정의할 <xref:System.Threading.Tasks.TaskCreationOptions> 옵션을 호출 하는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 오버 로드 합니다.  
  
-   매개 변수를 전달 합니다. 오버 로드는 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드 작업 대리자에 매개 변수를 전달할 수 없습니다. 오버 로드는 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 메서드를 수행 합니다.  
  
-   작업 스케줄러입니다. 오버 로드는 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> 메서드는 기본 작업 스케줄러를 사용 합니다. 작업 스케줄러를 제어 하려면 호출을 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 오버 로드는 `scheduler` 매개 변수입니다. 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework 사용한 병렬 프로그래밍 샘플</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <summary>작업을 만들고 시작합니다.</summary>
        <returns>시작된 작업입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기능적으로 해당 생성자 중 하나를 사용 하 고 다음 호출 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> 메서드 실행에 대 한 작업을 예약 합니다.  
  
 부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 메서드 호출을 신속 하 게 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> 기본 매개 변수를 사용 하 여. 단, 두 메서드 간의 동작에서 차이에 대 한: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> 기본적으로 없도록 자식 작업을 시작 합니다 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 현재 연결할 수 <xref:System.Threading.Tasks.Task> 반면 인스턴스 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> 않습니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> 반복적으로 호출 하는 메서드는 <xref:System.Action> 난수를 생성 하는 대리자 유니코드 코드 포인트를으로 해석 하 여 UTF16 인코딩 코드 단위로 변환 하 고 결과 대 한 정보를 표시 합니다. 문자 또는 문자입니다.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 `StartNew` 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드 호출을 신속 하 게 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> 기본 매개 변수를 사용 하 여. 단, 두 메서드 간의 동작에서 차이에 대 한: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 기본적으로 없도록 자식 작업을 시작 합니다 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 현재 연결할 수 <xref:System.Threading.Tasks.Task> 반면 인스턴스 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> 않습니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> C:\Windows\System32 디렉터리의 파일을 반복 하는 작업을 만드는 방법. 람다 식 호출을 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 각 파일에 대 한 정보를 추가 하는 메서드를 <xref:System.Collections.Generic.List%601> 개체입니다. 중첩 된 작업을 호출 하 여 각 분리를 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> 루프 취소 토큰의 상태를 확인 하 고, 취소가 요청 된 경우 호출 된 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드. 합니다 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 메서드가 throw를 <xref:System.OperationCanceledException> 에서 처리 되는 예외를 `catch` 호출 호출 스레드를 차단 합니다 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 메서드.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="state"><paramref name="action" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기능적으로 만들기를 <xref:System.Threading.Tasks.Task> 생성자 중 하나를 사용 하 여 한 다음 호출을 <xref:System.Threading.Tasks.Task.Start%2A> 실행에 대 한 예약 하는 방법입니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제에서는 6 자로 단어 배열을 정의합니다. 각 단어 전달 되는 <xref:System.Action%601> 단어를 암호화 하 고 원래 단어 및 해당 암호화 된 버전을 표시 하는 대리자입니다.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 이 예제에서는 단일 난수 생성기를 잠금으로 보호 되는 초기화는 참고 합니다. 잠금의 필요를 "System.Random 클래스와 스레드 안전성"의 참조는 <xref:System.Random> 클래스 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="state"><paramref name="action" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="cancellationToken">새 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에 할당할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제에서는 6 자로 단어 배열을 정의합니다. 각 단어 전달 되는 <xref:System.Action%601> 단어를 암호화 하 고 원래 단어 및 해당 암호화 된 버전을 표시 하는 대리자입니다.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 이 예제에서는 단일 난수 생성기를 잠금으로 보호 되는 초기화는 참고 합니다. 잠금의 필요를 "System.Random 클래스와 스레드 안전성"의 참조는 <xref:System.Random> 클래스 항목입니다. 취소 토큰이 전달 난수 생성기의 손상 가능성을 처리 하려면 작업을 합니다. 두 개의 난수 값이 0 인 경우 메서드는 난수 생성기 손상 되 고이 취소 토큰을 설정 하는 가정 합니다. 정렬 하기 전에 합니다 `chars` 배열 된 6를 포함 하는 문자, 단어, 메서드 호출을 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> throw 하는 방법은 <xref:System.OperationCanceledException> 토큰이 취소 된 경우.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="state"><paramref name="action" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="cancellationToken">새 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에 할당할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">만들어진 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ StartNew(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="taskFactory.StartNew (action, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">비동기적으로 실행할 동작 대리자입니다.</param>
        <param name="state"><paramref name="action" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="cancellationToken">새 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">만들어진 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 해당 생성자와 호출 중 하나를 사용 하 여 작업을 만드는 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용 및 코드 예제를 참조 하세요 [Task.Run vs Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 고 호출한 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 호출할 수 있습니다 합니다 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 메서드 호출을 신속 하 게 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 단, 두 메서드 간의 동작에서 차이에 대 한: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> 기본적으로 없도록 자식 작업을 시작 합니다 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 현재 연결할 수 <xref:System.Threading.Tasks.Task%601> 반면 인스턴스 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> 않습니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제는 두 개의 난수를 생성 하 고 해당 합계를 입력 하 라는 메시지는 단순한 더하기 앱. 그런 다음 답변 올바른지 여부, 사용자의 응답을 유효한 숫자가 아닌 경우 다시 유효한 숫자를 입력 하 라는 메시지가 표시 됩니다 나타냅니다. 합니다 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 만드는 데 사용 되는 <xref:System.Threading.Tasks.Task%601> 추가할 난수를 반환 하는 개체입니다.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 <see langword="null" />인 경우</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="state"><paramref name="function" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="cancellationToken">새 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에 할당할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 고 호출한 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 메서드 호출을 신속 하 게 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> 기본 매개 변수를 사용 하 여. 단, 두 메서드 간의 동작에서 차이에 대 한: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> 기본적으로 없도록 자식 작업을 시작 합니다 <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent?displayProperty=nameWithType> 현재 연결할 수 <xref:System.Threading.Tasks.Task%601> 반면 인스턴스 <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> 않습니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
   
  
## Examples  
 다음 예제에서는 두 가지 작업을 사용 하 여 F100 끝나는 피보나치 시퀀스 계산 F100 1 + 2 F100 초기값 F1 = = 1, F2 1 및 F1 = = 0, F2 = 1입니다. 약 절반의 경우 취소 토큰으로 설정 되 작업을 실행 합니다. 예제에서 출력의 두 작업을 완료 하 고 토큰이 취소 되는 경우 결과 보여 줍니다.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="state"><paramref name="function" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="cancellationToken">새 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />에 할당할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew(Of TResult) (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="state"><paramref name="function" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="cancellationToken">새 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">만들어진 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 결과의 형식입니다.</typeparam>
        <param name="function"><see cref="T:System.Threading.Tasks.Task`1" />를 통해 사용할 수 있는 이후 결과를 반환하는 함수 대리자입니다.</param>
        <param name="state"><paramref name="function" /> 대리자가 사용할 데이터가 포함된 개체입니다.</param>
        <param name="cancellationToken">새 작업에 할당할 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />입니다.</param>
        <param name="creationOptions">만들어진 <see cref="T:System.Threading.Tasks.Task`1" />의 동작을 제어하는 TaskCreationOptions 값입니다.</param>
        <param name="scheduler">만들어진 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 예약하는 데 사용할 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" />를 만들고 시작합니다.</summary>
        <returns>시작된 <see cref="T:System.Threading.Tasks.Task`1" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 StartNew를 호출 하는 것은 기능적으로 만들기를 <xref:System.Threading.Tasks.Task%601> 생성자 중 하나를 사용 하 여 한 다음 호출 <xref:System.Threading.Tasks.Task.Start%2A> 실행 되도록 합니다.  
  
 부터 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 <xref:System.Threading.Tasks.Task.Run%2A> 메서드는 <xref:System.Action> 신속 하 게 호출 하는 개체 <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> 기본 매개 변수를 사용 하 여 합니다. 자세한 내용과 코드 예제에 대 한 항목을 참조 [Task.Run vs. Task.Factory.StartNew](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/) 에서 Parallel Programming with.NET 블로그.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">제공된 <see cref="T:System.Threading.CancellationToken" />가 이미 삭제된 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> 인수가 null일 때 throw되는 예외입니다.  
  
또는 
<paramref name="scheduler" /> 인수가 null일 때 throw되는 예외입니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. <paramref name="creationOptions" /> 인수가 잘못된 TaskCreationOptions 값을 지정하는 경우 throw되는 예외입니다. 자세한 내용은 <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />에 대한 설명을 참조하십시오.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">연속 작업을 사용하여 작업 연결</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">작업 취소</related>
      </Docs>
    </Member>
  </Members>
</Type>