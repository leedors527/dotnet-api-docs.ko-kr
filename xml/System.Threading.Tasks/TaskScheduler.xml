<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bba851cfd6f156bb1595db68a433823776e03787" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58874893" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>작업을 스레드의 큐에 대기하는 낮은 수준의 작업을 처리하는 개체를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스는 <xref:System.Threading.Tasks.TaskScheduler> 클래스 작업 스케줄러를 나타내는입니다. 작업 스케줄러는 작업이 실제로 실행되도록 합니다.  
  
 기본 작업 스케줄러는 부하 분산을 위한 작업 가로채기, 최대 처리량을 위한 스레드 삽입/폐기 및 전반적으로 뛰어난 성능을 제공하는 .NET Framework 4 스레드 풀을 기반으로 합니다. 대부분의 시나리오에서는 이것만으로 충분합니다.  
  
 <xref:System.Threading.Tasks.TaskScheduler> 클래스 사용자 지정 가능한 모든 일정 논리에 대 한 확장 지점 역할도 합니다.  디버거 실행에 대 한 작업 및 방법을 예약 된 작업을 예약 하는 방법을 제공 해야 같은 메커니즘이 포함 됩니다. 특별 한 기능에 필요한 경우 사용자 지정 스케줄러를 만들고 특정 작업 또는 쿼리에 대 한 사용 하도록 설정할 수 있습니다.  
  
 항목 내용  
[기본 작업 스케줄러 및 스레드 풀](#Default)  
 [전역 큐와 로컬 큐 비교](#Queues)  
 [작업 가로채기](#Stealing)  
 [장기 실행 작업](#LongRunning)  
 [작업 인라인 처리](#Inlining)  
[동기화 컨텍스트 지정](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>기본 작업 스케줄러 및 스레드 풀  
 작업 병렬 라이브러리 및 PLINQ에 대 한 기본 스케줄러를 사용 하 여 표현 되는.NET Framework 스레드 풀을는 <xref:System.Threading.ThreadPool> 클래스, 큐 및 작업을 실행 합니다. 스레드 풀에서 제공 하는 정보를 사용 하는 <xref:System.Threading.Tasks.Task> 형식 효율적으로 병렬화 하는 작업 및 쿼리가 종종 나타내는 세분화 된 병렬 처리 (짧은 수명의 작업 단위)를 지원 합니다.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>전역 큐와 로컬 큐 비교  
 스레드 풀 전역 FIFO (선입 선출) 큐 각 응용 프로그램 도메인의 스레드에 대 한 작업을 유지 합니다. 프로그램을 호출할 때마다 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (또는 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 메서드를 작업이 공유 큐에 배치 되며 최종적으로 사용할 수 있는 다음 스레드 큐 해제 합니다. .NET Framework 4부터이 큐가 향상 되었습니다 유사한 잠금 없는 알고리즘을 사용 하 여 <xref:System.Collections.Concurrent.ConcurrentQueue%601> 클래스입니다. 이 잠금 없는 구현을 사용 하 여 스레드 풀 데 큐 및 작업 항목 큐에서 제거 하면 시간을 줄입니다. 이 성능 혜택은 스레드 풀을 사용 하는 모든 프로그램에 제공 됩니다.  
  
 다른 작업의 컨텍스트에서 생성되지 않은 작업인 최상위 작업은 다른 작업 항목과 마찬가지로 전역 큐에 배치됩니다. 그러나 다른 작업의 컨텍스트에서 생성된 중첩된 작업이나 자식 작업은 전혀 다르게 처리됩니다. 자식 작업이나 중첩된 작업은 부모 작업이 실행되는 스레드와 관련된 로컬 큐에 배치됩니다. 부모 작업은 최상위 작업이거나 다른 작업의 자식일 수 있습니다. 이 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐를 확인합니다. 작업 항목이 대기 중이면 신속하게 액세스할 수 있습니다. 로컬 큐를 마지막에 선출 lifo (후입선출) 경합을 줄이고 캐시 집약성을 유지 하려면에서 액세스 됩니다. 자식 작업 및 중첩 된 작업에 대 한 자세한 내용은 참조 하세요. [연결 된 자식 작업과 분리 된 자식 작업](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)합니다.  
  
 로컬 큐 사용 하 여 전역 큐에 대 한 압력 감소 뿐만 아니라 데이터 집약성의 이점도 있습니다. 로컬에서 작업 항목 큐 자주 물리적으로 서로 근처에 있는 메모리 참조 데이터 구조입니다. 이러한 경우에는 데이터가 이미 캐시에서 실행 되는 첫 번째 작업 후 신속 하 게 액세스할 수 있습니다. 둘 다 [PLINQ (병렬 LINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) 고 <xref:System.Threading.Tasks.Parallel> 중첩 된 작업 및 자식 작업을 광범위 하 게, 클래스 및 속도 크게 향상 로컬 작업 큐를 사용 하 여 합니다.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>작업 가로채기  
 .NET Framework 4 부터는 스레드 풀 기능도 되는지 확인 하기 위해 스레드가 늘어난 유휴 여전히 다른 큐에 대기 중인 작업이 있는 동안 작업 가로채기 알고리즘을 합니다. 스레드 풀 스레드가 추가 작업을 수행할 준비가 되면 먼저 로컬 큐의 시작 부분을 확인한 다음 전역 큐, 다른 스레드의 로컬 큐 순으로 확인합니다. 다른 스레드의 로컬 큐에서 작업 항목을 찾은 경우 먼저 추론을 적용하여 작업을 효율적으로 실행할 수 있는지 확인합니다. 가능한 경우 FIFO 순서 대로 끝 부분에서 작업 항목을 큐입니다. 이러한 과정을 통해 각 로컬 큐에서의 경합이 줄어들고 데이터 집약성이 유지됩니다. 이 아키텍처는 스레드 풀을 부하 분산 이전 버전 보다 더 효율적으로 작업할 수 있습니다.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>장기 실행 작업  
 작업이 로컬 큐에 배치되지 않도록 명시적으로 차단할 수도 있습니다. 예를 들어 특정 작업 항목이 비교적 오랜 시간 동안 실행되며 로컬 큐의 다른 모든 작업 항목을 차단할 가능성이 있음을 알고 있습니다. 이 경우 로컬 큐의 다른 스레드나 작업 항목의 정방향 진행을 차단하지 않도록 작업에 추가 스레드가 필요할 수도 있다는 힌트를 스케줄러에 제공하는 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 옵션을 지정할 수 있습니다. 이 옵션을 사용 하 여 않으려면 스레드 풀 완전히 전역 및 로컬 큐를 포함 합니다.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>작업 인라인 처리  
 일부 경우 사례를 <xref:System.Threading.Tasks.Task> 대기 중인에 실행 될 수 있습니다 동기적으로 대기 작업을 수행 하는 스레드에서 합니다. 추가 스레드가 필요를 방지 하 고 그렇지 않으면 차단 되었을 기존 스레드를 사용 하 여 성능이 향상 됩니다. 재진입으로 인 한 오류를 방지 하려면 작업 인라인 처리는 대기 대상이 관련 스레드의 로컬 큐에 있는 경우에 발생 합니다.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>동기화 컨텍스트 지정  
 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 메서드를 사용하여 작업이 특정 스레드에서 실행 예약되도록 지정할 수 있습니다. 이 기능은 UI 개체가 만들어진 스레드와 동일한 스레드에서 실행되는 코드로 사용자 인터페이스 개체에 대한 액세스가 종종 제한되는 Windows Forms 및 Windows Presentation Foundation과 같은 프레임워크에서 유용합니다.  
  
 다음 예제에서는 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 사용자 인터페이스 (UI) 컨트롤에서 만든 동일한 스레드에서 작업을 예약 하려면 Windows Presentation Foundation (WPF) 앱에서 메서드.   지정된 된 디렉터리에서 임의로 선택 된 이미지의 시스템을 만듭니다. WPF 개체를 로드 하 고 이미지를 크기 조정에 사용 됩니다. 원시 픽셀은 사용 하는 작업에 전달 된 <xref:System.Threading.Tasks.Parallel.For%2A> 큰 단일 바이트 배열로 픽셀 데이터를 작성 하는 루프입니다. 동기화가 필요 하지 되므로 동일한 배열 요소를 차지 하는 두 개의 타일이 없습니다. 타일의 위치는 다른 타일과 독립적으로 계산 되므로 순서에 관계 없이 작성할 수도 있습니다. 대형 배열은 그러면 픽셀 데이터 이미지 컨트롤을 로드 되는 UI 스레드에서 실행 되는 작업에 전달 됩니다.  
  
 이 예제에서는 UI 스레드에서 데이터를 이동, 병렬 루프를 사용 하 여 수정 및 <xref:System.Threading.Tasks.Task> 개체 및 UI 스레드에서 실행 되는 작업을 다시 전달 합니다. 이 방법은 작업 병렬 라이브러리를 사용 하 여 WPF API에서 지원 되지 않습니다 또는 충분히 빠르지 않은 작업을 수행 해야 할 경우에 유용 합니다. Wpf에서는 이미지 시스템을 만드는 또 다른 방법은 사용 하는 것을 <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> 제어 하 고 이미지를 추가 합니다. <xref:System.Windows.Controls.WrapPanel> 타일 배치 작업을 처리 합니다. 그러나이 작업 UI 스레드에서 수행할 수만 있습니다.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 예제를 만들려면 Visual Studio에서 WPF 응용 프로그램 프로젝트를 만들고 WPF_CS1 이름을 (에 대 한는 C# WPF 프로젝트) 또는 WPF_VB1 (Visual Basic WPF 프로젝트를)에 대 한 합니다. 다음을 수행 합니다.  
  
1. 디자인 뷰에서 <xref:System.Windows.Controls.Image> 에서 제어를 **도구 상자** 디자인 화면의 왼쪽된 위 모퉁이에 있습니다. 에 **이름** 의 텍스트 상자를 **속성** 창 "제어"이미지 이름입니다.    
  
2. 끌어서를 <xref:System.Windows.Controls.Button> 에서 제어 합니다 **도구 상자** 응용 프로그램 창의 왼쪽된 아래 부분에 합니다. XAML 뷰에서 지정 된 <xref:System.Windows.Controls.ContentControl.Content%2A> "Make 시스템"으로 단추의 속성 지정 해당 <xref:System.Windows.FrameworkElement.Width> 속성을 "100"으로 합니다. 연결 합니다 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 이벤트를 `button_Click` 이벤트 처리기를 추가 하 여 예제의 코드에 정의 된 `Click="button_Click"` 에 `<Button>` 요소. 에 **이름** 의 텍스트 상자를 **속성** 창 "단추" 컨트롤 이름입니다.  
  
3. 이 예제에서 코드를 사용 하 여 MainWindow.xaml.vb 또는 MainWindow.xaml.cs 파일의 전체 내용을 대체 합니다. 에 대 한는 C# WPF 프로젝트에서 작업 영역의 이름을 프로젝트 이름이 일치 하는지 확인 합니다. 
  
4. 이 예제에서는 C:\Users\Public\Pictures\Sample 사진 라는 디렉터리에서 JPEG 이미지를 읽고\\합니다. 디렉터리 만들기, 일부 이미지를 배치 또는 이미지가 포함 된 일부 다른 디렉터리를 가리키도록 경로 변경 합니다. 
  
이 예제에서는 몇 가지 제한 사항이 있습니다. 예를 들어만 32 비트-픽셀당 이미지는 지원 됩니다. 다른 형식의 이미지에서 손상 된를 <xref:System.Windows.Media.Imaging.BitmapImage> 개체 크기 조정 작업 중입니다. 또한 소스 이미지 모두 여야 합니다 타일 크기를 초과 합니다. 자세한 연습을 여러 픽셀 형식 및 파일 크기를 처리할 수 있는 기능을 추가할 수 있습니다.  
  
## Examples  
 다음 예제에서 가져온 것은 [Samples for Parallel Programming.NET Framework 4를 사용 하 여](https://go.microsoft.com/fwlink/?LinkID=165717) MSDN 코드 갤러리 웹 사이트입니다.  앱에서 사용 되는 스레드 수를 제한 하는 사용자 지정 작업 스케줄러를 만듭니다. 그런 다음 두 가지 작업 집합을 시작 하 고 작업과 작업이 실행 되는 스레드 관련 정보가 표시 됩니다.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 또한 몇 가지 샘플 작업 스케줄러에 사용할 수 있는 코드 갤러리: [.NET Framework 4 사용한 병렬 프로그래밍에 대 한 샘플](https://go.microsoft.com/fwlink/?LinkID=165717)합니다.  
  
 ]]></format>
    </remarks>
    <threadsafe>모든 추상 멤버 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 형식은 스레드로부터 안전 하 고 여러 스레드에서 동시에 사용할 수 있습니다.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskScheduler" />을 초기화합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 실행 중인 작업과 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 가져옵니다.</summary>
        <value>현재 실행 중인 작업과 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업 내에서 호출 되지 않을 때 <xref:System.Threading.Tasks.TaskScheduler.Current%2A> 돌아갑니다는 <xref:System.Threading.Tasks.TaskScheduler.Default%2A> 스케줄러입니다.  
  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>.NET Framework에 의해 제공된 기본 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 인스턴스를 가져옵니다.</summary>
        <value>기본 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 인스턴스를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 스케줄러에 연결된 모든 리소스를 해제합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Threading.SynchronizationContext" />와 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />를 만듭니다.</summary>
        <returns><see cref="P:System.Threading.SynchronizationContext.Current" />에 따라 결정되는 현재 <see cref="T:System.Threading.SynchronizationContext" />와 연결된 <see cref="T:System.Threading.Tasks.TaskScheduler" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Threading.Tasks.Task> 인스턴스가 반환 된 대기 중인 스케줄러에 대 한 호출을 통해 실행 됩니다는 <xref:System.Threading.SynchronizationContext.Post%2A> 메서드 컨텍스트를 합니다.  
  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">현재 SynchronizationContext를 TaskScheduler로 사용할 수 없습니다.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>디버거를 지원하기 위해 현재 스케줄러의 큐에 대기되어 실행을 기다리고 있는 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 열거 가능한 형식을 생성합니다.</summary>
        <returns>디버거가 현재 이 스케줄러의 큐에 대기된 작업을 트래버스할 수 있도록 허용하는 열거 가능한 형식입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 디버거 통합을 지원 하기 위해이 메서드를 구현 합니다. 디버거 데이터에 대 한 액세스를 요청 하는 경우에이 메서드.NET 프레임 워크에서 호출 됩니다. 디버깅 작업에 액세스 하는 유틸리티에 의해 이동 열거형 반환 된 사용자 인터페이스에서이 정보는 표현을 제공 하려면 디버거를 사용 하도록 설정 하면이 스케줄러를 현재 큐에 대기 합니다.  
  
 이 메서드를 호출 하는 경우 프로세스의 다른 모든 스레드는 고정 하는 것이 반드시 합니다. 따라서 차단 시킬 수 있는 다른 스레드와 동기화를 방지 하려면 중요 한 것입니다. 동기화가 필요한 경우이 메서드에서 잠금을 가져올 수 없는 디버거를 중단 하지 않습니다 있도록 예외를 throw 해야 합니다. 다음 예제에서는 C#에서 한 가지 방법을 보여 줍니다.  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 또한이 메서드를 반환 하는 열거형 수정 해서는 안 전체적으로 표시 상태입니다.  
  
 반환 된 열거형 null이 아니어야 합니다. 가 현재 큐에 대기 중인된 작업이 없는 경우 빈 열거형을 대신 반환 되어야 합니다.  
  
 사용자 지정 디버거를 구현 하는 개발자는이 메서드를 직접 호출 하지 않아야 하지만 내부 래퍼 메서드를 사용 해야 `GetScheduledTasksForDebugger` 대신: `internal Task[] GetScheduledTasksForDebugger()`합니다. 이 래퍼 메서드에서 열거 하는 대신 작업의 배열을 반환합니다. 내부 메서드를 사용 하 여 현재 스케줄러의 목록을 검색할 `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`합니다. 이 정적 메서드는 모든 활성의 배열을 반환 <xref:System.Threading.Tasks.TaskScheduler> 인스턴스. 사용할 수 있습니다 `GetScheduledTasksForDebugger` 각 스케줄러 인스턴스에 예약 된 작업 목록을 검색 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 스케줄러는 현재 대기 중인 작업 목록을 생성할 수 없습니다.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 고유 ID를 가져옵니다.</summary>
        <value>이 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 고유 ID를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Threading.Tasks.TaskScheduler" />가 지원할 수 있는 최대 동시성 수준을 나타냅니다.</summary>
        <value>최대 동시성 수준을 나타내는 정수를 반환합니다. 기본 스케줄러는 <see cref="F:System.Int32.MaxValue" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">큐에 대기할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />를 스케줄러의 큐에 대기합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 스케줄러에서 예약 된 작업을 허용 하도록이 메서드를 구현 합니다.  
  
 일반적인 구현은 작업은 나중에 특정 시간에 해당 태스크를 실행 중인 스레드에 의해 서비스 됩니다는 내부 데이터 구조에 저장 됩니다.  
  
 이 메서드는.NET 프레임 워크에서 호출 되어야 하는 기능만 하며 파생된 클래스에서 직접 호출할 수 없습니다. 이 시스템의 일관성을 유지 하는 데 필요한 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> 인수가 null입니다.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">큐에서 제거할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <summary>이전에 이 스케줄러의 큐에 대기된 <see cref="T:System.Threading.Tasks.Task" />를 큐에서 제거하려고 합니다.</summary>
        <returns><paramref name="task" /> 인수가 큐에서 제거되었는지 여부를 나타내는 부울입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 이 메서드는에서 실행할 수는 finally 블록; 따라서 반환할 최대한 신속 하 게 되므로 모든 리소스와 같은 <xref:System.Threading.CancellationTokenRegistration> 적시에서의 개체를 삭제할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> 인수가 null입니다.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">실행할 <see cref="T:System.Threading.Tasks.Task" /> 개체입니다.</param>
        <summary>이 스케줄러에 제공된 <see cref="T:System.Threading.Tasks.Task" />를 실행하려고 합니다.</summary>
        <returns><paramref name="task" />가 실행되었으면 true이고, 그렇지 않으면 false인 부울입니다. 실행이 실패하는 일반적인 이유는 작업이 이전에 실행되었거나 다른 스레드에서 실행 중이기 때문입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스케줄러 구현이 제공 됩니다 <xref:System.Threading.Tasks.Task> 인스턴스를 통해 실행 되는 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 메서드 또는 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> 메서드. 스케줄러가 제공 된 작업을 실행 하는 적절 한 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 이렇게 하려면 사용 해야 합니다. TryExecuteTask 작업 호출, 예외 처리, 상태 관리 및 수명 주기 컨트롤을 포함 하 여 작업을 실행 하는 모든 측면을 처리 합니다.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 이 스케줄러에는.NET Framework 인프라에서 제공 하는 작업에만 사용 해야 합니다. 사용자 지정 메커니즘을 통해 얻은 임의 작업을 실행 하는 사용 되지 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" />는 이 스케줄러와 연결되어 있지 않습니다.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">실행할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
        <param name="taskWasPreviouslyQueued">작업이 이전에 큐에 대기되었는지 여부를 나타내는 부울입니다. 이 매개 변수가 True이면 작업이 이전에 큐에 대기된 것일 수 있습니다. False이면 작업이 큐에 대기되지 않은 것입니다. 작업을 큐에 대기하지 않고 인라인으로 실행하려면 이 호출을 수행합니다.</param>
        <summary>제공된 <see cref="T:System.Threading.Tasks.Task" />를 이 호출에서 동기적으로 실행할 수 있는지 여부를 확인하고 실행 가능할 경우 실행합니다.</summary>
        <returns>작업이 인라인으로 실행되었는지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 된 클래스 <xref:System.Threading.Tasks.TaskScheduler> 해당 작업 개체에서 대기를 시작 하는 스레드는 태스크의 인라인 실행을 지원 하려면이 함수를 구현 합니다. 인라인 실행 선택 사항이 며 false를 반환 하 여 요청을 거부 될 수 있습니다. 그러나 더 많은 작업을 수행할 수 있는 인라인 될, 더 나은 스케줄러 확장 됩니다. 사실, 스케줄러는 인라인 너무 적게 수 있습니다. 교착 상태가 발생할 수. 있습니다 적절 한 구현은 scheduler에 의해 보장 하는 정책에서 실행 하는 요청이 인라인으로 포함할 수 있습니다 성공적으로 확인 해야 합니다. 예를 들어, 태스크를 실행 하는 전용된 스레드를 사용 하는 스케줄러를 해당 스레드에서 모든 인라인 처리 요청이 성공 해야 합니다.  
  
 스케줄러를 인라인 실행을 수행 하기로 한 경우 작업을 수행 해야 기본 TaskScheduler 호출 하 여 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 메서드 반환 값을 전파 제공 된 작업 개체를 사용 하 여 합니다. 인라인 처리 요청을 수용 하기로 결정 하는 경우는 내부 데이터 구조에서 인라인된 작업을 제거 하려면 스케줄러에 대 한 적절 한 수도 있습니다. 단는 상황에 따라 스케줄러를 묻는 메시지가 나타날 수 인라인을 사용 하 여 이전에 제공 되지 않았습니다 하는 작업은 <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> 메서드.  
  
 파생 된 스케줄러는 호출 스레드는 자체 일정에 지정된 된 작업 실행에 적합 하 고 실행 정책이 관련 되어 있는지 확인 해야 합니다.  
  
 자세한 내용은 <xref:System.Threading.Tasks.TaskScheduler>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> 인수가 null입니다.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" />가 이미 실행되었습니다.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>오류가 발생한 작업의 확인되지 않은 예외가 기본적으로 프로세스를 종료하는 예외 에스컬레이션 정책을 트리거하려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 응용 프로그램 도메인 전체 이벤트에서 트리거 (기본적으로 종료 하는 프로세스)는 예외 에스컬레이션 정책을 방지 하는 메커니즘을 제공 합니다.  
  
 개발자가 작업 기반 비동기 코드를 작성 하는 데 쉽게는 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 관찰 되지 않은 예외에 대 한 기본 예외 동작을 변경 합니다. 관찰 되지 않은 예외를 여전히 발생 하지만 <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> 예외를 기본적으로 프로세스는 종료 되지 않습니다. 대신, 이벤트 처리기에서 예외를 관찰 하는 여부에 관계 없이 이벤트가 발생 한 후 예외가 런타임에서 처리 됩니다. 이 동작을 구성할 수 있습니다. 부터 합니다 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]를 사용할 수는 [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) 의 동작으로 되돌리려면 구성 요소는 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 프로세스를 종료 하 고:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">TPL(작업 병렬 라이브러리)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; 요소</related>
      </Docs>
    </Member>
  </Members>
</Type>