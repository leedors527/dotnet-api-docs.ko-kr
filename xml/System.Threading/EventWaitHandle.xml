<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="736b05993c69add826b16620b79fa609ad8ac941" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48743361" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>스레드 동기화 이벤트를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle> 클래스를 사용 하면 스레드가 신호를 보내 서로 통신할 수 있습니다. 하나 이상의 스레드가 차단 되는 일반적으로 <xref:System.Threading.EventWaitHandle> 스레드를 차단 해제 호출 될 때까지 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 하나 이상의 차단 된 스레드를 해제 합니다. 스레드 되었음을 알릴 수는 <xref:System.Threading.EventWaitHandle> 를 호출 하 여 다음 차단 합니다 `static` (`Shared` Visual Basic의) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> 메서드.  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle> 클래스는 명명 된 시스템 동기화 이벤트에 대 한 액세스를 제공 합니다.  
  
 동작을 <xref:System.Threading.EventWaitHandle> 신호를 받은 다시 설정 모드에 따라 달라 집니다. <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그는 단일 대기 스레드를 해제 한 후 신호를 받을 때 자동으로 재설정 합니다. <xref:System.Threading.EventWaitHandle> 사용 하 여 만든 합니다 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그가 계속 될 때까지 신호를 받은 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출 됩니다.  
  
 자동 재설정 이벤트는 리소스에 대 한 단독 액세스를 제공합니다. 대기 중인 스레드가 없을 때 신호를 받은 자동 재설정 이벤트는 스레드가 이 이벤트에서 대기를 시도할 때까지 신호를 받은 것으로 유지됩니다. 이벤트는 스레드를 해제하고 즉시 다시 설정되어 후속 스레드를 차단합니다.  
  
 수동 재설정 이벤트는 출입문과 비슷합니다. 이벤트 신호를 받지 대기 중인 스레드가 차단 됩니다. 이벤트가 신호를 모든 대기 스레드가 해제 되 고, 이벤트 신호를 받은 상태로 유지 됩니다 하는 경우 (즉, 후속 대기를 차단 하지 않습니다) 될 때까지 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출 됩니다. 수동 재설정 이벤트는 하나의 스레드가 다른 스레드에서 진행 되기 전에 작업을 완료 해야 하는 경우에 유용 합니다.  
  
 <xref:System.Threading.EventWaitHandle> 개체를 사용 하 여 사용할 수는 `static`(`Shared` Visual basic에서) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 및 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 메서드.  
  
 스레드 동기화 메커니즘에 대 한 자세한 내용은 참조 하세요. [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드는 주 스레드가 차단 된 스레드가 신호를 보내고 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.  
  
 이 예제에서는 5 개의 스레드를 시작 하 고에서 차단 될 수 있습니다는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다. 다음 예제에서는 다른 5 개의 스레드가 큐를 사용 하 여 모든 릴리스 하는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">초기 상태를 신호 받음으로 설정하려면 <see langword="true" />를 사용하고 초기 상태를 신호 없음으로 설정하려면 <see langword="false" />를 사용합니다.</param>
        <param name="mode">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
        <summary>대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부와 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부를 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트의 초기 상태 신호를 이벤트에서 대기 하는 스레드가 차단 됩니다. 초기 상태를 신호를 받으면 하며 <xref:System.Threading.EventResetMode.ManualReset> 에 대 한 플래그가 지정 된 `mode`, 이벤트에서 대기 하는 스레드가 차단 되지 것입니다. 초기 상태를 신호를 받으면 및 `mode` 는 <xref:System.Threading.EventResetMode.AutoReset>이벤트에서 대기 하는 첫 번째 스레드가 릴리스됩니다 즉시 지나면 이벤트 다시 설정 되 고 후속 스레드를 차단 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드는 주 스레드가 차단 된 스레드가 신호를 보내고 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.  
  
 이 예제에서는 5 개의 스레드를 시작 하 고에서 차단 될 수 있습니다는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다. 다음 예제에서는 다른 5 개의 스레드가 큐를 사용 하 여 모든 릴리스 하는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <see langword="true" />이고, nonsignaled로 설정하려면 <see langword="false" />입니다.</param>
        <param name="mode">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
        <param name="name">시스템 차원 동기화 이벤트의 이름입니다.</param>
        <summary>이 호출의 결과로 만들어진 대기 핸들의 초기 상태를 신호 받음으로 설정할지 여부, 대기 핸들을 자동으로 다시 설정할지 수동으로 다시 설정할지 여부 및 시스템 동기화 이벤트의 이름을 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `name` 됩니다 `null` 이거나 빈 문자열인 경우 로컬 <xref:System.Threading.EventWaitHandle> 만들어집니다.  
  
 경우에 대해 지정 된 이름 사용 하 여 시스템 이벤트를 `name` 매개 변수가 이미는 `initialState` 매개 변수가 무시 됩니다.  
  
> [!IMPORTANT]
>  이 생성자를 사용 하 여 명명 된 시스템 이벤트를 지정 `false` 에 대 한 `initialState`합니다. 이 생성자는 명명된 된 이벤트의 상태에 대 한 어떠한가 정도 할 수 없습니다. 명명된 된 시스템 이벤트 만들어졌는지 여부를 확인할 수 없으므로 제공 합니다. 명명된 된 이벤트 만들어졌는지 여부를 확인 하려면 사용 합니다 <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> 생성자 또는 <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> 생성자입니다.  
  
 이벤트의 초기 상태 신호를 이벤트에서 대기 하는 스레드가 차단 됩니다. 초기 상태를 신호를 받으면 하며 <xref:System.Threading.EventResetMode.ManualReset> 에 대 한 플래그가 지정 된 `mode`, 이벤트에서 대기 하는 스레드가 차단 되지 것입니다. 초기 상태를 신호를 받으면 및 `mode` 는 <xref:System.Threading.EventResetMode.AutoReset>이벤트에서 대기 하는 첫 번째 스레드가 릴리스됩니다 즉시 지나면 이벤트 다시 설정 되 고 후속 스레드를 차단 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <see langword="true" />이고, nonsignaled로 설정하려면 <see langword="false" />입니다.</param>
        <param name="mode">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
        <param name="name">시스템 차원 동기화 이벤트의 이름입니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 이벤트가 만들어진 경우(즉, <c>이름</c>이 <see langword="null" />이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 이벤트가 만들어진 경우에는 <see langword="true" />가 포함되고, 지정한 명명된 시스템 이벤트가 이미 있는 경우에는 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>이 호출의 결과로 대기 핸들이 초기에 신호를 받는지 여부, 자동으로 재설정되는지 또는 수동으로 재설정되는지, 시스템 동기화 이벤트의 이름, 호출 후에 해당 값이 명명된 시스템 이벤트가 생성되었는지 여부를 나타내는 부울 변수를 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 대해 지정 된 이름 사용 하 여 시스템 이벤트를 `name` 매개 변수가 이미는 `initialState` 매개 변수가 무시 됩니다. 이 생성자를 호출한 후에 대 한 지정 된 변수에 값을 사용 합니다 `ref` 매개 변수 (`ByRef` Visual Basic의 매개 변수)`createdNew` 있는지 여부를 명명 된 시스템 이벤트가 이미 존재 했는지 또는 만들어졌는지를 확인 하려면.  
  
 이벤트의 초기 상태 신호를 이벤트에서 대기 하는 스레드가 차단 됩니다. 초기 상태를 신호를 받으면 하며 <xref:System.Threading.EventResetMode.ManualReset> 에 대 한 플래그가 지정 된 `mode`, 이벤트에서 대기 하는 스레드가 차단 되지 것입니다. 초기 상태를 신호를 받으면 및 `mode` 는 <xref:System.Threading.EventResetMode.AutoReset>이벤트에서 대기 하는 첫 번째 스레드가 릴리스됩니다 즉시 지나면 이벤트 다시 설정 되 고 후속 스레드를 차단 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">명명된 이벤트가 이 호출의 결과로 만들어지는 경우 초기 상태를 signaled로 설정하려면 <see langword="true" />이고, nonsignaled로 설정하려면 <see langword="false" />입니다.</param>
        <param name="mode">이벤트가 자동으로 다시 설정되는지 또는 수동으로 다시 설정되는지를 결정하는 <see cref="T:System.Threading.EventResetMode" /> 값 중 하나입니다.</param>
        <param name="name">시스템 차원 동기화 이벤트의 이름입니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 이벤트가 만들어진 경우(즉, <c>이름</c>이 <see langword="null" />이거나 빈 문자열인 경우) 또는 지정한 명명된 시스템 이벤트가 만들어진 경우에는 <see langword="true" />가 포함되고, 지정한 명명된 시스템 이벤트가 이미 있는 경우에는 <see langword="false" />가 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <param name="eventSecurity">명명된 시스템 이벤트에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 개체입니다.</param>
        <summary>이 호출의 결과로 대기 핸들이 초기에 신호를 받는지 여부, 자동으로 재설정되는지 또는 수동으로 재설정되는지, 시스템 동기화 이벤트의 이름, 호출 후에 해당 값이 명명된 시스템 이벤트가 생성되었는지 여부를 나타내는 부울 변수, 생성되는 경우 명명된 이벤트에 적용될 액세스 제어 보안을 지정하여 <see cref="T:System.Threading.EventWaitHandle" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여 인해 다른 코드에서 이벤트의 제어권을 만들 때 명명 된 시스템 이벤트에 대 한 액세스 제어 보안을 적용 합니다.  
  
 이 생성자는 <xref:System.Threading.EventWaitHandle> 시스템 이벤트를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.EventWaitHandle> 같은 시스템 이벤트를 나타내는 개체입니다.  
  
 시스템 이벤트 존재 하지 않는 경우 지정 된 액세스 제어 보안을 사용 하 여 생성 됩니다. 이벤트가 있으면 지정한 액세스 제어 보안 무시 됩니다.  
  
> [!NOTE]
>  호출자에 게 완전히 제어할 새로 만든된 <xref:System.Threading.EventWaitHandle> 경우에도 개체 `eventSecurity` 거부 하거나 현재 사용자에 게 일부 액세스 권한을 부여 하지 못했습니다. 그러나 현재 사용자가 다른 <xref:System.Threading.EventWaitHandle> 개체를 나타내는 동일한 명명 된 이벤트를 사용 하 여 생성자 또는 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 메서드를 Windows 액세스 제어 보안이 적용 됩니다.  
  
 경우에 대해 지정 된 이름 사용 하 여 시스템 이벤트를 `name` 매개 변수가 이미는 `initialState` 매개 변수가 무시 됩니다. 이 생성자를 호출한 후에 대 한 지정 된 변수에 값을 사용 합니다 `ref` 매개 변수 (`ByRef` Visual Basic의 매개 변수) `createdNew` 있는지 여부를 명명 된 시스템 이벤트가 이미 존재 했는지 또는 만들어졌는지를 확인 하려면.  
  
 이벤트의 초기 상태 신호를 이벤트에서 대기 하는 스레드가 차단 됩니다. 초기 상태를 신호를 받으면 하며 <xref:System.Threading.EventResetMode.ManualReset> 에 대 한 플래그가 지정 된 `mode`, 이벤트에서 대기 하는 스레드가 차단 되지 것입니다. 초기 상태를 신호를 받으면 및 `mode` 는 <xref:System.Threading.EventResetMode.AutoReset>이벤트에서 대기 하는 첫 번째 스레드가 릴리스됩니다 즉시 지나면 이벤트 다시 설정 되 고 후속 스레드를 차단 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명된 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 메서드 오버 로드를 명명된 된 이벤트의 존재 여부를 테스트 합니다.  
  
 이벤트가 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 읽기 및 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 이벤트를 대기할 메서드 오버 로드 합니다.  
  
 권한이 변경 된 후 이벤트에서 대기 및 신호를 보내는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 이벤트를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 개체로 표시되는 명명된 시스템 이벤트에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Threading.EventWaitHandle" /> 개체를 가져옵니다.</summary>
        <returns>명명된 시스템 이벤트에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> 메서드는 다음과 같은 조합을 플래그 (비트 OR 연산을 사용 하 여 결합)를 사용 하 여 사용 권한을 검색할: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다.  
  
 사용자에 게 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> 이 메서드를 호출 하는 이벤트에 대 한 권한을 사용 하 여 열려 있어야 합니다 <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> 플래그입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명된 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 메서드 오버 로드를 명명된 된 이벤트의 존재 여부를 테스트 합니다.  
  
 이벤트가 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 읽기 및 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 이벤트를 대기할 메서드 오버 로드 합니다.  
  
 사용 권한을 읽은 후를 사용 하는 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> 메서드를 변경 이벤트에서 대기 및 신호를 보내는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.Threading.EventWaitHandle" /> 개체가 명명된 시스템 이벤트를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />가 없는 경우  
  
또는 
현재 <see cref="T:System.Threading.EventWaitHandle" /> 개체가 명명된 시스템 이벤트를 나타내지만 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />로 열리지 않는 경우</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이미 있는 경우 지정한 명명된 동기화 이벤트를 엽니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 동기화 이벤트의 이름입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 동기화 이벤트를 엽니다.</summary>
        <returns>명명된 시스템 이벤트를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 메서드는 지정 된 명명 된 시스템 이벤트를 열려고 합니다. 시스템 이벤트 존재 하지 않는 경우이 메서드는 시스템 이벤트를 만드는 대신 예외가 throw 됩니다. 아직 존재 하지 않는 경우 시스템 이벤트를 만들려면 중 하나를 사용 합니다 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.EventWaitHandle> 개체를 반환 하는 개체가 동일한 명명 된 시스템 이벤트를 나타내는 경우에 합니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.  
  
 지정는 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 플래그를 명명 된 시스템 이벤트를 대기할 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다를 <xref:System.Threading.EventWaitHandle.Set%2A> 및 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명된 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 메서드 오버 로드를 명명된 된 이벤트의 존재 여부를 테스트 합니다.  
  
 이벤트가 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 읽기 및 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 이벤트를 대기할 메서드 오버 로드 합니다.  
  
 권한이 변경 된 후 이벤트에서 대기 및 신호를 보내는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 시스템 이벤트가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 있지만 사용자에게 이 이벤트를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 동기화 이벤트의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 동기화 이벤트를 원하는 보안 액세스로 엽니다.</summary>
        <returns>명명된 시스템 이벤트를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 이벤트를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.EventWaitHandle.Set%2A> 및 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드.  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A> 메서드는 기존 명명 된 시스템 이벤트를 열려고 합니다. 시스템 이벤트 존재 하지 않는 경우이 메서드는 시스템 이벤트를 만드는 대신 예외가 throw 됩니다. 아직 존재 하지 않는 경우 시스템 이벤트를 만들려면 중 하나를 사용 합니다 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.EventWaitHandle> 개체를 반환 하는 개체가 동일한 명명 된 시스템 이벤트를 나타내는 경우에 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명된 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 메서드 오버 로드를 명명된 된 이벤트의 존재 여부를 테스트 합니다.  
  
 이벤트가 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 읽기 및 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 이벤트를 대기할 메서드 오버 로드 합니다.  
  
 권한이 변경 된 후 이벤트에서 대기 및 신호를 보내는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 시스템 이벤트가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이벤트 상태를 신호 없음으로 설정하여 스레드가 차단되도록 합니다.</summary>
        <returns>작업이 성공적으로 수행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>하나 이상의 대기 중인 스레드를 진행할 수 있도록 이벤트 상태를 신호 받음으로 설정합니다.</summary>
        <returns>작업이 성공적으로 수행되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한는 <xref:System.Threading.EventWaitHandle> 사용 하 여 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (등 <xref:System.Threading.AutoResetEvent>), <xref:System.Threading.EventWaitHandle.Set%2A> 메서드는 단일 스레드를 해제 합니다. 스레드, 또는 될 때까지 대기를 시도할 때까지 대기 핸들이 신호를 받은 남아 대기 중인 스레드가 없는 경우 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드가 호출 됩니다.  
  
> [!IMPORTANT]
>  보장은 없습니다는를 호출할 때마다 합니다 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드에서 스레드를 해제 합니다는 <xref:System.Threading.EventWaitHandle> 인 재설정 모드가 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>합니다. 두 번의 호출은 너무 가까이 함께 두 번째 호출 스레드가 해제 되기 전에 발생 하는, 하나의 스레드만 해제 됩니다. 것 처럼 두 번째 호출 발생 하지 않았습니다. 또한 경우 <xref:System.Threading.EventWaitHandle.Set%2A> 대기 중인 스레드가 없는 경우 라고 하며 <xref:System.Threading.EventWaitHandle> 이 이미 신호를 받고 호출에 영향을 주지 않습니다.  
  
 에 대 한는 <xref:System.Threading.EventWaitHandle> 사용 하 여 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (포함 <xref:System.Threading.ManualResetEvent>)를 호출 합니다 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드 유지 될 때까지 신호를 받은 상태 대기 핸들 해당 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드는 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> 메서드 오버 로드는 주 스레드가 차단 된 스레드가 신호를 보내고 스레드가 작업을 완료할 때까지 대기할 수 있도록 합니다.  
  
 이 예제에서는 5 개의 스레드를 시작 하 고에서 차단 될 수 있습니다는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> 플래그를 다음 릴리스에서 사용자가 ENTER 키를 누를 때마다 스레드를 하나씩 있습니다. 다음 예제에서는 다른 5 개의 스레드가 큐를 사용 하 여 모든 릴리스 하는 <xref:System.Threading.EventWaitHandle> 사용 하 여 만든는 <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> 플래그입니다.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">명명된 시스템 이벤트에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 개체입니다.</param>
        <summary>명명된 시스템 이벤트에 대해 액세스 제어 보안을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자에 게 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> 이 메서드를 호출 하는 이벤트에 대 한 권한을 사용 하 여 열려 있어야 합니다 <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> 플래그입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명된 된 시스템 이벤트의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용은 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 메서드 오버 로드를 명명된 된 이벤트의 존재 여부를 테스트 합니다.  
  
 이벤트가 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 이벤트를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽기 및 변경 이벤트에 대 한 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 읽기 및 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 이벤트를 대기할 메서드 오버 로드 합니다.  
  
 사용 권한을 사용 하 여 변경 된 후의 <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> 메서드를 이벤트에서 대기 및 신호를 보내는 데 필요한 권한으로 열립니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우이 예제에서는 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">사용자에게 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />가 없는 경우  
  
또는 
이벤트가 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />로 열리지 않은 경우</exception>
        <exception cref="T:System.SystemException">현재 <see cref="T:System.Threading.EventWaitHandle" /> 개체가 명명된 시스템 이벤트를 나타내지 않는 경우</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.Threading.WaitHandle.Close" /> 메서드가 이 <see cref="T:System.Threading.EventWaitHandle" />에 대해 이전에 호출된 경우</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent 및 ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 명명된 synchronization 이벤트(이미 존재하는 경우)를 열고 작업이 성공적으로 수행되었는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 동기화 이벤트의 이름입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 동기화 이벤트를 나타내는 <see cref="T:System.Threading.EventWaitHandle" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정한 명명된 동기화 이벤트(이미 존재하는 경우)를 열고 작업이 성공했는지를 나타내는 값을 반환합니다.</summary>
        <returns>명명된 동기화 이벤트를 열었으면 <see langword="true" />이고, 열지 않았으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명된 된 동기화 이벤트 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다. 아직 존재 하지 않는 경우 시스템 이벤트를 만들려면 중 하나를 사용 합니다 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 명명 된 동기화 이벤트 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> 동기화 이벤트가 없는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다. 지정는 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 플래그를 명명 된 시스템 이벤트를 대기할 스레드를 사용 하 고 지정 하는 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다를 <xref:System.Threading.EventWaitHandle.Set%2A> 및 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.EventWaitHandle> 개체를 반환 하는 개체가 동일한 명명 된 시스템 이벤트를 나타내는 경우에 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 동기화 이벤트의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출에 성공한 경우에는 명명된 동기화 이벤트를 나타내는 <see cref="T:System.Threading.EventWaitHandle" /> 개체를 포함하고 호출에 실패한 경우에는 <see langword="null" />을 포함합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정한 명명된 동기화 이벤트(이미 존재하는 경우)를 원하는 보안 액세스로 열고 작업이 성공적으로 수행되었는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>명명된 동기화 이벤트를 열었으면 <see langword="true" />이고, 열지 않았으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명된 된 동기화 이벤트 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다. 아직 존재 하지 않는 경우 시스템 이벤트를 만들려면 중 하나를 사용 합니다 <xref:System.Threading.EventWaitHandle.%23ctor%2A> 있는 생성자는 `name` 매개 변수입니다.  
  
 명명 된 동기화 이벤트 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> 동기화 이벤트가 없는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 합니다 `rights` 매개 변수를 포함 해야 합니다는 <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> 이벤트를 대기 하는 스레드를 허용 하도록 플래그 및 <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.EventWaitHandle.Set%2A> 및 <xref:System.Threading.EventWaitHandle.Reset%2A> 메서드.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.EventWaitHandle> 개체를 반환 하는 개체가 동일한 명명 된 시스템 이벤트를 나타내는 경우에 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 이벤트가 존재하지만 사용자에게 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>