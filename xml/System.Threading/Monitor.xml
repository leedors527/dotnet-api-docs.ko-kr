<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e925d576d52267c0e301b6428f677609e99940d3" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230743" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>개체에 대한 액세스를 동기화하는 메커니즘을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Threading.Monitor> 클래스를 사용 하면 가져오고 호출 하 여 특정 개체에 대 한 잠금을 해제 하 여 코드의 영역에 대 한 액세스를 동기화 할 수는 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, 및 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드. 개체 잠금 일반적으로 중요 섹션을 라고 하는 코드의 블록에 대 한 액세스를 제한 하는 기능을 제공 합니다. 스레드 개체에 대 한 잠금의 소유 하는 동안 다른 스레드가 잠금을 획득할 수 있습니다. 사용할 수도 있습니다는 <xref:System.Threading.Monitor> 다른 스레드가 응용 프로그램의 섹션에 액세스할 수 있는지 확인 하는 클래스 잠금 소유자에 의해 실행 되 고 다른 스레드가 잠겨 있는 다른 개체를 사용 하는 코드를 실행 중인 경우가 아니면 코드입니다.  
  
 이 문서의 내용  
  
 [Monitor 클래스: 개요](#Overview)   
 [잠금 개체](#Lock)   
 [중요 섹션](#CriticalSection)   
 [Pulse, PulseAll, 및 대기](#Pulse)   
 [모니터 및 대기 핸들](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor 클래스: 개요  
 <xref:System.Threading.Monitor> 에 다음 기능이 있습니다.  
  
-   필요에 따라 개체를 사용 하 여 연결 됩니다.  
  
-   바인딩 해제 되어 있으므로 모든 컨텍스트에서 직접 호출할 수 있습니다.  
  
-   인스턴스를 <xref:System.Threading.Monitor> 클래스를 만들 수 없습니다;의 메서드는 <xref:System.Threading.Monitor> 클래스는 모두 정적입니다. 각 메서드를 액세스를 제어 하는 동기화 개체를 전달 하는 중요 섹션에 있습니다.  
  
> [!NOTE]
>  사용 하 여는 <xref:System.Threading.Monitor> 문자열 이외의 잠금 개체 클래스 (참조 이므로 이외의 형식 <xref:System.String>), 값 형식이 없습니다. 자세한 내용은의 오버 로드를 참조 합니다 <xref:System.Threading.Monitor.Enter%2A> 메서드 및 [잠금 개체](#Lock) 이 문서의 뒷부분에 나오는 섹션입니다.  
  
 다음 표에서 동기화 된 개체에 액세스 하는 스레드에서 수행할 수 있는 작업을 보여 줍니다.  
  
|작업|설명|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|개체에 대 한 잠금을 획득합니다. 중요 섹션의 시작 부분을 표시합니다. 잠겨 있는 다른 개체를 사용 하 여 임계 영역에 있는 지침을 실행 하는 경우가 아니면 다른 스레드가 중요 섹션을 입력할 수 있습니다.|  
|<xref:System.Threading.Monitor.Wait%2A>|다른 스레드가 잠금 개체에 액세스를 허용 하기 위해 개체에 대 한 잠금을 해제 합니다. 호출 스레드가 다른 스레드가 개체에 액세스 하는 동안 대기 합니다. Pulse 신호 개체의 상태 변경에 대 한 대기 중인 스레드를 알리는 데 사용 됩니다.|  
|<xref:System.Threading.Monitor.Pulse%2A> (신호) <xref:System.Threading.Monitor.PulseAll%2A>|하나 이상의 대기 스레드는 신호를 보냅니다. 신호 잠긴된 개체의 상태 변경 대기 스레드를 알리고 잠금 소유자가 잠금을 해제 하는 준비 합니다. 개체에 대 한 잠금을 받을 수 있도록 대기 중인 스레드 개체의 준비 된 큐에 배치 됩니다. 스레드가 잠금에 되 면 필요한 상태에 도달한 경우 참조 개체의 새 상태를 확인해 합니다.|  
|<xref:System.Threading.Monitor.Exit%2A>|개체에 대 한 잠금을 해제합니다. 잠긴된 개체에 의해 보호 되는 중요 섹션의 끝을 표시 합니다.|  
  
 부터는 합니다 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]를 오버 로드에 대 한 두 가지를 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.TryEnter%2A> 메서드. 오버 로드 중 하나의 집합에는 `ref` (C#에서) 또는 `ByRef` (Visual Basic)에서는 <xref:System.Boolean> 원자적으로 설정 된 매개 변수 `true` 경우 잠금을 획득, 잠금을 획득할 때 예외가 발생 하는 경우에 합니다. 잠금을 해제 하는 모든 경우에 일관 된 상태로 리소스 잠금을 보호 하지 않을 경우에 중요 한 경우 이러한 오버 로드를 사용 합니다.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>잠금 개체  
 Monitor 클래스 이루어져 `static` (C#에서) 또는 `Shared` (Visual Basic)에서는 중요 섹션에 액세스를 제어 하는 개체에 대해 작동 하는 메서드.  다음 정보를 동기화 된 각 개체는 유지 됩니다.  
  
-   현재 잠금을 보유 하는 스레드에 대 한 참조입니다.  
  
-   잠금을 획득할 수 있는 스레드가 포함 된 준비 큐에 대 한 참조입니다.  
  
-   잠긴된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 하는 대기 중인 큐에 대 한 참조입니다.  
  
 <xref:System.Threading.Monitor>는 값 형식이 아니라 개체(즉, 참조 형식)를 잠급니다. <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A>에 값 형식을 전달할 수 있지만 각 호출에 대해 개별적으로 boxing됩니다. 호출마다 별도 개체를 만들기 때문에 <xref:System.Threading.Monitor.Enter%2A>가 차단되지 않으며, 보호하는 코드가 동기화되지 않습니다. 또한 <xref:System.Threading.Monitor.Exit%2A>에 전달되는 개체는 <xref:System.Threading.Monitor.Enter%2A>에 전달되는 개체와 다르므로 <xref:System.Threading.Monitor>에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생하고 "비동기화된 코드 블록에서 개체 동기화 메서드를 호출했습니다." 메시지가 표시됩니다.  
  
 다음 예제에서는 이 문제를 보여 줍니다. 각각 250밀리초 동안 대기하는 10개 작업을 시작합니다. 각 작업은 실제로 시작 및 실행된 작업 수를 계산하기 위한 카운터 변수 `nTasks`를 업데이트합니다. `nTasks`는 동시에 여러 작업에서 업데이트될 수 있는 전역 변수이기 때문에 모니터를 사용하여 여러 작업에서 동시에 수정되지 않도록 보호합니다. 그러나 예제의 출력과 같이 각 작업에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생합니다.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 각 작업의 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 메서드 호출 전에 `nTasks` 변수가 boxing되므로 각 작업에서 <xref:System.Threading.SynchronizationLockException> 예외가 발생합니다. 즉, 각 메서드 호출에 서로 독립적인 개별 변수가 전달됩니다. `nTasks`는 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 메서드 호출에서 다시 boxing됩니다. 이렇게 하면 다시 서로 독립적인 새 boxed 변수 10개, `nTasks` 및 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 메서드 호출에서 생성되는 boxed 변수 10개가 생성됩니다. 코드에서 이전에 잠기지 않은 새로 만든 변수에 대한 잠금을 해제하려고 하기 때문에 예외가 발생합니다.  
  
 다음 예제와 같이 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A>를 호출하기 전에 값 형식 변수를 boxing하고 boxing된 동일한 개체를 두 메서드에 모두 전달할 수 있지만 아무 이점이 없습니다. boxing되지 않은 변수의 변경 내용은 boxing된 복사본에 반영되지 않으며, boxing된 복사본의 값을 변경할 수 없습니다.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 동기화 할 개체를 선택할 때 전용 또는 내부 개체에 대해서만 잠가야 합니다. 외부 개체에 대 한 잠금을 관련 되지 않은 코드에서 다양 한 용도로 잠그지 동일한 개체를 선택할 수 있으므로 교착 상태 될 수 있습니다.  
  
 잠금에 사용 되는 개체에서 파생 되는 경우 여러 응용 프로그램 도메인의 개체에 동기화 할 수 있는 참고 <xref:System.MarshalByRefObject>합니다.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>중요 섹션  
 사용 된 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 임계 영역 시작과 끝을 표시 하는 방법입니다.  
  
> [!NOTE]
>  제공 하는 기능을 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 메서드는 제공 하는 동일 합니다 [잠금](~/docs/csharp/language-reference/keywords/lock-statement.md) C#의 문은 및 [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) Visual basic의 경우는 제외 하 고 문을 언어 구문이 도입 되면서 줄 바꿈 합니다 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> 메서드 오버 로드 하며 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 에서 메서드를 `try`...`finally` 블록 모니터가 해제 되도록입니다.  
  
 중요 섹션을 사용 하면 연속 지침으로 획득 된 잠금이의 집합인 경우는 <xref:System.Threading.Monitor.Enter%2A> 메서드를 사용 하면 단일 스레드만 잠겨 있는 개체를 사용 하 여 포함된 된 코드를 실행할 수 있습니다. 해당 코드를 배치 하는 권장이 예제의 경우를 `try` 블록과에 대 한 호출을 배치 합니다 <xref:System.Threading.Monitor.Exit%2A> 에서 메서드를 `finally` 블록. 이렇게 하면 예외가 발생해도 잠금이 해제됩니다. 다음 코드 조각에서는이 패턴을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 이 기능은 정적에 대 한 액세스 또는 클래스의 인스턴스 메서드를 동기화 하려면 일반적으로 사용 됩니다.  
  
 잠금 기능 임계 메서드 전체에 걸쳐 있는 경우 배치 하 여 수행할 수 있습니다는 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> 메서드를 지정 하는 <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> 값의 생성자에서 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>합니다. 이 특성을 사용 하는 경우는 <xref:System.Threading.Monitor.Enter%2A> 고 <xref:System.Threading.Monitor.Exit%2A> 메서드 호출은 필요 하지 않습니다. 다음 코드 조각에서는이 패턴을 보여 줍니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 현재 스레드를; 메서드는 반환 될 때까지 백그라운드에서 특성으로 인해 참고 잠금을 빨리 해제할 수를 사용 하 여는 <xref:System.Threading.Monitor> 클래스를 C# [잠금](~/docs/csharp/language-reference/keywords/lock-statement.md) 문 또는 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) 특성 대신 메서드 내에서 문.  
  
 에 대 한 수 있지만 합니다 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 잠그고 멤버 또는 클래스 경계를 교차 하는 지정 된 개체를 해제 하는 문,이 방법은 권장 되지 않습니다.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse, PulseAll, 및 대기  
 호출할 수 있는 스레드가 잠금을 소유 하 고 잠금이 보호 하는 중요 섹션 않았으면 합니다 <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, 및 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 메서드.  
  
 경우 스레드가 보유 하는 잠금 호출 <xref:System.Threading.Monitor.Wait%2A>잠금이 해제 되 고 스레드가 동기화 개체의 대기 큐에 추가 됩니다. 첫 번째 스레드가 준비 큐에 있는 경우 잠금을 획득 하 고 중요 섹션에 진입 합니다. 스레드가 준비 큐에 대기 중인 큐에서 이동는 경우 중 하나를 <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (이동할 스레드 여야 함 대기 중인 큐의 헤드에) 또는 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 메서드는 잠금을 보유 한 스레드에 의해 호출 됩니다. <xref:System.Threading.Monitor.Wait%2A> 호출 스레드 잠금을 다시 가져오면 메서드를 반환 합니다.  
  
 경우 스레드가 보유 하는 잠금 호출 <xref:System.Threading.Monitor.Pulse%2A>, 대기 중인 큐의 헤드에 스레드가 준비 큐로 이동 됩니다. 에 대 한 호출을 <xref:System.Threading.Monitor.PulseAll%2A> 메서드 대기 큐에서 모든 스레드가 준비 큐로 이동 합니다.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>모니터 및 대기 핸들  
 사용 간의 차이점을 확인 해야 합니다 <xref:System.Threading.Monitor> 클래스 및 <xref:System.Threading.WaitHandle> 개체입니다.  
  
-   <xref:System.Threading.Monitor> 클래스는 순수 하 게 관리 되는, 완전히 이식 가능한 클래스 이며 운영 체제 리소스 요구 사항 측면에서 더 효율적일 수 있습니다.  
  
-   <xref:System.Threading.WaitHandle> 개체는 운영 체제 대기 가능 개체를 나타내며, 관리 코드와 비관리 코드 간의 동기화에 유용하고, 동시에 많은 개체를 처리하는 기능과 같은 일부 고급 운영 체제 기능을 노출합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Threading.Monitor> 나타내는 난수 생성기의 단일 인스턴스에 대 한 액세스를 동기화 하는 클래스는 <xref:System.Random> 클래스입니다. 이 예제에서는 10 개 작업을 스레드 풀 스레드에서 비동기적으로 실행 하는 각를 만듭니다. 각 작업 10,000 난수 생성, 해당 평균을 계산 및 난수 생성 수 총 합계 및 합계를 유지 관리 하는 두 개의 프로시저 수준 변수를 업데이트 합니다. 모든 작업이 실행 된 후 전체 평균을 계산할 두 값이 사용 됩니다.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 스레드 풀 스레드에서 실행 중인 모든 태스크에서 액세스할 수 있습니다, 변수에 액세스할 `total` 고 `n` 도 동기화 되어야 합니다. <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> 메서드는이 용도로 사용 됩니다.  
  
 다음 예제에서는 함께 사용 하는 방법을 보여 줍니다는 <xref:System.Threading.Monitor> 클래스 (사용 하 여 구현 합니다 `lock` 또는 `SyncLock` 언어 구문), <xref:System.Threading.Interlocked> 클래스 및 <xref:System.Threading.AutoResetEvent> 클래스. 이 예제에서는 두 개의 `internal`(C#) 또는 `Friend`(Visual Basic) 클래스인 `SyncResource`와 `UnSyncResource`를 정의하며 각각 리소스에 대해 동기화되거나 동기화되지 않은 액세스를 제공합니다. 예제에서 동기화된 액세스와 동기화되지 않은 액세스(각 메서드 호출이 신속히 완료되는 경우일 수 있음) 간의 차이를 나타내도록 하기 위해 메서드에 임의 지연이 포함되어 있습니다. <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 속성이 짝수인 스레드에 대해, 메서드는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>를 호출하여 2,000밀리초의 지연을 사용합니다. `SyncResource` 클래스는 공용이 아니기 때문에 동기화된 리소스에서 잠금을 가져오는 클라이언트 코드는 없습니다. 내부 클래스가 자체적으로 잠금을 가져옵니다. 이를 통해 악성 코드가 공용 개체에서 잠금을 가져오는 것을 방지할 수 있습니다.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 이 예제에서는 `numOps` 변수를 정의하여 리소스에 액세스를 시도할 스레드 수를 정의합니다. 응용 프로그램 스레드는 동기화된 액세스와 동기화되지 않은 액세스에 대해 각각 5번씩 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 메서드를 호출합니다. <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 메서드는 어떠한 매개 변수도 받아들이지 않고 어떠한 값도 반환하지 않는 대리자인 단일 매개 변수가 있습니다. 이 매개 변수는 동기화된 액세스에 대해서는 `SyncUpdateResource` 메서드를 호출하고, 동기화되지 않은 액세스에 대해서는 `UnSyncUpdateResource` 메서드를 호출합니다. 호출 응용 프로그램 스레드가 각 일련의 메서드 호출 후는 [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) 될 때까지 차단 한다는 메서드는 <xref:System.Threading.AutoResetEvent> 인스턴스가 신호입니다.  
  
 `SyncUpdateResource` 메서드에 대한 각 호출은 내부 `SyncResource.Access` 메서드를 호출한 다음 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 메서드를 호출하여 `numOps` 카운터를 감소시킵니다. <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 메서드를 사용 하는 카운터를 감소, 그렇지 않으면 있습니다 수 없기 때문에 두 번째 스레드가 해당 값에 액세스 첫 번째 스레드의 감소 되기 전에 특정 값 변수에 저장 된 된 합니다. 마지막 카운터를 0 작업자 스레드 감소를 동기화 하는 경우 동기화 된 모든 스레드가 나타내는 완료 리소스 액세스는 `SyncUpdateResource` 메서드 호출을 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 주 스레드가 계속 알리는 메서드 실행 합니다.  
  
 `UnSyncUpdateResource` 메서드에 대한 각 호출은 내부 `UnSyncResource.Access` 메서드를 호출한 다음 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 메서드를 호출하여 `numOps` 카운터를 감소시킵니다. 이번에 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 메서드 두 번째 스레드가 변수에 첫 번째 스레드의 감소 된 값이 할당 되기 전에 값을 액세스 하지 않습니다 확인 하는 카운터를 감소를 사용 합니다. 마지막으로 동기화 작업자 스레드의 감소 된 카운터를 0, 리소스에 액세스 하는 데 필요한 동기화 되지 않은 스레드가 더 이상 있는지를 나타내는 합니다 `UnSyncUpdateResource` 메서드 호출을 <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> 메서드 main 메서드가 실행을 계속 하도록 신호를 보냅니다 .  
  
 예제의 출력에 나타난 것처럼, 동기화된 액세스는 호출한 스레드가 보호된 리소스를 종료한 다음 다른 스레드가 액세스할 수 있도록 하기 때문에 각 스레드는 선행 작업에서 대기합니다. 반면에 잠금 없이 `UnSyncResource.Access` 메서드는 스레드가 도달하는 순서로 호출됩니다.  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">스레딩 개체 및 기능</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 단독 잠금을 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">모니터 잠금을 가져올 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `Enter` 얻으려고 합니다 <xref:System.Threading.Monitor> 매개 변수로 전달 된 개체입니다. 다른 스레드가 실행 하는 경우는 `Enter` 개체에 해당 아직 실행 되지 않았으면 있지만 <xref:System.Threading.Monitor.Exit%2A>, 현재 스레드가 다른 스레드에서 개체를 해제할 때까지 차단 됩니다. 동일한 스레드에서 호출을 유효 `Enter` 차단 하지 않고 두 번 이상 하지만 동일한 수의 `Exit` 호출 전에 개체에서 대기 중인 다른 스레드를 차단 해제 호출 해야 합니다.  
  
 사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 값 형식 변수를 전달 하는 경우 `Enter`, 개체로 boxed 형식이 됩니다. 같은 변수를 전달 하는 경우 `Enter` 다시는 별도 개체로 boxed 및 스레드를 차단 하지 않습니다. 이 경우 코드는 `Monitor` 은 보호 중인 보호 되지 않습니다. 또한 변수를 전달할 때 `Exit`, 별도 또 다른 개체가 만들어집니다. 에 전달 된 개체가 `Exit` 전달 된 개체와에서 다르면 `Enter`, `Monitor` throw <xref:System.Threading.SynchronizationLockException>합니다. 자세한 내용은 해당 개념 항목을 참조 하세요 [모니터](xref:System.Threading.Monitor)합니다.  
  
 <xref:System.Threading.Thread.Interrupt%2A> 입력 대기 중인 스레드를 중단할 수는 `Monitor` 개체에 있습니다. <xref:System.Threading.ThreadInterruptedException> throw 됩니다.  
  
 C#을 사용 하 여 `try`...`finally` 블록 (`Try`...`Finally` Visual Basic)를 모니터를 해제 하거나 사용 하 여 C# `lock` 문 (`SyncLock` Visual Basic의 문)를 래핑하고 합니다 <xref:System.Threading.Monitor.Enter%2A> 및 <xref:System.Threading.Monitor.Exit%2A> 에서 메서드를 `try`...`finally` 블록입니다.  
  
   
  
## Examples  
 다음 예제에서는 `Enter` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.  
  
예외가 발생하지 않는 경우 이 메서드의 출력은 항상 <see langword="true" />입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 `Enter` 가져오려고 합니다 <xref:System.Threading.Monitor> 로 전달 된 개체는 `obj` 매개 변수입니다. 다른 스레드가 실행 하는 경우는 `Enter` 개체에 해당 아직 실행 되지 않았으면 있지만 <xref:System.Threading.Monitor.Exit%2A>, 현재 스레드가 다른 스레드에서 개체를 해제할 때까지 차단 됩니다. 동일한 스레드에서 호출을 유효 `Enter` 차단 하지 않고 두 번 이상 하지만 동일한 수의 `Exit` 호출 전에 개체에서 대기 중인 다른 스레드를 차단 해제 호출 해야 합니다.  
  
 에 대 한 지정 된 잠금이 된 그렇지 않은 경우 예외가 throw 되었기 때문에 변수를 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램입니다. 이 메서드는 예외를 throw 하지 않고 반환 하는 경우에 대 한 지정 된 변수를 `lockTaken` 매개 변수는 항상 `true`, 및 테스트할 필요가 없습니다.  
  
 사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 값 형식 변수를 전달 하는 경우 `Enter`, 개체로 boxed 형식이 됩니다. 같은 변수를 전달 하는 경우 `Enter` 다시는 별도 개체로 boxed 및 스레드를 차단 하지 않습니다. 이 경우 코드는 `Monitor` 은 보호 중인 보호 되지 않습니다. 또한 변수를 전달할 때 `Exit`, 별도 다른 개체가 만들어집니다. 에 전달 된 개체가 `Exit` 전달 된 개체와에서 다르면 `Enter`, `Monitor` throw <xref:System.Threading.SynchronizationLockException>합니다. 자세한 내용은 해당 개념 항목을 참조 하세요 [모니터](xref:System.Threading.Monitor)합니다.  
  
 <xref:System.Threading.Thread.Interrupt%2A> 입력 대기 중인 스레드를 중단할 수는 `Monitor` 개체에 있습니다. <xref:System.Threading.ThreadInterruptedException> throw 됩니다.  
  
   
  
## Examples  
 다음 코드를 사용 하기 위한 기본 패턴을 보여 줍니다.는 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드는 항상에 전달 되는 변수의 값을 설정 합니다 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드 변수 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 해제 합니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 해제할 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 스레드가에서 잠금을 소유 해야 합니다 `obj` 매개 변수입니다. 호출 스레드가 지정된 된 개체 잠금을 소유 하 고 동일한 수의 시켰습니다 경우 `Exit` 고 <xref:System.Threading.Monitor.Enter%2A> 잠금이 해제 되는 개체에 대 한 호출 합니다. 호출 스레드에서 호출 하지 않으면 `Exit` 횟수 만큼 `Enter`, 잠금이 해제 되지 않습니다.  
  
 잠금이 해제 되 고 다른 스레드가 개체에 대 한 준비 큐에서 스레드 중 하나가 잠금을 획득 합니다. 다른 스레드가 잠금을 획득 하려고 대기 하 고 대기 중인 큐에 있는 경우는 이동 하지는 자동으로 준비 된 큐로 잠금의 소유자를 호출할 때 `Exit`합니다. 하나 이상의 대기 중인 스레드가 준비 큐를 이동 하려면 호출 <xref:System.Threading.Monitor.Pulse%2A> 나 <xref:System.Threading.Monitor.PulseAll%2A> 를 호출 하기 전에 `Exit`입니다.  
  
   
  
## Examples  
 다음 예제에서는 `Exit` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">현재 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">테스트할 개체입니다.</param>
        <summary>현재 스레드에 지정된 개체에 대한 잠금이 있는지 여부를 확인합니다.</summary>
        <returns>현재 스레드에 <paramref name="obj" />에 대한 잠금이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 방법은의 메서드를 사용 하 여 획득 된 잠금에만 작동 합니다 <xref:System.Threading.Monitor> 클래스를 사용 하거나 사용 하 여 C# `lock` 문 또는 Visual Basic `SyncLock` 문을 사용 하 여 구현 됩니다 <xref:System.Threading.Monitor>합니다.  
  
 와 같은 진단 도구를 사용 하 여이 메서드를 사용 합니다 <xref:System.Diagnostics.Debug.Assert%2A> 메서드 및 <xref:System.Diagnostics.Contracts.Contract> 클래스를 포함 하는 잠금 문제를 디버깅 하는 <xref:System.Threading.Monitor> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">스레드에서 기다리는 개체입니다.</param>
        <summary>대기 중인 큐에 포함된 스레드에 잠겨 있는 개체의 상태 변경을 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 소유자의 잠금 대기 하 여 개체를 신호를 보낼 수 있습니다만 `Pulse`합니다.  
  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 잠금에 대 한 줄에 다음 스레드를 알리기 위해이 메서드를 호출 합니다. 펄스를 수신 하면 대기 중인 스레드가 준비 큐로 이동 됩니다. 호출한 스레드가 `Pulse` 잠금을 해제 (필요가 없는 펄스 된 스레드의) 준비 된 큐에 있는 다음 스레드 잠금을 가져옵니다.  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor> 클래스는 나타내는 상태를 유지 하지 않습니다는 <xref:System.Threading.Monitor.Pulse%2A> 메서드가 호출 되었습니다. 따라서 호출 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 때 대기 중인 스레드가 없는 호출 하는 다음 스레드에서 <xref:System.Threading.Monitor.Wait%2A> 블록 처럼 <xref:System.Threading.Monitor.Pulse%2A> 마치 호출 되지 않습니다. 두 개의 스레드를 사용 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 고 <xref:System.Threading.Monitor.Wait%2A> 상호 작용 하 고,이 인해 교착 상태가 발생에서 합니다. 동작을 사용 하 여이 대조해 보세요 합니다 <xref:System.Threading.AutoResetEvent> 클래스: 신호 하는 경우는 <xref:System.Threading.AutoResetEvent> 호출 하 여 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를 대기 스레드가 없으면 및를 <xref:System.Threading.AutoResetEvent> 스레드가 호출 될 때까지 신호를 받은 상태에 남아 <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, 또는 <xref:System.Threading.WaitHandle.WaitAll%2A>합니다. <xref:System.Threading.AutoResetEvent> 해당 스레드를 해제 하 고 알림에서 신호 알림 해제 상태로 돌아갑니다.  
  
 현재 잠금을, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 동기화 개체를 소유 하 고 있음을 확인 하는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 합니다 `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, 및 <xref:System.Threading.Monitor.Wait%2A> 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 여러 스레드가 신호를 사용 하 여를 <xref:System.Threading.Monitor.PulseAll%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">펄스를 보내는 개체입니다.</param>
        <summary>대기 중인 모든 스레드에 개체 상태 변경을 알립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 개체에 대 한 잠금을 획득 하려고 대기 하는 모든 스레드를 알리기 위해이 메서드를 호출 합니다. 신호를 보낸 후 대기 스레드가 준비 큐로 이동 됩니다. 호출한 스레드가 `PulseAll` 잠금을 해제 준비 된 큐에 있는 다음 스레드 잠금을 가져옵니다.  
  
 현재 잠금을, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 동기화 개체를 소유 하 고 있음을 확인 하는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, 및 <xref:System.Threading.Monitor.Wait%2A> 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 단일 스레드를 알리기 위해 사용 된 `Pulse` 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 성공 하면이 메서드가 배타적 잠금을 획득에 `obj` 매개 변수입니다. 이 메서드는 잠금을 사용할 수 있는지 여부를 즉시 반환 합니다.  
  
 이 메서드는 유사한 <xref:System.Threading.Monitor.Enter%2A>, 하지만 현재 스레드를 차단 하지는 것입니다. 메서드가 반환 하는 경우 스레드를 차단 하지 않고 입력할 수 없습니다, `false,`합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 문서.  
  
 스레드가 중요 섹션에 들어가지 않습니다을 보장 하려면 메서드의 반환 값 검사 및 해당 반환 값은 경우에 중요 섹션의 코드를 실행 해야 `true`합니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 다음 코드 예제에서는 `TryEnter` 메서드를 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 성공 하면이 메서드가 배타적 잠금을 획득에 `obj` 매개 변수입니다. 이 메서드는 잠금을 사용할 수 있는지 여부를 즉시 반환 합니다.  
  
 에 대 한 지정 된 잠금이 된 그렇지 않은 경우 예외가 throw 되었기 때문에 변수를 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램입니다.  
  
 이 메서드는 유사한 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, 하지만 현재 스레드를 차단 하지는 것입니다. 스레드를 차단 하지 않고 들어갈 수 없는 경우는 `lockTaken` 인수가로 설정 된 `false` 메서드가 반환 합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 <xref:System.Threading.Monitor>를 참조하십시오.  
  
 스레드가 중요 섹션에 들어가지 않습니다 위해이 값을 검사 해야 `lockTaken` 해당 값은 경우에 중요 한 섹션에서 코드를 실행 하 고 `true`입니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 다음 코드를 사용 하기 위한 기본 패턴을 보여 줍니다.는 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드는 항상에 전달 되는 변수의 값을 설정 합니다 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드 변수 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 해제 합니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="millisecondsTimeout">잠금을 기다릴 밀리초 수입니다.</param>
        <summary>지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `millisecondsTimeout` 매개 변수가 같으면 <xref:System.Threading.Timeout.Infinite>,이 메서드는 <xref:System.Threading.Monitor.Enter%2A>합니다. 하는 경우 `millisecondsTimeout` 가 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%2A>합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 문서.  
  
 스레드가 중요 섹션에 들어가지 않습니다을 보장 하려면 메서드의 반환 값 검사 및 해당 반환 값은 경우에 중요 섹션의 코드를 실행 해야 `true`합니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="timeout">잠금을 기다리는 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
        <summary>지정된 시간 동안 지정된 개체의 단독 잠금을 가져오려고 했습니다.</summary>
        <returns>현재 스레드에서 잠금을 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 값을 `timeout` 밀리초로 변환 하는 매개 변수가 같으면-1,이 메서드는 <xref:System.Threading.Monitor.Enter%2A>합니다. 경우 값 `timeout` 가 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%2A>합니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드가 중요 섹션에 들어가지 않습니다을 보장 하려면 메서드의 반환 값 검사 및 해당 반환 값은 경우에 중요 섹션의 코드를 실행 해야 `true`합니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="millisecondsTimeout">잠금을 기다릴 밀리초 수입니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 시간(밀리초) 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `millisecondsTimeout` 매개 변수가 같으면 <xref:System.Threading.Timeout.Infinite>,이 메서드는 <xref:System.Threading.Monitor.Enter%28System.Object%29>합니다. 하는 경우 `millisecondsTimeout` 가 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>합니다.  
  
 에 대 한 지정 된 잠금이 된 그렇지 않은 경우 예외가 throw 되었기 때문에 변수를 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램입니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드가 중요 섹션에 들어가지 않습니다 위해이 값을 검사 해야 `lockTaken` 해당 값은 경우에 중요 한 섹션에서 코드를 실행 하 고 `true`입니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 다음 코드를 사용 하기 위한 기본 패턴을 보여 줍니다.는 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> 메서드 오버 로드 합니다. 이 오버 로드는 항상에 전달 되는 변수의 값을 설정 합니다 `ref` 매개 변수 (`ByRef` Visual basic에서) `lockTaken`메서드 변수 값은 되도록 잠금을 있는지 여부를 테스트 하는 신뢰할 수 있는 방법은 예외를 throw 하는 경우에 해제 합니다.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">잠금을 가져올 개체입니다.</param>
        <param name="timeout">잠금을 대기할 시간입니다. -1밀리초 값은 무한 대기를 지정합니다.</param>
        <param name="lockTaken">잠금을 얻기 위한 시도의 결과로서, 참조에 의해 전달됩니다. 입력은 <see langword="false" />여야 합니다. 잠금을 얻으면 출력이 <see langword="true" />이고, 그렇지 않으면 출력이 <see langword="false" />입니다. 잠금을 얻으려는 시도 도중에 예외가 발생해도 출력이 설정됩니다.</param>
        <summary>지정된 시간 동안 지정된 개체의 단독 잠금을 가져오고 잠금 설정 여부를 나타내는 값을 자동으로 설정하려고 시도합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우의 값을 `timeout` 밀리초로 변환 하는 매개 변수가 같으면-1,이 메서드는 <xref:System.Threading.Monitor.Enter%28System.Object%29>합니다. 경우 값 `timeout` 가 0 이면이 메서드는 <xref:System.Threading.Monitor.TryEnter%28System.Object%29>합니다.  
  
 에 대 한 지정 된 잠금이 된 그렇지 않은 경우 예외가 throw 되었기 때문에 변수를 `lockTaken` 매개 변수는 `false` 이 메서드 종료 된 후입니다. 이렇게 하면 모든 경우에는 잠금을 해제 하는 데 필요한 인지를 확인 하려면 프로그램입니다.  
  
> [!NOTE]
>  사용 하 여 <xref:System.Threading.Monitor> 잠금 개체 (즉, 참조 형식), 값 형식이 없습니다. 자세한 내용은 참조는 <xref:System.Threading.Monitor> 클래스 항목입니다.  
  
 스레드가 중요 섹션에 들어가지 않습니다 위해이 값을 검사 해야 `lockTaken` 해당 값은 경우에 중요 한 섹션에서 코드를 실행 하 고 `true`입니다. 다음 코드 조각은이 메서드를 호출 하는 데 패턴을 보여 줍니다. 호출 해야 하는 참고 <xref:System.Threading.Monitor.Exit%2A> 에 `finally` 블록에 예외가 발생 하면 호출 스레드가 중요 섹션에 대 한 잠금을 해제는 합니다.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" />에 대한 입력이 <see langword="true" />인 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)와 같지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다.</summary>
        <returns>지정된 개체 잠금을 호출자가 다시 가져와 호출이 반환되면 <see langword="true" />입니다. 잠금을 다시 가져오지 않으면 이 메서드는 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 획득 하려고 대기 하는 동안 차단 됩니다. 이 메서드는 호출자가 다른 스레드의 작업의 결과로 발생 하는 상태가 변경 될 때까지 기다려야 하는 경우 호출 됩니다.  
  
 호출 하면 스레드 `Wait`, 개체에 대 한 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드에서 (있는 경우) 획득 된 잠금 개체의 단독으로 사용 하 고 있습니다. 호출 하는 모든 스레드가 `Wait` 신호를 받을 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>, 잠금 소유자가 전송 합니다. 경우 `Pulse` 스레드가 대기 중인 큐의 헤드에만 영향을 받는 전송 됩니다. 경우 `PulseAll` 개체에 대 한 대기 중인 모든 스레드에 영향을 받는 전송 됩니다. 신호를 받을 때 하나 이상의 스레드가 대기 중인 큐에 두고 준비 된 큐에 입력 합니다. 스레드가 준비 큐에서 잠금을 획득 허용 됩니다.  
  
 이 메서드는 호출 스레드 개체에 대 한 잠금을 다시 가져오면를 반환 합니다. 잠금의 소유자를 호출 하지 않는 경우이 메서드는 무기한으로 차단 하는 참고 `Pulse` 또는 `PulseAll`합니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 개념적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 `Enter` 개체에서 호출 `Exit` 잠겨 있는 개체를 완전히 해제 하는 데 필요한 횟수 만큼 합니다. 개체를 획득 하려고 대기 하는 동안 호출자를 차단 합니다. 시스템 호출 호출자가 잠금을 다시 가져오면 `Enter` 는 저장 된 복원 하는 데 필요한 횟수 만큼 `Enter` 호출자에 대 한 수입니다. 호출 `Wait` 지정된 된 개체에 대 한 잠금을 해제 되지 않습니다 호출자에 게 다른 개체에 대 한 잠금의 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
 현재 잠금을, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 동기화 개체를 소유 하 고 있음을 확인 하는 개체의 상태 변경에 대 한 알림을 대기 중인 스레드를 포함 합니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="millisecondsTimeout">스레드가 준비된 큐에 들어가기 전에 대기할 밀리초 수입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 획득 하려고 대기 하는 동안 차단 됩니다. 이 메서드는 호출자가 다른 스레드의 작업의 결과로 발생 하는 상태가 변경 될 때까지 기다려야 하는 경우 호출 됩니다.  
  
 제한 시간이 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드의 무기한으로 차단 되지 않습니다 보장 합니다 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 대기 큐의 다른 스레드에 앞서 무시 하 고, 준비 된 큐로 이동 합니다. 스레드의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 제한 하기 전에 잠금을 다시 가져왔는지 여부를 결정 하는 방법입니다. 스레드는 대기를 일으킨 조건을 평가할 수 경우에 필요한 호출을 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 개체에 대 한 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드에서 (있는 경우) 획득 된 잠금 개체의 단독으로 사용 하 고 있습니다. 호출한 스레드에서 `Wait` 잠금을 보유 하는 스레드 호출 될 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.PulseAll%2A>, 또는 큐에서 다음 이므로 잠금을 보유 하는 스레드 호출 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `millisecondsTimeout` 경과할 때까지이 개체를 호출 하는 다른 스레드가 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 잠금의 권한을 다시 얻기 위해 메서드를 원래 스레드가 준비 큐로 이동 합니다.  
  
> [!NOTE]
>  경우 <xref:System.Threading.Timeout.Infinite> 에 대해 지정 된 된 `millisecondsTimeout` 매개 변수를이 메서드에 무기한 차단 잠금 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 하는 경우 `millisecondsTimeout` 가 0을 호출 하는 스레드 `Wait` 잠금을 해제 한 다음 잠금의 권한을 다시 얻기 위해 즉시 준비 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 개념적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에서 호출 <xref:System.Threading.Monitor.Exit%2A> 잠겨 있는 개체를 완전히 해제 하는 데 필요한 횟수 만큼 합니다. 개체를 획득 하려고 대기 하는 동안 호출자를 차단 합니다. 시스템 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 는 저장 된 복원 하는 데 필요한 횟수 만큼 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 지정된 된 개체에 대 한 잠금을 해제 되지 않습니다 호출자에 게 다른 개체에 대 한 잠금의 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  동기화 된 개체를 현재 잠금, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 포함 된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="timeout">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 획득 하려고 대기 하는 동안 차단 됩니다. 이 메서드는 호출자가 다른 스레드의 작업의 결과로 발생 하는 상태가 변경 될 때까지 기다려야 하는 경우 호출 됩니다.  
  
 제한 시간이 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드의 무기한으로 차단 되지 않습니다 보장 합니다 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 대기 큐의 다른 스레드에 앞서 무시 하 고, 준비 된 큐로 이동 합니다. 스레드의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 제한 하기 전에 잠금을 다시 가져왔는지 여부를 결정 하는 방법입니다. 스레드는 대기를 일으킨 조건을 평가할 수 경우에 필요한 호출을 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 개체에 대 한 잠금을 해제 하 고 개체의 대기 큐에 들어갑니다. 개체의 준비 된 큐에 있는 다음 스레드에서 (있는 경우) 획득 된 잠금 개체의 단독으로 사용 하 고 있습니다. 호출한 스레드에서 `Wait` 잠금을 보유 하는 스레드 호출 될 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.PulseAll%2A>, 또는 큐에서 다음 이므로 잠금을 보유 하는 스레드 호출 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `timeout` 경과할 때까지이 개체를 호출 하는 다른 스레드가 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 잠금의 권한을 다시 얻기 위해 메서드를 원래 스레드가 준비 큐로 이동 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.TimeSpan> 에 대해 지정 된-1 밀리초를 나타내는 합니다 `timeout` 매개 변수를이 메서드에 무기한 차단 잠금 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 하는 경우 `timeout` 은 0 밀리초를 호출 하는 스레드 `Wait` 잠금을 해제 한 다음 잠금의 권한을 다시 얻기 위해 즉시 준비 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 개념적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에서 호출 <xref:System.Threading.Monitor.Exit%2A> 잠겨 있는 개체를 완전히 해제 하는 데 필요한 횟수 만큼 합니다. 개체를 획득 하려고 대기 하는 동안 호출자를 차단 합니다. 시스템 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 는 저장 된 복원 하는 데 필요한 횟수 만큼 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 지정된 된 개체에 대 한 잠금을 해제 되지 않습니다 호출자에 게 다른 개체에 대 한 잠금의 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  동기화 된 개체를 현재 잠금, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 포함 된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">호출한 스레드가 지정된 개체 잠금을 소유하지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 매개 변수의 값(밀리초)이 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="millisecondsTimeout">스레드가 준비된 큐에 들어가기 전에 대기할 밀리초 수입니다.</param>
        <param name="exitContext">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 또한 이 메서드는 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 대기 전에 종료하고 나중에 다시 가져오는지 여부도 지정합니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 획득 하려고 대기 하는 동안 차단 됩니다. 이 메서드는 호출자가 다른 스레드의 작업의 결과로 발생 하는 상태가 변경 될 때까지 기다려야 하는 경우 호출 됩니다.  
  
 제한 시간이 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드의 무기한으로 차단 되지 않습니다 보장 합니다 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 대기 큐의 다른 스레드에 앞서 무시 하 고, 준비 된 큐로 이동 합니다. 스레드의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 제한 하기 전에 잠금을 다시 가져왔는지 여부를 결정 하는 방법입니다. 스레드는 대기를 일으킨 조건을 평가할 수 경우에 필요한 호출을 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 잠금을 해제 하 고 대기 큐에 들어갑니다. 이 시점에서 준비 된 큐에 있는 다음 스레드 (있는 경우)는 제어할 수 있게 잠금. 호출한 스레드에서 `Wait` 잠금을 보유 하는 스레드 호출 될 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.PulseAll%2A>, 또는 큐에서 다음 이므로 잠금을 보유 하는 스레드 호출 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `millisecondsTimeout` 경과할 때까지이 개체를 호출 하는 다른 스레드가 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 잠금의 권한을 다시 얻기 위해 메서드를 원래 스레드가 준비 큐로 이동 합니다.  
  
> [!NOTE]
>  경우 <xref:System.Threading.Timeout.Infinite> 에 대해 지정 된 된 `millisecondsTimeout` 매개 변수를이 메서드에 무기한 차단 잠금 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 하는 경우 `millisecondsTimeout` 가 0을 호출 하는 스레드 `Wait` 잠금을 해제 한 다음 잠금의 권한을 다시 얻기 위해 즉시 준비 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 개념적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에서 호출 <xref:System.Threading.Monitor.Exit%2A> 잠겨 있는 개체를 완전히 해제 하는 데 필요한 횟수 만큼 합니다. 개체를 획득 하려고 대기 하는 동안 호출자를 차단 합니다. 시스템 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 는 저장 된 복원 하는 데 필요한 횟수 만큼 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 지정된 된 개체에 대 한 잠금을 해제 되지 않습니다 호출자에 게 다른 개체에 대 한 잠금의 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  동기화 된 개체를 현재 잠금, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 포함 된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다`exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.Monitor.Wait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.Monitor.Wait%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성을 적용 합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" />를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 매개 변수의 값이 음이고 <see cref="F:System.Threading.Timeout.Infinite" />와 같지 않은 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">대기할 개체입니다.</param>
        <param name="timeout">스레드가 준비된 큐에 들어가기 전에 대기할 시간을 나타내는 <see cref="T:System.TimeSpan" />입니다.</param>
        <param name="exitContext">대기 전에 컨텍스트의 동기화 도메인(동기화된 컨텍스트에 있는 경우)을 끝내고 다시 가져오면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>개체의 잠금을 해제한 다음 잠금을 다시 가져올 때까지 현재 스레드를 차단합니다. 지정된 시간 제한 간격이 지나면 스레드가 준비된 큐에 들어갑니다. 필요에 따라 동기화된 컨텍스트의 동기화 도메인을 대기 전에 종료하고 나중에 해당 도메인을 다시 가져옵니다.</summary>
        <returns>지정된 시간이 경과하기 전에 잠금을 다시 가져오면 <see langword="true" />이고, 지정된 시간이 경과한 후에 잠금을 다시 가져오면 <see langword="false" />입니다. 이 메서드는 잠금을 다시 가져올 때까지 반환하지 않습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 배타적 잠금을 다시 가져올 때까지이 메서드를 반환 하지 않습니다는 `obj` 매개 변수입니다.  
  
 지정된 된 개체에 대 한 잠금을 현재 소유한 스레드가 다른 스레드에서 액세스할 수 있도록 개체를 해제 하기 위해이 메서드를 호출 합니다. 호출자가 잠금을 획득 하려고 대기 하는 동안 차단 됩니다. 이 메서드는 호출자가 다른 스레드의 작업의 결과로 발생 하는 상태가 변경 될 때까지 기다려야 하는 경우 호출 됩니다.  
  
 제한 시간이 다른 스레드가 먼저 호출 하지 않고 잠금을 해제 하는 경우 현재 스레드의 무기한으로 차단 되지 않습니다 보장 합니다 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 메서드. 또한 스레드는 잠금을 더 빨리 다시 가져올 수 있도록 대기 큐의 다른 스레드에 앞서 무시 하 고, 준비 된 큐로 이동 합니다. 스레드의 반환 값을 테스트할 수는 <xref:System.Threading.Monitor.Wait%2A> 제한 하기 전에 잠금을 다시 가져왔는지 여부를 결정 하는 방법입니다. 스레드는 대기를 일으킨 조건을 평가할 수 경우에 필요한 호출을 <xref:System.Threading.Monitor.Wait%2A> 메서드를 다시 합니다.  
  
 호출 하면 스레드 `Wait`, 잠금을 해제 하 고 대기 큐에 들어갑니다. 이 시점에서 준비 된 큐에 있는 다음 스레드 (있는 경우)는 제어할 수 있게 잠금. 호출한 스레드에서 `Wait` 잠금을 보유 하는 스레드 호출 될 때까지 대기 중인 큐에 남아 <xref:System.Threading.Monitor.PulseAll%2A>, 또는 큐에서 다음 이므로 잠금을 보유 하는 스레드 호출 <xref:System.Threading.Monitor.Pulse%2A>합니다. 그러나 경우 `timeout` 시간 (밀리초)는 다른 스레드가이 개체를 호출 하기 전에 경과 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A> 잠금의 권한을 다시 얻기 위해 메서드를 원래 스레드가 준비 큐로 이동 합니다.  
  
> [!NOTE]
>  경우는 <xref:System.TimeSpan> 에 대해 지정 된-1 밀리초를 나타내는 합니다 `timeout` 매개 변수를이 메서드에 무기한 차단 잠금 소유자를 호출 하지 않는 경우 <xref:System.Threading.Monitor.Pulse%2A> 또는 <xref:System.Threading.Monitor.PulseAll%2A>합니다. 하는 경우 `timeout` 은 0 밀리초를 호출 하는 스레드 `Wait` 잠금을 해제 한 다음 잠금의 권한을 다시 얻기 위해 즉시 준비 큐에 들어갑니다.  
  
 호출자에 게 실행 `Wait` 횟수에 관계 없이 한 번 <xref:System.Threading.Monitor.Enter%2A> 지정 된 개체를 호출 했습니다. 개념적으로 `Wait` 메서드는 호출자가 호출한 횟수를 저장 <xref:System.Threading.Monitor.Enter%2A> 개체에서 호출 <xref:System.Threading.Monitor.Exit%2A> 잠겨 있는 개체를 완전히 해제 하는 데 필요한 횟수 만큼 합니다. 개체를 획득 하려고 대기 하는 동안 호출자를 차단 합니다. 시스템 호출 호출자가 잠금을 다시 가져오면 <xref:System.Threading.Monitor.Enter%2A> 는 저장 된 복원 하는 데 필요한 횟수 만큼 <xref:System.Threading.Monitor.Enter%2A> 호출자에 대 한 수입니다. 호출 `Wait` 지정된 된 개체에 대 한 잠금을 해제 되지 않습니다 호출자에 게 다른 개체에 대 한 잠금의 소유자 인 경우 이러한 잠금은 해제 되지 않습니다.  
  
> [!NOTE]
>  동기화 된 개체를 현재 잠금, 잠금을 획득할 수 있는 스레드를 포함 하는 준비 된 큐에 대 한 참조 및 포함 하는 대기 중인 큐에 대 한 참조를 보유 하는 스레드에 대 한 참조를 포함 하 여 여러 개의 참조가 포함 된 개체의 상태 변경에 대 한 알림을 대기 중인 스레드입니다.  
  
 합니다 <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, 및 `Wait` 동기화 된 코드 블록 내에서 메서드를 호출할 수 있어야 합니다.  
  
 에 대 한 설명을 합니다 <xref:System.Threading.Monitor.Pulse%2A> 메서드 상황을 설명 하는 경우 <xref:System.Threading.Monitor.Pulse%2A> 대기 중인 스레드가 없을 때 호출 됩니다.  
  
## <a name="notes-on-exiting-the-context"></a>종료 컨텍스트에 대 한 참고 사항  
 합니다`exitContext` 매개 변수 효과가 있습니다를 <xref:System.Threading.Monitor.Wait%2A> 기본이 아닌 관리 되는 컨텍스트 내에서 메서드를 호출 합니다. 파생 된 클래스의 인스턴스로 호출 내에서 스레드 경우 발생할 수 있습니다 <xref:System.ContextBoundObject>합니다. 파생 되지 않은 클래스에 메서드를 현재 실행 중인 경우에 <xref:System.ContextBoundObject>같은 <xref:System.String>, 기본이 아닌 컨텍스트에서 할 경우를 <xref:System.ContextBoundObject> 가 현재 응용 프로그램 도메인에서 스택에 합니다.  
  
 사용자 코드가 아닌 컨텍스트에서 실행 되는 경우를 지정 하 `true` 에 대 한 `exitContext` 기본값이 아닌 관리 되는 컨텍스트를 종료 하려면 스레드 (즉, 기본 컨텍스트로 전환)를 실행 하기 전에 <xref:System.Threading.Monitor.Wait%2A> 메서드. 호출 후 원래 컨텍스트로 돌아갑니다는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 완료 합니다.  
  
 컨텍스트 바인딩 클래스에 유용할 수 있습니다는 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 특성을 적용 합니다. 이 경우 클래스의 멤버에 대 한 모든 호출을 자동으로 동기화 및 동기화 도메인 클래스에 대 한 코드의 전체 본문입니다. 멤버의 호출 스택의 코드를 호출 하는 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 지정 하 고 `true` 에 대 한 `exitContext`, 스레드가 종료 동기화 도메인을 계속 하려면 개체의 모든 멤버에 대 한 호출에서 차단 된 스레드를 허용 합니다. 경우는 <xref:System.Threading.Monitor.Wait%2A> 메서드를 호출 하는 스레드 컨텍스트의 동기화 도메인을 다시 입력 하기 위해 대기 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" />가 동기화된 코드 블록 내에서 호출되지 않는 경우</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wait를 호출하는 스레드가 나중에 대기 상태에서 중단된 경우. 이 예외는 다른 스레드가 이 스레드의 <see cref="M:System.Threading.Thread.Interrupt" /> 메서드를 호출할 때 발생합니다.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 매개 변수가 음수이고 <see cref="F:System.Threading.Timeout.Infinite" />(-1밀리초)를 나타내지 않거나 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
      </Docs>
    </Member>
  </Members>
</Type>