<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ce9e7baa3a821c29a66c9f4a2774a3cefd34f623" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56071831" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>프로세스 간 동기화에 사용할 수도 있는 동기화 기본 형식입니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 두 개 이상의 스레드를 동시에 공유 리소스에 액세스 해야 하는 경우 시스템 리소스를 한 번에 하나의 스레드만 사용 되도록 동기화 메커니즘이 필요 합니다. <xref:System.Threading.Mutex> 하나의 스레드만 공유 리소스에 대 한 단독 액세스를 부여 하는 기본 동기화 합니다. 스레드가 뮤텍스를 획득 하 고 두 번째 스레드는 뮤텍스를 획득 하는 첫 번째 스레드가 뮤텍스를 해제할 때까지 일시 중단 됩니다.  
  
> [!IMPORTANT]
>  이 형식이 구현 하는 <xref:System.IDisposable> 인터페이스입니다. 형식을 사용 하 여 마쳤으면 직접 또는 간접적으로의 삭제 해야 있습니다. 직접 형식의 dispose 호출 해당 <xref:System.IDisposable.Dispose%2A> 의 메서드를 `try` / `catch` 블록입니다. 삭제 하지 직접, 언어 구문 같은 사용 `using` (C#에서) 또는 `Using` (Visual Basic에서는). 자세한 내용은 "를 사용 하는 개체는 구현 IDisposable" 섹션을 참조 하세요.를 <xref:System.IDisposable> 인터페이스 항목입니다.  
  
 사용할 수는 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> 뮤텍스의 소유권을 요청 하는 메서드. 해당 호출 스레드는 차단 중 하나가 발생할 때까지:  
  
-   뮤텍스는 신호를 소유 하지 않은 것을 나타냅니다. 이 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `true`, 호출 스레드가 뮤텍스의 소유권을 가정 하 고 뮤텍스 하 여 보호 되는 리소스에 액세스 하 고 있습니다. 스레드 호출 해야 리소스에 액세스할 완료 될 때를 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하는 방법입니다. 예제 섹션의 첫 번째 예제에서는이 패턴을 보여 줍니다.  
  
-   에 대 한 호출에 지정 된 시간 제한 간격을 <xref:System.Threading.WaitHandle.WaitOne%2A> 있는 메서드를 `millisecondsTimeout` 또는 `timeout` 매개 합니다. 이 경우는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드가 반환 되는 `false`, 호출 스레드가 뮤텍스의 소유권을 가져오려고 시도 하지 추가 하 고 있습니다. 이 경우 호출 스레드가 뮤텍스로 보호 되는 리소스에 대 한 액세스가 거부 되었습니다 있도록 코드를 구성 해야 합니다. 호출 하지 않아야 되지 스레드가 뮤텍스의 소유권을 획득 하기 때문에 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드. 예제 섹션의 두 번째 예제에서는이 패턴을 보여 줍니다.  
  
 <xref:System.Threading.Mutex> 뮤텍스를 획득 하는 스레드에 의해서만 해제 될 수 있으므로 클래스는 스레드 id를 적용 합니다. 반면,는 <xref:System.Threading.Semaphore> 클래스는 스레드 id를 적용 하지 않습니다. 뮤텍스는 애플리케이션 도메인 경계를 넘어 전달할 수도 있습니다.  
  
 뮤텍스를 소유 하는 스레드를 반복된 호출에서 동일한 뮤텍스를 요청할 수 <xref:System.Threading.WaitHandle.WaitOne%2A> 실행을 차단 하지 않고 있습니다. 그러나 스레드가 호출 해야 합니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 때문에 <xref:System.Threading.Mutex> 클래스에서 상속 <xref:System.Threading.WaitHandle>, 정적 호출할 수도 있습니다 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> 고 <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> 보호 된 리소스에 대 한 액세스를 동기화 하는 방법.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 하는 경우 뮤텍스는 중단 될 있다고 합니다. 뮤텍스의 상태 신호 설정 되 고 대기 스레드는 소유권을 가져옵니다. .NET Framework 버전 2.0부터는 <xref:System.Threading.AbandonedMutexException> 중단된 된 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. .NET Framework 버전 2.0 전에 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 종종 코드에서 심각한 오류를 나타냅니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 상태가 일관 되지 않을 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속할 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 애플리케이션이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
 뮤텍스는 두 가지 유형이: 명명 되지 않은, 되 고 시스템 뮤텍스를 명명 된 로컬 뮤텍스입니다. 로컬 뮤텍스는 프로세스 내에만 존재합니다. 에 대 한 참조가 있는 프로세스의 모든 스레드에서 사용할 수는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 되지 않은 각 <xref:System.Threading.Mutex> 별도 로컬 뮤텍스 개체를 나타냅니다.  
  
 명명 된 시스템 뮤텍스는 운영 체제 전체에서 볼 수 있으며 사용 하 여 프로세스 작업을 동기화 할 수 있습니다. 만들 수는 <xref:System.Threading.Mutex> 이름을 허용 하는 생성자를 사용 하 여 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 동시에 운영 체제 개체를 만들 수 있습니다 또는 만들기 전에 존재할 수는 <xref:System.Threading.Mutex> 개체입니다. 동일한 명명된 시스템 뮤텍스를 나타내는 여러 <xref:System.Threading.Mutex> 개체를 만들 수 있으며 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 사용하여 기존 명명된 시스템 뮤텍스를 열 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 있습니다. 해당 이름 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 해당 이름 접두사로 시작 하는 경우 "로컬\\", 뮤텍스 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 및 터미널 서버 세션에서 모든 프로세스에 표시 됩니다. 즉, 접두사 이름을 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 뮤텍스 이름 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 이 예에서는 로컬 <xref:System.Threading.Mutex> 개체는 보호 된 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다. 각 호출 스레드가 뮤텍스의 소유권을 가져올 때까지 차단 하기 때문에 호출 해야 합니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 스레드는 소유권을 해제 하는 방법입니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 다음 예제에서는 각 스레드 호출을 <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> 뮤텍스를 획득 하는 방법입니다. 메서드가 반환 하는 경우 시간 제한 간격이 경과 하면 `false`, 스레드가 뮤텍스를 획득 아니고 뮤텍스를 보호 하는 리소스에 대 한 액세스를 향상 하 고 있습니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스를 획득 하는 스레드에서 메서드가 호출 됩니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>기본 속성을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자 오버 로드는 호출에서와 동일 합니다 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자 오버 로드 하 고 지정 `false` 뮤텍스의 초기 소유권에 대 한 합니다. 즉, 호출 스레드가 뮤텍스를 소유 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 어떻게 로컬 <xref:System.Threading.Mutex> 개체는 보호 된 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다. 뮤텍스를 만드는 스레드는 소유 하지 않는 처음에 있습니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">호출한 스레드에 뮤텍스의 초기 소유권을 부여하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지 여부를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 어떻게 로컬 <xref:System.Threading.Mutex> 개체는 보호 된 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다. 만드는 스레드는는 <xref:System.Threading.Mutex> 처음 소유 합니다.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name"><see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <summary>호출 스레드가 뮤텍스의 초기 소유권을 가져야 할지 여부를 나타내는 부울 값과 뮤텍스 이름인 문자열을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 `name` 아닙니다 `null` 하 고 `initiallyOwned` 는 `true`,이 호출의 결과로 명명된 된 시스템 뮤텍스가 만들어진 경우에 호출 스레드가 뮤텍스를 소유 합니다. 명명된 된 시스템 뮤텍스에 만들어졌는지 여부를 결정 하는 메커니즘이 없습니다 이므로 것이 좋습니다 지정할 `false` 에 대 한 `initiallyOwned` 이 생성자 오버 로드를 호출 하는 경우. 사용할 수는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> 초기 소유권을 확인 하는 경우에 생성자입니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 사용 하 여 이미 생성 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 활동을 동기화 하는 데 필요한 권한만 사용 하 여 명명 된 뮤텍스를 열려면 참조를 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열로 `name`, 로컬 뮤텍스가 만들어진 호출한 것 처럼는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 예에서 `createdNew` 항상 `true`합니다.  
  
 시스템 차원의 되므로 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 명명 된 뮤텍스를 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 있습니다. 해당 이름 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 해당 이름 접두사로 시작 하는 경우 "로컬\\", 뮤텍스 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 및 터미널 서버 세션에서 모든 프로세스에 표시 됩니다. 즉, 접두사 이름을 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 뮤텍스 이름 범위에 설명 합니다.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 다음 예제에서는 두 개의 별도 프로세스에서 실행 되는 스레드 간의 신호를 보낼 명명된 된 뮤텍스는 사용 하는 방법을 보여 줍니다.  
  
 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는 한 <xref:System.Threading.Mutex> 명명 된 뮤텍스를 나타내는 `MyMutex`합니다. 명명 된 뮤텍스 수명이의 수명으로 제한 된 시스템 개체 인지를 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스는 첫 번째 프로세스를 만들 때 만들어집니다 해당 <xref:System.Threading.Mutex> 개체;이 예제에서는 명명 된 뮤텍스는 프로그램을 실행 하는 첫 번째 프로세스에서 소유 합니다. 명명 된 뮤텍스 소멸 될 때 모든는 <xref:System.Threading.Mutex> 릴리스된 것을 나타내는 개체입니다.  
  
 이 예제에서 사용 하는 생성자 오버 로드 호출 스레드 명명 된 뮤텍스의 초기 소유권이 부여 되었는지 여부를 확인할 수 없습니다. 하지 할 특정 스레드 명명 된 뮤텍스 만든 경우가 아니면 시스템 뮤텍스의 초기 소유권을 요청 하려면이 생성자를 사용 해야 합니다.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name"><see cref="T:System.Threading.Mutex" />의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <paramref name="name" />이(가) <see langword="null" />이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <see langword="true" />인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <see langword="false" />이(가) 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지를 나타내는 부울 값을 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `name` 아닙니다 `null` 및 `initiallyOwned` 됩니다 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드 `createdNew` 는 `true` 호출 후 합니다. 스레드를 호출 하 여 뮤텍스를 요청할 수이 고, 그렇지는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 사용 하 여 이미 생성 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 권한 예외가 throw 됩니다. 기존 스레드 활동을 동기화 하는 데 필요한 권한만 사용 하 여 명명 된 뮤텍스를 열려면 참조를 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열로 `name`, 로컬 뮤텍스가 만들어진 호출한 것 처럼는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 예에서 `createdNew` 항상 `true`합니다.  
  
 시스템 차원의 되므로 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 명명 된 뮤텍스를 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 있습니다. 해당 이름 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 해당 이름 접두사로 시작 하는 경우 "로컬\\", 뮤텍스 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 및 터미널 서버 세션에서 모든 프로세스에 표시 됩니다. 즉, 접두사 이름을 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 뮤텍스 이름 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 다음 코드 예제에서는 명명된 된 뮤텍스는 프로세스 또는 스레드 간에 신호를 보내는 데 하는 방법을 보여 줍니다. 두 개 이상의 명령 창에서이 프로그램을 실행 합니다. 각 프로세스는는 <xref:System.Threading.Mutex> "인 MyMutex" 명명 된 뮤텍스를 나타내는 개체입니다. 명명 된 뮤텍스 시스템 개체입니다. 이 예제에서는 수명이의 수명으로 제한 됩니다는 <xref:System.Threading.Mutex> 뮤텍스를 나타내는 개체입니다. 첫 번째 프로세스는 로컬에서 명명 된 뮤텍스 생성 됩니다 <xref:System.Threading.Mutex> 개체를 제거 하는 경우 모든는 <xref:System.Threading.Mutex> 릴리스된 것을 나타내는 개체입니다. 명명 된 뮤텍스는 처음에 첫 번째 프로세스에 의해 소유 됩니다. 두 번째 프로세스 및 모든 후속 프로세스가 이전 프로세스를 명명 된 뮤텍스를 해제 될 때까지 기다립니다.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">이 호출의 결과로 명명된 시스템 뮤텍스가 만들어지는 경우 호출한 스레드에 명명된 시스템 뮤텍스의 초기 소유권을 부여하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <param name="name">시스템 뮤텍스의 이름입니다. 값이 <see langword="null" />이면 <see cref="T:System.Threading.Mutex" />이(가) 명명되지 않습니다.</param>
        <param name="createdNew">이 메서드가 반환될 때 로컬 뮤텍스가 만들어진 경우(즉, <paramref name="name" />이(가) <see langword="null" />이거나 빈 문자열인 경우)나 지정된 명명된 시스템 뮤텍스가 만들어진 경우에는 <see langword="true" />인 부울이 포함되고, 지정된 명명된 시스템 뮤텍스가 이미 있는 경우에는 <see langword="false" />이(가) 포함됩니다. 이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
        <param name="mutexSecurity">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</param>
        <summary>호출한 스레드가 뮤텍스의 초기 소유권을 가져야 할지를 나타내는 부울 값, 뮤텍스의 이름인 문자열 및 메서드에서 반환할 때 호출한 스레드에 뮤텍스의 초기 소유권이 부여되었는지와 명명된 뮤텍스에 적용할 액세스 제어 보안을 나타내는 부울 변수를 사용하여 <see cref="T:System.Threading.Mutex" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 `name` 아닙니다 `null` 및 `initiallyOwned` 됩니다 `true`, 경우에만 명명 된 뮤텍스를 소유 하는 호출 스레드 `createdNew` 는 `true` 호출 후 합니다. 스레드를 호출 하 여 뮤텍스를 요청할 수이 고, 그렇지는 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드.  
  
 뮤텍스의 제어 인해 다른 코드를 만들 때 명명 된 시스템 뮤텍스에 액세스 제어 보안을 적용 하려면이 생성자를 사용 합니다.  
  
 이 생성자는 <xref:System.Threading.Mutex> 명명된 된 시스템 뮤텍스를 나타내는 개체입니다. 여러 개 만들 수 있습니다 <xref:System.Threading.Mutex> 명명 된 시스템 뮤텍스가 동일한를 나타내는 개체입니다.  
  
 명명된 된 시스템 뮤텍스가 존재 하지 않는 경우 지정 된 액세스 제어 보안을 사용 하 여 생성 됩니다. 명명 된 뮤텍스가 존재 하는 경우 지정 된 액세스 제어 보안 무시 됩니다.  
  
> [!NOTE]
>  호출자에 게 완전히 제어할 새로 만든된 <xref:System.Threading.Mutex> 경우에도 개체 `mutexSecurity` 거부 하거나 현재 사용자에 게 일부 액세스 권한을 부여 하지 못했습니다. 그러나 현재 사용자가 다른 <xref:System.Threading.Mutex> 개체를 나타내는 동일한 명명 된 뮤텍스를 사용 하 여 생성자 또는 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드를 Windows 액세스 제어 보안이 적용 됩니다.  
  
 명명된 된 뮤텍스에 액세스 제어 보안을 사용 하 여 이미 생성 하 고 호출자에 게 없는 경우 <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, 예외가 throw 됩니다. 기존 스레드 활동을 동기화 하는 데 필요한 권한만 사용 하 여 명명 된 뮤텍스를 열려면 참조를 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드.  
  
 지정 하는 경우 `null` 또는 빈 문자열로 `name`, 로컬 뮤텍스가 만들어진 호출한 것 처럼는 <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> 생성자입니다. 이 예에서 `createdNew` 항상 `true`합니다.  
  
 시스템 차원의 되므로 프로세스 경계를 넘어 리소스 사용을 조정 하기 위해 명명 된 뮤텍스를 사용할 수 있습니다.  
  
> [!NOTE]
>  터미널 서비스를 실행 하는 서버에서 명명된 된 시스템 뮤텍스는 두 가지 수준의 표시 유형 있습니다. 해당 이름 접두사로 시작 하는 경우 "Global\\", 뮤텍스 모든 터미널 서버 세션에 표시 됩니다. 해당 이름 접두사로 시작 하는 경우 "로컬\\", 뮤텍스 만들어진 터미널 서버 세션에만 표시 됩니다. 이 경우 각 서버에서 다른 터미널 서버 세션에서 동일한 이름 가진 별도 뮤텍스 존재할 수 있습니다. 명명된 된 뮤텍스를 만들 때 접두사를 지정 하지 않으면 접두사가 사용 "로컬\\"입니다. 터미널 서버 세션에서 이름이 해당 접두사만 다른 두 뮤텍스는 별도 뮤텍스 및 터미널 서버 세션에서 모든 프로세스에 표시 됩니다. 즉, 접두사 이름을 "Global\\" 및 "로컬\\" 터미널 서버 세션을 기준으로, 프로세스 관련 되지 뮤텍스 이름 범위에 설명 합니다.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드를 명명 된 뮤텍스가 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스 사용 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 뮤텍스를 엽니다.  
  
 권한이 변경 된 후에 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 존재하고 이 뮤텍스에 액세스 제어 보안이 있지만, 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />이 없는 경우</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">아마도 다른 형식의 대기 핸들에 동일한 이름이 있어서 명명된 뮤텍스를 만들 수 없는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 260자 보다 긴 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체를 가져옵니다.</summary>
        <returns>명명된 뮤텍스에 대한 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> 메서드는 다음과 같은 조합을 플래그 (비트 OR 연산을 사용 하 여 결합)를 사용 하 여 사용 권한을 검색할: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, 및 <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>합니다.  
  
 사용자에 게 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> 뮤텍스가이 메서드를 호출 하려면 열려 있어야와 <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드를 명명 된 뮤텍스가 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스 사용 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 합니다 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 뮤텍스를 열려는 메서드 오버 로드를 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후에 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지만 사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />가 없는 경우  
  
또는 
현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지만 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />를 사용하여 열리지 않은 경우</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 또는 Windows Millennium Edition에서 지원되지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 엽니다.</summary>
        <returns>명명된 시스템 뮤텍스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드 명명 된 시스템 뮤텍스가 된를 열려고 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만드는 대신 예외가 throw 됩니다. 시스템 뮤텍스를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Mutex.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 개체를 반환 하는 개체가 같은 명명 된 시스템 뮤텍스를 나타내는 경우에 합니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다.  
  
 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그 허용 스레드는 뮤텍스에서 대기를 지정 하 고는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드를 명명 된 뮤텍스가 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스 사용 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 뮤텍스를 엽니다.  
  
 권한이 변경 된 후에 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 뮤텍스가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <summary>이미 있는 경우 지정한 명명된 뮤텍스를 원하는 보안 액세스로 엽니다.</summary>
        <returns>명명된 시스템 뮤텍스를 나타내는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` 매개 변수에 포함 되어야 합니다 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 스레드가 뮤텍스를 대기할 수 있게 하는 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> 메서드는 기존 명명 된 뮤텍스를 열려고 합니다. 된 시스템 뮤텍스가 존재 하지 않는 경우이 메서드는 시스템 개체를 만드는 대신 예외가 throw 됩니다. 시스템 뮤텍스를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Mutex.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 개체를 반환 하는 개체가 같은 명명 된 시스템 뮤텍스를 나타내는 경우에 합니다.  
  
 이 메서드 뮤텍스의 소유권을 요청 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드를 명명 된 뮤텍스가 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스 사용 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 메서드 오버 로드를 읽고 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 뮤텍스를 엽니다.  
  
 권한이 변경 된 후에 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">명명된 뮤텍스가 없는 경우</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있지만 사용자에게 필요한 보안 액세스가 없습니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" />을(를) 한 번 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드가 뮤텍스를 획득 될 때마다 (예를 들어, 호출 하 여 해당 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드)를 이후에 호출 해야 합니다 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 포기 하 고 뮤텍스의 소유권 권한을 얻으려고 시도 하는 다른 스레드의 차단을 해제 하 합니다. 뮤텍스의 소유권을 가져오려는 시도가 실패 하는 경우 (예를 들어, 경우에 대 한 호출을 <xref:System.Threading.WaitHandle.WaitOne%2A> 메서드를 `millisecondsTimeout` 또는 `timeout` 매개 변수를 반환 `false` 요청 시간이 초과 하기 때문에), 스레드 호출 해서는 안 됩니다 <xref:System.Threading.Mutex.ReleaseMutex%2A>,이 경우 스레드는 또한 허용 되지 뮤텍스의 보호를 받는, 다음 예제와 같이 리소스에 액세스할 수 없습니다.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 뮤텍스를 소유 하는 스레드 실행을 차단 하지 않고 반복된 대기 함수 호출에서 동일한 뮤텍스를 지정할 수 있습니다. 공용 언어 런타임에 의해 호출 수가 유지 됩니다. 스레드에서 <xref:System.Threading.Mutex.ReleaseMutex%2A> 뮤텍스의 소유권을 해제 하려면 동일한 횟수입니다.  
  
 스레드가 뮤텍스를 소유 하는 동안 종료 하는 경우 뮤텍스는 중단 될 있다고 합니다. 뮤텍스의 상태를 signaled로 설정 되 고 대기 스레드는 소유권을 가져옵니다. 뮤텍스를 소유 아무도 뮤텍스의 상태 신호입니다. .NET Framework 버전 2.0부터는 <xref:System.Threading.AbandonedMutexException> 뮤텍스를 획득 하는 다음 스레드에서 throw 됩니다. 이전 버전의.NET Framework 2.0에서는 예외가 throw 되었습니다.  
  
> [!CAUTION]
>  중단 된 뮤텍스는 종종 코드에서 심각한 오류를 나타냅니다. 스레드가 뮤텍스를 해제 하지 않고 종료 되 면 뮤텍스의 보호를 받는 데이터 구조 상태가 일관 되지 않을 수 있습니다. 뮤텍스의 소유권을 요청 하는 다음 스레드에서이 예외를 처리 하 고 데이터 구조의 무결성을 확인할 수 있으면 계속할 수 있습니다.  
  
 시스템 차원 뮤텍스의 경우 중단된 뮤텍스는 애플리케이션이 갑자기 종료되었음을 나타낼 수 있습니다(예: Windows 작업 관리자를 사용하여).  
  
   
  
## Examples  
 다음 예제에서는 어떻게 로컬 <xref:System.Threading.Mutex> 개체는 보호 된 리소스에 대 한 액세스를 동기화 하는 데 사용 됩니다. 뮤텍스를 만드는 스레드는 소유 하지 않는 처음에 있습니다. <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드는 더 이상 필요 없는 뮤텍스를 해제 하는 데 사용 됩니다.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">호출 스레드가 뮤텍스를 소유하지 않습니다.</exception>
        <exception cref="T:System.ObjectDisposedException">현재 인스턴스가 이미 삭제된 경우</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">관리되는 스레딩</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">뮤텍스</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">명명된 시스템 뮤텍스에 적용할 액세스 제어 보안을 나타내는 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 개체입니다.</param>
        <summary>명명된 시스템 뮤텍스에 액세스 제어 보안을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자에 게 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 이 메서드를 호출 하는 뮤텍스에 대 한 권한을 사용 하 여 열려 있어야 <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 액세스 제어 보안을 사용 하 여 명명 된 뮤텍스의 프로세스 간 동작을 보여 줍니다. 이 예제에서는 사용 된 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 메서드 오버 로드를 명명 된 뮤텍스가 존재 여부를 테스트 합니다.  
  
 뮤텍스 존재 하지 않는 경우 시스템 뮤텍스의 초기 소유권 및 뮤텍스를 사용할 수 있는 권한이 현재 사용자를 거부 하지만 읽고 뮤텍스 사용 권한을 변경할 수 있는 권한을 부여 하는 액세스 제어 보안을 사용 하 여 생성 됩니다.  
  
 두 번째 복사본에 대 한 호출에는 액세스 위반 예외를 throw 합니다 두 개의 명령 창에서 컴파일된 예제를 실행 하는 경우 <xref:System.Threading.Mutex.OpenExisting%28System.String%29>합니다. 예외 포착 되 고이 예제에서는 사용 합니다 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 읽고 사용 하 여 사용 권한을 변경 하는 데 필요한 권한을 사용 하 여 뮤텍스를 열려는 메서드 오버 로드를 <xref:System.Threading.Mutex.GetAccessControl%2A> 및 <xref:System.Threading.Mutex.SetAccessControl%2A> 메서드.  
  
 권한이 변경 된 후에 뮤텍스 입력 하 고 해제 하는 데 필요한 권한으로 열려 있습니다. 세 번째 명령 창에서 컴파일된 예제를 실행 하는 경우 새 권한을 사용 하 여 실행 됩니다.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException">사용자에게 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />가 없는 경우  
  
또는 
뮤텍스가 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />를 사용하여 열리지 않은 경우</exception>
        <exception cref="T:System.SystemException">현재 <see cref="T:System.Threading.Mutex" /> 개체가 명명된 시스템 뮤텍스를 나타내지 않는 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 명명된 mutex(이미 존재하는 경우)를 열고 작업이 성공적으로 수행되었는지를 나타내는 값을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체를 포함하고 호출에 실패한 경우는 <see langword="null" />을(를) 포함해야 합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정한 명명된 뮤텍스(이미 존재하는 경우)를 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
        <returns>명명된 뮤텍스를 열었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다. 시스템 뮤텍스를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Mutex.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.  
  
 명명된 된 뮤텍스 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.Mutex.OpenExisting%28System.String%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 개체를 반환 하는 개체가 같은 명명 된 시스템 뮤텍스를 나타내는 경우에 합니다.  
  
 이 메서드 오버 로드는 호출에 해당 하는 <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> 메서드 오버 로드 하 고 지정 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 권한, 비트 OR 연산을 사용 하 여 결합 합니다. 지정 하는 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 플래그 허용 스레드는 뮤텍스에서 대기를 지정 하 고는 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 플래그는 스레드가 호출 될 수 있습니다는 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 이 메서드 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">열려는 시스템 뮤텍스의 이름입니다.</param>
        <param name="rights">원하는 보안 액세스 권한을 나타내는 열거형 값의 비트 조합입니다.</param>
        <param name="result">이 메서드가 반환될 때 호출이 성공적으로 실행된 경우 이름이 지정된 뮤텍스를 나타내는 <see cref="T:System.Threading.Mutex" /> 개체를 포함하고 호출에 실패한 경우는 <see langword="null" />을(를) 포함해야 합니다. 이 매개 변수는 초기화되지 않은 것으로 처리됩니다.</param>
        <summary>지정된 명명된 뮤텍스를 원하는 보안 액세스 상태에서 열고 작업이 수행되었는지를 나타내는 값을 반환합니다.</summary>
        <returns>명명된 뮤텍스를 열었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 명명 된 뮤텍스가 존재 하지 않는 경우이 메서드 만들어지지는지 않습니다 것입니다. 시스템 뮤텍스를 만들려면 이미 존재 하지 않을 경우 중 하나를 사용 합니다 <xref:System.Threading.Mutex.%23ctor%2A> 에 생성자를 `name` 매개 변수입니다.  
  
 명명된 된 뮤텍스 있는지 확실 하지 않은 경우 대신이 메서드 오버 로드를 사용 합니다 <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> 뮤텍스가 존재 하지 않는 경우 예외를 throw 하는 메서드 오버 로드 합니다.  
  
 `rights` 매개 변수에 포함 되어야 합니다 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 스레드가 뮤텍스를 대기할 수 있게 하는 플래그 및 <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 호출 스레드를 허용 하도록 플래그를 <xref:System.Threading.Mutex.ReleaseMutex%2A> 메서드.  
  
 에 대해 동일한 값을 사용 하는이 메서드를 여러 번 호출 `name` 동일한 반드시 반환 하지 않는 <xref:System.Threading.Mutex> 개체를 반환 하는 개체가 같은 명명 된 시스템 뮤텍스를 나타내는 경우에 합니다.  
  
 이 메서드 뮤텍스의 소유권을 요청 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />이 빈 문자열인 경우  
  
또는 
 <paramref name="name" />이 260자 보다 긴 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.IOException">Win32 오류가 발생한 경우</exception>
        <exception cref="T:System.UnauthorizedAccessException">명명된 뮤텍스가 있으나 사용자에게 이를 사용하는 데 필요한 보안 액세스 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
  </Members>
</Type>