<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="238f807decc4260faeb59f462b071f85556afa35" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/17/2019" /><Meta Name="ms.locfileid" Value="59676691" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>작업 실행, 작업 항목 게시, 비동기 I/O 처리, 다른 스레드 대신 기다리기 및 타이머 처리에 사용할 수 있는 스레드 풀을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 응용 프로그램 상당한 시간 대기 상태에서 이벤트가 발생 하기를 기다리는 소비 하는 스레드를 만듭니다. 다른 스레드는 대기 상태에 상태 정보를 업데이트 하거나 변경에 대해 폴링하는 데 주기적으로 활성화에 입력할 수 있습니다. 스레드 풀을 사용 하면 시스템에 의해 관리 되는 작업자 스레드 풀을 사용 하 여 응용 프로그램을 제공 하 여 스레드를 보다 효율적으로 사용할 수 있습니다. 스레드 풀 스레드를 사용 하는 작업의 예는 다음과 같습니다.  
  
-   만들 때를 <xref:System.Threading.Tasks.Task> 또는 <xref:System.Threading.Tasks.Task%601> 작업을 스레드 풀 스레드에서 실행 되도록 예약 되어 기본적으로 일부 작업을 비동기적으로 수행 하는 개체입니다.  
  
-   비동기 타이머 스레드 풀을 사용 합니다. 스레드 풀에서 콜백을 실행 합니다 <xref:System.Threading.Timer?displayProperty=nameWithType> 클래스에서 이벤트 발생 및는 <xref:System.Timers.Timer?displayProperty=nameWithType> 클래스입니다.  
  
-   등록 된 대기 핸들을 사용 하는 경우는 시스템 스레드가 대기 핸들의 상태를 모니터링 합니다. 대기 작업이 완료 되 면 스레드 풀에서 작업자 스레드는 해당 하는 콜백 함수를 실행 합니다.  
  
-   호출 하는 경우는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 스레드 풀 스레드에서 실행에 대 한 메서드를 큐 대기 하는 방법입니다. 메서드를 전달 하 여이 작업을 수행 하는 <xref:System.Threading.WaitCallback> 위임 합니다.   시그니처가 대리자  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     여기서 `state` 는 대리자가 사용할 데이터가 들어 있는 개체입니다. 호출 하 여 대리자에 전달할 수는 실제 데이터는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 메서드.  
  
> [!NOTE]
>  관리 되는 스레드 풀의 스레드는 백그라운드 스레드입니다. 즉, 해당 <xref:System.Threading.Thread.IsBackground%2A> 속성은 `true`합니다. 즉, 한 <xref:System.Threading.ThreadPool> 스레드 모든 포그라운드 스레드가 종료 된 후 실행 중인 응용 프로그램을 유지 하지 것입니다.  
  
> [!IMPORTANT]
>  표시 된 필드 또는 스레드 로컬 저장소의 데이터는 지우지 않습니다 때 스레드 풀 스레드를 다시는 <xref:System.ThreadStaticAttribute> 특성입니다. 메서드를 스레드 로컬 저장소를 검사 하거나 필드는 때로 표시 됩니다 따라서는 <xref:System.ThreadStaticAttribute> 특성을 찾으면 값 남게 될 수 있습니다를 통해 스레드 풀 스레드는 이전 사용 되지 않도록에서 합니다.  
  
 스레드 풀에 대기 작업과 관련 되지 않은 작업 항목을 대기 시킬 수 있습니다. 작업 항목을 스레드 풀 스레드에 의해 처리 될 요청을 호출 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드. 이 메서드는 메서드 또는 스레드 풀에서 선택한 스레드에서 호출 될 대리자에 대 한 참조를 매개 변수로 사용 합니다. 이 대기 후 작업 항목을 취소 하는 방법이 있습니다.  
  
 타이머 큐 타이머 및 등록 된 대기 작업 스레드 풀을 사용 합니다. 해당 콜백 함수는 스레드 풀에 대기 됩니다.  
  
 프로세스당 하나의 스레드 풀이 있습니다. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]부터 프로세스에 대한 스레드 풀의 기본 크기는 가상 주소 공간의 크기와 같은 여러 요인에 따라 달라집니다. 프로세스에서 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 메서드를 호출하여 스레드 수를 확인할 수 있습니다. 사용 하 여 스레드 풀의 스레드 수를 변경할 수 있습니다는 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 메서드. 기본 스택 크기를 사용 하 고 기본 우선 순위로 실행 하는 각 스레드입니다.  
  
> [!NOTE]
>  .NET Framework를 호스트 하는 관리 되지 않는 코드를 사용 하 여 스레드 풀의 크기를 변경할 수는 `CorSetMaxThreads` mscoree.h 파일에 정의 된 함수입니다.  
  
 스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다. 최소에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다. [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]부터는 스레드 풀이 시간 단위당 완료되는 작업 수로 정의된 처리량을 최적화하기 위해 작업자 스레드를 만들고 소멸시킵니다. 스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.  
  
> [!NOTE]
>  요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.  
  
 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 메서드를 사용하여 이러한 최소값을 가져올 수 있습니다.  
  
> [!CAUTION]
>  사용할 수는 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 스레드의 최소 수를 늘리려면 메서드. 그러나 이러한 값을 불필요하게 늘리면 성능 문제가 발생할 수 있습니다. 너무 많은 작업이 동시에 시작되는 경우 모두 속도가 느린 것처럼 나타날 수 있습니다. 대부분의 경우 스레드 풀은 고유한 스레드 할당 알고리즘에서 성능이 향상됩니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 응용 프로그램 스레드 큐 라는 메서드 `ThreadProc` 대기한 1 초에 한 다음 종료 스레드 풀 스레드에서 실행 합니다. `ThreadProc` 메서드 단순히 메시지를 표시 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 호출을 주석 처리 하는 경우는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드는 스레드 풀 스레드에서 실행 되기 전에 메서드를 주 스레드를 종료 합니다.  스레드 풀에는 응용 프로그램이 모든 포그라운드 스레드가 종료 된 경우 실행을 유지 하지 않는 백그라운드 스레드를 사용 합니다.  (이것이 경합 상태의 간단한 예입니다.)  
  
 ]]></format>
    </remarks>
    <threadsafe>이 형식은 스레드로부터 안전합니다.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">스레드 및 스레딩</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리 되는 스레드 풀링</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle">핸들을 보유하는 <see cref="T:System.IntPtr" />입니다. 핸들은 관리되지 않는 쪽의 겹쳐진 I/O에 열려 있어야 합니다.</param>
        <summary><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</summary>
        <returns>핸들이 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">운영 체제 핸들을 보유하는 <see cref="T:System.Runtime.InteropServices.SafeHandle" />입니다. 핸들은 관리되지 않는 쪽의 겹쳐진 I/O에 열려 있어야 합니다.</param>
        <summary><see cref="T:System.Threading.ThreadPool" />에 운영 체제 핸들을 바인딩합니다.</summary>
        <returns>핸들이 바인딩되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` 매개 변수를 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, 추상에서 파생 되는 <xref:System.Runtime.InteropServices.SafeHandle> 클래스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" />가 <see langword="null" />입니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 수 있습니다. 연관된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">사용 가능한 작업자 스레드 수입니다.</param>
        <param name="completionPortThreads">사용 가능한 비동기 I/O 스레드 수입니다.</param>
        <summary><see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 메서드에서 반환하는 최대 스레드 풀 스레드 수와 현재 활성 상태인 스레드 수의 차이를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 에 지정 된 변수는 반환 `workerThreads` 시작할 수 있는 추가 작업자 스레드 및 변수에서 지정한 수가 포함 `completionPortThreads` 포함 될 수 있는 추가 비동기 I/O 스레드 수 시작 합니다.  
  
 사용 가능한 스레드가 없는 경우 스레드 풀 스레드가 사용 가능 해질 때까지 추가 스레드 풀 요청이 큐에 대기 중인 상태로 유지 합니다.  
  
   
  
## Examples  
 다음 예제에서는 간단한 앱이 시작 될 때 작업자 스레드 및 사용할 수 있는 I/O 스레드 수를 표시 합니다.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">스레드 풀에 있는 최대 작업자 스레드 수입니다.</param>
        <param name="completionPortThreads">스레드 풀에 있는 최대 비동기 I/O 스레드 수입니다.</param>
        <summary>동시에 활성 상태가 될 수 있는 스레드 풀에 대한 요청 수를 검색합니다. 해당 개수를 초과하는 모든 요청은 스레드 풀 스레드가 사용 가능해질 때까지 큐에 대기 상태로 남아 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 에 지정 된 변수는 반환 `workerThreads` 최대 스레드 풀에 허용 된 작업자 스레드 및 지정 된 변수를 포함 `completionPortThreads` 에서 허용 하는 비동기 I/O 스레드의 최대 수를 포함 합니다 스레드 풀입니다.  
  
 사용할 수는 <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> 특정된 시점에 실제 스레드 풀의 스레드 수를 결정 하는 방법입니다.  
  
 사용할 수는 <xref:System.Threading.ThreadPool.SetMaxThreads%2A> 스레드 풀에서 최대 작업자 스레드 및 비동기 I/O 스레드 수를 설정 합니다.  
  
 시스템 메모리에서 허용 하는 만큼 스레드 풀 요청 큐 수 있습니다. 스레드 풀 스레드 보다 더 많은 요청이 없으면 스레드 풀 스레드가 사용 가능 해질 때까지 추가 요청은 큐에 대기 중인 상태로 유지 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 스레드 풀의 스레드의 최대 및 사용 가능한 수의 개수를 검색 하는 방법을 보여 줍니다. 작업 항목을 큐에 대기 되는 `FileStream` 비동기적으로 두 개의 파일에 쓸 수 있습니다. 콜백 메서드는 겹치는 시간이 되었습니다. 작업자 스레드가 작업 항목을 처리 하 고 속도 및 컴퓨터의 프로세서 수에 따라 하나 또는 두 개의 완료 포트 스레드 쓰기 작업을 처리 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">이 메서드가 반환될 때 스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수가 포함됩니다.</param>
        <param name="completionPortThreads">이 메서드가 반환될 때 스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수가 포함됩니다.</param>
        <summary>스레드 생성 및 소멸을 관리하기 위한 알고리즘으로 전환하기 전에 새 요청에 따라 스레드 풀이 만드는 스레드의 최소 개수를 검색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다. 기본적으로 최소 스레드 수는 시스템에서 프로세서의 수 설정 됩니다. 최소값에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다. 부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 스레드 풀을 만들고 시간 단위당 완료 하는 작업의 수로 정의 된 처리량을 최적화 하기 위해 스레드를 제거 합니다. 스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.  
  
> [!NOTE]
>  요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 작업자 스레드의 최소 수를 4 개로 설정 하 고 최소 비동기 I/O 완료 스레드 수에 대 한 원래 값을 유지 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>실행을 위해 메서드를 큐에 대기시킵니다. 이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">실행할 메서드를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</param>
        <summary>실행을 위해 메서드를 큐에 대기시킵니다. 이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</summary>
        <returns>메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큐에 대기 중인된 메서드에는 메서드가 정의 된 하거나 사용할 수는 클래스의 인스턴스 필드에 필요한 데이터를 배치할 수 있습니다는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> 필요한 데이터를 포함 하는 개체를 받아들이는 오버 로드 합니다.  
  
> [!NOTE]
>  Visual Basic 사용자를 생략할 수는 <xref:System.Threading.WaitCallback> 생성자 및 사용할 합니다 `AddressOf` 콜백 메서드를 전달 하는 경우 연산자 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>합니다. Visual Basic에는 자동으로 올바른 대리자 생성자를 호출합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0에에서는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> 으로 표현 되는 작업을 큐에 메서드 오버 로드는 `ThreadProc` 스레드 사용 가능 해지면 실행 방법. 작업 정보가 없습니다이 오버 로드를 사용 하 여 제공 됩니다. 사용할 수 있는 정보를 따라서는 `ThreadProc` 메서드는 메서드가 속하는 개체를 제한 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.NotSupportedException">CLR(공용 언어 런타임)이 호스팅되며 호스트에서 이 작업을 지원하지 않는 경우</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">실행할 메서드를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</param>
        <param name="state">메서드에서 사용할 데이터가 들어 있는 개체입니다.</param>
        <summary>실행을 위해 메서드를 큐에 대기시키고 메서드에서 사용할 데이터가 들어 있는 개체를 지정합니다. 이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</summary>
        <returns>메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 콜백 메서드는 복잡 한 데이터에 필요한 경우에 데이터를 포함 하는 클래스를 정의할 수 있습니다.  
  
> [!NOTE]
>  Visual Basic 사용자를 생략할 수는 <xref:System.Threading.WaitCallback> 생성자 및 사용할 합니다 `AddressOf` 콜백 메서드를 전달 하는 경우 연산자 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>합니다. Visual Basic에는 자동으로 올바른 대리자 생성자를 호출합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0에에서는 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는.NET 스레드 풀을 사용 하 여 계산 된 `Fibonacci` 20에서 40 사이의 숫자를 다섯 개에 대 한 결과입니다. 각 `Fibonacci` 결과는 계산을 수행하는 `ThreadPoolCallback`이라는 메서드를 제공하는 `Fibonacci` 클래스로 표현됩니다. 각 `Fibonacci` 값을 나타내는 개체가 생성되고 `ThreadPoolCallback` 메서드가 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>에 전달되면, 여기서 풀에서 사용 가능한 스레드를 할당하여 메서드를 실행합니다.  
  
 때문에 각 `Fibonacci` 개체 계산을 위해 어느 정도 임의적인 값이 지정 되 고 각 스레드가 프로세서 시간에 대 한 경쟁을 하기 때문에 모든 5 개 결과 계산할 걸리는 기간을 미리 알 수 없습니다. 이 때문에 생성 중 각 `Fibonacci` 개체에 <xref:System.Threading.ManualResetEvent> 클래스 인스턴스가 전달됩니다. 각 개체에 제공 된 이벤트 개체 신호 해당 계산이 완료 되 면, 기본 스레드를 사용 하 여 실행을 차단할 수 있습니다 <xref:System.Threading.WaitHandle.WaitAll%2A> 모든 5 개까지 `Fibonacci` 결과 계산할 개체입니다. 그런 다음 `Main` 메서드가 각 `Fibonacci` 결과를 표시합니다.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">CLR(공용 언어 런타임)이 호스팅되며 호스트에서 이 작업을 지원하지 않는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" />의 요소 형식입니다.</typeparam>
        <param name="callBack">실행할 메서드를 나타내는 <see cref="T:System.Action`1" />입니다.</param>
        <param name="state">메서드에서 사용할 데이터가 들어 있는 개체입니다.</param>
        <param name="preferLocal">다른 QueueUserWorkItem 메서드와 달리, 글로벌 스레드 풀이 아니라 로컬 스레드 풀에서 실행됩니다.</param>
        <summary>실행을 위해 <see cref="T:System.Action`1" /> 대리자에 의해 지정된 메서드를 큐에 대기시키고 메서드에서 사용할 데이터를 제공합니다. 이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</summary>
        <returns>메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</param>
        <param name="state">대리자에 전달되는 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 있는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</summary>
        <returns>기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다. 작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.  
  
-   지정된 된 개체가 신호를 받은 상태입니다.  
  
-   시간 제한 간격이 경과 합니다.  
  
 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다. 개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다. 대기 작업을 스레드 풀의 스레드에서 수행 됩니다. 대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다. 경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.  
  
> [!IMPORTANT]
>  사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다. 대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.  
  
 대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.  
  
 대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다. 따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다. 전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.  
  
 함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다. 신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다. 예를 들어, 세마포 수가 1 씩 감소 합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</param>
        <param name="state">대리자에 전달된 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 있는 64비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</summary>
        <returns>기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다. 작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.  
  
-   지정된 된 개체가 신호를 받은 상태입니다.  
  
-   시간 제한 간격이 경과 합니다.  
  
 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다. 개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다. 대기 작업을 스레드 풀의 스레드에서 수행 됩니다. 대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다. 경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.  
  
> [!IMPORTANT]
>  사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다. 대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.  
  
 대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.  
  
 대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다. 따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다. 전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.  
  
 함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다. 신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다. 예를 들어, 세마포 수가 1 씩 감소 합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</param>
        <param name="state">대리자에 전달된 개체입니다.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />으로 나타낸 제한 시간입니다. <paramref name="timeout" />이 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="timeout" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간에 <see cref="T:System.Threading.WaitHandle" /> 값을 지정하여 <see cref="T:System.TimeSpan" />을 기다리는 대리자를 등록합니다.</summary>
        <returns>기본 핸들을 캡슐화하는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다. 작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.  
  
-   지정된 된 개체가 신호를 받은 상태입니다.  
  
-   시간 제한 간격이 경과 합니다.  
  
 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다. 개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다. 대기 작업을 스레드 풀의 스레드에서 수행 됩니다. 대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다. 경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.  
  
> [!IMPORTANT]
>  사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다. 대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.  
  
 대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.  
  
 대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다. 따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다. 전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.  
  
 함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다. 신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다. 예를 들어, 세마포 수가 1 씩 감소 합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 매개 변수가 -1보다 작습니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> 매개 변수가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 <see cref="T:System.Threading.WaitOrTimerCallback" /> 대리자입니다.</param>
        <param name="state">대리자에 전달된 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 없는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다.</summary>
        <returns>등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 대리자를 스레드 풀 큐입니다. 작업자 스레드는 다음 중 하나가 발생 하면 대리자를 실행 합니다.  
  
-   지정된 된 개체가 신호를 받은 상태입니다.  
  
-   시간 제한 간격이 경과 합니다.  
  
 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드는 지정된 된 개체의 현재 상태를 확인 <xref:System.Threading.WaitHandle>합니다. 개체의 상태를 신호 받음 없으면 메서드는 대기 작업을 등록 합니다. 대기 작업을 스레드 풀의 스레드에서 수행 됩니다. 대리자는 개체의 상태를 신호 또는 시간 제한 간격이 경과 하는 경우 작업자 스레드에 의해 실행 됩니다. 경우는 `timeOutInterval` 매개 변수가 아닌 0 (영) 및 `executeOnlyOnce` 매개 변수는 `false`, 이벤트 신호를 받는 되거나 시간 제한 간격이 경과 될 때마다 타이머가 다시 설정 됩니다.  
  
> [!IMPORTANT]
>  사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다. 대신를 <xref:System.Threading.Mutex>를 사용 하 여는 <xref:System.Threading.Semaphore> 1의 최대 수.  
  
 대기 작업을 취소 하려면 호출을 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드.  
  
 대기 스레드가 Win32를 사용 하 여 `WaitForMultipleObjects` 함수 등록 된 대기 작업을 모니터링 합니다. 따라서에서 동일한 네이티브 운영 체제 핸들을 사용 해야 하는 경우를 여러 번 호출 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, Win32를 사용 하 여 핸들을 복제 해야 `DuplicateHandle` 함수입니다. 전달할 이벤트 개체를 펄스 하지는 확인 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>이므로 대기 스레드에서 다시 설정 되기 전에 이벤트가 신호를 감지 하지 못할 수 있습니다.  
  
 함수가 반환 되기 전에 일부 유형의 동기화 개체의 상태를 수정 합니다. 신호를 받은 상태로 인해 대기 조건이 충족된 하는 개체에 대해서만 수정이 발생 합니다. 예를 들어, 세마포 수가 1 씩 감소 합니다.  
  
## <a name="version-information"></a>버전 정보  
 .NET Framework 버전 2.0부터 합니다 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> 속성 값은 작업자 스레드에 전파를 사용 하 여 큐에 대기는 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드. 이전 버전에서 주체 정보를 전파 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법의 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 지정한 대기 핸들이 신호를 받을 때 지정된 된 콜백 메서드를 실행 하는 방법입니다. 이 예제에서는 콜백 메서드는 `WaitProc`, 및 대기 핸들은는 <xref:System.Threading.AutoResetEvent>합니다.  
  
 이 예제에서는 정의 `TaskInfo` 실행 될 때 콜백에 전달 되는 정보를 보유 하는 클래스입니다. 이 예에서는 만듭니다는 `TaskInfo` 개체 및 문자열 데이터를 할당 합니다. <xref:System.Threading.RegisteredWaitHandle> 에서 반환 하는 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 에 메서드가 할당 됩니다는 `Handle` 필드를 `TaskInfo` 콜백 메서드가에 액세스할 수 있도록 개체를 <xref:System.Threading.RegisteredWaitHandle>.  
  
 지정 하는 것 외에도 `TaskInfo` 콜백 메서드 호출에 전달할 개체로 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 지정는 <xref:System.Threading.AutoResetEvent> 에 대 한 작업에서 대기 하는 <xref:System.Threading.WaitOrTimerCallback> 나타내는 대리자입니다는 `WaitProc` 콜백 메서드를 1 초 제한 시간 간격 및 여러 콜백 합니다.  
  
 주 스레드가 신호 하는 경우는 <xref:System.Threading.AutoResetEvent> 호출 하 여 해당 <xref:System.Threading.EventWaitHandle.Set%2A> 메서드를를 <xref:System.Threading.WaitOrTimerCallback> 대리자가 호출 합니다. 합니다 `WaitProc` 메서드를 테스트 <xref:System.Threading.RegisteredWaitHandle> 제한 시간에 발생 한 것인지 확인 합니다. 대기 핸들 신호가 전달 되어 콜백이 호출 되는 경우는 `WaitProc` 메서드를 등록 취소를 <xref:System.Threading.RegisteredWaitHandle>, 콜백을 추가 중지 합니다. 시간 제한의 경우 작업이 계속 대기 합니다. `WaitProc` 메서드가 콘솔에 메시지를 인쇄 하 여 종료 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">스레드 풀에 있는 최대 작업자 스레드 수입니다.</param>
        <param name="completionPortThreads">스레드 풀에 있는 최대 비동기 I/O 스레드 수입니다.</param>
        <summary>동시에 활성 상태가 될 수 있는 스레드 풀에 대한 요청 수를 설정합니다. 해당 개수를 초과하는 모든 요청은 스레드 풀 스레드가 사용 가능해질 때까지 큐에 대기 상태로 남아 있습니다.</summary>
        <returns>성공적으로 변경되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정할 수 없습니다 최대 작업자 스레드 또는 I/O 완료 스레드 수는 컴퓨터의 프로세서 수보다 작은 합니다. 얼마나 많은 프로세서를 사용할 수 있는지를 확인 하려면 값을 검색 합니다 <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> 속성입니다. 또한 최대 작업자 스레드 또는 작업자 스레드의 해당 최소 값 보다 작은 수로 I/O 완료 스레드 또는 I/O 완료 스레드를 설정할 수 없습니다. 최소 스레드 풀 크기를 확인 하려면 호출을 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 메서드.  
  
 공용 언어 런타임 호스트 되는 경우 예를 들어 인터넷 정보 서비스 (IIS) 또는 SQL Server, 호스트 수 제한 하거나 스레드 풀 크기를 변경 하지 못하게 합니다.  
  
 스레드 풀의 스레드의 최대 수를 변경 하는 경우에 주의 해야 합니다. 코드의 이점을 얻을 수, 하는 동안 변경 내용을 코드 라이브러리 사용에 부정적인 영향이 있을 수 있습니다.  
  
 스레드 풀 크기를 너무 크게 설정 하면 성능 문제가 발생할 수 있습니다. 너무 많은 스레드를 동시에 실행 하는 경우 작업 전환 오버 헤드가 중요 한 요인이 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">스레드를 제어 하는 기능입니다. 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">스레드 풀에서 필요할 때 만드는 작업자 스레드의 최소 개수입니다.</param>
        <param name="completionPortThreads">스레드 풀에서 필요할 때 만드는 비동기 I/O 스레드의 최소 개수입니다.</param>
        <summary>스레드 생성 및 소멸을 관리하기 위한 알고리즘으로 전환하기 전에 새 요청에 따라 스레드 풀이 만드는 스레드의 최소 개수를 설정합니다.</summary>
        <returns>성공적으로 변경되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스레드 풀은 각 범주에 대 한 최소값에 도달할 때까지 주문형 새 작업자 스레드 또는 I/O 완료 스레드를 만듭니다. 최소값에 도달 하면 스레드 풀 해당 범주에 추가 스레드를 만들 수도 있고 일부 작업이 완료 될 때까지 기다립니다. 부터는 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 스레드 풀을 만들고 시간 단위당 완료 하는 작업의 수로 정의 된 처리량을 최적화 하기 위해 스레드를 제거 합니다. 스레드가 너무 적으면 사용 가능한 리소스가 효율적으로 사용되지 않는 반면, 너무 많으면 리소스 경합이 증가할 수 있습니다.  
  
 요구가 적을 때는 실제 스레드 풀 스레드 수가 최소값보다 작을 수 있습니다.  
  
 음수 또는 활성 스레드 풀 스레드의 최대 개수 보다 큰 숫자를 지정 하는 경우 (사용 하 여 가져온 <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> 반환 `false` 최소 값 중 하나를 변경 하지 않습니다.  
  
> [!CAUTION]
>  기본적으로 최소 스레드 수는 시스템에서 프로세서의 수 설정 됩니다. 사용할 수는 <xref:System.Threading.ThreadPool.SetMinThreads%2A> 스레드의 최소 수를 늘리려면 메서드. 그러나 이러한 값을 불필요하게 늘리면 성능 문제가 발생할 수 있습니다. 너무 많은 작업이 동시에 시작되는 경우 모두 속도가 느린 것처럼 나타날 수 있습니다. 대부분의 경우에서 스레드 풀 스레드 할당 알고리즘을 사용 하 여 더 잘 수행 합니다. 최소 프로세서 수가 성능 저하 될 수 있습니다 보다 작은 값으로 줄입니다.  
  
   
  
## Examples  
 다음 예제에서는 작업자 스레드의 최소 수를 4 개로 설정 하 고 최소 비동기 I/O 완료 스레드 수에 대 한 원래 값을 유지 합니다.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">스레드를 제어 하는 기능입니다. 권한 값: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">큐에 대기시킬 <see cref="T:System.Threading.NativeOverlapped" /> 구조체입니다.</param>
        <summary>실행할 중첩된 I/O 작업을 큐에 대기시킵니다.</summary>
        <returns>작업이 I/O 완료 포트 큐에 성공적으로 대기되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네이티브 Win32를 사용 하는 방법은 겹쳐진 I/O에 대 한 참조를 <xref:System.Threading.Overlapped> 클래스를 <xref:System.Threading.NativeOverlapped> 구조 및 `OVERLAPPED` Win32 플랫폼 SDK에는 구조입니다.  
  
> [!CAUTION]
>  사용 하는 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> 메서드 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, 스레드 풀 스레드 스택에 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack">스레드 풀에 있는 스레드에서 작업 항목을 선택할 때 호출되는 대리자를 나타내는 <see cref="T:System.Threading.WaitCallback" />입니다.</param>
        <param name="state">스레드 풀에서 제공할 때 대리자에 전달되는 개체입니다.</param>
        <summary>지정된 대리자를 스레드 풀에 대기시키지만 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
        <returns>메서드가 성공하면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.OutOfMemoryException" />이 발생합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리 합니다 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다. 이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.  
  
> [!CAUTION]
>  사용 하 여 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.ApplicationException">메모리가 부족한 경우</exception>
        <exception cref="T:System.OutOfMemoryException">작업 항목을 큐에 대기할 수 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" />가 <see langword="null" />입니다.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" />의 요소 형식입니다.</typeparam>
        <param name="callBack">실행할 메서드를 나타내는 대리자입니다.</param>
        <param name="state">메서드에서 사용할 데이터가 들어 있는 개체입니다.</param>
        <param name="preferLocal">로컬 스레드 풀에서 실행하려면 `true`이고, 전역 스레드 풀에서 실행하려면 `false`입니다.</param>
        <summary>실행을 위해 <see cref="T:System.Action`1" /> 대리자에 의해 지정된 메서드를 큐에 대기시키고 메서드에서 사용할 데이터가 들어 있는 개체를 지정합니다. 이 메서드는 스레드 풀 스레드를 사용할 수 있을 때 실행됩니다.</summary>
        <returns>메서드가 성공적으로 큐에 대기되면 <see langword="true" />이고, 작업 항목을 큐에 대기할 수 없으면 <see cref="T:System.NotSupportedException" />이 throw됩니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" />를 기다리도록  대리자를 등록하지만 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</param>
        <param name="state">대리자에 전달되는 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 있는 32비트 정수를 사용하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다. 이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
        <returns>등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다. 이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.  
  
> [!CAUTION]
>  사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.  
  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</param>
        <param name="state">대리자에 전달되는 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 있는 64비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다. 이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
        <returns>등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다. 이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.  
  
> [!CAUTION]
>  사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.  
  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 매개 변수가 -1보다 작습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</param>
        <param name="state">대리자에 전달되는 개체입니다.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />으로 나타낸 제한 시간입니다. <paramref name="timeout" />이 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="timeout" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간에 <see cref="T:System.Threading.WaitHandle" /> 값을 지정하여 <see cref="T:System.TimeSpan" />을 기다리는 대리자를 등록합니다. 이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
        <returns>등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다. 이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.  
  
> [!CAUTION]
>  사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.  
  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 매개 변수가 -1보다 작습니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> 매개 변수가 <see cref="F:System.Int32.MaxValue" />보다 큰 경우</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">등록할 <see cref="T:System.Threading.WaitHandle" />입니다. <see cref="T:System.Threading.Mutex" />가 아닌 <see cref="T:System.Threading.WaitHandle" />을 사용합니다.</param>
        <param name="callBack"><paramref name="waitObject" /> 매개 변수가 신호를 받으면 호출할 대리자입니다.</param>
        <param name="state">대리자에 전달되는 개체입니다.</param>
        <param name="millisecondsTimeOutInterval">제한 시간(밀리초)입니다. <paramref name="millisecondsTimeOutInterval" /> 매개 변수가 0이면 해당 함수에서 개체의 상태를 테스트한 다음 즉시 반환합니다. <paramref name="millisecondsTimeOutInterval" />이 -1이면 해당 함수의 시간 제한 간격이 경과하지 않습니다.</param>
        <param name="executeOnlyOnce"><see langword="true" />는 대리자를 호출한 후 스레드가 <paramref name="waitObject" /> 매개 변수를 더 이상 기다리지 않음을 나타내고 <see langword="false" />는 대기 작업이 완료될 때마다 타이머가 다시 설정됨을 나타냅니다.</param>
        <summary>제한 시간(밀리초)에 부호 없는 32비트 정수를 지정하여 <see cref="T:System.Threading.WaitHandle" />을 기다리는 대리자를 등록합니다. 이 메서드는 호출 스택을 작업자 스레드에 전파하지 않습니다.</summary>
        <returns>등록된 대기 작업을 취소하는 데 사용할 수 있는 <see cref="T:System.Threading.RegisteredWaitHandle" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 달리 합니다 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 메서드를 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 호출 스택을 작업자 스레드에 전파 하지 않습니다. 이렇게 하면 코드가 호출 스택을 잃게 되므로 코드를 보안 권한을 상승 시킬 수 있습니다.  
  
> [!CAUTION]
>  사용 하 여 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> 보안 문제가 무심코 열 수 없습니다. 코드 액세스 보안 스택의 모든 호출자의 권한을 해당 권한 검사를 기반합니다. 작업을 스레드 풀 스레드를 사용 하 여 대기 중인 경우 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, 스레드 풀 스레드 스택의 실제 호출자의 컨텍스트에서 없습니다. 악성 코드가 못할 권한 검사를 방지 하려면이 악용 합니다.  
  
 사용 하는 <xref:System.Threading.Mutex> 에 대 한 `waitObject` 기본 Windows API는 기본값을 사용 하므로 콜백에 대 한 상호 배제를 제공 하지 않습니다 `WT_EXECUTEDEFAULT` 플래그를 별도 스레드 풀 스레드에서 각 콜백 디스패치 됩니다.  
  
 완료 될 때 사용 하는 <xref:System.Threading.RegisteredWaitHandle> 이 메서드에서 반환 되는, 호출 해당 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 대기 핸들에 대 한 참조를 해제 하는 방법. 항상 호출 하는 것을 권장 합니다 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드를 지정 하는 경우에 `true` 에 대 한 `executeOnlyOnce`. 가비지 수집 보다 효율적으로 작동 호출 하는 경우는 <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> 메서드 대신 등록 된 대기 핸들의 종료자에 따라 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">직접 실행 호출자에 대 한 완전 신뢰가 필요 합니다. 이 멤버는 부분적으로 신뢰할 수 있는 또는 투명 코드에서 사용할 수 없습니다.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">관리되는 스레드 풀</related>
      </Docs>
    </Member>
  </Members>
</Type>