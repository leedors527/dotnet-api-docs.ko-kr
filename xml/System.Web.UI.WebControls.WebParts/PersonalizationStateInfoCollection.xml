<Type Name="PersonalizationStateInfoCollection" FullName="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a426857eb6f687609069d34b0ff762a104da6dbd" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55386723" /></Metadata><TypeSignature Language="C#" Value="public sealed class PersonalizationStateInfoCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PersonalizationStateInfoCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PersonalizationStateInfoCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationStateInfoCollection sealed : System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type PersonalizationStateInfoCollection = class&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo" /> 및 <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> 개체의 컬렉션을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> 세트에 대 한 컬렉션 기반 래퍼를 제공 하는 클래스 <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> 고 <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> 인스턴스. 이러한 인스턴스 컬렉션을 순차적으로 반복 하 여, 서 수 인덱스 또는 키 값으로 검색 됩니다.  
  
 인스턴스 경로 및 사용자 이름의 조합에 따라 인덱싱됩니다. 이 작업이 필요 하므로 <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> 에 따라 공유 데이터를 나타내는 인스턴스 인덱싱됩니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> 개체인 반면 <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> 인스턴스 둘 다에 따라 인덱싱됩니다를 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A> 개체 및 <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A> 개체입니다.  
  
 정보 개체는 공급자 로부터 수신 된 순서에 컬렉션에 유지 됩니다. 컬렉션 인스턴스의 순서를 변경 하거나 컬렉션에서 특정 정렬 순서를 유지 관리 하지 않습니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PersonalizationStateInfoCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PersonalizationStateInfoCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자는 빈 컬렉션을 초기화합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (data As PersonalizationStateInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo -&gt; unit" Usage="personalizationStateInfoCollection.Add data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" />
      </Parameters>
      <Docs>
        <param name="data">추가할 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 파생 인스턴스입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 파생 인스턴스를 컬렉션의 끝에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 추가 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-컬렉션의 끝에 파생 인스턴스입니다. 내부적으로 컬렉션 수가 1 씩 증가 합니다. 컬렉션에 대해 현재 활성 상태인 모든 열거자는 무효화 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">컬렉션이 읽기 전용으로 표시되었습니다.</exception>
        <exception cref="T:System.ArgumentException">컬렉션에 이미 공유 상태 또는 사용자별 상태가 동일한 인스턴스가 있지만 컬렉션에 개체를 추가하려고 했습니다.</exception>
        <exception cref="T:System.ArgumentNullException">데이터 매개 변수가 null입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="personalizationStateInfoCollection.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 항목 컬렉션을 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션에 대해 현재 활성 상태인 모든 열거자는 무효화 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">컬렉션이 읽기 전용으로 표시되었습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo(System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As PersonalizationStateInfo(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[] * int -&gt; unit" Usage="personalizationStateInfoCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateInfo[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">컬렉션의 요소가 복사되는 배열입니다.</param>
        <param name="index">복사 작업을 시작할 위치입니다.</param>
        <summary>지정된 위치부터 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> 컬렉션의 요소를 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 배열에 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들려는 경우이 메서드를 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> 배열입니다. 이 메서드를 호출 합니다 <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> 메서드와 전달을 `array` 및 `index` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컬렉션의 항목 수를 가져옵니다.</summary>
        <value>컬렉션의 항목 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 항목 수가 예제와 같이 컬렉션을 반복 하 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count%2A> 속성입니다.  
  
 [!code-csharp[WebParts_PersAdmin#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_PersAdmin/CS/PersAdmin.ascx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="personalizationStateInfoCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션 전체를 반복할 수 있는 표준 열거자를 반환합니다. 이 메서드는 상속될 수 없습니다.</summary>
        <returns>컬렉션에서 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.IEnumerator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열거자를 사용하여 컬렉션의 데이터를 읽을 수는 있지만 내부 컬렉션을 수정할 수는 없습니다.  
  
 처음에 열거자는 컬렉션의 첫 번째 요소 앞에 배치됩니다. <xref:System.Collections.IEnumerator.Reset%2A> 메서드 또한 다시이 위치로 열거자를 가져옵니다. 이 위치에 <xref:System.Collections.IEnumerator.Current%2A> 속성 정의 되지 않습니다. 따라서 호출 해야 합니다 <xref:System.Collections.IEnumerator.MoveNext%2A> 해당 열거자의 값을 읽기 전에 컬렉션의 첫 번째 요소를 이동 하는 방법 <xref:System.Collections.IEnumerator.Current%2A>합니다. 열거자에 대 한 자세한 내용은 참조 하세요. <xref:System.Collections.IEnumerator>합니다.  
  
 열거자는 컬렉션이 변경되지 않은 상태로 유지되는 한 유효한 상태를 유지합니다. 컬렉션에 대해 변경 내용을 수행하면(예: 요소 추가, 수정 또는 삭제) 열거자는 복구 불가능하게 무효화되고 해당 동작은 정의되지 않습니다.  
  
 @FSHO1@C# 언어의 `foreach` 문(Visual Basic의 경우 `for each`)은 열거자의 복잡성을 숨깁니다. 그러므로 열거자를 직접 조작하는 대신 `foreach`를 사용하는 것이 좋습니다.  
  
 열거자는 컬렉션에 배타적으로 액세스하지 못하므로 컬렉션을 열거하는 것은 본질적으로 스레드로부터 안전한 프로시저가 아닙니다. 열거 동안 스레드 보안을 보장하려면 전체 열거 동안 컬렉션을 잠그면 됩니다. 여러 스레드에서 컬렉션에 액세스하여 읽고 쓸 수 있도록 허용하려면 사용자 지정 동기화를 구현해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> 컬렉션에 대한 액세스가 동기화되는지 즉, 스레드로부터 안전하게 보호되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>컬렉션에 대한 액세스가 동기화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 웹 파트 컨트롤 집합에서 만든 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> 개체의 경우 값이 항상 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> 속성은 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection>에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 반환합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 매개 변수에 기반하여 컬렉션에서 요소를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[int] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">검색할 개체의 서수 인덱스입니다.</param>
        <summary>컬렉션에서 지정된 서수 인덱스에 해당하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 인스턴스를 가져옵니다.</summary>
        <value>컬렉션에서 지정된 서수 인덱스에 해당하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 검색 합니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo> 인스턴스 컬렉션에서 지정 된 서 수 인덱스 위치입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />가 0보다 작은 경우  
  
또는 
 <paramref name="index" />가 <see cref="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Count" />보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.PersonalizationStateInfo this[string path, string username] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfo Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(path As String, username As String) As PersonalizationStateInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ default[System::String ^, System::String ^] { System::Web::UI::WebControls::WebParts::PersonalizationStateInfo ^ get(System::String ^ path, System::String ^ username); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">검색할 개인 설정 상태 개체의 상대 애플리케이션 경로입니다.</param>
        <param name="username">검색할 <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> 개체의 사용자 이름입니다.</param>
        <summary>지정된 매개 변수에 기반하여 컬렉션에서 요소를 가져옵니다.</summary>
        <value>지정된 매개 변수에 기반한 컬렉션의 요소입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 컬렉션에 대 한 기본 인덱서. 경우에 `path` 속성을 반환 합니다. 제공 된를 <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> 인스턴스. 모두 `path` 및 `username` 속성을 반환 합니다. 제공 되는 <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> 조합에 대 한 인스턴스 `path` 및 `username`.  
  
 경우 `path` (경우에는 `username` 로 설정 됩니다 `null`) 존재 하지 않는 경우 `username` 및 `path` 존재 하지 않는 `null` 반환 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string path, string username);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string path, string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (path As String, username As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ path, System::String ^ username);" />
      <MemberSignature Language="F#" Value="member this.Remove : string * string -&gt; unit" Usage="personalizationStateInfoCollection.Remove (path, username)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">제거할 개인 설정 상태 개체의 상대 애플리케이션 경로입니다.</param>
        <param name="username">제거할 <see cref="T:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo" /> 파생 개체의 사용자 이름입니다.</param>
        <summary>컬렉션에서 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 파생 개체를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드로 제거 되는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>-컬렉션에서 파생 되는 인스턴스입니다. 제거 된 인스턴스 다음 요소가 하나라도 빈 위치를 차지 하도록 위로 이동 합니다. 내부적으로 컬렉션 수가 1 씩 감소 됩니다. 컬렉션에 대해 현재 활성 상태인 모든 열거자는 무효화 됩니다.  
  
 경우에 `path` 제공 되는 <xref:System.Web.UI.WebControls.WebParts.SharedPersonalizationStateInfo> 해당 경로가 제거 됩니다에 대 한 인스턴스. 둘 다 `path` 및 `username` 제공 되는 <xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo> 조합에 대 한 인스턴스 `path` 및 `username` 제거 됩니다.  
  
> [!NOTE]
>  컬렉션에서 존재 하지 않는 항목을 제거 하려고 시도할 수 있습니다. 이 작업에는 예외가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">컬렉션이 읽기 전용으로 표시되었습니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 null인 경우  
  
또는 
두 매개 변수 모두 null인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="public void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReadOnly();" />
      <MemberSignature Language="F#" Value="member this.SetReadOnly : unit -&gt; unit" Usage="personalizationStateInfoCollection.SetReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컬렉션을 읽기 전용으로 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 와 같은 읽기 전용 컬렉션을 수정 하려고 하는 메서드 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Add%2A> 하 고 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.Remove%2A>, throw를 <xref:System.NotSupportedException> 예외입니다.  
  
> [!NOTE]
>  호출할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SetReadOnly%2A> 메서드 컬렉션에 대해 여러 번; 예외가 발생 하지이 그러면 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" /> 인스턴스에 대한 액세스를 동기화하는 데 사용할 수 있는 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />에 대한 액세스를 동기화하는 데 사용할 수 있는 개체입니다. 웹 파트 컨트롤 집합은 현재 컬렉션 개체에 대한 참조를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션 전체를 열거하는 프로시저는 기본적으로 스레드로부터 안전하지 않습니다. 컬렉션이 동기화되어 있을 때 다른 스레드에서 해당 컬렉션을 수정할 수 있으므로 이렇게 되면 열거자에서 예외가 throw됩니다. 열거하는 동안 스레드로부터 안전을 보장하려면 전체 열거를 수행하는 동안 컬렉션을 잠그거나 다른 스레드에서 변경된 내용으로 인해 발생한 예외를 catch하면 됩니다.  
  
 파생된 클래스에는 자체 동기화 버전을 사용 하 여 컬렉션을 제공할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> 속성입니다. 동기화 하는 코드에서 작업을 수행 해야 합니다 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.SyncRoot%2A> 컬렉션 자체에서 직접 컬렉션의 합니다. 이렇게 하면 다른 개체에서 파생되는 컬렉션에 대해 적절한 작업이 수행됩니다. 특히 컬렉션 인스턴스를 동시에 수정할 수 있는 다른 스레드와 적절한 동기화가 유지됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 개체의 컬렉션이 복사될 배열입니다.</param>
        <param name="index"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 개체를 복사하기 시작할 <paramref name="array" />의 지점입니다.</param>
        <summary>기본 <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" /> 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 같은 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection> 클래스의 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection.CopyTo%2A> 메서드를 호출 합니다 <xref:System.Collections.ArrayList.CopyTo%2A?displayProperty=nameWithType> 메서드와 전달을 `array` 및 `index` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="M:System.Collections.ArrayList.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>