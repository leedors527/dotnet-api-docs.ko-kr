<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="447b59226991f146bb5bc23c2a9103a7bf6ed612" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59350160" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>웹 파트 컨트롤 집합의 중심 클래스로 사용되며, 웹 파트 컨트롤, 기능 및 웹 페이지에서 발생하는 이벤트를 모두 관리합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 허브 또는 제어 센터 웹 파트 응용 프로그램의 역할입니다. -한 개의-해야<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 웹 파트 컨트롤을 사용 하는 모든 페이지에서 컨트롤 인스턴스입니다. 웹 파트 응용 프로그램의 대부분의 측면에서와 마찬가지로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인증 된 사용자만 작동 합니다. 해당 기능에서 상속 되는 웹 파트 영역 내에 있는 서버 컨트롤과 거의 완전히 작동 하는 또한는 <xref:System.Web.UI.WebControls.WebParts.WebZone> 클래스입니다. 거의 웹 파트 기능 또는 상호 작용 페이지에서 이러한 영역 외부에 상주 하는 서버 컨트롤 수를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 페이지에 웹 파트 기능에 대 한 허브로의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 종류의 다음 표에 설명 된 작업을 수행 합니다.  
  
|작업 범주|컨트롤의 용도|  
|-------------------|---------------------------|  
|웹 파트 컨트롤을 추적|페이지의 컨트롤을 비롯 한 웹 파트 기능을 제공 하는 다양 한 종류의 추적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 연결, 영역 및 기타.|  
|웹 파트 컨트롤 추가 및 제거|추가, 삭제 및 닫기에 대 한 메서드를 제공 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지의 컨트롤입니다.|  
|연결 관리|컨트롤 간의 연결을 만들고 추가 및 제거 프로세스 뿐만 아니라 연결을 모니터링 합니다.|  
|컨트롤 및 페이지를 개인 설정|사용자가 페이지에서 다른 위치로 컨트롤을 이동할 수 있으며 모양, 속성 및 컨트롤의 동작을 사용자가 편집할 수 있는 뷰를 실행 합니다. 각 페이지에 대 한 사용자별 개인 설정을 유지합니다.|  
|다른 페이지 보기를 전환|사용자가 페이지 레이아웃을 변경 하거나 편집 컨트롤 등의 특정 태스크를 수행할 수 있도록 페이지의 다른 특수 한 보기 사이에서 페이지를 전환 합니다.|  
|웹 파트 수명 주기 이벤트를 발생 시키기|컨트롤 추가 될 때, 이동, 연결 또는 삭제와 같은 웹 파트 컨트롤의 수명 주기 이벤트를 처리할 수 있도록 개발자 및 발생을 정의 합니다.|  
|컨트롤의 가져오기 및 내보내기를 사용 하도록 설정|속성의 상태를 포함 하는 XML 스트림을 내보냅니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤과 다른 페이지 또는 사이트에서 복잡 한 컨트롤을 개인 설정에 편의 위해 파일을 가져올 수 있습니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스에는 다양 한 속성입니다. 와 일치 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다양 한 웹 파트 컨트롤 또는 기타 특수 한 웹 파트 개체의 컬렉션을 참조 하는 속성 있기 다른 컨트롤을 추적 하는 역할을 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성을 사용 하는 모든 컬렉션을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 해당 추적 및 기타 컨트롤 관리 작업입니다.  
  
 속성의 다른 그룹은 웹 파트 응용 프로그램에서 발생 하는 특정 시나리오에 적용 되는 사용자 지정 가능한 경고를 포함 합니다. 여기에 포함 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스는 대부분의 웹 서버 컨트롤에서 사용 되는 해당 기본 상속 된 속성 중 일부를 재정의 합니다. 여기에 포함 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성.  
  
 마지막으로, 반드시 속성 그룹을 응용 프로그램의 현재 상태에 액세스 하는 데 유용 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성 페이지에 있는 현재 표시 모드를 나타냅니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 속성 컨트롤을 사용자 수 있는 다양 한 기능을 사용 하 여 브라우저 또는 해제 스크립트 있는 경우와 관련이 있는 클라이언트 쪽 스크립트를 렌더링할지 허용 되는지 여부를 나타냅니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성은 다양 한 확장성 사례에 사용 되는 중요 한 웹 파트 메서드 호출을 포함 하는 유틸리티 클래스를 참조 하는 데 유용 합니다. 별도 클래스에서 이러한 메서드 호출을 숨겨 (합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 클래스), <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스의 자체 API가 간소화 됩니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 해당 데이터를 영구 저장소를 유지 및 사용자의 개인 설정을 저장 하는 개인 설정 개체에 대 한 액세스를 제공 합니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성을 나타내는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용자 또는 응용 프로그램 페이지에서 컨트롤의 현재 선택 되어 있습니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성을 나타냅니다 여부를 사용자 지정 개인 설정 데이터를를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 변경 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 5 컨트롤에 기본 제공 디스플레이 모드 또는 웹 페이지의 보기입니다. 개발자가 확장할 수 있습니다이 기능을 사용자 지정 디스플레이 모드와 같은 형식을 확장 하 여 만드는 합니다 <xref:System.Web.UI.WebControls.WebParts.WebZone> 클래스 또는 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 클래스입니다. 사용자는 지정된 된 디스플레이 모드에 해당 하는 컨트롤의 적절 한 종류 페이지에 있는 페이지에 다양 한 디스플레이 모드를 전환할 수 있습니다.  
  
> [!NOTE]
>  사용자 페이지에 해당 하는 영역을 하지 않고도 사용자 지정 디스플레이 모드를 전환할 수 있도록이 기능을 확장 하는 것이 가능 합니다. 그러나 기본 동작은 디스플레이 모드 영역에 해당 합니다.  
  
 표준 디스플레이 모드의 공용 필드로 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다. 다음 표에서 필드 및 참조 하는 디스플레이 모드입니다. 페이지의 현재 표시 모드를 위에서 설명한 것 처럼 항상 참조에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성과 페이지에 있는 영역의 종류에 따라 해당 특정 페이지에서 사용할 수 있는 디스플레이 모드의 집합에 포함 된를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
|필드|세부 정보를 표시 모드|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|웹 페이지의 일반 사용자 보기 기본 및 가장 일반적인 디스플레이 모드입니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|사용자를 다시 정렬할 수 또는 페이지 레이아웃을 변경 하려면 컨트롤을 삭제 하는 뷰.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|편집 사용자 인터페이스 (UI)는 표시 되는 보기 사용자는 모양, 속성 및 표준 찾아보기 모드로 표시 되는 컨트롤의 동작을 편집할 수 있습니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|뷰는 카탈로그 UI가 표시 사용자의 사용 가능한 컨트롤 카탈로그에서 페이지에 컨트롤을 추가할 수 있습니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|연결 UI가 표시 되는 뷰로 사용자 연결, 관리 또는 컨트롤 간의 연결을 끊을 수 있습니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 수의 웹 파트 페이지 및 컨트롤의 수명 주기에서 중요 한 이벤트를 포함 합니다. 이러한 이벤트는 웹 파트 컨트롤의 동작을 보다 정밀 하 게 프로그래밍 방식 제어를 제공합니다. 대부분의 메서드를 직접 관련 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 또는 사용자 컨트롤에 있는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 처럼 동작할 수 있도록 영역 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤). 그러나 몇 가지 이벤트를 페이지 또는 페이지에는 연결의 상태와 관련이 있습니다. 다음 표에서 사용 가능한 이벤트를 나열 하 고 해당 용도 요약 합니다.  
  
> [!NOTE]
>  표에 모든 경우에 "컨트롤" 이라는 단어에 의미를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 또는 영역에 있고 래핑되는 서버 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임에 개체입니다.  
  
|이벤트|설명|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|컨트롤이 있는 권한이 있는지 확인 하려면 페이지에 추가 되는 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|페이지에 모든 연결이 활성화 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|페이지의 모든 연결을 활성화 하는 프로세스 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|페이지의 현재 디스플레이 모드가 변경 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|페이지의 디스플레이 모드를 변경 하는 과정 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|컨트롤의 선택 취소 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|컨트롤의 선택이 취소 프로세스 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|영역에 컨트롤을 추가한 후에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|영역에 컨트롤을 추가 하는 프로세스 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|컨트롤을 닫힌 후 (페이지에서 제거 됨) 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|컨트롤을 닫는 프로세스 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|동적 컨트롤 (하나는 프로그래밍 방식으로 생성 되었거나 카탈로그에서 추가 된) 인스턴스의 영구적으로 삭제 되 면 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|동적 컨트롤을 삭제 하는 바로 전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|해당 영역 내에서 또는 다른 영역으로 컨트롤이 이동 된 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|프로세스 컨트롤을 이동 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|연결에 참여 하도록 선택 된 두 개의 연결을 설정한 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|두 컨트롤을 연결 하는 프로세스 하기 직전에 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|두 개의 연결 된 컨트롤의 연결이 끊어진 후 발생 합니다.|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|두 개의 연결을 끊는 프로세스 하기 직전에 발생 합니다.|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에는 웹 파트 페이지를 관리 하기 위한 다양 한 메서드가 있습니다. 다양 한 메서드를 여기에 나열 되지 가지가 이름이의 형태로*EventName*합니다. 이러한 메서드는 일반적으로 관련 된 이벤트를 발생 시키는 및 형식의 처리기를 사용 하 여 이벤트를 제공 <xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>합니다. 상속 하는 개발자도 이러한 메서드의 대부분을 재정의할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다. 또한 페이지 개발자는 이러한 메서드를 사용 하 여 연결 된 이벤트에 대 한 사용자 지정 처리기를 제공할 수 있습니다. 예의 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트 페이지 개발자 추가할 수는 `OnWebPartAdded` 특성을 `<asp:webpartmanager>` 요소에서 이벤트에 대 한 사용자 지정 처리를 위해 특성 이름을 사용자 지정 메서드는 웹 페이지 및 할당 합니다. 특성에 해당 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드를 처리 하는 대부분의 웹 파트 이벤트 및 해당 관련된 메서드는 작동 이벤트의이 기본 패턴입니다.  
  
 또한 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 관리 작업에 특정 한 메서드 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (사용 되는 서버 또는 사용자 컨트롤 및 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤). 이러한 메서드를 포함 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>합니다.  
  
 메서드 집합도 연결에 대 한 특수화 합니다. 와 같은 메서드가 포함 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>합니다.  
  
 마지막으로, 일부 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 메서드 개인 설정 기능에 집중 합니다. 여기에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>이 포함됩니다.  
  
 기타에 대 한 자세한 내용은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 메서드를 통해 액세스할 수 있는 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성에 대 한 설명서를 참조를 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 클래스.  
  
   
  
## Examples  
 다음 코드 예제에는 선언적 및 프로그래밍 방식의 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 사용자 정의 컨트롤에는 페이지에 있는 웹 파트 컨트롤에 따라 해당 페이지에서 가능한 표시 모드를 표시 하는 드롭다운 목록 컨트롤을 있습니다. 이 코드 예제에 대 한 웹 페이지에서이 사용자 정의 컨트롤 바로 아래 선언 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 페이지의 태그에 되며를 `Register` 컨트롤을 등록 하려면 웹 페이지의 위쪽 지시문입니다. 이 컨트롤의 모드 및 소스 코드에 대 한 설명을 표시 하는 대 한 정보를 참조 [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 웹 페이지에 대 한 선언적 태그 포함 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. 페이지에 대 한 연결 관련 이벤트를 처리 하는 일부 인라인 코드도 포함 되어는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 연결 하 고 컨트롤을 연결을 끊을 때이 코드의 효과 볼 수 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 예제는 세 번째 부분은 컨트롤에 대 한 소스 코드를 사용 하는 것입니다. 라는 인터페이스가 있다는 점에 주의 `IZipCode`,이 인터페이스에서 구현 되는 `ZipCodeWebPart` 클래스입니다. 이 클래스는 명명 된 특수 콜백 메서드가 `ProvideIZipCode` 는 공급자 역할을 합니다. 명명 된, 다른 형식 `WeatherWebPart`, 라는 특수 한 메서드로 구현 됩니다 `GetIZipCode`, 다른 컨트롤의 소비자 역할을 하도록 컨트롤을 활성화 하는 합니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제는 소스를 어셈블리로 컴파일한 가정 및 `Register` 지시문 웹 페이지에서 어셈블리 이름을 참조 합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 UI를 표시 한 다음 클릭 합니다 **소비자에 대 한 연결을 만들** 링크 합니다. 셀은 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 컨트롤** 클릭 하 고 드롭다운 목록에서 **Connect** 두 컨트롤의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여 합니다 **디스플레이 모드** 페이지를 표준 찾아보기 모드로 돌아가려면 드롭다운 목록입니다. 우편 번호를 입력할 수 있으며 소비자 컨트롤 입력 한 값으로 업데이트 됩니다. 때문에 합니다 `ZipCode` 속성으로 표시 되어 있으므로 `Personalizable` 특성 속성 값이 소스 코드에서 사용자가 입력 한 값을 저장 하므로 브라우저 세션 간에 유지 됩니다. 보다 복잡 한 소비자 컨트롤 우편 번호 정보를 가져올 수 없습니다, 그리고 코드에 대 한 날씨 정보를 조회 및 사용자에 게 표시  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤은 확장 되도록 설계 되었습니다. 중앙 웹 파트 응용 프로그램에 일부 특정 형식을 확장 하거나, 대부분의 웹 파트 컨트롤 집합에서 제어 하려는 경우에 확장 되어야 하므로 이므로 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스, 속성 또는 메서드를 확인 하는 데 필요한 몇 가지 가능성이 있기 때문에  사용자 지정 형식의 웹 파트 응용 프로그램의 컨텍스트에서 작동 합니다. 웹 파트 참조 설명서 (참조 <see cref="N:System.Web.UI.WebControls.WebParts" />) 자주 언급 되어 확장을 수행 하는 데 필요한 입력 웹 파트를 확장 하는 방법을 설명 하는 경우는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 도 클래스 또는 코드 예제를 확장 하는 방법을 보여 줍니다.</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> 생성자에서 사용 하는 몇 가지 중요 한 변수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 기본 페이지 디스플레이 모드를 찾아보기 모드로 설정 된 사실 모든 웹 파트 페이지에 직접 영향을 주는 하나의 할당 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 페이지에서 현재 비활성 상태인 모든 연결을 활성 상태로 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 간의 기존 연결을 활성화 하려면 페이지에 각 요청에서 호출 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 및 기타 서버 컨트롤에 있는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역입니다. 경우에 따라 충돌에에서 있으면이 메서드가 활성화 되는 연결에서 인스턴스 호출에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 문제가 발생 한 연결을 종료 하는 방법입니다. 연결을 끊는 동안는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트가 발생 합니다. 일반적으로 개발자가이 이벤트를 취소할 수 있습니다 하지만 경우에서 이므로 취소할 수 없으며 연결 간에 충돌이 있는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 연결을 활성화 하는 프로세스를 완료 하기 위해 충돌을 해결 해야 합니다. 세부 정보를 참조 하세요. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">웹 페이지에 추가하거나 페이지에서 열 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />(또는 서버 컨트롤이나 사용자 정의 컨트롤)입니다.</param>
        <param name="zone"><paramref name="webPart" />가 추가될 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</param>
        <param name="zoneIndex"><paramref name="webPart" />에서 <paramref name="zone" />의 다른 컨트롤을 기준으로 <paramref name="zone" />가 나타나는 서수 위치를 나타내는 정수입니다.</param>
        <summary>웹 페이지에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 프로그래밍 방식으로 추가하기 위한 방법을 제공합니다.</summary>
        <returns>페이지에 추가된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드는 새 동적 추가할 모두 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지로 및 페이지에 이전에 닫혀 있는 정적 또는 동적 컨트롤 다시 제어 합니다. 새 컨트롤을 추가 하는 메서드 호출 되 면 실제로 만들면에서 참조 하는 컨트롤의 복사본을 `webPart` 매개 변수입니다. 개발자 참조 해야 하므로 컨트롤의 복사본에 대 한 새 ID 생성 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 새 ID 값을 검색할 메서드에서 제어를 반환 합니다. 메서드가 이전에 닫힌된 컨트롤을 다시 호출 되 면 참조 하는 컨트롤에 대 한 직접 참조를 반환 합니다 `webPart` 매개 변수입니다.  
  
> [!IMPORTANT]
>  항상 사용 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드를 대신 <xref:System.Web.UI.ControlCollection.Add%2A> 참조 하는 컨트롤의 컬렉션에 대 한 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> 추가할 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용 때문에 페이지를 프로그래밍 방식으로 제어를 <xref:System.Web.UI.ControlCollection.Add%2A> 메서드에서 예외가 throw 됩니다. 없는 컨트롤을 추가 하려면를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (즉,로 묶어야 하는 서버 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임 시 컨트롤), 먼저 호출 해야를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 컨트롤을 만들려면 다음 호출 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 추가 하는 방법 컨트롤입니다. 이 방법의 데모를 보려면 예제 단원을 참조 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 서버 컨트롤을 프로그래밍 방식으로 페이지에 추가 하는 방법입니다. 페이지 태그나 빈 포함 `<asp:webpartzone>` 요소 및 `<asp:webpartmanager>` 요소입니다. 처음으로 **추가 달력** 단추 코드를 이벤트 처리기를 만듭니다를 <xref:System.Web.UI.WebControls.Calendar> 컨트롤을 영역에 추가 합니다를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="zone" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" />이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 영역 컬렉션에 등록되지 않은 경우  
  
또는 
 <paramref name="webPart" />가 이미 <paramref name="zone" />에 있는 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 값이 0보다 작은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 또는 서버 컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위해 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 메서드가 호출될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트가 발생할 때마다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 페이지에 추가 될 합니다. 페이지에 컨트롤을 추가할 수 있는 일반적인 시나리오는 여러 가지가 있습니다. 이러한 설명은, 설명 섹션을 참조 하세요.를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드. 보려는 검사할 해야 컨트롤이 추가 되 면 여부를 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 설정 되었는지, 그렇다면 여부 컨트롤 하기 및 페이지에 추가할 수 있습니다.  
  
 개발자에 대 한 이벤트 처리기를 만들 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트를 컨트롤에 대 한 필터링을 제공 하도록 합니다. 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값에 맞지 않는 이벤트 처리기 코드 조건을 컨트롤에 추가 되지 않습니다 페이지입니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 사용자 지정 이벤트 처리기를 설정 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 자동으로 기본값을 재정의 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드.  
  
 코드를 `mgr1_AuthorizeWebPart` 메서드는 페이지의 컨트롤에 해당 하는지 여부를 확인 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `user` 그렇다면 반환 및 `true`, 페이지에 추가할 수 있음을 나타내는입니다. 이 기본 방법은 사용자 컨트롤을 페이지를 사용 하 여 사용자 개인 설정 범위에서 볼 수 있도록 하는 것을 가정 합니다. 알 수 있는데, 하나는 컨트롤의 예에는 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `admin`합니다. 개발자만 관리 사용자에 게 표시 용으로 설계 된 특수 한 컨트롤에이 필터를 적용할 수 있습니다. 이 제어 하는 동안 권한 부여 검사 실패는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트를 표시 하지 것입니다. Note도; 속성이 설정 되지 않은 컨트롤 표시 되는 이므로 필터링 시나리오를 포함 될 필요가 간주 됩니다 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 설정 되지 않습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤 간의 웹 파트 연결을 만드는 데 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체의 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> 메서드 컬렉션을 만듭니다. 기본적으로 응용 프로그램 구성 파일에서 사용할 수 있는 변환기를 읽습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">웹 파트 연결 개요</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결이 설정되는 컨트롤입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 연결하는 프로세스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 메서드는 존재 하므로 개발자에 게 연결 프로세스를 보다 더 많은 제어를 제공 별도 단계에서 컨트롤 간의 연결을 설정 하는 과정을 수행할 수 있습니다. 메서드는 일련의 되도록 초기 검사 수행 `webPart` 있는 연결을 올바르게 설정할 수 상태입니다. 하는 경우 `webPart` 는 모든 검사를 통과 현재 선택 된 컨트롤로 설정 되 (참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성), 고 연결 프로세스를 계속할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">페이지의 현재 디스플레이 모드가 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 닫혀 있습니다.  
  
또는 
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 포함되지 않은 경우  
  
또는 
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 컨트롤과 같은 경우</exception>
        <block subset="none" type="overrides"><para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤을 파생된 클래스에서이 메서드를 재정의 하려고 합니다. 한 가지 방법은 기본 메서드를 호출 하 고 다음 몇 가지 추가 사용자 지정 처리;를 추가 하는 것 또는 컨트롤 간의 연결을 시작 하는 프로세스를 완전히 사용자 지정할 수 있습니다. 예를 들어 다음 연결을 만들기 전에 특정 데이터를 사용할 수 있는지 확인 하는 것이 좋습니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">편집할 컨트롤입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 편집하는 프로세스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드는 존재 하므로 개발자에 게 프로세스를 보다 더 많은 제어를 제공 별도 단계에서 편집 컨트롤의 프로세스를 수행할 수 있습니다. 메서드는 일련의 되도록 초기 검사 수행 `webPart` 편집할 수 있는 상태입니다. 하는 경우 `webPart` 는 모든 검사를 통과 현재 선택 된 컨트롤로 설정 되 (참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성), 고 편집 프로세스를 계속할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">페이지의 현재 디스플레이 모드가 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 닫혀 있습니다.  
  
또는 
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 포함되지 않은 경우  
  
또는 
 <paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 컨트롤과 같은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 페이지의 기본 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 필드에 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고 포함 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 정적 개체 이기 때문에 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지 컨트롤 처음 로드할 때의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 사용자는 일반적인 웹 페이지에서 일관 되 게를 검색할 단순히 때 페이지 찾아보기 모드로 유지 됩니다. 페이지를 통해 사용할 수 있는 특수 한 디스플레이 모드 중 하나로 전환 해야 사용자가 페이지의 레이아웃, 컨트롤, 모양 또는 동작을 개인 설정 하려는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 프로그래밍 방식으로 필드입니다. 코드는 찾아보기 및 디자인이 경우에 지원 되는 디스플레이 모드를 사용 하 여 드롭다운 목록을 채웁니다. 있음을에 `Page_PreRender` 메서드, 코드 검사 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>합니다. 그렇다면 `Label1` 를 볼 수는 그렇지 않은 경우 및 `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 기본적으로 찾아보기 모드 상태입니다. 찾아보기 모드에서 나타내는 페이지의 레이블을 확인할 수 있습니다. 페이지 디자인 모드로 전환 하려면 드롭다운 목록 컨트롤을 사용 합니다. 있음을의 코드로 인해는 `Page_PreRender` 메서드, 레이블을 이제 숨겨집니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 확인하여 해당 컨트롤을 연결할 수 있는지 여부를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드는 두 확인 데 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 연결할 수 있습니다. 메서드를 호출 하기 전에 조건부 검사를로 일반적으로 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드는 다양 한 두 개의 연결을 설정할 수 전에 충족 해야 하는 조건 확인 합니다. 다음은 연결에 대 한 기본 조건을 요약 합니다. 메서드가 반환 하는 경우 이러한 모든 조건 (및 일부 추가 내부 조건)이 충족 되 면 `true`, 컨트롤을 연결할 수 있음을 의미 합니다.  
  
-   공급자 컨트롤과 소비자 컨트롤 일 수 없습니다 `null`를 참조 하는 컨트롤의 컬렉션에 포함 되어야 합니다 및는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
-   공급자와 소비자는 동일한 컨트롤 일 수 없습니다. 다른 말로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 자체에 연결할 수 없습니다.  
  
-   합니다 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint> 공급자와 소비자 모두에 대 한 개체 (연결점) 일 수 없습니다 `null`합니다.  
  
-   공급자와 소비자를 닫을 수 없습니다 (모두 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A> 속성 수 `true`).  
  
-   <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A> 연결 지점 컨트롤의 속성에는 소비자와 공급자의 컨트롤의 형식과 일치 해야 합니다.  
  
-   연결 지점 모두 사용할 수 있어야 합니다 (자신의 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A> 메서드 모두 반환 해야 합니다 `true`).  
  
-   각 연결 지점은 자체에 지정 된 것 보다 더 많은 연결을 구성 하기 위해 시도 하지 해야 <xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A> 속성입니다.  
  
-   경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 될 수 없습니다, 개체 (변환기)는 호환 되지 않는 컨트롤을 연결 하는 데 필요한 `null`합니다. 그러나 컨트롤에 이미 호환 되는 변환기 해야 `null`합니다.  
  
-   참조 해야 합니다 (사용) 하는 경우 변환기를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A> 컬렉션입니다.  
  
-   변환기 (사용) 하는 경우에 두 개의 컨트롤 간에 데이터를 변환할 수 있도록 공급자와 소비자를 사용 하 여 호환 되는 인터페이스 있어야 합니다. 또한 소비자와 공급자의 보조 인터페이스 호환 되어야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">컨트롤이 연결될 때 <paramref name="consumer" />에 데이터를 제공하는 컨트롤입니다.</param>
        <param name="providerConnectionPoint"><paramref name="provider" />가 연결에 참여할 수 있게 해 주는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="consumer">컨트롤이 연결될 때 <paramref name="provider" />에서 데이터를 받는 컨트롤입니다.</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" />가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <summary>공급자 및 소비자 컨트롤에 호환되는 인터페이스가 있고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 개체가 필요하지 않은 경우, 연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 컨트롤을 확인하여 해당 컨트롤을 연결할 수 있는지 여부를 확인합니다.</summary>
        <returns><paramref name="provider" />와 <paramref name="consumer" />를 연결할 수 있는지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연결 하는 데 사용 됩니다 `provider` 하 고 `consumer` 두 컨트롤 모두 호환 되는 연결 지점 형식을 경우 있도록를 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체가 필요 하지 않습니다. 이 메서드를 사용 하 여 두 컨트롤을 호출 하기 전에 연결할 수 있는지 확인 하려는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 프로그래밍 방식으로 연결을 만듭니다.  
  
 이 오버 로드로 동일한 구현을 사용 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 메서드 오버 로드에만 제외 하 고이 오버 로드는 변환기를 필요 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 메서드를 사용 하는 방법에 설명 합니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤을 `<asp:webpartmanager>` 요소와 이벤트 처리 코드를 사용 하 여 연결을 만드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그 포함 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. `Page_Load` 메서드는 여부를 확인 연결 수, 그렇다면 해당 연결 지점을, 소비자 및 공급자를 정의 하 고 를참조하는정적연결집합에새연결을추가한<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예제는 세 번째 부분은 컨트롤에 대 한 소스 코드를 사용 하는 것입니다. 인터페이스 및 두 개의 사용자 지정 포함 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하나는 공급자 및 소비자로 서 다른 역할을 제어 합니다. 호환 되는 연결 지점에 있기 때문에 (두 인식 된 `IZipCode` 인터페이스), 변환기가 연결을 만드는 데 필요 하지 않습니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">컨트롤이 연결될 때 <paramref name="consumer" />에 데이터를 제공하는 컨트롤입니다.</param>
        <param name="providerConnectionPoint"><paramref name="provider" />가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="consumer">컨트롤이 연결될 때 <paramref name="provider" />에서 데이터를 받는 컨트롤입니다.</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" />가 연결에 참여할 수 있도록 콜백 메서드 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />입니다.</param>
        <param name="transformer">호환되지 않는 <paramref name="provider" />와 <paramref name="consumer" />를 연결할 수 있게 해 주는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</param>
        <summary>연결에 참여할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 검사하여 해당 컨트롤을 연결할 수 있는지 여부를 확인하고, <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체를 사용하여 호환되지 않는 소비자와 공급자 간의 연결을 만듭니다.</summary>
        <returns><paramref name="provider" />와 <paramref name="consumer" />를 연결할 수 있는지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연결 하는 데 사용 됩니다 `provider` 하 고 `consumer` 두 컨트롤에는 연결 지점 형식이 호환 되지 않는 경우 있도록를 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체가 필요 합니다. 이 메서드를 사용 하 여 두 컨트롤을 호출 하기 전에 연결할 수 있는지 확인 하려는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 프로그래밍 방식으로 연결을 만듭니다.  
  
 이 오버 로드로 동일한 구현을 사용 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 만 제외 하 고이 오버 로드 한다는 변환기를 사용 하 여 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 카탈로그의 서버 컨트롤을 웹 페이지에 추가하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 필드에 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고 포함 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 정적 개체 이기 때문에 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 사용자를 서버 컨트롤의 카탈로그를 사용할 수 있는 경우 페이지에 컨트롤을 추가 하려면 페이지를 전환할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (카탈로그 모드)는 카탈로그 UI (사용자 인터페이스) 표시 됩니다. 웹 파트 카탈로그에 대 한 UI가 제공한는 <xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase> 영역 컨트롤입니다. 개발자는 디자인 타임에이 영역 페이지에 추가 하 고 사용자가 런타임에 해당 페이지에 이러한 컨트롤을 추가할 수 있도록 서버 컨트롤 영역에 추가 합니다. 개발자가 이러한 컨트롤을 추가한 후 카탈로그 모드 카탈로그 모드를 사용 하도록 설정 하려면 필요한 컨트롤 사항이 때문에 페이지의 지원 되는 디스플레이 모드를 됩니다.  
  
 때 사용자 모드, 영역 및 표시 되므로 추가 된 모든 서버 컨트롤을 카탈로그 페이지를를 전환 하 고 사용자 페이지를 추가 하거나 페이지에서 컨트롤을 제거 하는 카탈로그에서 컨트롤을 선택할 수 있습니다. 페이지에 컨트롤을 추가한 후 표준 찾아보기 모드로 표시 되 고 페이지 업데이트 됩니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 프로그래밍 방식으로 필드입니다. 코드는 찾아보기, 디자인 및 카탈로그가 경우에 페이지에 대해 지원 되는 디스플레이 모드를 사용 하 여 드롭다운 목록을 채웁니다. 카탈로그 모드는 때문에 사용할 수는 `<asp:CatalogZone>` 요소와 웹 페이지에서 자식 요소입니다. 있음을에 `Page_PreRender` 메서드, 코드 검사 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>합니다. 그렇다면 `Label1` 를 볼 수는 그렇지 않은 경우 및 `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 기본적으로 찾아보기 모드 상태입니다. 페이지의 레이블이 숨겨지는지를 확인 합니다. 페이지 카탈로그 모드로 전환 하려면 드롭다운 목록 컨트롤을 사용 합니다. 있음을의 코드로 인해는 `Page_PreRender` 메서드는 레이블이 표시 됩니다. 컨트롤 카탈로그에서 선택한 페이지의 두 영역 중 하나에 추가할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요청하는 브라우저의 기능과 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 속성 값을 확인하여 클라이언트 스크립트를 렌더링할지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트를 렌더링할지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결에서 다른 컨트롤에 대해 공급자 역할을 하는 컨트롤을 사용자가 닫을 때 표시되는 경고를 가져오거나 설정합니다.</summary>
        <value>경고 메시지가 들어 있는 문자열입니다. 기본값은 .NET Framework에서 제공하는 문화권별 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 닫을 때를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 일반적으로 메시지가 표시 됩니다. 컨트롤을 닫을 의미 하는 방법에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드.  
  
 그러나 컨트롤을 다른 컨트롤에 연결 된 다른 컨트롤에 데이터의 공급자 역할을 하 고 하는 경우 사용자는 컨트롤을 닫을 때 기본 경고 메시지가 표시 됩니다. 메시지는 공급자 컨트롤 인지를 닫 히 려는 소비자가 사용할 데이터가 더 이상 방법을 제어 하는이 공급자에 연결 된 사용자를 알려 줍니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성을 사용 하면 개발자가 사용자에 게 표시 되는 경고 메시지를 사용자 지정 합니다.  
  
 사용자가 닫을 때 없음 경고 메시지 상자는 비어 있거나 null 문자열 값이이 속성에 할당 하는 페이지 개발자를 하는 경우 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 공급자는 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성을 사용자에 게 사용자 지정 경고를 표시 합니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 다음 코드 예제에서는 웹 페이지 부분만 포함 되어 있습니다. 사용자 제어 해야 하 고 위에서 언급 한 사용자 지정 컨트롤에 대 한 소스 코드입니다. 이 예제에서는 섹션에서 두 개의 항목을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요.  
  
 다음 웹 페이지 코드에는 사용자 지정 경고 메시지를 할당 하는 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성에 선언적 태그에는 `<asp:webpartmanager>` 요소입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 클릭 합니다 **소비자에 대 한 연결을 만들** 링크 합니다. 셀은 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 컨트롤** 클릭 하 고 드롭다운 목록에서 **Connect** 두 컨트롤의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여 합니다 **디스플레이 모드** 페이지를 표준 찾아보기 모드로 돌아가려면 드롭다운 목록입니다. 마지막으로, 동사 메뉴를 클릭 합니다 **우편** (되는 공급자 컨트롤이 경우)을 제어 하 고 선택 **닫기**합니다. 사용자 지정 메시지에 할당 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> 속성이 표시 됩니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />에서 닫을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 서버 컨트롤입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 닫습니다. 닫힌 컨트롤은 웹 페이지에 렌더링되지 않지만 다시 열 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드를 제거는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 서버 컨트롤을 원래 포함 되어 있는 웹 페이지에서 렌더링 되지 않습니다. 닫힌된 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 닫힌된 컨트롤에 대 한 참조를 유지 관리 하 고 컨트롤을 페이지를 복원할 수 있도록 하는 개체입니다. 닫힌 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤이 참조 하는 컬렉션에 계속 표시 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
 컨트롤을 닫는 하는 것에서 삭제 하는 것과 다릅니다. 닫힌된 컨트롤은 페이지를 복원할 수 있지만 삭제 된 컨트롤 인스턴스를 영구적으로 제거 되 고 복원할 수 없습니다. 여부에 관계 없이 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 서버 컨트롤 (페이지의 태그에 선언 됨) 정적 또는 동적 (페이지에 추가할 사용자 또는 프로그래밍 방식으로 웹 파트 카탈로그에서)를 닫고 페이지에 다시 사용할 수 있습니다.  
  
 사용자가 닫을 수는 일반적으로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 해당 동사 메뉴를 클릭 하 고 닫기 동사를 선택 하 여 제어 합니다. 컨트롤을 직접 호출 하 여 닫을 수도 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드와에 대 한 참조를 전달 `webPart`합니다.  
  
 페이지에 있는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 닫힌 개발자 선언 하는 경우는 `<asp:catalogzone>` 요소를 그 안에 추가 `<asp:pagecatalogpart>` 요소를 런타임 시 닫힌된 컨트롤 페이지를 복원 하는 사용자에 대 한 간단한 사용자 인터페이스 (UI)를 제공 합니다. 사용자 페이지를 카탈로그 디스플레이 모드를 전환할 수 있습니다 및 닫힌된 컨트롤 페이지 카탈로그 내에서 표시 됩니다. 사용자 닫힌된 컨트롤을 선택 하 고 추가할 수는 원하는 어떤 위치에 있는 페이지로 돌아갈 수 및 다음 선택된 된 컨트롤이 페이지에 복원 되며 정상적으로 렌더링 합니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드가 호출 되 면 이벤트가 발생: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> (많은 경우 여러 개의 컨트롤), 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (연결 된 컨트롤이 있는 경우). 취소할 수 것 특정 경우에만 일반적으로 개발자가 이러한 이벤트를 취소할 수 있습니다. 자세한 내용은 설명서를 참조 하십시오.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>, 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   페이지 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤입니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   웹 페이지입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 코드 예제의 두 번째 부분은 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예제에서는 동적 컴파일 방식이; 없기 때문에 없습니다 `Assembly` 특성을 `Register` 웹 페이지의 맨 위에 있는이 컨트롤에 대 한 지시문입니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 이 페이지에는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을 사용 하 여는 <`asp:pagecatalogpart>` 그 안에서 선언 된 요소입니다. 이 닫힌 될 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 하 고 사용자가 페이지에 다시 추가할 수 있도록 합니다. `Button1_Click` 메서드를 직접 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 닫는 사용자 지정 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 닫을 수는 있지만 또한 동사 메뉴를 통해 해당 컨트롤입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 사용자 지정을 닫고 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤의 머리글에서 동사 메뉴 (화살표)를 클릭 하 여 컨트롤 **닫습니다**합니다. 이제 페이지를 선택 하 여 카탈로그 모드 변경 **카탈로그** 에 **디스플레이 모드** 드롭다운 목록 컨트롤입니다. 페이지 카탈로그 닫힌된 컨트롤을 사용 하 여 표시 됩니다. 닫힌된 컨트롤 옆의 확인란을 선택, 클릭 **추가** 페이지에 추가를 클릭 **닫기** 페이지를 찾아보기 모드로 돌아갑니다. 컨트롤이는 페이지에 복원 됩니다. 이제 닫습니다 다시 클릭 하 여이 시간을 **Close WebPart** 단추입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 없는 경우  
  
또는 
 <paramref name="webPart" />가 공유 컨트롤이고 다른 사용자에 의해 이미 닫힌 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결을 관리할 수 있도록 특수 UI(사용자 인터페이스)를 표시하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 필드에 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고 포함 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 정적 개체 이기 때문에 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 사용자 간의 연결을 관리 하려는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하는 경우 웹 페이지 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone> 페이지에 영역이 선언 된, 페이지를 전환할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드. 연결 디스플레이 모드를 컨트롤 연결 끊기 또는 연결 하 고 기존 연결의 세부 정보를 편집할 수 있는 기능을 포함 하는 연결을 관리 하기 위한 특별 한 UI를 표시 합니다.  
  
 웹 파트 컨트롤 집합에서 제공 하는 UI를 사용 하 여 연결을 관리 하는 기능을 사용 하 여 사용자에 게 제공 하려는 경우를 선언 해야 합니다는 `<asp:connectionszone>` 페이지의 태그에는 요소입니다. 다른 유형의 요소와는 달리 <xref:System.Web.UI.WebControls.WebParts.WebZone> 영역,이 요소 내에 있는 다른 모든 태그를 추가할 필요가 없습니다; 자체적으로 요소를 간단히 선언 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는의 사용법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드입니다.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   인터페이스 및 사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결을 설정할 수 있는 컨트롤입니다.  
  
-   연결 UI를 제공 하 고 사용 방법을 보여는 웹 페이지는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드입니다.  
  
-   예제를 실행 하는 방법 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 인터페이스 및 두 개의 사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결 될 수 있도록 디자인 된 컨트롤입니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제에서는 동적 컴파일 방법을 사용 합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 예제의 두 번째 부분은 사용자 지정 컨트롤을 호스팅하는 웹 페이지입니다. 서버 내에서 `<script>` 태그 페이지에서 여러 가지 방법으로 페이지의 사용 가능한 표시 모드를 사용 하 여 드롭다운 목록을 채웁니다. 사용자는 페이지의 표시 모드를 변경 하려면 드롭다운 목록에서 선택할 수 있습니다. 사용 가능한 표시 모드 중 하나 이므로 연결 디스플레이 모드를 `<asp:connectionszone>` 요소가 페이지의 태그에 선언 되어 있습니다. 이 요소에 다른 자식 요소가; 없는지 확인할 수 있습니다. 사용자에 대 한 연결 관리 UI를 사용 하도록 설정에 존재 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 모드 두 위치에서이 예제에 표시 됩니다. 먼저 합니다 `Page_Init` 메서드를 연결 디스플레이 모드를에 추가 됩니다 디스플레이 모드의 드롭다운 목록으로에서 참조 하는 컬렉션을 반복 하는 코드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성. 두 번째는 `Page_PreRender` 메서드 확인 페이지에서 현재 표시 모드를 고 현재 모드 이면 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>에 메시지가 표시 됩니다는 <xref:System.Web.UI.WebControls.Label> 컨트롤입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 드롭다운 목록을 클릭 하 고 선택 **Connect** 페이지 연결 디스플레이 모드를 전환 합니다. 확인 페이지에 있는 연결 디스플레이 모드를 알리는 메시지가 나타납니다. 이제 중 하나의 제목 표시줄에서 동사 메뉴 (화살표 기호)를 클릭 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 클릭 **Connect** 동사 메뉴에서. UI가 표시에 연결한 후 연결을 만들려면 링크를 클릭 합니다. 연결 표시 되는 UI 내에서 드롭다운 목록을 사용 하 여, 연결에 참여를 클릭 하는 다른 컨트롤을 선택 합니다 **Connect** 단추입니다. 연결이 설정 됩니다. 클릭 합니다 **닫기** 단추를 클릭 한 다음 목록을 사용 하 여 드롭다운 목록 페이지의 맨 위에 있는 페이지를 찾아보기 디스플레이 모드를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 현재 연결이 모두 들어 있는 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 속성 페이지에는 연결의 현재 집합에 액세스 하는 방법을 제공 합니다. 컬렉션 자체는 읽기 전용 및 컬렉션에서 특정 연결을 조작 하려는 개발자도 사용할지 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 와 같은 메서드와 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 선언적 및 프로그래밍 방식의 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 다음 코드 예제에서는 웹 페이지 부분만 포함 되어 있습니다. 사용자 제어 해야 하 고 위에서 언급 한 사용자 지정 컨트롤에 대 한 소스 코드입니다. 이 예제에서는 섹션에서 두 개의 항목을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요.  
  
 다음 웹 페이지 코드를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 속성 페이지에 현재 연결의 수를 가져옵니다을 프로그래밍 방식으로 합니다. `<script>` 태그 섹션에 대 한 두 개의 이벤트를 처리 하는 코드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 액세스를 제어 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> 속성을 가져올 수 합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)는 표시를 클릭 합니다 **소비자에 대 한 연결을 만들** 링크 합니다. 셀은 드롭다운 목록 컨트롤이 나타납니다. 선택 **날씨 컨트롤** 클릭 하 고 드롭다운 목록에서 **Connect** 두 컨트롤의 연결을 완료 합니다. 클릭 **닫기**를 사용 하 여 합니다 **디스플레이 모드** 페이지를 표준 찾아보기 모드로 돌아가려면 드롭다운 목록입니다. 레이블을 연결 수 및 개수를 이제 표시 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 모드를 연결 하 고 두 연결 끊기 컨트롤 찾아보기 모드로 돌아가면 이제 반환 레이블의 콘텐츠를 업데이트 해야 하 고 연결이 없어야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지에 있는 현재 웹 파트 연결이 모두 연결되어 있을 뿐 아니라 각 연결에 관련된 소비자 및 공급자 컨트롤 간에 실제로 데이터가 공유되기 시작한 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결의 수명 주기에서이 이벤트는 페이지 로드 프로세스가 완료 된 후 발생 합니다. 후에 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트 것만 나타냅니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 특정 연결에 관련 된 서버 컨트롤 성공적으로 연결한 또는 합니다. 경우에서 페이지에 여러 연결이 있는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 메서드는 유효한 모든 웹 파트 연결 페이지에 활성 상태이 고 데이터를 공유할 수 이제 됨을 나타냅니다. 활성 상태인 모든 연결이 알고 있으면 개발자가 수행할 수는 모든 연결의 상태는 사용자에 게 알리는 등의 작업을 개수에 관계 없이 소비자 컨트롤을 처리 하 고 해당 공급자에서 데이터 표시 등을 알리는.  
  
 이 이벤트와 연결 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 메서드를 이벤트에 대 한 사용자 지정 처리기를 만들 수 있게 해 주는 이벤트를 발생 시킵니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnConnectionsActivated` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 설정된 웹 파트 연결을 모두 활성화하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연결의 수명 주기에서이 이벤트 발생 페이지는 로드 프로세스를 직전 완료 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 메서드가 호출 됩니다. 다른 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 간에 특정 연결을 포함 하는 경우 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 서버 컨트롤입니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 이벤트 페이지에서 가능한 모든 연결 연결한 활성화 될 때 발생 합니다.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 이벤트와 연결 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 메서드를 이벤트를 발생 시킵니다. 페이지에 추가할 수 있는 연결 유형을 확장 하려는 컨트롤 개발자가 보호 된 재정의 될 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 메서드 및 다른 유형의 연결을 활성화 합니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnConnectionsActivating` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 있는 두 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤(또는 연결을 설정할 수 있는 다른 서버 컨트롤) 간의 연결을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드 두 간의 연결을 형성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤입니다. 연결을 만들려면이 메서드를 호출 하기 전에 수도 있습니다를 호출 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 컨트롤에 대 한 연결을 형성 하는 것에 대 한 요구 사항을 충족 하는지 확인 하는 조건부 검사에서 메서드.  
  
> [!NOTE]
>  것도 가능 하지 않은 두 서버 컨트롤 간의 연결을 만들려면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 일반적으로 두 개의 해야 사용자 지정 서버 컨트롤 (에서 상속 되는 컨트롤에 예를 들어 <xref:System.Web.UI.WebControls.WebControl> 또는 기존 ASP.NET 서버 컨트롤) 필수 멤버를 추가할 수 있도록 합니다. 컨트롤은도 아래에 지정 된 요구 사항을 충족 해야 합니다.  
  
 두 컨트롤 간의 연결 시나리오의 모든 형식에 연결 하려면 다음 요구 사항을 충족 해야 합니다.  
  
-   에 있는 각 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 (되지 않은 동일한 영역에 되도록).  
  
-   연결에서 공급자 컨트롤과를 공급자에 대 한 콜백 역할을 하는 공용 메서드로 인터페이스를 구현 하는 웹 파트 컨트롤 집합에서 구현 된 대로 `ConnectionProvider` 공급자 연결으로 식별 방법에 대 한 메타 데이터 특성 지점입니다. 때문에 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 검색 공급자 연결 지점 임을 가상 메서드, 파생 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 반드시 동일한 메타 데이터 특성을 사용할 필요가 없습니다.  
  
-   웹 파트 컨트롤 집합에서 구현 된 대로 연결에서 소비자 컨트롤과 또한에 공급자의 콜백 메서드를 노출 된 인터페이스에 대 한 참조를 가져올 수 있도록 하는 특수 메서드 있고 소비자는 `ConnectionConsumer` 에서 메타 데이터 특성 소비자 연결으로 식별 하는 메서드를 가리킵니다. 때문에 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 소비자 연결 지점을 검색은 가상 메서드, 파생 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 반드시 동일한 메타 데이터 특성을 사용할 필요가 없습니다.  
  
-   콜백 메서드를 호환 되어야 하거나, 공급자의 콜백 메서드 (소비자 및 공급자를 공유할 수 있다는 데이터 직접 의미) 또는 개발자 제공 되는 인터페이스를 사용 해야 합니다는 소비자의 형식을 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체 소비자가 사용할 수 있는 형식으로 공급자에서 데이터를 변환 합니다.  
  
    > [!IMPORTANT]
    >  변환기, 필요 하지 않은 경우 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29> 메서드 오버 로드 합니다. 변환기를 해야 하는 경우 사용 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">연결된 다른 컨트롤에 데이터를 제공하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <param name="providerConnectionPoint">연결에서 콜백 메서드로 사용되는 메서드입니다. 웹 파트 컨트롤 집합에서 구현될 때 이 메서드는 <paramref name="provider" />에서 <see langword="ConnectionProvider" /> 메타데이터 특성으로 표시되는 공용 메서드입니다.</param>
        <param name="consumer"><paramref name="provider" />로부터 데이터를 받아 이를 처리하거나 표시하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <param name="consumerConnectionPoint"><paramref name="providerConnectionPoint" />와 연결하여 연결에 대한 데이터를 받는 메서드입니다. 웹 파트 컨트롤 집합에서 구현될 때 이 메서드는 <paramref name="consumer" />에서 <see langword="ConnectionConsumer" /> 메타데이터 특성으로 표시되는 공용 메서드입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤에 대한 참조와 각 컨트롤의 지정된 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 개체만 사용하여 두 컨트롤 간의 연결을 만듭니다.</summary>
        <returns>연결에 필요한 공급자 및 소비자에 대한 다양한 정보가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 해당 연결 지점이 충분히 호환 되는지 사용 하지 않고 연결할 수 있는 경우 컨트롤을 자동으로 연결할 때 사용 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체입니다. 메서드의이 오버 로드를 호출 하면 단순히 메서드의 다른 오버 로드 된 버전에 대 한 호출을 전달 하 고 전달 `null` 필요한 매개 변수는 <xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 개체입니다.  
  
 두 컨트롤을 프로그래밍 방식으로 연결 하려고 할 때 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 메서드는 컨트롤을 직접 연결할 수 있는지 여부를 확인 하는 조건부 검사에서.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 연결을 만들려면이 메서드를 사용 하는 방법에 설명 합니다. 예제를 실행 하는 데 필요한 전체 코드의 예제 섹션을 참조 하세요.를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 해당 예제에서 해야 페이지의 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤에 대 한 소스 코드와 소스 코드는 두 가지 사용자 지정에 대 한 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 두 호스트 하는 웹 페이지에 대 한 코드를 다음과 같이 제어 합니다. 페이지를 사용 하 여 `Register` 지시문 맨 위에 있는 사용자 정의 컨트롤 및 사용자 지정 컨트롤을 선언 합니다. 사용자 지정 컨트롤을 선언적으로 내 참조는 `<asp:webpartzone>` 요소입니다. 처리 하는 코드를 `Button1_Click` 메서드를 사용 하 여 컨트롤 간의 연결을 만듭니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 클릭 합니다 **WebPart 컨트롤 연결** 단추는 연결을 설정할 수 있습니다. 그런 다음 텍스트 상자에 데이터를 입력 하 고 클릭 수를 **5 자리 우편 번호를 입력** 단추를 연결 된 컨트롤을 1 초 동안에서 첫 번째 컨트롤에 입력 한 데이터가 업데이트 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 동적 연결 컬렉션이 읽기 전용인 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">연결된 다른 컨트롤에 데이터를 제공하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <param name="providerConnectionPoint"><paramref name="provider" />의 공용 메서드로, <see langword="ConnectionProvider" /> 메타데이터 특성으로 표시되며 연결의 콜백 메서드로 사용됩니다.</param>
        <param name="consumer"><paramref name="provider" /> 또는 <paramref name="transformer" />로부터 데이터를 받아 이를 처리하거나 표시하는 역할을 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" />의 공용 메서드로, <see langword="ConnectionConsumer" /> 메타데이터 특성으로 표시되며 <paramref name="providerConnectionPoint" />와 연결되어 연결의 데이터를 받습니다.</param>
        <param name="transformer"><paramref name="provider" />의 데이터를 <paramref name="consumer" />가 처리할 수 있는 형식으로 변환하여 두 컨트롤 간을 연결할 수 있게 해 주는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />입니다.</param>
        <summary>두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤에 대한 참조와 각 컨트롤의 지정된 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 개체, 그리고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 개체를 사용하여 두 컨트롤 간의 연결을 만듭니다.</summary>
        <returns>연결에 필요한 공급자, 소비자 및 변환기에 대한 다양한 정보가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 연결할 때 해당 연결점 호환 되지 않습니다. 컨트롤에 사용 됩니다. 비 호환성이 발생 하면 `consumer` 보다 다양 한 인터페이스를 구현 `provider` 연결 지점으로 합니다. 변환기에서 인식할 수 있는 형식으로 데이터를 변환 `consumer`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">연결이 이미 <see cref="E:System.Web.UI.Control.PreRender" />에서 활성화된 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 포함되고 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤이 관리하는 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤, 서버 컨트롤 또는 사용자 정의 컨트롤의 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.ControlCollection" /> 컨트롤이 관리하는 모든 컨트롤이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> 속성에서 참조 하는 다른 컨트롤을 참조 하지 않습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다양 한 영역 컨트롤 같은 컨트롤 <xref:System.Web.UI.WebControls.WebParts.EditorPart> 또는 <xref:System.Web.UI.WebControls.WebParts.CatalogPart> 컨트롤 및 기타.  
  
 이 속성은 코드에서 호출할 수 없습니다는 대부분의 개발 환경에서 웹 파트 컨트롤 집합에서 사용 됩니다. 따라서이 속성은 공용 것은 IntelliSense에서 숨겨집니다. 컬렉션에 액세스 하려는 개발자도 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 서버 컨트롤에서 관리 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 사용 하 여 해당 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">복사할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤입니다.</param>
        <summary>웹 파트 컨트롤 집합에서 웹 페이지에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 추가하기 위해 해당 컨트롤의 복사본을 만드는 데 사용됩니다.</summary>
        <returns>페이지에 추가할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 사용자 코드에서 직접 메서드. 이 메서드는 내부적으로 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 새 동적 추가 하는 프로세스의 일부로 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 서버 컨트롤을 페이지입니다. 동적 컨트롤은 페이지에 추가할 프로그래밍 방식이 나 웹 파트 사용자 인터페이스 (UI)를 통해 예를 들어 컨트롤 대신 페이지의 태그에 직접 선언 된 정적 컨트롤, 컨트롤의 카탈로그에서 추가 사용자가.  
  
> [!NOTE]
>  개발자가 추가 컨트롤 복사 시나리오를 처리 하는 메서드를 사용 하도록 설정 하려는 경우에 파생된 클래스에서 메서드를 재정의할 수 있습니다. 세부 정보를 상속자 섹션의 정보를 참조 하세요.  
  
 있으면, 새 동적 컨트롤이 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 메서드는 컨트롤의 새 인스턴스를 반환 합니다. 추가할 컨트롤이 다른 유형의 서버 컨트롤 (예: 사용자 정의 컨트롤, 사용자 지정 컨트롤 또는 ASP.NET 컨트롤) 이면 컨트롤은 이미 래핑와 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 웹 파트 컨트롤 집합 개체입니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 발견 하면이 메서드는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤의 새 인스턴스를 반환 합니다는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 그 래핑된 자식 컨트롤의 새 인스턴스를 사용 하 여 컨트롤입니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 도 모든 속성의 값을 기본값으로 다시 설정, 메서드가 반환 하는 컨트롤의 새 복사본을 만듭니다. 방법은 있고 개인 설정 가능한 속성의 값을 보존 하려는 경우 새 컨트롤 인스턴스로 복사 하는 호출 해야 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A> 메서드 역시 합니다. 마지막 단계에서 수행 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A> 메서드를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A> 컨트롤에 대 한 새 ID를 가져오는 방법입니다.  
  
> [!NOTE]
>  참조의 원래 id 페이지에 추가 되는 동적 컨트롤에 의존 하지 않아야 하므로 메서드는 복사 된 컨트롤에 대 한 새 ID를 얻고 대신 확장 메서드에서 반환한 컨트롤의 새 인스턴스를 참조 해야 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>메서드는 선언 <see langword="virtual" /> 개발자에서 상속할 수 있도록는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 메서드를 재정의 하 고 있는 컨트롤의 복사본을 만들 수 하는 추가 시나리오에 대 한 제공 합니다. 예를 들어, 메서드를 선택적으로 받을 수 입력으로 XML 파일로 serialize 된 컨트롤입니다. 메서드 (있는 경우)에서 XML을 deserialize 하 고 다음의 새 인스턴스를 반환 하 고 기존 사례를 처리 하는 기본 메서드를 호출 수를 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 제어 합니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 사이트의 구성 파일에 지정된 변환기 집합을 만들고 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 속성에서 참조하는 변환기의 컬렉션에 이 변환기 집합을 추가합니다.</summary>
        <returns>웹 사이트의 구성 파일에 지정된 변환기 컬렉션입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>응용 프로그램에서 사용할 수 있는 추가 변환기를 추가 하려면이 메서드를 재정의할 수 있습니다. 예를 들어, 웹 서비스에서 사용할 수 있는 변환기의 목록을 검색 하는 메서드를 작성할 수 있습니다.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 모든 컨트롤의 컬렉션을 반환합니다. 이 클래스는 상속될 수 없습니다.</summary>
        <returns><see cref="T:System.Web.UI.ControlCollection" /> 컨트롤에서 관리하는 다양한 웹 파트 컨트롤이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>이 메서드는 보호 되 고 봉인 되므로 클래스에서 상속에 표시 되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 하지만 재정의할 수 없습니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 파트 응용 프로그램에서 사용할 수 있는 모든 디스플레이 모드의 집합을 만듭니다.</summary>
        <returns>지원되는 디스플레이 모드가 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 특정 페이지에 지원 되는 디스플레이 모드 뿐 아니라 모든 가능한 표시 모드 목록을 만듭니다. 지원 되는 디스플레이 모드에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다.  
  
 기본적으로 웹 파트 컨트롤 집합 웹 파트 페이지에서 사용할 표시 모드의 다음 집합을 만듭니다.  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 또는에서 파생 되는 사용자 지정 영역을 함께 제공 되는 비 개발자 지정 디스플레이 모드를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebZone> 또는 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 클래스입니다. 상속 해야 지정 디스플레이 모드를 만들려면 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스에서 상속 해야 합니다 페이지에서 지원 되는 모드로 표시 모드를 추가 하 고는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스를 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드.  
  
 디스플레이 모드를 사용 하 여 추가 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A> 메서드를 추가 해야 하는 원하는 모든 사용자 인터페이스 (UI) 컨트롤에 표시할 순서 대로 (같은 <xref:System.Web.UI.WebControls.ListBox> 컨트롤)를 제공 하는 사용자에 게 가능한 표시 모드를 페이지입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 코드 예제는 5 부:  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   다른 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   에 상주 하는 사용자 정의 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역 웹 페이지에 입력 하 고 레이블에 텍스트를 표시할 수 있습니다.  
  
-   두 개의 컨트롤이 포함 된 소스 코드 파일입니다. 하나는 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 및 다른 사용자 지정은 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 페이지의 기본 디스플레이 모드에 추가할 개체입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 웹 페이지입니다. 두 개가 포함 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤을 사용자 정의 컨트롤 및 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 통지를 `Register` 지시문 페이지의 맨 위에 있는 사용자 정의 컨트롤 및 컴파일된 컨트롤에 대 한 네임 스페이스를 참조 하도록 합니다.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 이 예제에서는 세 번째 부분에는 입력 및 텍스트 표시에 대 한 사용자 컨트롤입니다. 사용 하 여는 <xref:System.Web.UI.WebControls.MultiView> UI의 여러 뷰를 만들 수 있습니다. 뷰 하나는 `Button1` 없이 다른 단추입니다. 재정의 된 있음을 `OnPreRender` 메서드를 코드를 확인 하는지 여부를 확인 페이지를 현재 사용자 지정 표시 모드에서 그렇다면 단추가 포함 된 사용자 정의 컨트롤의 첫 번째 뷰를 표시 합니다. 페이지 사용자 지정 디스플레이 모드를 예를 들어 페이지 찾아보기 또는 디자인 모드인 경우에 없는 경우 단추가 숨겨집니다.  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 이 예제에서는 네 번째 부분에서는 두 개의 사용자 지정 클래스에 대 한 소스 파일입니다. 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 클래스를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 메서드와 먼저 모든 기본 디스플레이 모드를 추가 하려면 기본 메서드를 호출 하 고 다음 사용자 지정 디스플레이 모드를 추가 합니다. 사용자 지정 디스플레이 모드 클래스 `InLineEditDisplayMode`에서 상속 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>, 생성자에서 디스플레이 모드의 이름을 설정 하 고 다양 한 사용자 지정 표시의 특성을 설정 하는 기본 속성을 재정의 합니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 코드 예제를 실행 하려면 브라우저에서 페이지를 로드 합니다. 페이지는 찾아보기 모드에서는 현재 없는 단추가 표시 되는지 확인 합니다. 사용 하 여는 **디스플레이 모드** 드롭다운 목록 컨트롤, 페이지를 변경 **인라인 편집 디스플레이** 모드 및를 `Button1` 단추 낮은 사용자 정의 컨트롤에 표시 됩니다. 텍스트를 추가 하 고 컨트롤을 업데이트 하려면 단추를 클릭 합니다. 페이지 표시를 찾아보기 모드로 반환 됩니다, 입력 한 텍스트를 표시 하는 다시 한 번 단추 페이지 사용자 지정 표시 모드에서 더 이상 이므로 알 수 없습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">연습: 웹 파트 페이지에서 디스플레이 모드를 변경합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>동적 연결의 ID 역할을 하는 고유 값을 가져옵니다.</summary>
        <returns>연결의 고유 ID가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A> 메서드는 GUID 값을 생성 하 고 연결에 대 한 고유 ID로 사용할 문자열로 변환 합니다. 메서드는 동적 연결 만들어질 때마다 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생에서이 메서드를 재정의할 수 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 고유 ID를 생성 하는 것에 대 한 구현을 변경 하는 클래스</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">ID를 생성할 컨트롤의 <see cref="T:System.Type" />입니다.</param>
        <summary>동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 고유 ID를 생성합니다.</summary>
        <returns>컨트롤의 고유 ID가 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 웹 페이지에 추가할 일 수 있습니다 (즉, 페이지 태그에서 컨트롤을 선언한) 정적 또는 동적 (즉, 프로그래밍 방식으로 추가 됩니다). 모든 시나리오에서 위치를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 만들고 고유 ID를 생성 하려면이 메서드를 호출한 페이지에 추가 하려면 새 동적 컨트롤  
  
 메서드는 개발자 ID를 생성 하는 사용자 지정 구현을 제공 하는 경우 해당 재정의할 수 있도록 가상  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">실패한 컨트롤의 ID를 나타내는 문자열입니다. <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우 이 ID는 자식 서버 컨트롤의 ID입니다.</param>
        <param name="originalTypeName">실패한 컨트롤의 <see cref="T:System.Type" /> 이름을 나타내는 문자열입니다. <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우 이 형식 이름은 자식 서버 컨트롤의 형식입니다.</param>
        <param name="originalPath">자식 사용자 정의 컨트롤이 포함된 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />가 오류와 관련된 경우, 사용자 정의 컨트롤의 경로가 들어 있는 문자열입니다.</param>
        <param name="genericWebPartID"><see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />의 형식이 컨트롤 로드 또는 생성 오류와 관련된 경우 해당 컨트롤의 ID를 반환하는 문자열입니다.</param>
        <param name="errorMessage">페이지에 표시할 오류 메시지가 포함된 문자열입니다.</param>
        <summary>어떤 이유로 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 로드하거나 만드는 데 실패할 경우 페이지에 삽입되고 최종 사용자에게 표시되는 특수 컨트롤을 만듭니다.</summary>
        <returns>로드하거나 만드는 데 실패한 컨트롤 대신 페이지에 삽입되는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 메서드는 웹 파트 컨트롤 집합을 로드 하거나 동적 인스턴스를 만들 때 호출 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 서버 컨트롤이 고 어떤 이유로 실패 합니다. 메서드는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 개체, 오류 메시지를 할당 하 고 반환 합니다. <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 컨트롤, 못한 컨트롤 대신 삽입 되 고 페이지에서 해당 오류 메시지가 표시 됩니다.  
  
 호출할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 사용자 코드에서 직접 메서드. 그러나에서 상속할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 및 메서드를 확장 합니다. 자세한 내용은 상속자 섹션에 대 한 참고를 참조 하세요.  
  
 최종 사용자에 게 작업할 수는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 제어 페이지에 많은 일반적인 하 듯 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 오류 메시지를 제거 하려면이 시점에서 컨트롤에 추가 됩니다 닫기 동사를 클릭 하 여 컨트롤을 닫을 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 와 같은 다른 컨트롤 개체입니다. 최종 사용자를 삭제 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.ErrorWebPart> 컨트롤을 로드 하지 못한 서버 컨트롤 페이지에서 삭제 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>반환 되는 정보를 사용자 지정 하려는 경우는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 컨트롤을 재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" /> 메서드, 기본 메서드를 호출, 기본 메서드에 전달 된 매개 변수에 다른 값을 할당 및 돌아와서 다음 결과 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />컨트롤입니다. 예를 들어 최종 사용자에 게 표시 하지 않으려면는 <paramref name="originalPath" /> 값 (사용자 정의 컨트롤의 가상 디렉터리 경로 표시), 기본 메서드를 호출 하는 경우에 빈 문자열을 전달할 수 있습니다 ("") 해당 매개 변수에 대 한 합니다.  
  
동작을 사용자 지정할 수도 있습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" /> 자체에서 상속 하 여 제어 합니다. 재정의 하려는 하는 예를 들어, 해당 <see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" /> 또는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" /> 속성입니다.</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 웹 페이지에 대한 사용자의 개인 설정 데이터를 포함하는 개인 설정 개체를 반환합니다.</summary>
        <returns>사용자의 개인 설정 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A> 메서드 포함 하 고 현재 페이지에 대 한 사용자의 개인 설정을 관리할 개체를 반환 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 이 개체를 관리 하는 컨트롤입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">웹 파트 개인 설정 개요</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 아닌 서버 컨트롤입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 아닌 서버 컨트롤을 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 개체로 래핑하여 웹 파트 기능을 갖도록 합니다.</summary>
        <returns><paramref name="control" />을 래핑하여 실제 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤처럼 동작할 수 있게 하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드는 사용 되지 않는 서버 컨트롤에 대 한 기본 메커니즘 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에서 동일한 기능을 수행 하는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 이므로 웹 파트 응용 프로그램에 완전히 참여 합니다. 크게 개발자가이 메서드를 사용 하 여 웹 파트 응용 프로그램에서 사용할 수 있습니다. 있는 서버 컨트롤의 수를 확장, 서버 컨트롤의 거의 모든 유형을 때문에 표준 ASP.NET 컨트롤, 사용자 컨트롤 및 사용자 지정 컨트롤-수 있습니다.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 또한이 메서드를 사용이 다른 두 가지 시나리오에서 사용 하 여 서버 컨트롤을 래핑하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체입니다. 때 사용자가 서버 컨트롤을 추가 페이지를 사용 하 여를 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 가져온 있지 않은 경우이 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드는. 서버 컨트롤 내에서 지 속성 형식으로 선언 된 경우에 또한을 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 페이지의 영역을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 되지 않는 모든 컨트롤에 대 한 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 영역에 프로그래밍 방식으로 서버 컨트롤을 추가 하는 경우는 일반적인 방법은 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드를 사용 하 여 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 컨트롤의 모든 컬렉션을 추가 하는 방법 <xref:System.Web.UI.WebControls.WebParts.WebPart> 참조 하는 페이지에서 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드. 에 `Button2_Click method`, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 메서드를 래핑하는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 영역에 추가 하기 전에 개체입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생을 사용 하려면이 메서드를 재정의할 수 있습니다 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 클래스 대신 웹 파트와 함께 제공 되는 기본 클래스의 컨트롤 집합입니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최종 사용자가 컨트롤을 삭제할 때 해당 사용자에게 표시되는 사용자 지정 경고 메시지를 가져오거나 설정합니다.</summary>
        <value>경고 메시지의 텍스트가 포함된 문자열입니다. 기본값은 지역화된 경고 메시지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 삭제 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 일반적으로 기본 경고 메시지가 표시 됩니다. 컨트롤의이 인스턴스를 삭제 하면 삭제는 영구적 사용자 경고 합니다. 페이지 개발자 페이지에 컨트롤의 새 인스턴스를 추가 하는 방법을 사용 하 여 사용자를 제공할 수 있습니다 (같은 카탈로그를 통해 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 통해서나 프로그래밍 방식), 삭제 되는 컨트롤의 현재 인스턴스는 영구적으로 제거 하지만 합니다. 경고를 표시 하는 대화 상자에 원하는 경우 삭제를 취소 하려면 사용자에 대 한 단추가 포함 됩니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성을 사용 하면 개발자가 사용자에 게 표시 되는 경고 메시지를 설정할 수 있습니다.  
  
 페이지 개발자는 빈 문자열을 할당 하는 경우 ("") 사용자를 삭제할 때 값이 속성에 경고 메시지 대화 상자가 표시 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 정적 경우 속성이 표시 되지 않습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 서버 컨트롤입니다. 정적 컨트롤은 내에 선언 된 서버 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 페이지의 태그에는 영역입니다. 이러한 컨트롤은 정적 이기 때문에 삭제할 수 없습니다, 때문 삭제 경고 메시지는 경우에 표시 되지 않습니다. 사용자가 static 컨트롤을 닫을 수 있습니다 하지만 닫힌된 컨트롤 올 하 여 추가할 수 있습니다 페이지로 돌아갈 사용자 삭제 된 컨트롤은 복구할 수 없습니다 하지만 페이지 카탈로그에 추가 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성 선언적 및 프로그래밍 합니다.  
  
 코드 예제에서는 네 가지 부분이 있습니다.  
  
-   페이지 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤입니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   웹 페이지입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 코드 예제의 두 번째 부분은 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예제에서는 동적 컴파일 방식이; 없기 때문에 없습니다 `Assembly` 특성을 `Register` 웹 페이지의 맨 위에 있는이 컨트롤에 대 한 지시문입니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 이 페이지에는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 사용자 지정을 사용 하 여 영역을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 사용자를 런타임에 페이지로 것으로 추가할 수 있도록 제어 영역에서 선언 합니다. 페이지에서 동적 컨트롤 (프로그래밍 방식으로 또는 이와 같은 카탈로그 페이지에 추가 되는 컨트롤)를 삭제할 수 있습니다 note 합니다. 정적 컨트롤 (컨트롤 내에 선언 된를 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 페이지의 태그에는 영역)을 닫을 수 있지만 삭제 되지 않습니다. `<asp:webpartmanager>` 요소 선언에 대 한 사용자 지정 값을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 를 사용 하 여 속성은 `DeleteWarning` 특성. 합니다 `Button1_Click` 메서드를 다른 사용자 지정 값을 할당 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 추가 해야 하는 브라우저에서 페이지를 로드 한 후에 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 페이지입니다. 사용 하는 **디스플레이 모드** 드롭다운 목록 컨트롤, 카탈로그 모드를 선택 합니다. 카탈로그에 표시 되 면 사용자 지정 컨트롤 옆의 확인란을 선택, 클릭 **추가** 페이지에 추가를 클릭 **닫기** 페이지를 찾아보기 모드로 돌아갑니다. 컨트롤이 표시 되는지, 했으므로를 삭제할 수 있습니다. 사용 하는 **디스플레이 모드** 다시 컨트롤을 페이지 (삭제할 수 없습니다 컨트롤 페이지가 있는 동안 찾아보기 모드에서) 디자인 모드를 전환 합니다. 머리글에서 동사 메뉴 (화살표)를 클릭 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 선택 **삭제**합니다. 설정한 경고를 `DeleteWarning` 특성이 나타납니다. 클릭 **취소**합니다. 이제 단추를 클릭 **경고를 삭제 하는 변경**를 프로그래밍 방식으로 속성 값을 변경 하는 합니다. 컨트롤의 동사 메뉴에서 선택 **삭제** 마찬가지로이 이번 다른 경고 메시지가 표시 되는 것을 확인 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">삭제할 서버 컨트롤입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 동적 인스턴스를 웹 페이지에서 영구적으로 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드는 영구적으로 나타내는 컨트롤을 제거는 `webPart` 페이지에서 매개 변수입니다. 닫힌 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 컨트롤을 페이지로 다시 삭제 컨트롤 인스턴스를 추가할 수 없습니다 페이지로 다시 추가할 수 있습니다.  
  
> [!NOTE]
>  웹 파트 컨트롤에 의해 구현 된 설정, 동적을 삭제 하려면 사용자가 기능 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 사용자는 컨트롤을 페이지에 추가한 개인 설정 범위에 따라 달라 집니다. 컨트롤을 추가 하면 페이지가 공유 범위에 있을 때 (권한이 있는 사용자), 다음 컨트롤을 삭제할 수 없습니다 개별 사용자가 페이지가 사용자 범위에 있을 때.  
  
 동적 컨트롤에만 삭제할 수 있습니다. 동적 컨트롤은 프로그래밍 방식으로 또는 카탈로그에서 컨트롤을 추가 하는 사용자가 페이지에 추가 됩니다. 정적 컨트롤 태그 또는 지 속성 형식에서 선언적으로 페이지에 추가 됩니다. 선언적 태그를 영구적으로 태그에 있는 이기 때문에 정적 컨트롤을 삭제할 수 있지만 닫힌 후 다시 열 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다. 처음으로 **추가 달력** 단추 코드를 이벤트 처리기를 만듭니다를 <xref:System.Web.UI.WebControls.Calendar> 컨트롤을 영역에 추가 하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체입니다. 컨트롤은 프로그래밍 방식으로 추가 되므로, 동적 컨트롤과 이며 따라서 삭제할 수 있습니다. 클릭할 때 합니다 **달력 삭제** 단추를 확실히 컨트롤 존재 하 고이 다시 호출 하 여이 삭제 하는 코드를 통해를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 메서드.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 웹 페이지의 레이아웃을 변경하는 데 사용되는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 필드에 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고 포함 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 정적 개체 이기 때문에 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지 컨트롤 처음 로드할 때의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 페이지를 먼저 사용자를 다른 영역 또는 현재 영역 내의 컨트롤을 이동 하 여 페이지의 레이아웃을 변경 하려면 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (디자인 모드). 디자인 모드에서 다양 한 영역에 대 한 사용자 인터페이스 (UI) 나타나고 사용자가 레이아웃을 변경 하려면 컨트롤을 끌어 놓을 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 프로그래밍 방식으로 필드입니다. 코드는 찾아보기 및 디자인이 경우에 페이지에 대해 지원 되는 디스플레이 모드를 사용 하 여 드롭다운 목록을 채웁니다. 있음을에 `Page_PreRender` 메서드, 코드 검사 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>합니다. 그렇다면 `Label1` 를 볼 수는 그렇지 않은 경우 및 `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 기본적으로 찾아보기 모드 상태입니다. 페이지의 레이블이 숨겨지는지를 확인 합니다. 페이지 디자인 모드로 전환 하려면 드롭다운 목록 컨트롤을 사용 합니다. 있음을의 코드로 인해는 `Page_PreRender` 메서드는 레이블이 표시 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결을 끊을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</param>
        <summary>닫거나 삭제할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 해당 컨트롤이 참여하는 연결에서 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드는 내부적으로 컨트롤을 페이지에 닫혀 또는 페이지에서 삭제를 설정 하는 웹 파트 컨트롤입니다. 이러한 시나리오는 메서드는 소비자 또는 공급자 관련 되어 있는 모든 연결에서 컨트롤을 제거 하려면 호출 됩니다. 컨트롤은 모든 연결에서 제거 되 면 하는 경우이 메서드 호출을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 모든 연결을 종료 하는 방법 `webPart` 참여 했습니다.  
  
 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드가 호출 되 면 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트입니다. 일반적으로이 이벤트를 취소할 수 있지만 두 경우에서에 취소할 수 없습니다. 페이지 요청 중 발생 한 경우 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> 메서드가 호출 됩니다. 기존 연결 간에 충돌이 발생 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 충돌 하는 연결 및이 인스턴스가 하나 닫으려면 메서드를 호출할는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 충돌을 해결할 수 있어야 하기 때문에 이벤트를 취소할 수 없습니다.  
  
 다른 경우 발생 경우를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 현재 연결 된 서버 컨트롤 중 닫히거나 삭제 합니다. 제어로 인해이 경우 종료 될도 따라서 취소 하는 것이 불가능 의도적인 연결 요구 사항 페이지에서 제거 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 연결을 종료 하면 프로세스를 중단 하는 이벤트입니다. 자세한 내용은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드를 사용하는 방법을 보여 줍니다. 두 가지 사용자 지정을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 웹 페이지에서는 다른 단추를 사용 하면 컨트롤을 분리 하는 동안 단추를 클릭 하 여 컨트롤 간의 연결을 만들 수 있습니다. 사용자 컨트롤 중 하나는 동안를 닫고 페이지는 찾아보기 모드 이며 컨트롤이 연결 될 경우 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드 닫힌된 컨트롤의 연결을 끊습니다 해당 연결을 종료 하 고 메시지를 표시 합니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   디스플레이 모드를 변경 하는 것에 대 한 사용자 컨트롤입니다.  
  
-   사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
-   컨트롤을 호스트 하는 웹 페이지입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 두 번째 부분은 두 가지 사용자 지정에 대 한 소스 코드를 포함 하는 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결 하는 컨트롤 및 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예제에서는 동적 컴파일 사용 하므로 `Register` 웹 페이지에서 이러한 구성 요소를 참조 하는 지시문이 적절 하 게 선언 된 웹 페이지의 맨 위에 있는 합니다. 컴파일 옵션을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 소스 코드에서 상속 된 컨트롤을 확인할 수 있습니다 `MyWebPartManager` 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드. 이 메서드를 여부를 닫히기 컨트롤 연결에 참여 하는 경우 호출 페이지에서 각 연결을 검사 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드는 연결을 종료 합니다. 메서드의 기본 구현에 동일 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 그런 다음 재정의 된 메서드는 페이지에 메시지를 작성 하 여 기본 구현을 사용자 지정 합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 위쪽 가까이 있음을 알 수 있습니다 `Register` 지시문을 사용 하 고 사용자 컨트롤을 사용 하 여 동적으로 컴파일된 어셈블리를 등록 하는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 페이지에는 두 가지 주요 방법에 있습니다. 합니다 `Button1_Click` 메서드는 컨트롤 간의 연결을 만듭니다 동안는 `Button2_Click` 메서드는 컨트롤의 연결을 끊습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 페이지를 로드 한 후 클릭 합니다 **연결** 단추 컨트롤을 연결 합니다. 그런 다음 동사 메뉴 (컨트롤의 헤더에 있는 아래쪽 화살표)를 컨트롤 중 하나를 클릭 하 고 선택 **닫기** 동사 메뉴에서. 컨트롤을 닫으려고 할 때 재정의 된 메서드 호출 되 면 연결이 종료 되 고 페이지에 메시지가 기록 됩니다. 닫힌된 컨트롤을 복원 하 고 다른 옵션을 사용 하 여 실험을 클릭 하 여 페이지를 다시 설정 하려는 경우는 **사용자 상태를 다시 설정** 연결할 개인 설정 데이터를 제거 하 고 페이지의 원래 상태를 복원 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">서버 컨트롤 간의 연결을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />입니다.</param>
        <summary>웹 페이지에 있는 연결된 서버 컨트롤의 연결을 끊는 프로세스를 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드 간의 연결을 종료 하는 전체 과정을 수행 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 서버 컨트롤에 전달할 때의 `connection` 매개 변수입니다.  
  
 이 메서드는 컨트롤을 배치 하면 연결을 끊을 데는 `<asp:connectionszone>` 연결 관리에 대 한 사용자 인터페이스 (UI)를 제공 하는 웹 페이지에는 요소입니다. 페이지의 경우 연결 디스플레이 모드 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>), 현재 연결이 있는 호출 하는 단추를 클릭 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 연결을 종료 하는 방법입니다.  
  
 호출할 수도 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 프로그래밍 방식으로 및 추가 하지 않고도 컨트롤을 분리 하려는 경우 코드에서 직접 메서드는 `<asp:connectionszone>` 페이지에는 요소입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드를 사용하는 방법을 보여 줍니다. 두 가지 사용자 지정을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 웹 페이지에서는 다른 단추를 사용 하면 컨트롤을 분리 하는 동안 단추를 클릭 하 여 컨트롤 간의 연결을 만들 수 있습니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   디스플레이 모드를 변경 하는 것에 대 한 사용자 컨트롤입니다.  
  
-   사용자 지정을 포함 하는 원본 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
-   컨트롤을 호스트 하는 웹 페이지입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 두 번째 부분은 두 가지 사용자 지정에 대 한 소스 코드를 포함 하는 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결 될 컨트롤입니다. 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 예제에서는 동적 컴파일 사용 하므로 `Register` 웹 페이지에서 이러한 구성 요소를 참조 하는 지시문이 적절 하 게 선언 된 웹 페이지의 맨 위에 있는 합니다. 컴파일 옵션을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 위쪽 가까이 있음을 알 수 있습니다 `Register` 사용자 정의 컨트롤을 사용 하 여 동적으로 컴파일된 어셈블리를 등록 하는 지시문을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 페이지에는 두 가지 주요 방법에 있습니다. 합니다 `Button1_Click` 메서드는 컨트롤 간의 연결을 만듭니다 및 `Button2_Click` 메서드는 컨트롤의 연결을 끊습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 페이지를 로드 하면 클릭할 수는 **Connect** 단추 컨트롤을 연결 합니다. 텍스트 상자 컨트롤에 일부 텍스트를 입력 하 고 클릭 하는 경우는 **Enter** 단추, 텍스트 (없습니다 표시 될 컨트롤에 연결이 끊어진 경우) 연결 된 컨트롤에 표시 됩니다. 클릭 하면 합니다 **연결 끊기** 단추 컨트롤의 연결이 끊어집니다. 사용 하 여 컨트롤의 연결 상태를 확인할 수 있습니다 합니다 **디스플레이 모드** 페이지를 전환 하려면 드롭다운 목록 컨트롤 **Connect** 모드입니다. 그 다음 컨트롤 중 하나의 제목 표시줄에서 동사 메뉴 (화살표로 표시 됨)를 클릭 하 고 선택 합니다 **Connect** 항목입니다. 연결 UI가 표시 됩니다. 있기 때문에 사용할 수 있기를 `<asp:connectionszone>` 요소가 페이지에서 선언 합니다. 또한 연결 하 고이 UI에서 컨트롤을 연결을 끊을 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 또는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />에 포함되지 않은 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />이(가) 읽기 전용입니다.  
  
또는 
 <paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />에서 이미 연결이 끊긴 경우  
  
또는 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />이(가) 읽기 전용입니다.  
  
또는 
 <paramref name="connection" />이 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />에서 이미 연결이 끊긴 경우</exception>
        <block subset="none" type="overrides"><para>재정의할 수 있습니다 합니다 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" /> 연결 끊기에 대 한 기본 구현을 변경 하려는 경우 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다. 메서드를 재정의 하는 단순히 기존 메서드 일부 구현을 추가 하려는 경우에 사용자 고유의 코드를 실행 하기 전에 기본 메서드를 호출할 수 있습니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 컨트롤이 들어 있는 웹 페이지의 활성 디스플레이 모드를 가져오거나 설정합니다.</summary>
        <value>페이지의 디스플레이 모드를 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 컨트롤을 포함 하는 페이지는 항상 여러 가능한 표시 모드 중 하나입니다. 디스플레이 모드에 대 한 자세한 내용은 참조 하세요 [웹 파트 페이지 표시 모드](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스는 웹 페이지에 대 한 디스플레이 모드를 만듭니다. 기본을 사용 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 웹 파트 컨트롤이 들어 있는 페이지에 사용할 수 있는 몇 가지 표준 디스플레이 모드 개체를 만듭니다. 이러한 표준 디스플레이 모드에 설명 되어는 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 클래스 개요입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 디스플레이 모드 웹 파트 컨트롤을 사용 하는 페이지를 관리 합니다. 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 페이지에 현재 표시 모드에 대 한 참조를 유지 합니다. 사용할 수도 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성 페이지를 다른 디스플레이 모드로 전환 합니다. 웹 파트 컨트롤을 사용 하는 페이지의 디스플레이 모드를 변경 하는 예제를 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 디스플레이 모드를 관리 하는 일환으로는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 이벤트 및 디스플레이 모드와 같은 관련 된 이벤트 처리기도 제공 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 메서드. 이러한 메서드는 페이지의 동작을 사용자 지정 및 사용자 지정 디스플레이 모드를 추가 하는 메커니즘을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성입니다. 브라우저에서 페이지를 로드 한 후 표시 모드를 전환 하려면 페이지 아래쪽에 있는 단추를 사용할 수 있습니다. 페이지를 로드할 때 기본적으로 찾아보기 모드입니다. 디자인 모드로 전환 하는 경우에 다른 영역에서 서버 컨트롤을 끌어 수도 있고 하나의 영역 내에서 두 개의 정렬 수 있습니다. 편집 모드로 전환 하면 클릭할 수 중 한 서버 컨트롤의 헤더에 있는 동사 메뉴 **편집**, 제공 된 편집 사용자 인터페이스 (UI)를 사용 하 여 컨트롤을 편집 하 고 있습니다.  
  
> [!NOTE]
>  웹 파트 응용 프로그램의 디스플레이 모드 간에 전환 하는 것은 매우 흔히 및 웹 파트 컨트롤이 들어 있는 모든 페이지에이 작업을 수행 하는 일관 되 고 다시 사용할 수 있는 방법을 제공 하는 것이 좋습니다. 여러 페이지에는 디스플레이 모드 변경 하는 사용자 정의 컨트롤의 예제를 다시 사용할 수 있습니다, 참조 [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체가 지원되는 디스플레이 모드 중 하나가 아닌 경우  
  
또는 
속성에 할당되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체를 사용할 수 없는 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">연습: 웹 파트 페이지에서 디스플레이 모드를 변경합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 파트 페이지의 현재 디스플레이 모드가 변경된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시 모드는 웹 파트 응용 프로그램의 필수적인 부분입니다. 사용자가 웹 페이지의 디스플레이 모드를 전환 하는 경우 페이지를 종종 새 디스플레이 모드의 용도 매우 다양 한 형태를 수행 합니다. 표시 모드를 변경 된 후에 선택한 UI 요소의 모양을 변경를 숨기 거 나 특정 컨트롤을 보여 주는 같은 사용자 인터페이스 (UI)에서 특정 변경 해야 할 수도 있으며 등 수 있습니다.  
  
> [!NOTE]
>  디스플레이 모드에 대 한 자세한 내용은 참조 하세요. [웹 파트 페이지 표시 모드](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다. 이벤트 소비에 대 한 자세한 내용은 참조 하세요. [방법: Web Forms 응용 프로그램에서 이벤트 사용](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 웹 페이지에서 디스플레이 모드 변경 프로세스를 시작하는 동사를 클릭한 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시 모드는 웹 파트 응용 프로그램의 필수적인 부분입니다. 사용자가 웹 페이지의 디스플레이 모드를 전환 하는 경우 페이지를 종종 새 디스플레이 모드의 용도 매우 다양 한 형태를 수행 합니다. 특정 사용자 인터페이스 (UI)에서 사용 하 여 변경 하려는 사용자가 동사를 클릭 하 여 새로운 디스플레이 모드를 변경 하는 프로세스를 시작한 후의 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A> 어떤 새로운 디스플레이 모드 및 다양 한 UI를 변경한 다음 확인 하는 속성 요소가 적절 하 게 합니다. 이 작업을 수행 하는 유용한 방법은 재정의 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> UI 사용자 지정 하는 방법입니다.  
  
> [!NOTE]
>  디스플레이 모드에 대 한 자세한 내용은 참조 하세요. [웹 파트 페이지 표시 모드](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)합니다. 이벤트 소비에 대 한 자세한 내용은 참조 하세요. [방법: Web Forms 응용 프로그램에서 이벤트 사용](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤과 관련된 모든 디스플레이 모드의 읽기 전용 컬렉션을 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> 컨트롤과 관련된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 와 달리 연결 된 모든 디스플레이 모드에서 속성 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 디스플레이 모드 (지원) 현재 페이지에서 사용할 수 있는 참조 하는 속성입니다.  
  
 제공 된 디스플레이 모드, 찾아보기 및 디자인의 두 페이지에 항상 지원 됩니다. 다른 세 가지 디스플레이 모드, 편집, 카탈로그 및 연결 페이지에 해당 영역 종류를 작동 하려면 특정 디스플레이 모드에 필요한 경우에 지원 됩니다. 예를 들어, 페이지에 없는 경우는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 영역 편집 디스플레이 모드를 참조 하는 컬렉션에 나타나는 것을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 속성을 참조 하는 컬렉션에 표시 되지 않습니다 하지만 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성.  
  
   
  
## Examples  
 다음 코드 예제에는 프로그래밍 방식으로 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 속성입니다. 코드는 웹 파트 컨트롤 집합에서 사용 가능한 모든 디스플레이 모드를 사용 하 여 목록 채우기, 현재 페이지에서 지원 되지 않는 것에이 속성을 사용 합니다. 이 경우 카탈로그 하 고 해당 영역 페이지에 없는 필요 하기 때문에 모드에서는 지원 되지 않으므로 표시를 연결 합니다.  
  
 다른 세 가지 디스플레이 모드-찾아보기, 디자인 및 편집-페이지에서 지원 됩니다. 편집 페이지에 포함 되어 있으므로 모드가 지원 되는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 찾아보기 하는 동안 영역 및 디자인 모드는 항상 지원.  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드에서 페이지 디자인 모드를 전환 하려면 드롭다운 목록 컨트롤을 사용할 수 있습니다 다음 편집 모드를 합니다. 편집 모드 중 한 서버 컨트롤의 헤더에서 동사 드롭다운 메뉴를 클릭 하 고 수 선택 **편집** 컨트롤을 편집 합니다. 선택 하는 경우 사용자에 게 유의 **카탈로그** 하거나 **Connect** 드롭 다운 목록에서 오류 페이지가 생성 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">연습: 웹 파트 페이지에서 디스플레이 모드를 변경합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 현재 있는 모든 동적 연결의 컬렉션을 가져옵니다.</summary>
        <value>페이지의 모든 동적 연결에 대한 참조가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 연결에 프로그래밍 방식으로 정적이 아니라 만든 연결이 있습니다. Web Forms 페이지의 태그에 선언 하 여 정적 연결이 설정 됩니다. 프로그래밍 방식으로 또는 연결 사용자 인터페이스 (UI)를 사용 하 여 연결을 만드는 사용자가 동적 연결을 구성 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 컬렉션,이 기능은 읽기 전용 이며 해당 콘텐츠를 변경할 수 없습니다, 각 동적 연결 개체에 대 한 프로그래밍 방식의 액세스를 제공 하는 합니다.  
  
> [!NOTE]
>  연결 또는 연결 끊기와 같은 일반적인 작업을 수행할 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 개발자에서 공용 메서드를 사용 해야 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스와 같이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, 직접 연결을 수정 하는 대신 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최종 사용자가 서버 컨트롤을 편집 및 수정할 수 있는 디스플레이 모드를 나타냅니다. 이 필드는 읽기 전용입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 필드에 사용자 지정 참조 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> 만들어지고 포함 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 정적 개체 이기 때문에 참조할 수 있습니다를 통해 직접는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 인스턴스를 필요로 하지 않고 클래스입니다.  
  
 웹 파트를 포함 하는 페이지 컨트롤 처음 로드할 때의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> (찾아보기 모드) 기본적으로 합니다. 페이지를 사용자가 편집 하거나 서버 컨트롤을 수정 하려면, 먼저 전환 해야 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (편집 모드). 둘째, 특정 서버 컨트롤의 편집 동사를 제어 하는 헤더에 있는 동사 메뉴를 클릭 하 여 편집을 선택 해야 합니다. 컨트롤이 편집 모드로 되 면 선택한 컨트롤을 편집 하는 것에 대 한 편집 사용자 인터페이스 (UI) 표시 됩니다.  
  
 페이지에서 편집 모드를 사용 하려면 페이지 적어도 하나 있어야 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 제공 되는 편집 중 하나 이상을 포함 하는 영역 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> 컨트롤 또는 사용자 지정 편집 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 프로그래밍 방식으로 필드입니다. 코드는 찾아보기, 디자인 및 편집이 경우에 페이지에 대해 지원 되는 디스플레이 모드를 사용 하 여 드롭다운 목록을 채웁니다. 편집을 지원 하려면는 `<asp:EditorZone>` 요소가 페이지에 포함 됩니다. 있음을에 `Page_PreRender` 메서드, 코드 검사 여부를 현재 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A> 속성이 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>합니다. 그렇다면 `Label1` 를 볼 수는 그렇지 않은 경우 및 `Label1` 숨겨집니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 기본적으로 찾아보기 모드 상태입니다. 페이지의 레이블이 숨겨지는지를 확인 합니다. 페이지를 편집 모드로 전환 하려면 드롭다운 목록 컨트롤을 사용 합니다. 있음을의 코드로 인해는 `Page_PreRender` 메서드는 레이블이 표시 됩니다. 클릭 합니다 **편집** 해당 특정 컨트롤의 편집을 사용 하려면 컨트롤 중 하나에 있는 동사 메뉴의 동사입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 들어 있는 웹 페이지에서 클라이언트 스크립트를 사용할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>페이지에서 클라이언트 스크립트를 실행할 수 있는지 여부를 나타내는 부울 값입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A> 속성은 클라이언트 스크립트를 사용 하지 않도록 설정 하기 위한 방법을 제공 합니다. 클라이언트 보안을 위해 스크립트를 사용 하지 않도록 설정 하거나 되도록 페이지의 모든 사용자는 비슷한 사용자 환경이 되어 다른 브라우저를 사용 하는 경우에 좋습니다.  
  
 클라이언트를 추가 하 여 스크립트를 비활성화할 수 있습니다는 `EnableClientScript` 특성을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 선언적 코드의 다음 줄을 웹 페이지:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 개발자가에서 상속 하 여이 속성을 제거할 수는 또한 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 및 기본 설정 값을 `false`입니다.  
  
 웹 파트 컨트롤 집합에는 클라이언트의 일부 사용자 인터페이스 (UI) 및 개인 설정 기능을 제공 하는 데 클라이언트 스크립트를 사용 합니다. 클라이언트를 사용 하지 않도록 설정 하는 경우 스크립팅, 웹 파트 컨트롤은 여전히 작동 하지만 일부 기능이 사용 되지 않습니다. 다른 영역으로 컨트롤을 끌어다 놓을 수 (동사 대신 컨트롤의 제목 표시줄에서 링크로 표시 됨) 하는 컨트롤의 제목 표시줄에서 동사 드롭다운 메뉴에 동사를 렌더링 하는 기능과 더불어 비활성화 됩니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 테마를 사용할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>테마를 사용할 수 있는지 여부를 나타내는 부울 값입니다. 모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 기본 재정의 <xref:System.Web.UI.Control.EnableTheming%2A> 속성 값이 항상 반환 하는지 확인을 `true`입니다. 웹 파트 컨트롤 집합에서는 웹 파트를 렌더링 하는 테마를 사용 하는 컨트롤의 자식 컨트롤 되므로 이렇게는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤과 웹 페이지의 사용자 인터페이스 (UI)를 구성 합니다. 예를 들어 테마는 다양 한 영역을 렌더링 하는 데 및 다양 한 유형의 해당 영역에 있는 컨트롤 파트 컨트롤 (에서 상속 되는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.Part> 클래스)를 사용자 컨트롤, ASP.NET 서버 컨트롤 및 사용자 지정 서버 컨트롤입니다.  
  
 하지만 재정의 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A> 속성은 해당 기본 속성에 따라 읽기/쓰기 속성으로 구현, 디자인 하 여 반환 해야 하므로 항상 값 속성을 설정할 수 없습니다 `true`합니다. 속성을 설정 하려는 경우는 <xref:System.NotSupportedException> 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 설정하려고 한 경우</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 다른 컨트롤에 연결하는 프로세스를 완료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 연결 하는 프로세스를 완료 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 다른 컨트롤입니다. 상응 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> 메서드.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 메서드를 사용 하면 개인 설정 개체에서 참조 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 수정할 수 있는 필요한 유형이 기 때문에 대 한 연결을 형성 자체를 개인 설정 합니다. 메서드는를 사용 하면 다음 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 개체가 아닙니다 `null`, 마지막으로 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성이 참조하는 컨트롤이 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides"><para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤을 파생된 클래스에서이 메서드를 재정의 하려고 합니다. 기본 메서드를 호출 하 고 몇 가지 추가 사용자 지정 처리를 추가 하는 한 가지 방법은 것 또는 컨트롤 간의 연결을 완료 하는 전체 프로세스를 완전히 사용자 지정할 수 있습니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 편집하는 프로세스를 완료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 편집 프로세스를 완료 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 상응 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 메서드를 사용 하면 개인 설정 개체에서 참조 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성은 수정할 수 있는 필요한 이므로 컨트롤 편집을 개인 설정 변경 해야 하는 프로세스입니다. 메서드는를 사용 하면 다음 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 개체가 아닙니다 `null`되도록 현재 선택 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 수를 변경 하 고 마지막를 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성이 참조하는 컨트롤이 <see langword="null" />인 경우</exception>
        <block subset="none" type="overrides"><para>확장 하는 개발자는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤을 파생된 클래스에서이 메서드를 재정의 하려고 합니다. 기본 메서드를 호출 하 고 몇 가지 추가 사용자 지정 처리를 추가 하는 한 가지 방법은 것 또는 컨트롤의 편집을 완료 하는 전체 프로세스를 완전히 사용자 지정할 수 있습니다. 예를 들어, 재정의 메서드에서 수 없습니다 기본 메서드를 먼저 호출을 추가한 다음 편집 변경 내용을 결정 하는 일부 코드 및 변경 내용 목록을 다시 최종 사용자에 게 확인 메시지가 표시 됩니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤에서 중요한 상태 데이터를 내보내려고 할 때 표시되는 경고 메시지 텍스트를 가져오거나 설정합니다.</summary>
        <value>경고 메시지가 들어 있는 문자열입니다. 기본 메시지는 .NET Framework에서 제공하는 문화권별 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 중요 한 상태 데이터를 내보낼 하려고 할 때를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어, 하 라는 메시지 상자에 사용자에 게 경고 메시지가 표시 됩니다 내보내는 데이터의 소스 코드에서 중요 한 정보로 표시 된 멤버에서 상태가 되 면 중요 한 데이터를 내보내고 내보내기를 취소 하는 기회를 제공 합니다. 개발자 설정 하 여 중요 한 특정 멤버의 데이터를 표시할 수는 `isSensitive` 의 매개 변수를 `[Personalizable]` 특성을 `true` 멤버입니다. 이 특성 및 매개 변수에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute> 클래스입니다.  
  
> [!IMPORTANT]
>  웹 파트의 내보내기 기능을 사용 하는 경우 중요 한 데이터가 권한이 없는 사용자에 게 잠재적으로 내보낼 수도 있습니다. 이 위협 으로부터 보호 하는 방법에 대 한 세부 정보를 참조 하세요 [웹 파트 페이지 보안](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 기본 메시지는 사용자가 내보내기를 시도할 때마다 표시 됩니다. 그러나 값을 할당 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성을 사용자 지정 경고 메시지를 제공할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 선언적는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A> 속성입니다.  
  
 다음 웹 페이지의 코드를 사용 하 여 표준 <xref:System.Web.UI.WebControls.BulletedList> 제어 하 고 영역에 배치 합니다. 컨트롤 래핑를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 를 true로 역할을 할 수 있는 런타임 시 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 컨트롤을 내보낼 수 있도록를 `ExportMode` 특성이 추가 되는 `<asp:bulletedlist>` 요소 및 특성 값으로 설정 됩니다 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, 즉, 중요 한 및 중요 하지 않은 데이터를 내보낼 수 있습니다. 또한 합니다 `<asp:webpartmanager>` 요소는 `ExportSensitiveDataWarning` 특성을 사용자 지정 값이 할당 됩니다.  
  
 코드 예제가 작동 하려면, 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에 추가 해야 하는 설정이 있습니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내 합니다 `<system.web>` 섹션, 있는지는 `<webParts>` 요소는 `enableExport` 특성이로 설정 `true`다음 태그 에서처럼.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 링크를 포함 하는 컨트롤의 제목 표시줄에서 동사 메뉴 (아래쪽 화살표로 표시 됨)를 클릭 합니다. 동사 메뉴에서 선택 **내보내기**, 사용자 지정 경고를 사용 하 여 메시지 상자에 나타나는 것을 확인 합니다. 내보내기를 계속 하려면 클릭 **확인**를 컨트롤에 대 한 모든 데이터를 사용 하 여 XML 설명 파일의 로컬 복사본을 저장할 수 있는 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">데이터를 내보낼 해당 컨트롤입니다.</param>
        <param name="writer"><paramref name="webPart" />에서 내보낸 데이터를 XML 설명 파일에 쓰는 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>서버 컨트롤의 상태 및 속성 데이터가 들어 있는 XML 설명 파일을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 메서드를 다양 한 상태 및 속성 데이터가 조합 `webPart` XML 파일로. 데이터는 해당 어셈블리, 상태 데이터 및 속성 데이터를 포함 하 여 컨트롤 자체에 대 한 정보를 포함 합니다. 내보내기를 시작 하는 사용자 로컬 컴퓨터 또는 네트워크 디스크에 XML 파일을 저장 수 있습니다. 다른 사용자에 게 다음 설명 파일 다른 페이지 또는 웹 사이트를 가져오고 상태 및 속성 데이터의 다른 인스턴스에 적용 `webPart`합니다. 이 사용자가 공유 하 여 서버 컨트롤에서 해당 설정을 다시 사용할 빠르고 편리한 메커니즘을 제공 하며, 내보낸 및 가져온 컨트롤의 동작과 모양을 제어 하는 수단을 사용 하 여 개발자 해줍니다.  
  
 속성에 `webPart` 기본적으로 내보내지 않습니다. 내보내기를 사용 하도록 설정 속성을 표시 해야 하는 `[Personalizable]` 소스 코드의 특성입니다. 또한 필요에 따라 설정 하 여 중요 한 데이터를 포함 하는 내보낼 수 있는 속성을 표시할 수 있습니다 합니다 `isSensitive` 의 매개 변수를 `[Personalizable]` 특성을 `true`입니다. 기본적으로 `isSensitive` 는 `false`합니다. 개발자 매개 변수를 설정할 수 있습니다 `true` 중요 한 데이터 임을 나타냅니다.  
  
 사용할 수 있도록 `webPart` 내보낼 개발자는 다음과 같이 설정 됩니다. 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성 값을 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (개인 및 중요 한 속성을 모두 포함), 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>, 중요 한 속성을 제외한 내보내기를 .  
  
> [!IMPORTANT]
>  사용자가 컨트롤에서 데이터 내보내기 및 다른 컨트롤에 데이터를 가져올 수 있도록 몇 가지 보안 위험을 수반 합니다. 중요 한 데이터를 보호 하기 위해 위에서 설명한 방법을 사용 해야 하며 해당 데이터를 모두 노출 위험을 방지 하는 경우에 export를 사용 하지는 마십시오 `webPart` 전혀 합니다. 웹 파트 보안 문제에 대 한 자세한 내용은 참조 하세요. [웹 파트 페이지 보안](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.  
  
또는 
 <paramref name="writer" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />에서 참조되는 컨트롤의 컬렉션에 포함되지 않은 경우  
  
또는 
<paramref name="webPart" />의 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 속성이 <paramref name="webPart" />에서 데이터를 내보낼 수 없음을 나타내는 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" /> 값으로 설정된 경우</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">웹 파트 페이지 보안</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에는 UI(사용자 인터페이스)가 없으므로 이 컨트롤에 포커스를 설정하지 못하도록 재정의된 메서드입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> 메서드 재정의 기본 <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> 메서드 호출자 메서드를 호출 하는 경우 예외를 throw 합니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 포커스를 자체를 설정할 수 없도록 수, UI가 없는 컨트롤과 사용자에 게 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">호출자가 UI가 없는 컨트롤에서 지원되지 않는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 메서드를 호출하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결에서 소비자 역할을 하는 서버 컨트롤입니다.</param>
        <summary>웹 파트 연결의 소비자 역할을 하는 서버 컨트롤에서 연결 지점으로 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 개체의 컬렉션을 검색합니다.</summary>
        <returns>소비자의 연결 지점이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 연결을 항상 정확 하 게 두 가지 컨트롤을 데이터에는 다른 역할을 하는 데이터의 소비자의 공급자 역할을 하나 포함 됩니다. 각 컨트롤에는 연결 지점으로 정의 된 메서드를 하나 이상 있어야 합니다. 소비자 컨트롤의 경우 해당 연결점은 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint> 개체입니다. 소비자 연결 지점을 검색 하는 것은 웹 파트 연결을 구하기 위해 필요한 단계입니다.  
  
 소비자 항상 하나 이상의 연결점에 연결할 수 있어야 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드 소비자 컨트롤을 확인 하 고 모든 연결 지점의 컬렉션을 검색 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 연결 지점이 없습니다, 메서드가 빈 컬렉션을 반환 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 항목을 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그 포함 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. `Page_Load` 메서드를 코드 확인 여부를 연결을 이미 존재 하 고, 그렇지 않은 경우 해당 연결 지점을, 소비자 및 공급자를 정의 하 고 다음 참조 하는 정적 연결 집합에 새 연결을 추가 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection> 를 사용 하 여 검색 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 메서드에 전달 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 두 컨트롤 간의 연결을 만들 수 있는지 여부를 확인 하는 방법입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예제는 세 번째 부분은 컨트롤에 대 한 소스 코드를 사용 하는 것입니다. 이 코드와의 예제 섹션에서 컴파일 후에 대 한 지침을 얻을 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이 페이지 뒷부분에 나오는 브라우저 세션에서 반환 하는 경우이 정적 연결 이미 설정 및 페이지가 로드 될 때마다 다시 생성 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />의 인스턴스가 들어 있는 웹 페이지입니다.</param>
        <summary>페이지에 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 현재 인스턴스에 대한 참조를 검색합니다.</summary>
        <returns>페이지에 있는 컨트롤의 현재 인스턴스를 참조하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 메서드는 현재에 대 한 참조를 검색 하려는 상황에서 유용 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 수행 되는이 일반적인 시나리오는 어떤 ID를 개발 하는 동안 알 수 없는 사용자 지정 컨트롤을 작성 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 해당 페이지에서 제어 됩니다.  
  
> [!NOTE]
>  합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 의 인스턴스를 필요로 하지 않고 직접 호출할 수 있도록 메서드는 정적는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다.  
  
 와 같은 일부 웹 파트 컨트롤 컨트롤 집합을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에 <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A> 현재에 대 한 참조를 검색할 수 있는 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 따라서 이러한 컨트롤을 사용 하는 경우이 속성 참조를 검색 하려면 사용 해야 합니다.  
  
 ID를 알고 있는 컨텍스트에서 코딩 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 같은 웹 페이지 내에서 인라인에서 코드를 작성 하는 것이 가장 간단 하 고 가장 효율적인을 직접 참조 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> ID를 사용 하 여 컨트롤  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 메서드를 사용하는 방법을 보여 줍니다. 이 예제는 두 부분으로 구성: 사용자 지정 서버 컨트롤 및 컨트롤을 호스팅하는 웹 페이지입니다.  
  
 사용자 지정 <xref:System.Web.UI.WebControls.Label> 컨트롤이 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 의 ID를 검색 하는 방법의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 현재 페이지에서 다음 ID 표시 합니다.  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 다음 코드 예제에서 컨트롤을 호스팅하는 웹 페이지를 제공 된 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 있음을 현재 ID <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 사용자 지정 내 컨트롤에 표시 됩니다 <xref:System.Web.UI.WebControls.Label> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />가 <see langword="null" />입니다.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">메서드가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 값을 반환하는 컨트롤입니다.</param>
        <summary><see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 속성 값이 포함된 문자열을 가져옵니다.</summary>
        <returns><paramref name="webPart" />에 대해 계산된 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 값이 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 계산 된 값을 가져옵니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> 속성에 대 한 `webPart`합니다. 개발자에 값을 할당 하지 않는 경우는 <xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> 의 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤,이 메서드는 생성 제목으로 표시할 값입니다. 제목 없는 컨트롤에 대 한 계산 된 값을 현재 영역 내에서 컨트롤의 시퀀스를 나타내는 숫자를 사용 하 여 문자열에 추가 하는 숫자로 구성 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컬렉션에 없는 경우</exception>
        <block subset="none" type="overrides"><para>기본 표시 제목은 어떻게 계산을 변경 하려면이 메서드를 재정의할 수 있습니다.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">내보낼 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</param>
        <summary>사용자가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 내보내려고 할 때 요청에 포함된 상대 가상 경로와 쿼리 문자열을 가져옵니다.</summary>
        <returns>컨트롤 내보내기 요청을 구성하는 상대 가상 경로와 쿼리 문자열이 포함된 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환한 값은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 메서드는 컨트롤을 포함 하는 페이지의 서버 위치 상대 가상 경로 내보내기 요청을 구성 하는 추가 쿼리 문자열 값을 서버로 전송 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A> 메서드 요청을 제출할 수, 악성 스크립트 공격 으로부터 보호 하기 위해 허용 하기 전에 문자열을 인코딩합니다.  
  
> [!NOTE]
>  웹 파트 응용 프로그램을 보호 하는 방법에 대 한 자세한 내용은 참조 하세요. [웹 파트 페이지 보안](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control"><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />에 있으며 런타임에 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />의 자식 컨트롤로 래핑되는 서버 컨트롤입니다.</param>
        <summary>서버 컨트롤이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 컨트롤의 인스턴스에 대한 참조를 가져옵니다.</summary>
        <returns><paramref name="control" />을 자식 컨트롤로 래핑하는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />입니다. <paramref name="control" />이 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />에 포함되지 않은 경우 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 두 가지 범주가 있습니다 개발자에 배치 하는 컨트롤의 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 파트 응용 프로그램에 참여 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에서 상속 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 기본 클래스 및 표준 수 있는 다른 서버 컨트롤 ASP.NET 컨트롤, 사용자 지정 컨트롤 또는 사용자 정의 컨트롤입니다. 이러한 컨트롤 중 하나를 배치 하면를 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 기능에서 수행 하는 영역에는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에는이 기능이 기본적으로, 하지만 다른 서버 컨트롤 종류 하지 않습니다. 역할을 하는 다른 서버 컨트롤을 사용 하도록 설정 하려면 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 배치 되는 경우 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 를 사용 하 여 영역을 ASP.NET 래핑하는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤입니다. 때문에 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤에서 직접 상속 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 클래스는 자식 컨트롤 true 웹 파트 기능을 사용 하 여 합니다.  
  
 런타임 시 자주 페이지 개발자가 할 수에 대 한 참조를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 영역에 있는 서버 컨트롤 중 하나를 포함 하는 컨트롤입니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 메서드를 사용 하면에 대 한 참조를 검색할 수 있도록는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 메서드. 코드 예제에는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤 내에서 선언를 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다. `Button1_Click` 의 ID를 처음 인쇄 하는 메서드를 <xref:System.Web.UI.WebControls.Calendar> 컨트롤의 레이블을 사용 하 여 다음을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 에 대 한 참조를 검색 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 달력을 래핑하는 컨트롤입니다. ID를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 컨트롤과 해당 자식 컨트롤의 ID (되는 <xref:System.Web.UI.WebControls.Calendar> 컨트롤), 두 번째 레이블을 인쇄 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">연결에서 공급자 역할을 하는 서버 컨트롤입니다.</param>
        <summary>웹 파트 연결의 공급자 역할을 하는 서버 컨트롤에서 연결 지점으로 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 개체의 컬렉션을 검색합니다.</summary>
        <returns>공급자의 연결 지점이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 연결을 항상 정확 하 게 두 가지 컨트롤을 데이터에는 다른 역할을 하는 데이터의 소비자의 공급자 역할을 하나 포함 됩니다. 각 컨트롤에는 연결 지점으로 정의 된 메서드를 하나 이상 있어야 합니다. 공급자 컨트롤의 경우 해당 연결점은 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint> 개체입니다.  
  
 공급자에는 항상 하나 이상의 연결점에 연결할 수 있어야 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드는 공급자 컨트롤을 확인 하 고 모든 연결 지점의 컬렉션을 검색 합니다. 공급자 연결 지점을 검색 하는 것은 웹 파트 연결을 구하기 위해 필요한 단계입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드를 사용하는 방법을 보여 줍니다.  
  
 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 웹 페이지에 대 한 선언적 태그 포함 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. `Page_Load` 메서드를 코드 확인 여부를 연결을 이미 존재 하 고, 그렇지 않은 경우 해당 연결 지점을, 소비자 및 공급자를 정의 하 고 다음 참조 하는 정적 연결 집합에 새 연결을 추가 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection> 를 사용 하 여 검색 된 개체를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 메서드에 전달 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 두 컨트롤 간의 연결을 만들 수 있는지 여부를 확인 하는 방법입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 예제는 세 번째 부분은 컨트롤에 대 한 소스 코드를 사용 하는 것입니다. 이 코드와의 예제 섹션에서 컴파일 후에 대 한 지침을 얻을 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다.  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이 페이지 뒷부분에 나오는 브라우저 세션에서 반환 하는 경우이 정적 연결 이미 설정 및 페이지가 로드 될 때마다 다시 생성 해야 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">가져올 XML 설명 파일의 상태 및 속성 데이터를 읽는 <see cref="T:System.Xml.XmlReader" />입니다.</param>
        <param name="errorMessage">가져오는 중에 오류가 발생할 경우 사용자에게 표시되는 <see cref="T:System.String" />입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤에 대한 상태 및 속성 데이터가 들어 있는 XML 설명 파일을 가져온 다음 해당 데이터를 컨트롤에 적용합니다.</summary>
        <returns>가져온 XML 설명 파일에서 참조되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />(또는 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />로 래핑되어 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />로 취급되는 서버 컨트롤)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드 가져오는 데 사용 하 여 만든 XML 설명 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 서버 컨트롤에 대 한 메서드. 를 가져온 실제 서버 컨트롤이 있지만 컨트롤에 대 한 상태 및 속성 데이터를 포함 하는 설명 파일만 아닙니다. 이미 설명 파일에 참조 된 어셈블리 확인 하 고 제어 설명 파일 가져오기에 사용자가 서버에서 사용할 여야 합니다.  
  
 가져오기를 사용 하도록 설정 하는 컨트롤을 추가 하려면 개발자가는 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 가져오기를 사용할 페이지의 컨트롤입니다. 를 제외한 영역 내는 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 컨트롤을 추가 해야 합니다. 이 컨트롤에는 사용자가 설명을 가져올 파일을 찾을 수 있도록 파일 대화 상자를 제공 합니다.  
  
 Description 파일을 읽은 후 사용자 설명 파일을 찾을 시작 가져오기는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드. 오류가 없는 경우 서버 컨트롤 내에서 카탈로그를 추가 어셈블리와 컨트롤 발견 되 면는 <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart> 제어 및 description 파일의 지정 된 다양 한 속성 및 상태 데이터를 컨트롤에 적용 됩니다. 다음 사용자 컨트롤을 선택 하 고 페이지에 추가할 수 있습니다.  
  
> [!IMPORTANT]
>  같은 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> 메서드가 일부 잠재적인 보안 위험에 대 한 합니다. 웹 사이트에 데이터를 가져오는 포함 하기 때문에 악의적인 사용자가 가져온 설명 파일에 잘못 된 데이터 또는 스크립트 코드를 삽입할 시도할 수 있습니다. 잘못 된 데이터를 데이터베이스 또는 페이지에 표시 될 수 있습니다 또는 삽입 된 스크립트를 실행할 수 있습니다. 설명 파일 및 이러한 위험을 방지 하는 방법을 가져오기와 관련 된 잠재적인 위험 개요를 참조 하세요 [웹 파트 페이지 보안](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" />에서 파일을 읽지 못한 경우  
  
또는 
 가져오기 오류 메시지를 표시하는 데 필요한 <paramref name="reader" />를 파일에서 찾지 못한 경우  
  
또는 
 <paramref name="reader" />에서 내보낸 데이터가 들어 있는 XML 요소를 찾지 못하고 파일 끝에 도달한 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">웹 파트 페이지 보안</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 클래스에서 실제로 구현되어 있지만 대개 컨트롤 개발자에게 유용한 여러 메서드를 조합 및 분리하는 데 사용되는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에 대한 참조를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />가 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />로 분리된 다양한 메서드를 참조하는 데 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성의 집합으로 호출 하는 Api를 노출 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 확장성 사례에 주로 사용 되는 메서드.  
  
 이러한 내부 메서드를 사용 하는 디자인된 방법은 통해 액세스 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A> 속성입니다. 가 속성을 보호 하기 때문에 액세스 하는 인스턴스 내의 메서드를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> 클래스에서 상속 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스입니다.  
  
> [!NOTE]
>  이 속성의 IntelliSense에서 숨겨집니다. [!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]합니다. 그러나 파생에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스, 속성 및 다양 한 해당 멤버에 액세스할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 파트 기능의 유연성이 향상의 부분은 런타임 시 웹 페이지 서버 컨트롤을 추가할 수 있습니다. 일반적인 시나리오는 서버 컨트롤의 여러 가지 (사용자 지정 되는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 사용자 지정 서버 컨트롤, 사용자 지정 컨트롤, 또는 ASP.NET 컨트롤)를 추가할 수 있습니다.  
  
 다음과 같은 일반적인 시나리오에서 웹 파트 컨트롤 집합을 페이지에 서버 컨트롤을 추가 하려고 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 인증을 위해 호출 됩니다.  
  
-   내 웹 페이지의 태그에 선언 하 여 서버 컨트롤이 추가 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역입니다.  
  
-   때 서버 컨트롤은 영역에 프로그래밍 방식으로 추가 됩니다.  
  
-   때 사용자는 컨트롤의 웹 파트 카탈로그에 서버 컨트롤을 가져옵니다.  
  
-   기존 서버 컨트롤 개인 설정 데이터 저장소에서 로드 됩니다.  
  
-   서버 컨트롤을 추가할 때를 <xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart> 서버 컨트롤의 카탈로그에서 사용할 수 있도록 하는 컨트롤입니다.  
  
 컨트롤을 추가 하는 각 시나리오에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 호출 하는 컨트롤을 추가할 수 있도록 하는 모든 권한 부여 조건을 충족 되었는지 확인 합니다. 기본 설정에 있는 컨트롤 인지 필터링 시나리오 되었으면 것 처럼 일반적으로 추가 됩니다. 컨트롤을 받지 않은 경우 웹 파트 컨트롤 집합은 컨텍스트에 따라 여러 가지 방법으로 응답할 수 있습니다. 컨트롤 집합 (사용자에 게 알릴 필요가 없는 경우) 권한이 없는 파트를 추가 하지 않을 수, 오류 메시지를 표시할 수 또는 인스턴스를 추가할 수는 <xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart> 자리 표시자 클래스입니다. 이 자리 표시자 개체 페이지에 표시 되지 않지만 허가 되지 않은 컨트롤을 제외 된 나타내려면 페이지 소스 코드에 표시 됩니다.  
  
 있는 컨트롤 인지 여부의 행렬식 권한 부여 필터입니다. 권한 부여 필터에는 개발자가 지정된 된 조건을 충족 하지 않는 모든 컨트롤을 페이지에서 제외할 수 있는 웹 파트 컨트롤 집합에서 기능입니다.  
  
 개발자는 필터링 시나리오를 만들려면 두 가지 작업을 수행 해야 합니다. 먼저 문자열 값 (값을 임의의 수 있음)을 할당 해야 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 각 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 시나리오에서 사용 하 려 합니다. 되지 않는 서버 컨트롤의 다른 형식에 대 한이 속성에 값도 할당할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 때문에 컨트롤에 배치 될 경우 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역에 이러한 컨트롤은 사용 하 여 래핑됩니다는 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임에 컨트롤과이 컨트롤이 상속 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성입니다.  
  
 필터링 시나리오를 만드는 데 필요한 두 번째 단계는 재정의 하거나 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드를 이벤트 처리기를 만들려면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트. 이러한 메서드에서 개발자 확인할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성인 개발자 있는지 확인 하는 값이 컨트롤은 권한을 받지 않았음이 나타내면를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드 값을 반환 합니다. `false`.  
  
> [!NOTE]
>  코드 예제를 사용 하는 사용자 지정 필터링 시나리오를 설정 하는 방법에 대 한 설명을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드인 메서드의 오버 로드에 대 한 항목을 참조 하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">권한이 부여되었는지 확인할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤입니다.</param>
        <summary>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위한 초기 단계를 수행합니다.</summary>
        <returns><paramref name="webPart" />가 페이지에 추가할 수 있는 컨트롤인지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드는 초기 설정에 대 한 권한 부여를 확인 하려면 웹 파트 컨트롤에서 호출을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다. 받아들이는지 `webPart` 매개 변수로 궁극적으로 컨트롤 페이지에 추가할지를 결정 하는 프로세스가 시작 됩니다. 지정된 된 컨트롤 권한이 있는지 확인 해야 할 때 코드에서이 메서드를 직접 호출 합니다.  
  
 이 메서드는 컨트롤에서 상속 되는지 여부를 결정 하는 초기 작업을 수행 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 아니거나 클래스를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 제어 하 고 그렇다면 어떤 유형의 자식 제어 포함 되어 있습니다. 권한 부여 작업을 완료 하려면 호출을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드를 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 호출 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 페이지를 추가할 수 있는 컨트롤 인지 여부를 확인 하는 코드에서 메서드.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 하는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드.  
  
-   필터를 만들고 있는 웹 페이지를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 합니다.  
  
-   코드 예제를 실행 하는 방법 설명 합니다.  
  
 이 코드 예제에서는 사용자 지정 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 하는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 의 사용자 지정 처리를 제공 하는 메서드를 오버 로드는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성입니다. 이 컨트롤의 속성 값에 대 한 확인 `admin` 컨트롤에 값이 있는 경우 권한을 부여 합니다. 컨트롤을 다른 값에 권한이 없습니다. 속성 값이 없는 컨트롤은 공인 된도 필터링 시나리오의 일부가 아닐 것으로 가정 됩니다.  
  
 이 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제에서는 동적 컴파일 메서드를 사용합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 코드 예제에서는 두 번째 부분에는 컨트롤을 제외 시킬 수 있는 필터를 만듭니다. 다음 웹 페이지의 세 가지 ASP.NET 서버 컨트롤에는 `<asp:webpartzone>` 요소입니다. 첫 번째와 두 번째 컨트롤에는 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 다른 값으로 설정 하 고 세 번째 속성을 할당 하지 않습니다. 런타임 시이 권한 부여 값을 확인할 수 있습니다 하 고 필터 개발자 설정 된 조건과 일치 하는 경우 페이지에 컨트롤을 추가할 수 있습니다. 또한 합니다 `Page_Load` 메서드를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29> 여부 각 컨트롤의 권한이 부여 되 고 따라서 설정 각 컨트롤의 결정 방법 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내 합니다 `<system.web>` 섹션, 있는지는 `<webParts>` 요소는 `enableExport` 특성이로 설정 `true`다음 태그 에서처럼.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 브라우저에서 페이지를 로드, 재정의 된 메서드에서 조건 일치 하기 때문에 첫 번째 컨트롤에 표시 되도록 note 합니다. 필터에 의해 제외 되었으므로 두 번째 컨트롤이 페이지에 추가 되지 않습니다. 에 없기 때문에 세 번째 컨트롤에도 추가 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 집합입니다. 컨트롤의 제목 표시줄에서 동사 메뉴 아이콘을 클릭 하면 수 있다는 두 가지 모두 표시 하기 때문에 내보낼 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A> 속성 값이 할당 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" />가 <see langword="null" />입니다.</exception>
        <block subset="none" type="usage"><para>이 메서드는 사용자 코드에서 직접 호출 됩니다. 프로그래밍 방식으로 보다 효율적으로 제어 권한 부여 프로세스를 하려는 경우 재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" /> 메서드를 오버 로드 합니다.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">권한이 부여되었는지 확인할 컨트롤의 <see cref="T:System.Type" />입니다.</param>
        <param name="path">컨트롤이 사용자 정의 컨트롤인 경우 권한이 부여될 컨트롤의 소스 파일에 대한 상대 응용 프로그램 경로입니다.</param>
        <param name="authorizationFilter">컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하는 데 사용되는 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 속성에 할당된 임의의 문자열 값입니다.</param>
        <param name="isShared">권한이 부여되었는지 확인할 컨트롤이 공유 컨트롤인지 여부를 나타냅니다. 즉, 컨트롤이 응용 프로그램의 다수 또는 모든 사용자에게 표시되고 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 속성 값이 <see langword="true" />로 설정되어 있습니다.</param>
        <summary>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 확인하기 위한 마지막 단계를 수행합니다.</summary>
        <returns>컨트롤이 페이지에 추가할 수 있는 컨트롤인지 여부를 나타내는 부울 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 오버 로드 메서드 컨트롤이 페이지에 추가할 수 있는 컨트롤 인지 여부를 결정할 때 최종 단계를 수행 합니다. 메서드를 사용 하면 `type` 이 올바른 형식인 `path` 사용자 정의 컨트롤을 경우에 값이 있습니다. 중요 한 호출을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 를 발생 시키는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 페이지를 추가할 수 있는 컨트롤 인지 여부를 결정 하는 방법입니다.  
  
 첫 번째 단계는 컨트롤을 제외 시킬 수 있는 필터를 만드는 것입니다. 다음 웹 페이지의 세 가지 ASP.NET 서버 컨트롤에는 `<asp:webpartzone>` 요소입니다. 첫 번째와 두 번째 컨트롤에는 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성이 다른 값으로 설정 하 고 세 번째 속성을 할당 하지 않습니다. 런타임 시이 권한 부여 값을 확인할 수 있습니다 하 고 필터 개발자 설정 된 조건과 일치 하는 경우 페이지에 컨트롤을 추가할 수 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 재정의 하는 두 번째 단계입니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 메서드를 사용자 지정 권한 부여 필터에 대 한 처리를 만듭니다. 코드는 먼저 확인 속성에 값이 있는지 여부를 제어 하는 참고를 할당 하지 않습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성은 자동으로 추가 됩니다. 코드를 반환 하는 경우 컨트롤에 필터가 `true` 필터 값과 동일한 경우에 `admin`합니다. 이 해당 역할에 따라 특정 사용자에 게 특정 컨트롤을 표시 하기 위해 사용할 수 있는 간단한 메커니즘을 보여 줍니다. 역할을 사용 하 여 전체 예제는이 항목의 범위를 벗어납니다, 하는 동안 사용할 수 있습니다. 동일한 논리가 코드 예제에서는 재정의 된 메서드를 제외 하 고 현재 사용자가 권한 부여 필터 값과 일치 하는 역할에 있는지 여부를 확인할 수 있습니다. 을 추가한 다음 해당 사용자에 대해서만 제어 합니다. 이렇게 하면 일부 사용자는 모든 컨트롤을를 참조 하 고 다른 사용자가 선택한 컨트롤에만 나타나는 있는 페이지를 만들 수 있습니다. 이 필터를 확인 하는 논리 역할을 사용 하는 경우 이런 모양:  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 이 코드 예제에서는 동적 컴파일 메서드를 사용합니다. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 브라우저에서 페이지를 로드, 재정의 된 메서드에서 조건 일치 하기 때문에 첫 번째 컨트롤에 표시 되도록 note 합니다. 두 번째 컨트롤의 필터 값이 제외 되므로 페이지에 추가 되지 않습니다. 에 없기 때문에 세 번째 컨트롤이 추가 되 고, 해당 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 집합입니다. 일치 하는 첫 번째 컨트롤의 다음 페이지를 다시 실행 하는 두 번째 컨트롤의 속성 값을 변경한 경우 두 번째 컨트롤도 추가 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" />이 사용자 정의 컨트롤이고 <paramref name="path" />가 <see langword="null" />이거나 빈 문자열("")인 경우  
  
또는 
 <paramref name="type" />이 사용자 정의 컨트롤이 아니고 <paramref name="path" />에 할당된 값이 있는 경우</exception>
        <block subset="none" type="overrides"><para>상속 하 여이 메서드를 재정의할 수 있습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스, 권한 부여를 확인 하는 경우 추가 처리를 제공 하려는 경우. 특정 값을 확인 하려면 메서드를 재정의 하는 것이 좋습니다는 <paramref name="authorizationFilter" /> 매개 변수를 페이지에 컨트롤 추가 될 지 여부를 확인 하는 부울 값을 반환 값에 따라 합니다.  
  
또한 권한 부여 필터에 대 한 확인 하 고 사용자 지정 처리를 제공 하려는 페이지 개발자를 위한 모든 클래스에서 상속 하지 않고도.aspx 페이지 또는 코드 숨김 파일에서이 인라인으로이 수행할 수가 있습니다. 페이지에서 대체 이벤트 처리기를 선언할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 메서드는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 제어 합니다. 자세한 내용 및 예제에 대 한 참조를 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> 메서드.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 제어하는 페이지 수준 개인 설정 정보에 영향을 주는 개인 설정 변경 사항이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>개인 설정 변경 사항이 있는지 여부를 나타내는 부울 값입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성이 있는지 여부를 관리 하는 페이지 수준 개인 설정 데이터를 추적 하는 내부적으로 변경 합니다. 개인 설정 데이터가 변경 되는 사용자 추가 또는 제거와 같이 페이지 수준에서 다양 한 개인 설정 작업을 수행할 때 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 연결 하거나 분리 컨트롤, 컨트롤 및 기타 작업을 이동 하 여 페이지의 레이아웃을 변경 합니다.  
  
> [!NOTE]
>  사용자 컨트롤 수준에서 특정 컨트롤에 개인 설정 변경 내용은 할는 의미 있는 개인 설정을 수행할 수도 있습니다 및는 변경 내용이 해당 컨트롤에만 적용 합니다. 예제는 컨트롤 편집 되 고 해당 제목 텍스트 또는 해당 배경색을 변경 합니다. 제어 수준 개인 설정 하 여 추적 페이지 수준 개인 설정 데이터를 영향을 주지 않습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하므로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성 값으로 변경 되지 않습니다 `true` 제어 수준 개인 설정의 경우.  
  
 메서드는 보호 되 고 호출자가 직접 액세스할 수 없는 있지만 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성 호출자가 직접 액세스할 수 있으며이 속성의 값을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">로드하려는 저장된 상태 데이터가 들어 있습니다.</param>
        <summary>이전 페이지 요청에서 저장되었고 후속 요청에서 복원해야 하는 컨트롤 상태 데이터를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A> 메서드는 페이지의 포스트백에서 유지 되어야 하는 속성 데이터를 복원 하는 데 도움이 경우에 합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이 `false`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" />은 유효한 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />이 아닙니다.</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary>나중에 초기화 프로세스 동안 사용될 수 있게 개인 설정 개체에 의해 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 전달된 사용자 지정 개인 설정 데이터를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 형식의 저장 된 상태 데이터를 제공 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary> 개체입니다. 이 데이터는 웹 파트 컨트롤에 개인 설정 데이터를 로드 하 고 다른 초기화 작업을 수행 하기에 결국 사용 됩니다.  
  
> [!NOTE]
>  이 메서드는 시작 하는 경우는 메서드의 시퀀스를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A> 메서드를 처음으로 연결 된 요청 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 개인 설정 데이터를 제공 하는 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤.  
  
 이 메서드 코드에서 직접 호출할 수 없습니다. 직접 호출할 수 있지만 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A> 직접 메서드를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 메서드 및 개인 설정 데이터를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 에서 파생 된 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 형식 deserialization에 가져오는 동안이 속성에 의해 반환 되는 개체를 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Security.PermissionSet" /> 권한과 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 권한만 허용하는 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 개체를 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> 역직렬화 입력 점을 제외 하 고 모든 항목에 대 한 가져오기 작업 중이 속성에서 반환 하는 개체를 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">이동할 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤입니다.</param>
        <param name="zone"><paramref name="webPart" />가 이동될 대상 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</param>
        <param name="zoneIndex"><paramref name="webPart" /> 내의 다른 컨트롤에 상대적인 <paramref name="zone" />의 인덱스를 나타내는 정수입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 한 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에서 다른 영역이나 동일한 영역 내의 새 위치로 이동합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 이동할 메서드 `webPart` 동일한 영역에 또는 다른 시간대에 새 위치를 합니다. 코드에서 직접이 메서드를 호출할 수 있습니다 하 고 컨트롤을 웹 파트 사용자 인터페이스 (UI)에서 다양 한 옵션을 사용 하 여 새 위치로 이동할 때 호출 됩니다.  
  
 여러 조건 충족 해야 `webPart` 이동할 수 있습니다 및 이들 중 대부분은이 항목의 예외 섹션에 나열 된 항목으로 표시 됩니다. 하는 경우 `webPart` 에 포함 되지 않은 한 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 먼저 영역으로 이동할 수 없습니다.  
  
 다음 작업 순서에 따라 이동할 발생 조건을 조건이 충족 후 `webPart`:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트를 발생시킵니다.  
  
2.  `webPart` (필요한 경우) 현재 영역에서 제거 되 고 새 영역이 나 현재 영역 내의 새 위치에 추가 합니다.  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트를 발생시킵니다.  
  
4.  합니다 `zoneIndex` 의 모든 <xref:System.Web.UI.WebControls.WebParts.WebPart> 원본 및 대상 영역에서 컨트롤 이동된 컨트롤을 반영 하도록 다시 설정 됩니다.  
  
   
  
## Examples  
 다음 코드 예제를 호출 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 이동 하는 코드에서 직접 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 다른 영역에서 컨트롤입니다.  
  
 이 코드 예제는 세 부분으로 구성 합니다.  
  
-   디스플레이 모드를 변경 하는 것에 대 한 사용자 컨트롤입니다.  
  
-   컨트롤을 호스트 하는 웹 페이지입니다.  
  
-   코드 예제를 실행 하는 방법 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 자세한 내용은 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 두 서버 컨트롤에 포함 된 각 두 영역을 포함 하는 웹 페이지입니다. 클릭할 때 합니다 **WebPart 이동** 페이지의 코드에서 단추를 `Button1_Click` 메서드 첫 번째 영역에서 컨트롤을 두 번째 영역에서 새 위치로 이동 합니다. 코드를 먼저 호출 해야 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> 검색 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 래핑하는 개체는 `list1` 컨트롤. 때문에 이것이 필요의 첫 번째 매개 변수를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 메서드를 사용 하려면를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 반면 컨트롤 `list1` ASP.NET 서버 컨트롤입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 페이지를 로드 한 후 클릭 합니다 **WebPart 이동** 단추 및 링크를 포함 하는 컨트롤 두 번째 영역의 가운데 위치로 이동 합니다. 컨트롤의이 이동이 호출 하 여 프로그래밍 방식으로 수행 됩니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 메서드. 사용할 수도 있습니다는 **디스플레이 모드** 디자인 모드에서 페이지를 디자인 모드로 전환 하려면 드롭다운 목록 컨트롤을 다른 영역이 나 해당 영역 내에서 다른 위치로 컨트롤을 끌 수 있습니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 또한 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 사용자가 시작한를 처리 하는 컨트롤은 이동 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컬렉션에 없는 경우  
  
또는 
 <paramref name="zone" />가 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 컨트롤의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컬렉션에 없는 경우  
  
또는 
<paramref name="webPart" /> 컨트롤의 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 속성이 참조하는 영역이 <see langword="null" />인 경우, 즉 <paramref name="webPart" />가 현재 영역에 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 또는 <paramref name="zone" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" />가 0보다 작은 경우</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 포함된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 이벤트를 발생시키고 이벤트의 처리기가 있는 경우 이 처리기를 호출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드를 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드 때를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 페이지에 추가 권한 부여 검사 됩니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드가 호출 되 면 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트 처리기를 호출 이벤트 처리기 메서드 이면 및 합니다.  
  
 권한을 부여 하는 프로세스 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 중요 한 웹 파트 기능입니다. 모든 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하 여 영역에 추가 되는 서버 컨트롤 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 컨트롤을 추가할 수 있는지 여부를 결정 하는 권한 부여 프로세스를 거칩니다. 기본적으로 웹 파트 컨트롤 집합에는 영역에 추가 되 고 컨트롤을 방지 하기 위해 필터링 조건을 제공 하지 않습니다. 하지만 컨트롤 집합에는 개발자가 직접 필터링 조건을 만드는 데 필요한 메커니즘 제공지 않습니다. 이러한 메커니즘을 사용 하 여 사용자 지정 필터링 시나리오를 만들 수 있습니다. 예를 들어, 페이지를 렌더링 하 고 사용자 역할의 사용자 인 경우 해당 컨트롤이 추가 되지 때 특정 컨트롤 영역에 추가 될 관리자 역할에 사용자 인 경우 있도록 필터를 만들 수 있습니다.  
  
 컨트롤 권한 부여 프로세스 동안 필터링 메커니즘은는 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다.  
  
 필터링 시나리오를 만들려면 기본적으로 두 가지 작업입니다. 먼저에 문자열을 할당 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 각 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 필터링 할 컨트롤입니다. 이러한 문자열 값 임의적이 될 수 있지만 필터링 할 조건이 포함 해야 합니다. 예를 들어, 지정된 된 컨트롤을 사용 하려는 경우 사용자가 페이지에 추가할 경우에만 관리자로 보고 한 다음 문자열 값을 할당할 수 있습니다 `admin` 속성입니다. 그런 다음 ASP.NET 역할 기능을 사용 하 고 관리자, 관리자 및 사용자와 같은 다양 한 역할을 사이트의 모든 사용자를 추가할 수 있습니다. 필터링 코드 페이지를 로드할 때 사용자 역할을 확인를 검사 중인 컨트롤에 권한 부여 필터 값과 비교 하 고 예를 들어 사용자가 관리자 역할 및 사용자가 컨트롤의 설정한 경우 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 값`admin`에 컨트롤을 추가할 수 있습니다.  
  
 필터링 시나리오를 만드는 두 번째 단계 검사 하는 코드를 작성 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 해당 영역에 추가 되기 전에 각 제어 권한이 있는지 확인 합니다. 필터링이 코드를 배치할 위치에 대해 두 가지 옵션이 있습니다. 첫 번째 옵션에는 페이지 개발자를 위한 기본 옵션이입니다. 처리 하는 메서드를 만들 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 코드 분리 파일 또는 웹 페이지 서버 스크립트 코드에서 직접 이벤트입니다. 메서드를 추가 하 여 이벤트와 연결 합니다 `OnAuthorizeWebPart` 특성을 태그에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 다음 태그 샘플 코드 에서처럼 페이지에서 제어 합니다.  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 검사는 각 작업을 수행 하는 사용자 지정 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 필터링 조건에 대 한 제어 하 고 결과 따라 부울 값을 할당 하는 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A> 의 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs> 개체를 나타내는 여부를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어 될 수 있습니다 추가 합니다. 예제 단원의 코드에는이 작업을 수행 하는 방법을 보여 줍니다.  
  
 필터링 코드를 배치할 위치에 대해 두 번째 옵션에서 상속 하는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 및 필터 조건을 확인 하는 메서드를 재정의 합니다. 이 수행 하기 위해 재정의할 수 두 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드. 두 방법 중 하나는 작동 하지만, 대부분의 것이 좋습니다 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 제공 하므로 전체 권한 부여 프로세스를 통해 프로그래밍 방식 제어 권한을 강화 반면를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드 하나만 특정 작업을 수행 이벤트 및 처리기에 대 한 검사를 발생 시키는 것입니다. 사용자 지정의 코드 예제 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 재정의 하는 클래스를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 메서드를 참조 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드의 오버 로드 합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 사용자 지정 이벤트 처리기를 설정 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart> 이벤트 처리기에 대 한 사용자 지정 필터링 코드를 제공할 수 있도록 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 메서드. 이 예제에서는 필터링 시나리오 및 권한 부여를 제공 하는 페이지 개발자를 위한 일반적인 방법은 것 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지에 추가할 컨트롤입니다.  
  
 웹 페이지에서를 `<asp:webpartmanager>` 요소에는 `OnAuthorizeWebPart` 특성에 할당 된 이벤트 처리기의 이름입니다. 이 메서드는 페이지의 컨트롤에 해당 하는지 여부를 확인 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 속성 값으로 설정 `admin` 그렇다면 반환 및 `true`, 페이지에 추가할 수 있음을 나타내는입니다.  
  
> [!NOTE]
>  컨트롤에 할당 된 모든 값에 있지 않은 <xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> 필터링 시나리오의 일부가 될 필요가 간주 되므로 속성도 추가 됩니다. 이 필터링 시나리오에서 일반적인 방법은 됩니다: 일부 컨트롤 필터링 하 고 다른 사용자가 되지 않습니다를 모든 사용자에 게 제공 되도록 것으로 가정 됩니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 이 항목의 범위를 벗어납니다 역할의 사용자 설정 이기 때문에이 코드 예제에서는 필터링의 사용자 역할을 확인 하지 않습니다. 그러나 사용자 역할에 따라 컨트롤을 필터링 시나리오는 필터링이 기능의 가장 일반적인 사용 중 하나일 수 있습니다. 사이트에서 역할이 있고 컨트롤을 필터링 하는이 방법은이 사용자 역할을 확인 하려는 경우 메서드 다음 코드 블록 (역할을 사용 하지 않는 이전 코드 예제에서는 간단한 방법)와 유사 합니다.  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>페이지와 해당 페이지의 컨트롤이 로드되고 페이지의 연결이 데이터 공유를 시작할 수 있도록 활성화되었음을 나타내는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated> 이벤트 페이지 로드 프로세스를 완료 합니다. 메서드는 이벤트에 대 한 처리기를 추가 하는 방법을 제공 합니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnConnectionsActivated` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" /> 에서 파생 된 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>페이지와 해당 페이지의 컨트롤이 로드되었으며 연결을 활성화하는 프로세스를 시작할 수 있음을 나타내는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> 프로그래밍 방식으로 연결을 활성화 프로세스를 사용자 지정 하는 메커니즘을 사용 하 여 개발자에 게 제공 하는 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnConnectionsActivating` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" /> 에서 파생 된 메서드 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">변경된 디스플레이 모드와 관련된 이벤트 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 컨트롤이 웹 페이지에서 특정 디스플레이 모드를 다른 모드로 전환하는 프로세스를 완료했음을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A> 메서드 기준에서 구성만 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" /> 메서드. 예를 들어 표시 모드를 변경한 후 하려는 모드에 포함 된 어느 디스플레이 따라 사용자 인터페이스 (UI)의 모양이 변경 된 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" /> 속성입니다. 또는 특정 콘텐츠를 숨기 거 나 특정 컨트롤을 표시 하는 것이 좋습니다.  
  
메서드를 재정의 하는 경우 일반적으로 호출 해야 기본 메서드 재정의 된 메서드의 마지막 단계로 사용자 지정 코드를 먼저 실행 되 고 이벤트가 마지막으로,에서 모드 변경이 완료 되었음을 나타내는입니다.</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">변경되는 디스플레이 모드와 관련된 이벤트 데이터가 들어 있는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 컨트롤이 웹 페이지에서 특정 디스플레이 모드를 다른 디스플레이 모드로 전환하는 프로세스를 진행 중임을 나타내는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A> 메서드 기준에서 구성만 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의할 수 있습니다는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" /> 메서드. 예를 들어, 디스플레이 모드를 변경 하는 대로 하려는 수 있는 새로운 디스플레이 모드를 확인 (사용 하 여를 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" /> 속성) 될 새 디스플레이 모드에 따라 사용자 인터페이스 (UI)에서 일부 내용을 변경 하 고 있습니다. 사용자 지정 디스플레이 모드를 설치한 경우 사용자 지정 모드를 새로운 디스플레이 모드를 사용할 예정인 경우 특정 컨트롤이 보이도록 하는 것이 좋습니다.  
  
이 메서드를 재정의 하는 경우 일반적으로 호출 해야 기본 메서드 재정의 된 메서드의 첫 번째 단계로 변경 하기 시작 하는 디스플레이 모드를 나타내는 이벤트가 발생 되도록 합니다. 그런 다음 사용자 지정 코드 전에 변경할 수도 사용자 인터페이스 (UI)에 실제로 새 디스플레이 모드를 표시 합니다.</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> 컨트롤 주기 중 첫 번째 이벤트인 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A> 메서드를 발생 시키는 기본 메서드를 호출 합니다 <xref:System.Web.UI.Control.Init> 제어 및 다음의 인스턴스가 하나만 있는지 확인 하는 등의 몇 가지 준비 단계를 수행 하는 것에 대 한 이벤트를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 페이지에 대 한 control 권한 및 로드 개인 설정 데이터입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">페이지에 다른 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 있는 경우</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 웹 페이지에 렌더링되기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A> 메서드를 발생 시키는 기본 메서드를 호출 합니다 <xref:System.Web.UI.Control.PreRender> 제어 및 다음 레지스터에 대 한 이벤트 웹 파트를 포함 하는 페이지에 필요한 몇 가지 클라이언트 스크립트 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 새로 선택되었거나 선택이 취소된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 이벤트는 일반적으로 지점 (UI) 사용자 인터페이스의 모양을 변경 하는 개발자 저장할 수 있습니다. 예를 들어, 새 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 선택 하면 웹 파트 컨트롤 집합을 새로 선택한 컨트롤의 렌더링을 변경 합니다. 컨트롤의 선택 항목의 선택을 취소 한 후 렌더링 정상으로 반환 됩니다.  
  
 사용자가 특정을 선택한 후 <xref:System.Web.UI.WebControls.WebParts.WebPart> 편집에 대 한 제어를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드가 호출 됩니다. 사용자 컨트롤 편집을 완료 하 고 결과 컨트롤의 선택이 취소를 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드가 다시 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>여러 가지 방법으로 관련 된 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 선택한 컨트롤이 변경 된 후 발생 하는 렌더링을 사용자 지정할 수 있도록 하는 경우. 선언적 코드에서 내 합니다 <see langword="&lt;asp:webpartmanager&gt;" /> 요소를 설정할 수 있습니다는 <see langword="OnSelectedWebPartChanged" /> 특성과 할당할 사용자 지정 메서드의 이름입니다. 사용자 지정 메서드에서 이벤트가 발생할 때 선택한 컨트롤의 렌더링을 수정할 수 있습니다. 상속 하는 또 다른 옵션은 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스 및 메서드를 재정의 합니다. 세 번째 방법은 영역 수준에서 렌더링을 사용자 지정 예를 들어에서 상속할 수 있습니다 합니다 <see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" /> 클래스를 재정의 해당 <see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" /> 메서드를 선택 하 고 편집 과정 선택을 취소 하는 컨트롤의 렌더링을 사용자 지정 합니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 이벤트를 발생시킵니다. 이 이벤트는 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤을 변경하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드를 발생 시킵니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 변경 하는 프로세스 중 발생 하는 이벤트 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에서 현재 선택 된 합니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에서 선택한 컨트롤 변경 되는 프로세스를 취소할 수 있도록이 메서드와 관련된 된 이벤트를 사용 합니다. 내는 메서드가 호출 되는 예를 들어를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 메서드를 및 내의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 방법에서 나 프로세스를 취소 하는 방법을 제공 합니다. 사용자가 편집 되는 컨트롤에 취소 동사를 클릭 하면 컨트롤을 더 이상 선택 및 편집 내용이 저장 되지 않습니다, 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드를 사용 하면 편집 내용을 취소 하려면.  
  
> [!NOTE]
>  시작 및 연결 하는 프로세스를 종료 하는 메서드 동안 메서드는 마찬가지로 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 다른 컨트롤을 해당 프로세스를 취소할 수 있도록 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 추가 하 여 이벤트를 `OnSelectedWebPartChanging` 특성을 `<asp:webpartmanager>` 선언형 페이지 태그 요소와 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">컨트롤 제거와 관련된 이벤트 데이터입니다.</param>
        <summary>기본 <see cref="E:System.Web.UI.Control.Unload" /> 이벤트를 발생시키고 웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 인스턴스를 제거합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지에 추가된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드를 추가 하는 프로세스 중에 호출 됩니다를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 기타 서버 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역) 페이지.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 추가 하 여 이벤트를 `OnWebPartAdded` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)을 추가하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 이벤트 추가 되 고 컨트롤 임을 나타냅니다. 메서드는 또한 추가 프로세스를 취소 하는 옵션을 제공 합니다. 컨트롤을 성공적으로 추가 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartAdding` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary>컨트롤이 페이지에서 제거되었음을 알리는 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 메서드를 발생 시킵니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 나타내는 이벤트를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 다른 서버 또는 사용자 정의 컨트롤) 성공적으로 닫 혔는 페이지.  
  
 닫으려면는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 렌더링 되지 않습니다 하 고 있는 특수 적용할 개체를 보유 라고도 페이지 카탈로그 페이지에서 제거할 것을 의미 합니다. 에 해당 하는 페이지 카탈로그를 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 컨트롤을 닫힌에 대 한 참조를 유지 관리 <xref:System.Web.UI.WebControls.WebParts.WebPart> 각 페이지에 대 한 제어 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 컨트롤이 있는 페이지에 선언 된를 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역에 사용자가 페이지 카탈로그 디스플레이 모드를 전환 하 고 이전에 닫힌는 모든 컨트롤을 페이지로 다시 추가할 수 있습니다.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 에 대 한 사용자 지정 처리기를 만드는 개발자를 위한 기회를 제공 하는 메서드는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트입니다. 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartClosed` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다. 개발자가 메서드에서 수행 될 수 있습니다 하나 유용한 작업은 닫힌된 컨트롤 대신 자리 표시자를 표시, 페이지로 컨트롤을 추가 하는 방법을 사용자에 게 알려 주는 도구 설명을 사용 하 여 완료 하는 것입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 페이지에서 제거하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트 닫히거나 페이지에서 제거 되 고 컨트롤 임을 나타냅니다. 메서드는 또한 닫는 프로세스를 취소 하는 옵션을 제공 합니다. 컨트롤이 페이지에서 제거 된 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartClosing` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지에서 영구적으로 삭제된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 메서드는 삭제 하는 과정을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 (또는 기타 서버 컨트롤에 추가 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역) 페이지에서.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 추가 하 여 이벤트를 `OnWebPartDeleted` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 이벤트를 발생시킵니다. 이 이벤트는 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 포함된 서버 컨트롤이나 사용자 정의 컨트롤)이 삭제 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 삭제할 수 있습니다 하 고 컨트롤을 삭제 하면 제어 인스턴스 페이지에서 영구적으로 제거 됩니다 복원할 수 없습니다. 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 웹 파트 카탈로그에서 달리 정적 컨트롤에에서 선언 된 웹 페이지의 태그 또는 컨트롤은 프로그래밍 방식으로 추가 됩니다.  
  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 컨트롤은 해당 영역에서 영구적으로 삭제 되 고 있음을 나타내는 이벤트를 합니다. 메서드는 또한 삭제 프로세스를 취소할 수 있는 기회를 제공 합니다. 컨트롤이 페이지에서 성공적으로 삭제 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartDeleting` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 페이지의 다른 위치로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드를 발생 시킵니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 맨 끝에서 이벤트를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> 모든 코드가 이벤트 처리기 실행 전에 컨트롤을 이동 프로세스가 완료 되었는지 확인 하는 메서드.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트는 현재 해당 영역 내에서 또는 다른 영역에 컨트롤을 이동 하 고 프로그래밍 방식으로 또는 사용자 컨트롤을 끌어 이동 이루어집니다 여부는 중요 하지 않습니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 추가 하 여 이벤트를 `OnWebPartMoved` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤 또는 사용자 정의 컨트롤이 이동 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드를 발생 시킵니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 발생 하는 이벤트 때를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 기타 서버 컨트롤은 이동 하는 해당 영역 내에서 또는 다른 영역 또는 합니다. 메서드는 또한 이동 프로세스를 취소할 수 있는 기회를 제공 합니다. 이동이 완료 되는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartMoving` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결이 설정된 이후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 메서드 맨 끝에서 해당 이벤트를 발생 시킵니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 메서드를 이벤트 처리기에서 코드를 실행 하기 전에 두 가지 컨트롤을 연결 하는 데 필요한 단계는 완료 되도록 합니다.  
  
 연결된 된 이벤트는 사용자 인터페이스 (UI)를 업데이트 하거나 연결 된 사용자에 게 알리려면 편리한 점이 및 메서드 프로그래밍 방식으로 제어할 연결을 만드는 과정을 제공 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 추가 하 여 이벤트를 `OnWebPartsConnected` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 이벤트를 발생시킵니다. 이 이벤트는 두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 포함된 서버 컨트롤 또는 사용자 정의 컨트롤 간의 연결을 설정하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 두 개의 연결을 설정 하려고 할 때 발생 하는 이벤트입니다. 메서드를 연결 시도 취소할 수가 있습니다. 연결에 성공 하면는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartsConnecting` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 이벤트를 발생시킵니다. 이 이벤트는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 간의 연결이 종료된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 메서드 맨 끝에서 해당 이벤트를 발생 시킵니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 두 컨트롤 간의 연결을 종료 프로세스를 수행 하는 메서드.  
  
 연결을 종료 하는 과정을 통해 프로그래밍 방식 제어를 제공 하는 메서드, 개발자가 사용자에 게 알릴 수 있습니다, 있도록 사용자 인터페이스 (UI)에 대 한 변경 또는 응용 프로그램에 대 한 다른 변경 합니다.  
  
 페이지 개발자에 대 한 사용자 지정 처리기를 만들 수 있습니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 추가 하 여 이벤트를 `OnWebPartsDisconnected` 특성을 <`asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 이벤트를 발생시킵니다. 이 이벤트는 두 개의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이나 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤 또는 사용자 정의 컨트롤이 편집 프로세스를 진행 중임을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 메서드를 발생 시킵니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 두 개의 연결을 종료 하는 경우 발생 하는 이벤트입니다. 연결 끊기를 기반으로 프로세스를 취소할 기회를 제공 하는 메서드. 연결이 성공적으로 제거 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트가 발생 합니다.  
  
 페이지 개발자를 추가 하 여 연결된 된 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartsDisconnecting` 특성을 `<asp:webpartmanager>` 요소 웹 페이지 및 사용자 지정 메서드 이름 특성에 할당 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스에서 재정의할 수는 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" /> 이벤트 처리를 사용자 지정 하는 방법입니다.</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 개인 설정 데이터가 들어 있는 개체에 대한 참조를 가져옵니다.</summary>
        <value>개인 설정 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성에 액세스 하는 방법을 제공 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> 를 통해 페이지를 사용 하 여 연결 된 개체는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤입니다. 이 속성을 사용 하 여 개인 설정 개체의 다양 한 멤버를 액세스할 수 있습니다. 예를 들어 사용할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드는 페이지의 개인 설정 범위에서 전환할 사용자 범위 또는 그 반대로 공유 합니다. 개인 설정 페이지에서 개인 설정 데이터에 사용 되는 공급자도 사용 하도록 설정할지 여부를 페이지의 현재 개인 설정 범위를 초과 찾을 수 있습니다.  
  
 참조 하는 데이터는 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성이에서 추적 되는 페이지 수준 개인 설정 데이터를는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 합니다. 컨트롤별 개인 설정 데이터에 대 한 개인 설정 가능한 속성의 값과 같은 <xref:System.Web.UI.WebControls.WebParts.WebPart> 제어는의 일부가 아닌는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성입니다.  
  
> [!NOTE]
>  웹 파트 개인 설정에 대 한 자세한 내용은 참조 하세요. [웹 파트 개인 설정 개요](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성 프로그래밍 방식으로 합니다.  
  
 다음 웹 페이지에는 사용자의 특정 측면을 편집 하려면 편집 모드로 전환 하도록 허용 된 <xref:System.Web.UI.WebControls.Calendar> 제어 합니다. 합니다 **토글 범위** 단추 사용자나 공유 개인 설정 범위에 페이지를 전환 합니다. 합니다 **편집 모드** 하 고 **찾아보기 모드** 단추는 각 페이지의 적절 한 디스플레이 모드를 전환 합니다. 되었는지 확인 합니다 `<script>` 태그를 사용 하 여 이벤트를 처리 하는 메서드의 두 파일의 섹션은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 기본 개체의 유용한 멤버에 액세스 하는 속성입니다. 특히 이러한 방법을 사용 하 여 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A> 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A> 를 통해 액세스 된 개체에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 코드 예제를 실행 하려면도 활성화 해야 사용자 또는 사용자 공유 범위에서 페이지를 개인 설정. 내 Web.config 파일에 항목을 추가 합니다 `<system.web>` 섹션에 다음 태그 것 같습니다.  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 브라우저에서 페이지를 로드 한 후 클릭 합니다 **토글 범위** 단추 및 페이지 범위를 공유 하는 이제 라는 알림이 있습니다. 클릭 **편집 모드** 디스플레이 모드를 변경 하려면 표시 된 컨트롤에 있는 동사 메뉴를 클릭 하 고 선택 **편집** 합니다. 편집 컨트롤 모두에 대 한 사용자 인터페이스 (UI)이 나타나는지 확인 합니다. 이제 클릭 **찾아보기 모드** 일반 탐색으로 돌아갑니다. 페이지 라는 공유 범위에 있는 경우 클릭 **토글 범위** 사용자 범위에 있으면 페이지를 다시 합니다. 다음 컨트롤을 다시 편집 하지만 있음을 이제 편집 ui에서 동일한 단계에 따라는 <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart> 컨트롤이 표시 되지 않습니다. 이 컨트롤 페이지 공유 개인 설정 범위에 있을 때만 작동 하기 때문입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">웹 파트 개인 설정 개요</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤 끌기와 같은 다양한 개인 설정 기능에 사용되는 클라이언트측 스크립트를 내보낼 수 있도록 합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">페이지에 쓸 컨트롤의 내용을 받는 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤이 내용을 렌더링하지 못하도록 재정의된 메서드입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 상태 데이터를 저장하여 해당 컨트롤이 들어 있는 웹 페이지에 대한 후속 요청에서 복원할 수 있도록 합니다.</summary>
        <returns>컨트롤의 저장된 상태 데이터가 들어 있는 <see cref="T:System.Object" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A> 페이지 포스트백에서 유지 되어야 하는 속성에 대 한 상태 데이터를 저장 하는 메서드 경우에 합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터를 페이지가 다시 로드될 때마다 다시 로드할 수 있도록 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A> 메서드는 이후의 브라우저 세션에 대해 저장할 개인 설정 된 사용자 설정을 사용 하도록 설정 하 고 페이지에 방문 때문에 개인 설정, 프로세스에서 중요 합니다. 메서드는 다음과 같은 항목을 포함 하는 사용자 지정 개인 설정 상태 데이터를 저장 합니다: 동적 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 페이지에 추가 되거나 삭제 페이지, 페이지에 이동 된 컨트롤 및 있는 동적 연결 된 서버 컨트롤 생성 또는 삭제 되었습니다.  
  
 이 메서드 코드에서 직접 호출할 수 없습니다. 그러나 호출할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 메서드는 자체 개인 설정 데이터를 저장 하려면이 메서드를 호출 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는 파생에서이 메서드를 재정의할 수 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 개인 설정 데이터를 저장 하는 프로세스를 사용자 지정 클래스입니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>다른 컨트롤과의 연결을 편집하거나 만들기 위해 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤에 대한 참조를 가져옵니다.</summary>
        <value>연결을 편집하거나 설정하기 위해 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 속성에 대 한 참조를 반환 합니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 다른 컨트롤을 사용 하 여 연결 만들기 또는 편집에 대 한 현재 선택 되어 있는 기타 서버 컨트롤입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 컨트롤을 선택 하는 프로세스를 처리 하기 위한 몇 가지 유용한 메서드 및 이벤트를 제공 합니다. <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 시점과 변경 될 컨트롤을 선택한 후에 이벤트가 발생 합니다. 선택 된 후에 컨트롤의 작업을 수행 하려면 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드. 예를 들어, 다음 컨트롤의 선택 되어 있지만 아직 변경 되지 않은 시각적으로 강조할 컨트롤을 선택 하는 모양을 변경 하는 것이 좋습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged> 이벤트 선택된 된 컨트롤이 변경 된 직후에 발생 합니다. 변경 된 후에 컨트롤의 작업을 수행 하려면 재정의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>한 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤의 선택 상태가 변경되고 웹 페이지의 다른 컨트롤로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트와 함께에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 선택한 컨트롤의 사용자 인터페이스 (UI)를 변경 하는 방법입니다. 예를 들어, 사용자 페이지를 디자인 모드로 전환 하는 경우 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), 다음를 선택 하 고는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤의 새 위치로 끌어 의도로 색을 변경 하 여 선택된 된 컨트롤의 렌더링을 예를 들어 변경에 공통적으로 적용 됩니다 해당 테두리 또는 배경 선택 되어 있습니다.  
  
> [!NOTE]
>  이벤트 소비에 대 한 자세한 내용은 참조 하세요. [방법: Web Forms 응용 프로그램에서 이벤트 사용](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에서 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤을 변경하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트와 함께에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드. 페이지 개발자가 코드에 추가 하 여에 이벤트 처리기를 만들 수 있습니다 합니다 `OnSelectedWebPartChanging` 특성을 `<asp:webpartmanager>` 페이지 및 사용자 지정 메서드 이름 특성의 값을 설정 하는 요소는 이벤트를 처리 합니다.  
  
 이 이벤트는 시작 되거나 시작 및 종료 컨트롤을 편집 하는 때와 컨트롤 간의 연결을 종료 하는 과정입니다. 자세한 내용은 참조는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A> 메서드.  
  
 일반적으로,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 선택한 컨트롤을 변경 하는 사용자의 동작의 직접적인 결과로 이벤트가 발생 하면 이벤트를 취소할 수 있습니다. 그러나 이벤트를 취소할 수 없는 시나리오가 있습니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되기는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 하지 사용자에 해당 결정 해야 합니다 컨트롤에서 현재 선택 된 중단 수 없으므로 선택을 변경 하는 경우 및 정리 하는 과정을 완료할 수 있도록 모든 컨트롤입니다. 따라서 설계상의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> 이 시나리오에서는 메서드를 취소할 수 없습니다. 취소할 수 있는 관련된 이벤트에 대 한 참조를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤의 사용자 지정 개인 설정 데이터가 변경되었음을 나타내는 플래그를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 메서드 궁극적으로 업데이트 된 개인 설정 데이터를 저장 하도록 설정 하는 웹 파트 컨트롤에서 개인 설정 구성 요소를 발생 하는 플래그를 설정 합니다. 추적 개인 설정 데이터가 변경 될 수 있습니다 하는 시나리오에 대 한 자세한 내용은 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어를 참조 하십시오는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성입니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A> 메서드 코드에서 직접 호출할 수 없습니다 및 웹 파트 개인 설정 기능 중 하나로 설정 하는 웹 파트 컨트롤에 의해 내부적으로 사용 되기 때문에 재정의할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>메서드를 호출할 수 있습니다를 파생 하 여 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스입니다. 이 개인 설정 웹 파트 컨트롤의 구성 요소 설정 및 개인 설정 데이터에 대 한 플래그를 설정 하는 프로세스를 제어 해야 하므로 사용자 지정 하려는 경우에 유용 합니다.</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤입니다.</param>
        <summary><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 속성 값을 현재 선택된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤과 같게 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 메서드는 시작 또는 끝에서 지정 된 컨트롤의 편집 하는 프로세스 중 합니다 `webPart` 매개 변수를 지정 하 고 시작 하거나 포함 하는 연결을 종료 하는 `webPart`.  
  
 편집 및 연결 프로세스를 시작할 때 `webPart` 편집 하거나 연결을 선택 된 컨트롤입니다.  
  
 편집 및 연결 프로세스의 끝 `null` 에 전달 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A> 메서드를 선택 하지 않은 현재 선택 된 컨트롤의 결과입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 스킨을 적용할 수 없도록 빈 문자열("")을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 스킨이 할당되지 않도록 하는 빈 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> 상속 된 속성을 재정의 <xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType> 방지 하려면 속성을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 은 보이지 않는 컨트롤 스킨을 사용 하는 컨트롤입니다. 속성의 구현을 항상에서 빈 문자열을 반환 하 여 할당 된의 스킨을 방지 합니다 `get` 접근자와 항상 값을 설정 하려고 한 경우 예외를 throw 합니다 `set` 접근자입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 설정하려고 한 경우</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에 정적 연결로 정의된 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 개체의 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value>페이지의 정적 연결이 모두 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성은 사용을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 추적 하 고 페이지의 모든 정적 연결을 관리 합니다. 동적 연결을 달리 정적 연결을 페이지가 렌더링 될 때마다 페이지에 추가할 필요가 없습니다.  
  
 프로그래밍 방식으로 생성 또는 지정 된 페이지에 있는 모든 정적 연결을 포함 하는이 속성에서 참조 하는 컬렉션을 `<asp:webpartconnection>` 페이지의 태그에는 요소입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 프로그래밍 방식으로 사용 방법을 보여 줍니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 페이지의 디스플레이 모드를 변경할 수 있게 해 주는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정을 포함 하는 소스 코드 파일을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 및 사용자 지정 인터페이스입니다.  
  
-   두 가지 사용자 지정을 포함 하는 웹 페이지 <xref:System.Web.UI.WebControls.WebParts.WebPart> 에 연결할 수 있는 컨트롤 및 `<asp:webpartmanager>` 요소입니다.  
  
-   예제 브라우저에서 작동 하는 방법에 대해 설명 합니다.  
  
 다음 코드 예제에서는 웹 페이지 부분만 포함 되어 있습니다. 예제 섹션에서 예제-사용자 지정 사용자 정의 컨트롤 및 사용자 지정 컨트롤 및 인터페이스에 대 한 소스 코드의 처음 두 부분을 얻을 수 해야는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 해당 항목을 컴파일하기 위해 옵션도 설명 된 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다.  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 페이지에 대 한 선언적 태그 포함 `Register` 사용자 정의 컨트롤 및 사용자 지정 컨트롤에 대 한 지시문입니다. `<asp:webpartmanager>` 요소는 `<asp:webpartzone>` 사용자 지정 컨트롤을 포함 하는 요소 및 `<asp:connectionszone>` 요소입니다. `Page_Load` 메서드를 코드 확인 여부를 연결을 이미 존재 하 고, 그렇지 않은 경우 해당 연결 지점을, 소비자 및 공급자를 정의 하 고 다음 참조 하는 정적 연결 집합에 새 연결을 추가 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 브라우저에서 웹 페이지를 로드 한 후 클릭 합니다 **디스플레이 모드** 드롭다운 목록 컨트롤 및 선택 **연결** 페이지 연결 모드를 전환 하려면. 연결 모드는 `<asp:connectionszone>` 컨트롤 간의 연결을 만들 수 있도록 하는 요소입니다. 연결 모드에서의 제목 표시줄에 있는 아래쪽 화살표를 클릭 합니다 **우편** 동사 메뉴의 활성화를 제어 하 고 클릭 **Connect**합니다. 연결 사용자 인터페이스 (UI)를 표시 한 다음 확인에 포함 된 코드에서 연결을 이미 만들어진 것입니다는 `Page_Load` 메서드. 이 페이지 뒷부분에 나오는 브라우저 세션에서 반환 하는 경우이 정적 연결 이미 설정 및 페이지가 로드 될 때마다 다시 생성 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>특정 웹 페이지에서 사용할 수 있는 모든 디스플레이 모드의 읽기 전용 컬렉션을 가져옵니다.</summary>
        <value>특정 웹 페이지에서 사용할 수 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" /> 개체의 집합이 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성 페이지에 있는 영역 컨트롤의 종류에 따라 해당 페이지에서 실제로 사용할 수 있는 디스플레이 모드를 포함 합니다.  
  
> [!NOTE]
>  디스플레이 모드를 해제할 수 있습니다, 그리고 및에 추가 되지 디스플레이 모드를 사용 하지 않도록 설정 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 컬렉션, 해당 형식에는 디스플레이 모드를 지 원하는 영역 페이지에 있는 경우에 합니다.  
  
 찾아보기 모드와 디자인 모드는 항상 지원 됩니다. 다를 수 있는 디스플레이 모드는 편집, 카탈로그 및 모드를 연결 합니다. 이러한 각 디스플레이 모드의 특정 형식과 연결 된 <xref:System.Web.UI.WebControls.WebParts.ToolZone> 제어 합니다. 참조 하는 컬렉션에 추가할 특정 디스플레이 모드를 발생 시키는 웹 페이지에는 특별히 형식화 된 영역의 현재 상태는 것은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다. 예를 들어, 웹 페이지를 포함 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 아닌 영역을 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역을 편집 디스플레이 모드를 사용 하면 페이지에 있는 지원 되는 모드 중 하나인 하지만 카탈로그 디스플레이 모드 지원 되지 않습니다.  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성에서 다른 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> 현재 사용할 수 있는 모든 디스플레이 모드를 포함 하는 컬렉션을 참조 하는 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 특정 페이지에서 지원 되지 않습니다 하는 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 프로그래밍 방식으로 사용 방법을 보여 줍니다.는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> 속성입니다. 코드는 현재 웹 페이지에서 사용할 수 있는 디스플레이 모드만 사용 하 여 목록을 채우는 데이 속성을 사용 합니다.  
  
 이 페이지의 디스플레이 모드 지원 되는 세 가지: 찾아보기, 디자인 및 편집 합니다. 항상 사용 가능한 첫 번째 두와 편집 모드는 페이지가 포함 되어 있으므로이 코드 예제에서 사용할 수는 <xref:System.Web.UI.WebControls.WebParts.EditorZone> 제어 합니다. 카탈로그 디스플레이 모드 표시 되지 않습니다를이 페이지에서 해당 영역이 없기 때문에 연결 합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후 찾아보기 모드에서 페이지 디자인 모드를 전환 하려면 드롭다운 목록 컨트롤을 사용할 수 있습니다 다음 편집 모드를 합니다. 편집 모드 중 한 서버 컨트롤의 헤더에서 동사 드롭다운 메뉴를 클릭 하 고 수 선택 **편집** 컨트롤을 편집 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">웹 파트 페이지 디스플레이 모드</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터가 웹 페이지에서 변경되었는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>개인 설정 상태 데이터가 변경되었는지 여부를 나타내는 부울 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성은 호출자가 확인할 수 있는 방법을 제공 개인 설정 상태에서 관리 되는 데이터가 있는지 여부를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 변경 되었습니다. 사용자 개인 설정 페이지 수준 세부 정보, 예를 들어 페이지 레이아웃 변경, 만들 연결을 삭제 하 여 시간과 컨트롤 추가 및 삭제, 개인 설정 데이터를 관리 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤이 변경 합니다. 이 호출자에 게 보호 되는 값을 반환 하는 통과 메서드 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A> 속성 호출자가 직접 액세스할 수 없습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성을 나타내지 않습니다 여부를 개인 설정할 수 있는 속성 값 또는 개인의 모양에 영향을 주는 개별 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤을 변경 합니다. 각 컨트롤에 대 한 제어 수준 개인 설정 개별적으로 추적 됩니다. 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성 나타내고만 있는지 여부를 개인 설정 데이터는 페이지 수준에서 관리 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 변경 되었습니다.  
  
 다음 목록에는 설명 하는 개인 설정의 일부 일반적인 인스턴스를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 속성의 값을 반환 `true`나타내는는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에 일부 변경 된 개인 설정 데이터:  
  
-   정적 닫는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지에 컨트롤 (또는 서버 또는 사용자 정의 컨트롤).  
  
-   닫힌된 정적 복원 <xref:System.Web.UI.WebControls.WebParts.WebPart> 페이지로 다시 페이지 카탈로그에서 제어 합니다.  
  
-   다른 영역 또는 영역 내에서 모든 컨트롤을 이동 합니다.  
  
-   컨트롤의 카탈로그에서 추가 <xref:System.Web.UI.WebControls.WebParts.WebPart> 서버 컨트롤 또는 컨트롤을 프로그래밍 방식으로 추가 합니다.  
  
-   두 연결을 만드는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 프로그래밍 방식이 나 연결 사용자 인터페이스 (UI)를 사용 하 여 제어 합니다.  
  
-   두 연결을 삭제 해도 <xref:System.Web.UI.WebControls.WebParts.WebPart> 프로그래밍 방식이 나 연결 UI를 사용 하 여 제어 합니다.  
  
 이 속성 값에 액세스 하려면 캐스팅 해야 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 인스턴스를를 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable> 인터페이스를 한 다음 읽기 수를 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> 속성 값.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 간단한 방법을 보여 줍니다 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 몇 가지 일반적인 페이지 개인 설정을 나타내는 속성을 야기 하는 인스턴스는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 변경 하려면 컨트롤의 개인 설정 데이터.  
  
 코드 예제에는 네 가지 부분이 있습니다.  
  
-   웹 파트 컨트롤이 들어 있는 페이지의 디스플레이 모드를 변경할 수 있는 사용자 정의 컨트롤입니다.  
  
-   두 가지 사용자 지정에 대 한 코드가 포함 된 소스 파일 <xref:System.Web.UI.WebControls.WebParts.WebPart> 연결할 수 있는 컨트롤 및 인터페이스입니다.  
  
-   모든 컨트롤을 호스팅하는 웹 페이지입니다.  
  
-   코드 예제의 작동 방식을 설명 합니다.  
  
 코드 예제의 첫 번째 부분은 디스플레이 모드를 변경 하는 것에 대 한 사용자 정의 컨트롤입니다. 예제 섹션에서 사용자 정의 컨트롤에 대 한 소스 코드를 가져올 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 클래스 개요입니다. 디스플레이 모드 및 사용자 정의 컨트롤의 작동 원리에 대 한 정보를 참조 하세요. [연습: 페이지 파트는 웹에서 디스플레이 모드 변경](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)합니다.  
  
 예제의 두 번째 부분은 사용자 지정 컨트롤 및 인터페이스를 사용 하 여 원본 파일입니다. `IZipCode` 인터페이스는 하나의 메서드를 노출 하 고 사용자 지정에서 구현으로이 메서드는 `ZipCodeWebPart` 컨트롤을 사용 하도록 설정 하는 콜백 메서드로 사용 `ZipCodeWebPart` 연결 시나리오에서 공급자 역할을 합니다. 기타 컨트롤 `WeatherWebPart`, 연결에서 소비자의 역할도 제어;에서 제공 하는 특정 인터페이스를 사용할 수 있는 `ZipCodeWebPart`합니다. 실제 응용 프로그램에서는 `WeatherWebPart` 공급자에서 개인 설정 된 우편 번호 값을 사용 하 고 사용자에 게 그래픽 날씨 정보를 제공할 수 있습니다.  
  
 코드 예제를 실행 하려면이 소스 코드를 컴파일해야 합니다. 명시적으로 컴파일할 수 있으며 결과 어셈블리를 웹 사이트의 Bin 폴더 또는 전역 어셈블리 캐시에 넣을 수 있습니다. 또는 컴파일 수 있는 수 동적으로 런타임 시 사이트의 App_Code 폴더에 소스 코드를 넣을 수 있습니다. 동적 컴파일을 사용 하 여이 코드 예제 따라서 있음을 합니다 `Register` 웹 페이지의 맨 위에 있는이 구성 요소에 대 한 지시문만 포함 `TagPrefix` 하 고 `Namespace` 특성 없이 `Assembly` 특성. 컴파일하는 방법을 보여 주는 연습을 참조 하세요. [연습: 개발 및 사용자 지정을 사용 하 여 웹 서버 컨트롤](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)합니다.  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 코드 예제에서는 세 번째 부분에는 웹 페이지입니다. 두 개 포함 되어 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역이 있고 두 가지 사용자 지정을 포함 하는 첫 번째 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 이기도 한 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 표준을 포함 하는 영역 <xref:System.Web.UI.WebControls.Calendar> 사용자 페이지에 추가할 수 있는 컨트롤. `<asp:connectionszone>` 요소 연결 컨트롤 간의 연결을 만드는 사용자에 대 한 UI를 제공 합니다. 에 `Page_PreRender` 의 텍스트를 업데이트 하는 메서드를 확인 하는 개인 설정 데이터가 변경 되었는지 그리고 있다면는 `Label1`합니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 브라우저에서 페이지를 로드 한 후에 개인 설정 데이터가 변경 되는이 항목의 설명 섹션에 나열 된 시나리오 중 일부를 만들려고 시도 합니다. 변경 추적 개인 설정 시나리오 중 하나를 포함 하는 경우 다양 한 변경 작업을 수행 하면서 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤의 텍스트는 `Label1` 컨트롤 개인 설정 데이터가 변경 되었음을 나타내기 위해 표시 됩니다. 예를 들어 다음 작업을 할 수 있습니다.  
  
-   클릭 하 여 컨트롤 간의 연결을 만들 합니다 **WebPart 컨트롤 연결** 단추입니다.  
  
-   사용 하 여는 **디스플레이 모드** 드롭다운 목록 컨트롤 페이지 모드로 전환 하려면 카탈로그를 추가 합니다 **내 일정** 두 번째 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역.  
  
-   페이지를 다시 찾아보기 모드로 클릭 메뉴의 동사 (제목 표시줄의 화살표 기호를 사용 하 여 표시 됨)에 대 한 변경 합니다 **내 일정** 컨트롤을 선택 **닫습니다** 을 닫고 페이지 카탈로그에 추가 합니다.  
  
-   카탈로그 모드로 페이지를 반환 하 고 추가 합니다 **내 일정** 페이지로 컨트롤입니다.  
  
-   사용 된 **디스플레이 모드** 페이지 디자인 모드로 전환 하려면 제어 하 고 다른 영역 또는 동일한 영역에 다른 위치로 끌어서 하나 이상의 컨트롤의 레이아웃을 다시 정렬 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">로드할 상태 데이터를 포함하는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 로드되어야 하는 이전에 저장된 사용자 지정 개인 설정 상태 데이터를 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 구현 된 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType> 웹 파트 컨트롤 집합에 직접 액세스 보호 되는 방법을 제공 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType> 메서드. 이 메서드를 호출 하 여 관리 되는 사용자 지정 개인 설정 된 데이터를 저장 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 및는 초기화 프로세스에서 나중에 사용에 대 한 영구 데이터 저장소에서 이전에 저장 합니다.  
  
> [!NOTE]
>  대부분의 경우, 페이지 및 컨트롤에 해당 하는 개발자의 코드 필요가 없습니다이 메서드를 호출 하므로 개인 설정 데이터를 검색 하기 위한 메커니즘으로 설정 하는 웹 파트 컨트롤에서 주로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>개발자는이 메서드를 사용 하는 한 가지 시나리오는 하나 대신 사용할 사용자 지정 개인 설정 프레임 워크를 개발 하려는 경우 웹 파트 컨트롤 집합에서 제공 됩니다. 이러한 경우 개발자에서 상속할 수 없습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스를 재정의 합니다 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 의 사용자 지정 구현을 반환 하는 방법을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체입니다. 사용자 지정 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체의 구현을 호출 합니다 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 사용자 지정 개인 설정 데이터를 로드 하려면 적절 한 시기 메서드.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">저장될 상태 데이터가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />입니다.</param>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에서 관리하는 사용자 지정 개인 설정 상태 데이터를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 메서드는 구현의 합니다 <xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType> 집합에 대 한 웹 파트 컨트롤에 직접 액세스 보호 되는 방법을 제공 하는 메서드를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType> 메서드. 이 메서드를 호출 하 여 관리 되는 모든 개인 설정된 데이터 저장을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 영구 데이터 저장소는 웹 파트 응용 프로그램에 대해 구성 된 컨트롤입니다.  
  
> [!NOTE]
>  대부분의 경우, 페이지 및 컨트롤에 해당 하는 개발자의 코드 필요가 없습니다이 메서드를 호출 하므로 개인 설정 데이터를 저장 하기 위한 메커니즘으로 설정 하는 웹 파트 컨트롤에서 주로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>이 메서드를 사용 하 여 개발자는 사용 하는 한 가지 시나리오는 하나 대신 사용할 사용자 지정 개인 설정 프레임 워크를 개발 하려는 경우 웹 파트 컨트롤 집합에서 제공 됩니다. 이러한 경우 개발자에서 상속할 수 없습니다는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 클래스를 재정의 합니다 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" /> 의 사용자 지정 구현을 반환 하는 방법을 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체입니다. 사용자 지정 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" /> 개체의 구현을 호출 합니다 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" /> 메서드는 사용자 지정 개인 설정 데이터를 저장 하려면 적절 한 시기입니다.</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 개인 설정 상태 데이터를 적용하고 기본 메서드를 호출하여 컨트롤의 뷰 상태 데이터에 대한 변경 내용을 추적할 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 뷰 상태 데이터는 변경 내용이 저장 되는 <xref:System.Web.UI.StateBag> 개체를 컨트롤을 통해 액세스할 수 있습니다 <xref:System.Web.UI.Control.ViewState%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>자식 컨트롤이 표시되도록 하는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤과 해당 자식 컨트롤이 표시되는지 여부를 나타내는 부울 값입니다. 모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 기본 재정의 <xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType> 항상 값을 반환 하도록 속성 `true` 에 대 한는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성입니다. 도 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 자체에 표시 되지 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성 설정 해야 `true` 그 자식 컨트롤 모두 기본적으로 표시 되도록 합니다.  
  
 값을 설정 하려는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> 속성을 항상 오류가 발생 하기 때문에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤은 기본 속성 동작을 재정의 하 고 속성에 값을 할당 하지 못하도록 합니다.  
  
 이 속성에는 비주얼 디자이너에서 바인딩되지 이지만 런타임에 바인딩할 수 있습니다. 자세한 내용은 <xref:System.ComponentModel.BindableAttribute>를 참조하십시오.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">이 속성에 값을 할당하려고 한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 추가된 후에 컨트롤이 성공적으로 추가되었음을 나타내기 위해 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트 영역에 동적 컨트롤 (페이지 태그에 선언 되는 대신 프로그래밍 방식으로 추가 된 컨트롤)가 성공적으로 추가 되었는지 나타내는 데 유용 합니다. 와 함께에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A> 메서드, 이벤트 사용자 인터페이스 (UI)를 업데이트 하거나 컨트롤을 성공적으로 추가 된 사용자에 게 알림 방법을 개발자에 게 제공 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤을 추가하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 메서드 영역에 컨트롤을 추가 하는 과정을 시작한 후입니다. 이 이벤트는 완료 되기 전에 프로세스를 취소할 수 있는 기회를 제공 합니다. 이 이벤트 뒤에 추가 프로세스가 성공 하면 되는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartAdding` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)이 페이지에서 제거되었을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 컨트롤이 닫 혔 음 성공적으로, 사용자 또는 프로그래밍 방식으로 이벤트를 나타냅니다. 닫으려면는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 렌더링 되지 않습니다 하 고 있는 특수 적용할 개체를 보유 라고도 페이지 카탈로그 페이지에서 제거할 것을 의미 합니다. 에 해당 하는 페이지 카탈로그를 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 컨트롤을 닫힌에 대 한 참조를 유지 관리 <xref:System.Web.UI.WebControls.WebParts.WebPart> 각 페이지에 대 한 제어 합니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart> 컨트롤이 있는 페이지에 선언 된를 <xref:System.Web.UI.WebControls.WebParts.CatalogZone> 영역에 사용자가 페이지를 카탈로그 디스플레이 모드를 전환 하 고 이전에 닫힌는 모든 컨트롤을 페이지로 다시 추가할 수 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트와 연결 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 이벤트가 모두에 대 한 처리기를 제공 하는 메서드.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartClosed` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤)을 제거하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 메서드 때는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 하는 컨트롤을 닫는 동안. 이 이벤트 뒤에 성공한 경우 컨트롤의 제거는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 이벤트입니다.  
  
 페이지 개발자를 추가 하 여 이벤트에 대 한 사용자 지정 처리기에 제공할 수 있습니다 합니다 `OnWebPartClosed` 특성을 <`asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 일반적으로, 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 닫는 사용자의 직접적인 결과로 이벤트가 발생을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤 이벤트를 취소할 수 있습니다. 그러나 이벤트를 취소할 수 없는 시나리오가 있습니다. 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되기는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 사용자가 아니라 합니다. 및 시기를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤 하는 동안 호출 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 각 컨트롤을 닫을 메서드 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트가 발생 하면 없으므로로 (디자인) 이벤트를 취소할 수 없습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 정리 작업을 완료 해야 하는 경우 모든 영역 컨트롤입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 다른 서버 컨트롤이 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에서 삭제된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트 영역에서 동적 컨트롤 (페이지 태그에 선언 되는 대신 프로그래밍 방식으로 추가 된 컨트롤)가 성공적으로 삭제 되었음을 나타내는 데 유용 합니다. 와 함께에서 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A> 메서드, 이벤트 사용자 인터페이스 (UI)를 업데이트 하거나 컨트롤을 성공적으로 삭제 된 사용자에 게 알림 방법을 개발자에 게 제공 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에서 동적 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤의 인스턴스를 삭제하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 메서드 (하나는 웹 파트 사용자 인터페이스를 통해 사용자 또는 프로그래밍 방식으로 추가 된) 동적 컨트롤을 삭제 하는 과정입니다. 이벤트가 완료 되기 전에 프로세스를 취소할 수 있는 기회를 제공 합니다. 이 이벤트는 삭제 프로세스가 완료 되 면 뒤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 제공할 수는 `OnWebPartDeleting` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤이 웹 페이지의 다른 위치로 이동된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 (웹 페이지의 태그에 선언 됨) 정적 및 동적 컨트롤에 적용 됩니다. 연결 된 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 메서드. 이동이 완료 한 후 이벤트 발생 하기 때문에 개발자는 사용자, 일부 유효성 검사 또는 일부 다른 작업에 몇 가지 알림을 제공 하는 이벤트 처리기를 포함할 수 있습니다. 이벤트 처리기를 추가 하려면 추가할 수 있습니다는 `OnWebPartMoved` 특성을 `<asp:webpartmanager>` 를 페이지 요소와 특성에 사용자 지정 메서드의 이름 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 영역에 포함된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 또는 다른 서버 컨트롤을 이동하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트는 때를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 기타 서버 컨트롤은 이동 하는 고유한 영역 내에서 또는 다른 영역입니다. 프로그래밍 방식으로 이동할 때와 사용자 컨트롤을 끌 때 발생할 수 있습니다.  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 메서드 및 해당 완료 되기 전에 이동 프로세스를 취소할 기회를 제공 합니다. 이동이 완료 된 후이 이벤트에서 다음 컨트롤을 새 위치에 배치 하는 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 만들 수는 `OnWebPartMoving` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에서 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤이 관리하는 모든 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 컨트롤에 대한 참조를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" /> 컨트롤 집합에 대한 참조가 들어 있는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성은 사용를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 모두 추적 하는 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 내에 포함 된 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 페이지의 영역입니다. 컬렉션 읽기 전용으로 경우에 액세스할 수 있습니다 개별 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하 고 컬렉션 변경 내용을 통해 프로그래밍 방식으로 제어 합니다.  
  
> [!NOTE]
>  이 있을 수를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 외부 페이지에 컨트롤 배치를 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 추적 중이지 않은 컨트롤에는 영역에는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 제어 하거나 참조 해당 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 컬렉션. 그러나 이유는 거의 없습니다 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 그런 다음 해당 웹 파트 기능을 손실 하 고 일반적인 서버 컨트롤의 역할을 하기 때문에 영역에 외부에서 제어 합니다.  
  
 모든 형식의 사용자 지정 영역에서 배치할 수 있는 컨트롤 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤, 표준 ASP.NET 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 컨트롤을으로 처리 될 수는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 런타임 시 컨트롤입니다. 때 없는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤에 배치 됩니다를 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> ASP.NET 컨트롤을 래핑하는 런타임 시 영역을 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 개체를 컨트롤 진정한 처럼 동작할 수 있도록 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤. 따라서 사용 하 여는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성인을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에는 서버 컨트롤에서 파생 되었는지 여부에 관계 없이 모든 유형의 추적할 수 있습니다는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 클래스.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 프로그래밍 방식으로 액세스 개별 속성 <xref:System.Web.UI.WebControls.WebParts.WebPart> 컨트롤입니다. 내 웹 페이지에 대 한 선언적 태그에 있음을 `<asp:webpartzone>` 요소는 두 가지 표준 ASP.NET 서버 컨트롤입니다. 상속 하지 않습니다 하지만 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 클래스를 사용 하 여 래핑 영역에 있기 때문에 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> 런타임에 개체 이며 따라서 참조 하는 컬렉션에 포함할 수는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 속성입니다. 사용자 지정도 추가할 수 있습니다 <xref:System.Web.UI.WebControls.WebParts.WebPart> 이 영역에 있는 컨트롤, 사용자 정의 컨트롤 또는 사용자 지정 서버 제어 하 고 동일한 방식으로 처리 되 고 있습니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내 합니다 `<system.web>` 섹션, 있는지는 `<webParts>` 요소는 `enableExport` 특성이로 설정 `true`다음 태그 에서처럼.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 클릭 하면 브라우저에 페이지를 로드 한 후에 **WebPart 수** 단추 코드를 사용 하 여를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> 컬렉션에서 컨트롤의 개수를 반환 하는 속성입니다. 클릭할 경우 합니다 **숨기기 일정 제목** 단추 코드를 렌더링 하는 것만 테두리와 제목이 아닌 달력을 변경 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 서버 컨트롤이나 사용자 정의 컨트롤) 간에 특정 연결이 설정된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트와 연결 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A> 메서드. 이벤트 연결 전체 인지를 확인 한 후 하려는 팩트를 사용자에 게 알릴 또는 페이지의 사용자 인터페이스 (UI)을 변경할 수도 있으므로 유용 합니다. 예를 들어 일부 그래픽 이미지 두 컨트롤 간의 연결에 성공 했음을 표시할 수 있습니다 또는 찾아보기 모드로 다시 간단한 메시지를 표시 하 고 페이지 디스플레이 모드를 변경 합니다.  
  
 페이지 개발자가 추가 하 여이 이벤트를 사용 하 여 사용자 지정 이벤트 처리기에 연결할 수는 `OnWebPartsConnected` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 컨트롤(또는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역에 있는 서버 컨트롤이나 사용자 정의 컨트롤) 간의 연결을 만드는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 메서드를 신호를 보냅니다. 연결 프로세스가 시작 하 고 (예를 들어 사용자가 컨트롤을 선택 및 연결 동사를 클릭) 아직 완료 되지 합니다. 이벤트 완료 되기 전에 연결을 취소할 수 있는 기회를 제공 합니다. 연결이 완료 되 면이 이벤트가 다음는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartsConnecting` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>두 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤 간의 연결이 종료된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트와 연결 된 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A> 메서드. 이벤트는 연결이 종료 된 것을 확인 한 후 하려는 사용자에 게 알릴, 코드에서 일부 정리 작업을 수행 하거나 사용자 인터페이스 (UI)에 대 한 다른 변경 때문에 유용 합니다.  
  
 페이지 개발자가 추가 하 여이 이벤트를 사용 하 여 사용자 지정 이벤트 처리기에 연결할 수는 `OnWebPartsDisConnected` 특성을 `<asp:webpartmanager>` 페이지 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이전에 연결된 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 또는 서버 컨트롤 간의 연결을 종료하는 프로세스 중에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트를 발생 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 메서드 및 해당 사실을 알립니다. 사용자가 연결 끊기 동사를 클릭 또는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 메서드를 호출 했음을 합니다. 이벤트가 완료 되기 전에 연결을 종료 프로세스를 취소할 수 있는 기회를 제공 합니다. 이 이벤트는 연결을 성공적으로 종료 하는 경우 뒤의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 이벤트입니다.  
  
 페이지 개발자가 추가 하 여 이벤트에 대 한 사용자 지정 처리기를 추가할 수는 `OnWebPartsDisconnecting` 특성을 `<asp:webpartmanager>` 요소와 특성에 사용자 지정 메서드 이름을 할당 합니다.  
  
 일반적으로,는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 연결을 종료 하는 사용자의 동작의 직접적인 결과로 이벤트가 발생 하면 이벤트를 취소할 수 있습니다. 그러나 일부의 시나리오는 이벤트를 취소할 수 없습니다. 첫 번째 시나리오는 경우를 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 컨트롤이 삭제 되기를 <xref:System.Web.UI.WebControls.WebParts.WebPart> 분리는 그렇지 않은 경우, 포함 된 컨트롤 모두 닫아야 합니다. 이 경우에 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 닫히는 제어는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 하지 사용자 컨트롤과 해당 수도 있어야 중단 수 없으므로 연결 된 컨트롤의 연결을 종료 하려면 정리 하 고 닫으면 프로세스를 완료할 수 있도록 모든 컨트롤입니다. 따라서 설계상의 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이 시나리오에서는 메서드를 취소할 수 없습니다. 취소할 수 있는 관련된 이벤트에 대 한 참조를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> 이벤트입니다.  
  
 두 번째 시나리오는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이벤트를 취소할 수 없습니다 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A> (이 예를 들어 페이지에 각 요청 하는 동안 호출) 메서드 호출 되 고 일부 유형의 페이지에 기존 연결이 충돌 합니다. 예를 들어, 사용자 컨트롤 y로 x 컨트롤에 연결 하는 것 하지만 공유 z를 제어 하는 x 컨트롤 연결 및 아직 x 컨트롤은 여러 연결을 구성할 수 없습니다. 이 예제의 경우 연결에 대 한 개별 사용자의 설정이 우선 순위를 및 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 호출 하 여 충돌을 해결 하는 컨트롤을 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드 간의 연결을 종료 하 고 x 및 z 특정 사용자에 대 한 합니다. 이 연결 끊기를 기반이으로 디자인 하 여 충돌을 해결 하는 데 필수적 이므로 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 이 시나리오에서는 이벤트를 취소할 수 없습니다.  
  
 세 번째 시나리오는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 메서드를 취소할 수 없습니다 경우는 <xref:System.Web.UI.WebControls.WebParts.WebPart> 또는 현재 연결 된 서버 컨트롤 삭제 되거나 닫힙니다. 컨트롤을 페이지에서 제거할 확실 하 게 것, 이므로 해당 연결을 제거 하는 논리적으로 필수적입니다. 따라서 경우 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤에서 호출 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 메서드를 발생 시킵니다를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 디자인 이벤트는 이벤트를 취소 될 가능성이 없습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET 웹 파트 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 영역이 모두 들어 있는 컬렉션에 대한 참조를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 영역 집합을 참조하는 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성은 사용를 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 컨트롤을 추적 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 웹 페이지의 영역. 참고 속성은 모든 유형의 영역;를 참조 하지 않습니다 파생 되는 영역에만 참조 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 클래스를 포함 하 여 <xref:System.Web.UI.WebControls.WebParts.WebPartZone> 영역입니다.  
  
 읽기 전용 속성으로 참조 된 컬렉션 이지만 컬렉션의 개별 개체에 액세스 하 여 프로그래밍 방식으로 작업을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 액세스 개별에 프로그래밍 방식으로 속성 <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> 영역 컨트롤입니다. 웹 페이지에 대 한 선언적 태그에서 두 개의 알 수 있습니다. `<asp:webpartzone>` 요소를 포함 하는 각 서버 컨트롤입니다. 에 `<script>` 코드는 페이지의 섹션은 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 모든 영역 Id를 나열 하 고 두 번째 영역에 배경 색상을 변경한 다음 개별 영역에 액세스 하는 속성입니다.  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 코드 예제가 작동 하려면 해야 설정을 추가 하면 웹 파트 설명 파일을 내보낼 수 있도록 Web.config 파일에서 note 합니다. 이 코드 예제에 대 한 웹 페이지와 같은 디렉터리에 Web.config 파일이 있는지 확인 합니다. 내 합니다 `<system.web>` 섹션, 있는지는 `<webParts>` 요소는 `enableExport` 특성이로 설정 `true`다음 태그 에서처럼.  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 클릭 하면 브라우저에 페이지를 로드 한 후에 **목록 영역 Id** 단추 코드를 사용 하는 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 속성 Id가 나열 되어 컬렉션의 모든 영역을 합니다. 클릭할 경우 합니다 **변경 영역 BackColor** 단추 코드를 두 번째 영역의 배경색을 변경 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>