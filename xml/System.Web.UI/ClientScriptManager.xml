<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="362838f0721b50d4f9941389c889e4c552a1bbc0" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395983" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>웹 애플리케이션에서 클라이언트 스크립트를 관리하는 메서드를 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> 클래스 클라이언트 스크립트를 관리 하 고 웹 응용 프로그램에 추가 하는 데 사용 됩니다. 에 대 한 참조를 가져올 수 있습니다는 <xref:System.Web.UI.ClientScriptManager> 에서 클래스를 <xref:System.Web.UI.Page.ClientScript%2A> 의 속성을 <xref:System.Web.UI.Page> 개체입니다.  
  
 추가할 수 있습니다 클라이언트 스크립트를 웹 페이지에 선언적으로 페이지의 HTML 태그에서 스크립트를 포함 하 여. 그러나 클라이언트 스크립트를 동적으로 추가 해야 하는 경우가 있습니다. 동적으로 스크립트를 추가 하려면 사용 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드를를 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 메서드를를 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드를 또는 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 스크립트를 추가 하려는 방법과 시기에 따라 메서드를 합니다. 자세한 내용은 [방법: 추가 클라이언트 스크립트 동적 ASP.NET 웹 페이지에](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666)입니다.  
  
 합니다 <xref:System.Web.UI.ClientScriptManager> 클래스는 키로 스크립트를 고유 하 게 식별 <xref:System.String> 및 <xref:System.Type>합니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 스크립트 유형을 사용 하는 작업은 페이지에서 사용에서 될 수 있는 다른 사용자 정의 컨트롤의 유사한 스크립트를 혼동 하지 않으려면 수 있습니다.  
  
 <xref:System.Web.UI.ClientScriptManager> 클래스를 사용 하 여 포스트백을 수행 하지 않고 클라이언트에서 서버 코드를 실행 하는 것이 바람직한 경우 상황에서 클라이언트 콜백은 호출할 수 있습니다. 이 서버는 대역의 콜백을 수행 이라고 합니다. 클라이언트 콜백을 클라이언트 스크립트 함수는 ASP.NET 웹 페이지에는 비동기 요청을 보냅니다. 웹 페이지 콜백 처리할 일반적인 수명 주기의의 수정된 된 버전을 실행합니다. 사용 된 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드를 호출 하면 클라이언트 함수에 대 한 참조를 얻으려면 서버 이벤트에 대 한 클라이언트 콜백을 시작 합니다. 자세한 내용은 [포스트백 없이 클라이언트 콜백 구현](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)합니다.  
  
> [!NOTE]
>  스크립트 콜백 문서 개체 모델 (DOM)을 지원 하지 않는 이전 브라우저에서 작동 하지 않으며 ECMAScript 클라이언트에서 활성화 되어 있는지 필요 합니다. 브라우저에서 콜백을 지원 하는지 확인 하려면 사용 합니다 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 속성을 통해 액세스할 수 있는 합니다 <xref:System.Web.HttpRequest.Browser%2A> asp.net 내장 속성 <xref:System.Web.HttpContext.Request%2A> 개체.  
  
 사용 된 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드 및 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> 클라이언트 포스트백 이벤트를 정의 하는 방법입니다. 이러한 메서드는 페이지에 다시 게시 하 여 서버를 호출 하면 클라이언트 스크립트 함수를 사용 합니다. 클라이언트 다시 게시 이벤트를 클라이언트 포스트백 이벤트를 프로세스에는 일반적인 수명 주기를 완료 하는 웹 페이지에는 클라이언트 콜백와 다릅니다.  
  
> [!NOTE]
>  사용 중인 경우를 <xref:System.Web.UI.WebControls.Button> 컨트롤 및 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 속성이로 설정 되어 `false`를 사용할 수 있습니다를 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 클라이언트를 반환 하는 방법에 대 한 이벤트를 포스트백를 <xref:System.Web.UI.WebControls.Button> 컨트롤입니다.  
  
 <xref:System.Web.UI.WebControls.Button.OnClientClick%2A> 의 속성을 <xref:System.Web.UI.WebControls.Button> 컨트롤 <xref:System.Web.UI.WebControls.ImageButton> 컨트롤 및 <xref:System.Web.UI.WebControls.LinkButton> 클라이언트 스크립트를 실행 하려면 컨트롤을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 두 개의 클라이언트 스크립트가 페이지에 정의 된: `PopupScript`, 페이지가 로드 될 때 경고 메시지를 표시 하는 하 고 `ButtonClickScript`를 HTML 단추에 대 한 클라이언트 처리기를 정의 하는 `onClick` 이벤트입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">ASP.NET 웹 페이지에서 클라이언트 스크립트</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>호출될 경우 클라이언트에서 서버 이벤트를 콜백하도록 하는 클라이언트 함수에 대한 참조를 가져옵니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 콜백을 처리하는 서버 <see cref="T:System.Web.UI.Control" />입니다. 이 컨트롤에서는 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하고 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 제공해야 합니다.</param>
        <param name="argument">클라이언트 스크립트에서 서버 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 호출하여 생성됩니다.</param>
        <param name="clientCallback">성공한 서버 이벤트의 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="context">콜백을 시작하기 전에 클라이언트에서 계산되는 클라이언트 스크립트입니다. 스크립트 결과는 클라이언트 이벤트 처리기로 다시 전달됩니다.</param>
        <summary>호출될 경우 클라이언트에서 서버 이벤트를 콜백하도록 하는 클라이언트 함수에 대한 참조를 가져옵니다. 이 오버로드된 메서드의 클라이언트 함수에는 지정한 컨트롤, 인수, 클라이언트 스크립트 및 컨텍스트가 포함됩니다.</summary>
        <returns>클라이언트 콜백을 호출하는 클라이언트 함수의 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> 메서드는 페이지의 일반적인 수명 주기의 수정된 된 버전에는 서버는 대역의 콜백을 수행 합니다. 자세한 내용은 [포스트백 없이 클라이언트 콜백 구현](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)합니다.  
  
> [!NOTE]
>  브라우저는 Microsoft Internet Explorer (버전 5.0 이상) 이면 스크립트 콜백 메커니즘 Microsoft.XmlHttp COM 개체를 통해 구현 되 고 ActiveX 컨트롤을 사용 하도록 설정할 브라우저 필요. 다른 브라우저를 브라우저의 로컬 문서 개체 모델 (DOM)를 사용 하 여 XMLHttpRequest은 사용 합니다. 브라우저 클라이언트 콜백은 지원 하는지 여부를 확인 하려면 사용 된 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 속성입니다. 브라우저는 HTTP를 통해 XML을 지원 하는지 여부를 확인 하려면 사용 된 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> 속성입니다. 두 속성을 통해 액세스할 수 합니다 <xref:System.Web.HttpRequest.Browser%2A> 내장 asp.net 속성 <xref:System.Web.HttpContext.Request%2A> 개체입니다.  
  
 합니다 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 오버 로드는 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드는 동기적으로 XML을 사용 하 여 HTTP를 통해 콜백을 수행 합니다. 데이터를 보낼 때 동기적으로 콜백 시나리오에서 동기 콜백을 즉시 반환 하 고 브라우저를 차단 하지 않습니다. 두 개의 동기 콜백을 없는 브라우저에서 동시에 실행할 수 있습니다. 두 번째 콜백이 하나는 현재 보류 중, 하는 경우 두 번째 동기 콜백 첫 번째 취소 하 고 두 번째 콜백만 반환 됩니다.  
  
 데이터를 비동기적으로 전송 하는 오버 로드 중 하나를 사용는 `useAsync` 매개 변수는 부울 값이이 동작을 제어 합니다. 비동기 시나리오에서 여러 개의 보류 중인 콜백을; 할 수 있습니다. 그러나 반환 하는 순서는 시작 된 순서와 일치 하는 보장 되지 않습니다.  
  
 또한이 오버 로드 된 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 에서 생성 된 오류 조건의 경우를 처리할 수 없는 클라이언트 함수를 지정 하는 메서드는 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드. 클라이언트 오류 콜백 처리기를 지정 하는 오버 로드 중 하나를 사용 합니다 `clientErrorCallback` 매개 변수입니다.  
  
 합니다 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> 메서드는 선택적 문자열 `argument` 매개 변수는 문자열을 반환 합니다. 전달할 또는 여러 값을 받을 입력의 값을 연결 하거나 문자열을 각각 반환 합니다.  
  
> [!NOTE]
>  스크립트 콜백 작업 하는 동안 업데이트 해야 하는 페이지 또는 컨트롤 속성의 구현에서 뷰 상태를 사용 하지 마십시오. 속성 페이지 요청을 계속 유지 될 경우에 세션 상태를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 오버 로드를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 정수 증가 하는 클라이언트 콜백 시나리오에는 메서드.  
  
 두 콜백 메커니즘 표시 됩니다. 사용 하는 것의 차이 `context` 매개 변수입니다. A `ReceiveServerData1` 클라이언트 콜백 함수를 사용 하 여 제공 된 `context` 매개 변수입니다. 반면에 `ReceiveServerData2` 클라이언트 콜백 함수에 정의 된를 `<script>` 페이지의 블록입니다. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드는 전달 되는 값을 증가 하는 서버 처리기 및 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> 메서드를 문자열로 증가 값을 반환 합니다. 경우는 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드는 오류를 반환 하면 `ProcessCallBackError` 클라이언트 함수를 호출 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">지정된 <see cref="T:System.Web.UI.Control" />는 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정한 <see cref="T:System.Web.UI.Control" />에서 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 콜백을 처리하는 서버 <see cref="T:System.Web.UI.Control" />입니다. 이 컨트롤에서는 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하고 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 제공해야 합니다.</param>
        <param name="argument">클라이언트 스크립트에서 서버 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 호출하여 생성됩니다.</param>
        <param name="clientCallback">성공한 서버 이벤트의 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="context">콜백을 시작하기 전에 클라이언트에서 계산되는 클라이언트 스크립트입니다. 스크립트 결과는 클라이언트 이벤트 처리기로 다시 전달됩니다.</param>
        <param name="useAsync">콜백을 비동기적으로 수행하려면 <see langword="true" />이고, 동기적으로 수행하려면 <see langword="false" />입니다.</param>
        <summary>호출될 경우 클라이언트에서 서버 이벤트를 콜백하도록 하는 클라이언트 함수에 대한 참조를 가져옵니다. 이 오버로드된 메서드의 클라이언트 함수에는 지정한 컨트롤, 인수, 클라이언트 스크립트, 컨텍스트 및 부울 값이 포함됩니다.</summary>
        <returns>클라이언트 콜백을 호출하는 클라이언트 함수의 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드를 사용 하려면를 `useAsync` 매개 변수 값을 설정 하 여 클라이언트 콜백을 비동기적으로 수행할 수 있는 `true`합니다. 필요가 없는 경우이 메서드의 오버 로드 버전의 `useAsync` 매개 변수 값을 설정 `false` 기본적으로 합니다.  
  
 이 메서드에 대 한 자세한 내용은 오버 로드에 대 한 설명을 참조 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">지정된 <see cref="T:System.Web.UI.Control" />는 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정한 <see cref="T:System.Web.UI.Control" />에서 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">클라이언트 콜백을 처리하는 서버 <see cref="T:System.Web.UI.Control" />의 이름입니다. 이 컨트롤에서는 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하고 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 제공해야 합니다.</param>
        <param name="argument">클라이언트 스크립트에서 서버 
 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 호출하여 생성됩니다.</param>
        <param name="clientCallback">성공한 서버 이벤트의 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="context">콜백을 시작하기 전에 클라이언트에서 계산되는 클라이언트 스크립트입니다. 스크립트 결과는 클라이언트 이벤트 처리기로 다시 전달됩니다.</param>
        <param name="clientErrorCallback">서버 이벤트 처리기에서 오류가 발생할 때 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="useAsync">콜백을 비동기적으로 수행하려면 <see langword="true" />이고, 동기적으로 수행하려면 <see langword="false" />입니다.</param>
        <summary>호출될 경우 클라이언트에서 서버 이벤트를 콜백하도록 하는 클라이언트 함수에 대한 참조를 가져옵니다. 이 오버로드된 메서드의 클라이언트 함수에는 지정한 대상, 인수, 클라이언트 스크립트, 컨텍스트, 오류 처리기 및 부울 값이 포함됩니다.</summary>
        <returns>클라이언트 콜백을 호출하는 클라이언트 함수의 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드를 `target` 매개 변수 대신 문자열을 <xref:System.Web.UI.Control> 매개 변수입니다. 콜백을 포함 하는 문자열 이외의 값으로 다시 이동 하려는 경우이 오버 로드를 사용 하 여를 <xref:System.Web.UI.Control.UniqueID%2A> 컨트롤입니다.  
  
 또한이 오버 로드 된 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드를 사용 하려면를 `useAsync` 및 `clientErrorCallback` 매개 변수입니다. 합니다 `useAsync` 매개 변수 값을 설정 하 여 클라이언트 콜백을 비동기적으로 수행할 수 있도록 `true`입니다. 필요가 없는 경우이 메서드의 오버 로드 버전의 `useAsync` 매개 변수 값을 설정 `false` 기본적으로 합니다. `clientErrorCallback` 매개 변수를 사용 하면 호출 되는 클라이언트 함수의 이름을 정의할 수 있습니다 서버 처리기는 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드를 오류를 반환 합니다. 필요가 없는 경우이 메서드의 오버 로드 버전을 `clientErrorCallback` 매개 변수 값을 null로 설정 합니다.  
  
 이 메서드에 대 한 자세한 내용은 오버 로드에 대 한 설명을 참조 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 오버 로드를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 정수 증가 하는 클라이언트 콜백 시나리오에는 메서드.  
  
 두 콜백 메커니즘 표시 됩니다. 사용 하는 것의 차이 `context` 매개 변수입니다. A `ReceiveServerData1` 클라이언트 콜백 함수를 사용 하 여 제공 된 `context` 매개 변수입니다. 반면에 `ReceiveServerData2` 클라이언트 콜백 함수에 정의 된를 `<script>` 페이지의 블록입니다. A <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드는 전달 되는 값을 증가 하는 서버 처리기 및 <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> 메서드를 문자열로 증가 값을 반환 합니다. 경우는 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드는 오류를 클라이언트 함수 `ProcessCallBackError` 라고 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 콜백을 처리하는 서버 <see cref="T:System.Web.UI.Control" />입니다. 이 컨트롤에서는 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하고 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드를 제공해야 합니다.</param>
        <param name="argument">클라이언트 스크립트에서 서버 <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> 메서드로 전달되는 인수입니다.</param>
        <param name="clientCallback">성공한 서버 이벤트의 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="context">콜백을 시작하기 전에 클라이언트에서 계산되는 클라이언트 스크립트입니다. 스크립트 결과는 클라이언트 이벤트 처리기로 다시 전달됩니다.</param>
        <param name="clientErrorCallback">서버 이벤트 처리기에서 오류가 발생할 때 결과를 받는 클라이언트 이벤트 처리기의 이름입니다.</param>
        <param name="useAsync">콜백을 비동기적으로 수행하려면 <see langword="true" />이고, 동기적으로 수행하려면 <see langword="false" />입니다.</param>
        <summary>호출될 경우 클라이언트에서 서버 이벤트를 콜백하도록 하는 클라이언트 함수에 대한 참조를 가져옵니다. 이 오버로드된 메서드의 클라이언트 함수에는 지정한 컨트롤, 인수, 클라이언트 스크립트, 컨텍스트, 오류 처리기 및 부울 값이 포함됩니다.</summary>
        <returns>클라이언트 콜백을 호출하는 클라이언트 함수의 이름입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드 된 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드를 사용 하려면를 `useAsync` 및 `clientErrorCallback` 매개 변수입니다. 합니다 `useAsync` 매개 변수 값을 설정 하 여 클라이언트 콜백을 비동기적으로 수행할 수 있도록 `true`입니다. 필요가 없는 경우이 메서드의 오버 로드 버전의 `useAsync` 매개 변수 값을 설정 `false` 기본적으로 합니다. 합니다 `clientErrorCallback` 매개 변수를 사용 하면 호출 되는 클라이언트 함수의 이름을 정의할 수 있습니다 서버 처리기 (의 <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> 메서드) 오류를 반환 합니다. 필요가 없는 경우이 메서드의 오버 로드 버전을 `clientErrorCallback` 매개 변수 값을 null로 설정 합니다.  
  
 이 메서드에 대 한 자세한 내용은 오버 로드에 대 한 설명을 참조 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">지정된 <see cref="T:System.Web.UI.Control" />는 <see langword="null" />입니다.</exception>
        <exception cref="T:System.InvalidOperationException">지정한 <see cref="T:System.Web.UI.Control" />에서 <see cref="T:System.Web.UI.ICallbackEventHandler" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서버에 다시 게시하는 클라이언트 이벤트에 사용할 수 있는 참조를 가져옵니다. 이 참조의 시작 부분에는 <see langword="javascript:" />가 추가됩니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">다시 게시 작업을 처리하는 서버 컨트롤입니다.</param>
        <param name="argument">서버 컨트롤에 전달된 매개 변수입니다.</param>
        <summary>지정된 이벤트 인수를 사용하여 지정된 컨트롤을 서버에 다시 게시하는 클라이언트 이벤트에 사용할 수 있는 참조를 가져옵니다. 이 참조의 시작 부분에는 <see langword="javascript:" />라는 문자열이 추가됩니다.</summary>
        <returns>대상 컨트롤의 ID 및 이벤트 인수를 포함하는 다시 게시 함수에 대한 JavaScript 호출을 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 구현 하는 포스트백을 처리 하는 컨트롤에 필요 합니다 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다. 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page>, 지시문을 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> 메서드. 사용자 지정 컨트롤 `MyControl`를 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다. 페이지의 HTML 앵커 요소를 클릭할 때는 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 사용자 지정 컨트롤의 메서드가 호출 됩니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 다음 코드 예제에서는 사용자 지정 컨트롤을 대신 이전과 동일한 기능이 합니다 <xref:System.Web.UI.Page> 구현 클래스는 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">다시 게시 작업을 처리하는 서버 컨트롤입니다.</param>
        <param name="argument">서버 컨트롤에 전달된 매개 변수입니다.</param>
        <param name="registerForEventValidation">유효성 검사에 대한 다시 게시 이벤트를 등록하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 이벤트 인수와 이벤트 유효성 검사에 대한 다시 게시를 등록할지 여부를 나타내는 부울 값을 사용하여 지정된 컨트롤에 대해 서버에 다시 게시하는 클라이언트 이벤트에 사용할 수 있는 참조를 가져옵니다. 이 참조의 시작 부분에는 <see langword="javascript:" />가 추가됩니다.</summary>
        <returns>대상 컨트롤의 ID 및 이벤트 인수를 포함하는 다시 게시 함수에 대한 JavaScript 호출을 나타내는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 구현 하는 포스트백을 처리 하는 컨트롤에 필요 합니다 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다. 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page>, 지시문을 사용 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서버에 다시 게시 작업을 발생시키는 클라이언트 이벤트에 사용할 수 있는 문자열을 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">다시 게시를 정의하는 <see cref="T:System.Web.UI.PostBackOptions" />입니다.</param>
        <summary>서버에 다시 게시 작업을 발생시키는 클라이언트 이벤트에 사용할 수 있는 문자열을 반환합니다. 참조 문자열은 지정한 <see cref="T:System.Web.UI.PostBackOptions" /> 인스턴스에 의해 정의됩니다.</summary>
        <returns>클라이언트의 스크립트로 처리될 때 클라이언트 다시 게시 작업을 시작하는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page>, 지시문을 사용 합니다.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 사용 하 여 사용할 수 있습니다를 <xref:System.Web.UI.WebControls.Button> 시기를 제어 합니다 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 속성이 `false`합니다. 이 시나리오에서는 합니다 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드가 반환 되는 클라이언트 포스트백에 대 한 이벤트를 <xref:System.Web.UI.WebControls.Button> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" /> 매개 변수가 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">서버에서 다시 게시 작업을 처리하는 서버 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <param name="argument">다시 게시 작업을 처리하는 컨트롤에 전달할 선택적 인수의 문자열입니다.</param>
        <summary>서버에 다시 게시 작업을 발생시키는 클라이언트 이벤트에 사용할 수 있는 문자열을 반환합니다. 참조 문자열은 다시 게시 작업과 추가 이벤트 정보의 문자열 인수를 처리하는 지정된 컨트롤에 의해 정의됩니다.</summary>
        <returns>클라이언트의 스크립트로 처리될 때 다시 게시 작업을 시작하는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page>, 지시문을 사용 합니다.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 사용 하 여 사용할 수 있습니다를 <xref:System.Web.UI.WebControls.Button> 시기를 제어 합니다 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 속성이 `false`합니다. 이 시나리오에서는 합니다 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드가 반환 되는 클라이언트 포스트백에 대 한 이벤트를 <xref:System.Web.UI.WebControls.Button> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드. 사용자 지정 컨트롤 `MyControl`를 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다. 페이지의 단추를 클릭 하면는 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 사용자 지정 컨트롤의 메서드가 호출 됩니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 다음 코드 예제에서는 사용자 지정 컨트롤을 대신 이전과 동일한 기능이 합니다 <xref:System.Web.UI.Page> 구현 클래스는 <xref:System.Web.UI.IPostBackEventHandler> 인터페이스입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">지정된 <see cref="T:System.Web.UI.Control" />는 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options">다시 게시를 정의하는 <see cref="T:System.Web.UI.PostBackOptions" />입니다.</param>
        <param name="registerForEventValidation">유효성 검사에 대한 이벤트 참조를 등록하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>서버에 다시 게시 작업을 발생시키는 클라이언트 이벤트에 사용할 수 있는 문자열을 반환합니다. 참조 문자열은 지정된 <see cref="T:System.Web.UI.PostBackOptions" /> 개체에 의해 정의됩니다. 유효성 검사에 대한 이벤트 참조도 선택적으로 등록합니다.</summary>
        <returns>클라이언트의 스크립트로 처리될 때 클라이언트 다시 게시 작업을 시작하는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page> 개체, 지시문을 사용 합니다.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 사용 하 여 사용할 수 있습니다를 <xref:System.Web.UI.WebControls.Button> 시기를 제어 합니다 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 속성이 `false`합니다. 이 시나리오에서는 합니다 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드가 반환 되는 클라이언트 포스트백에 대 한 이벤트를 <xref:System.Web.UI.WebControls.Button> 제어 합니다.  
  
 경우 `registerForEventValidation` 됩니다 `true`의 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> 메서드 호출을 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> 이벤트를 생성 하는 클라이언트 컨트롤을 나타내는 고유 컨트롤 ID를 사용 하 여 유효성 검사에 대 한 이벤트 참조를 등록 하는 방법.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Web.UI.PostBackOptions" />이 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">서버에서 다시 게시 작업을 처리하는 서버 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <param name="argument"><paramref name="control" />에 전달할 선택적 인수의 문자열입니다.</param>
        <param name="registerForEventValidation">유효성 검사에 대한 이벤트 참조를 등록하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>서버에 다시 게시 작업을 발생시키는 클라이언트 이벤트에 사용할 문자열을 반환합니다. 참조 문자열은 다시 게시 작업과 추가 이벤트 정보의 문자열 인수를 처리하는 지정된 컨트롤에 의해 정의됩니다. 유효성 검사에 대한 이벤트 참조도 선택적으로 등록합니다.</summary>
        <returns>클라이언트의 스크립트로 처리될 때 다시 게시 작업을 시작하는 문자열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 하는 <xref:System.Web.UI.IPostBackEventHandler> 에 대 한 인터페이스를 <xref:System.Web.UI.Page>, 지시문을 사용 합니다.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드를 사용 하 여 사용할 수 있습니다를 <xref:System.Web.UI.WebControls.Button> 시기를 제어 합니다 <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> 속성이 `false`합니다. 이 시나리오에서는 합니다 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> 메서드가 반환 되는 클라이언트 포스트백에 대 한 이벤트를 <xref:System.Web.UI.WebControls.Button> 제어 합니다.  
  
 하는 경우 `registerForEventValidation` 가 true 이면 합니다 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> 메서드 호출을 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> 이벤트를 생성 하는 클라이언트 컨트롤을 나타내는 고유 컨트롤 ID를 사용 하 여 유효성 검사에 대 한 이벤트 참조를 등록 하는 방법.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">지정된 <see cref="T:System.Web.UI.Control" />는 <see langword="null" />입니다.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">ASP.NET 페이지의 포스트백 없이 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">리소스의 형식입니다.</param>
        <param name="resourceName">어셈블리에 있는 리소스의 정규화된 이름입니다.</param>
        <summary>어셈블리의 리소스에 대한 URL 참조를 가져옵니다.</summary>
        <returns>리소스에 대한 URL 참조입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 메서드는 어셈블리에 포함 된 리소스에 대 한 URL 참조를 반환 합니다. 반환 된 참조로 인코딩된 URL이 아닙니다. 리소스는 스크립트 파일, 이미지 또는 모든 정적 파일 수 있습니다. 리소스에 액세스 하는 개체를 기반으로 형식을 지정할 수 있습니다.  
  
 페이지를 사용 하 여 등록 된 웹 리소스는 해당 유형과 이름으로 고유 하 게 식별 됩니다. 지정 된 형식 및 이름 쌍을 사용 하 여 하나의 리소스 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 리소스를 등록 하는 동안 등록 된 리소스의 중복을 만들지 않습니다.  
  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 메서드를 함께에서 사용 된 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 어셈블리에 포함 된 리소스에 액세스 하기 위한 메서드. 애플리케이션에서 리소스 사용에 대 한 자세한 내용은 참조 하세요. [ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> 메서드. 합니다 *형식* 이 예제에서 매개 변수는 리소스를 포함 하는 어셈블리에서 클래스의 형식으로 설정 됩니다. `resourceName` 기본 네임 스페이스를 포함 하는 리소스에 정규화 된 경로 사용 하 여 매개 변수를 지정 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 다음 코드 예제에서는 프로그래밍 방식으로 적용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebResourceAttribute> 메타 데이터 특성에 제공 되는 리소스에 대 한 어셈블리를 표시 합니다. 로 설정 하는 기본 네임 스페이스를 사용 하 여 클래스 라이브러리에서 다음 클래스를 컴파일하면 `Samples.AspNet.CS.Controls` 또는 `Samples.AspNet.VB.Controls`사용 하는 언어에 따라 합니다.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 이 예제에서는 라는 JavaScript 파일 `Script_include.js`합니다. .Js 파일이 포함 된 어셈블리에 포함된 된 리소스는 `ClientScriptResourceLabel` 개체입니다. Visual Studio 클래스 라이브러리 프로젝트의 속성 창에서를 사용 하는 경우 설정 **빌드 작업** 하 **포함 리소스** 스크립트 파일을 선택 하는 경우. 명령줄에서 라이브러리를 컴파일하는 경우 리소스를 포함 하는 스위치를 사용 합니다.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">웹 리소스 형식이 <see langword="null" />인 경우

또는

웹 리소스 이름이 <see langword="null" />인 경우  
  
또는 
웹 리소스 이름의 길이가 0인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">ASP.NET Web Page Resources Overview</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/resource (리소스 파일 포함을 출력) (C# 컴파일러 옵션)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource(Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 스크립트 블록이 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">검색할 클라이언트 스크립트 블록의 키입니다.</param>
        <summary>클라이언트 스크립트 블록이 지정한 키를 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트 블록이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 중복 스크립트가 등록 되지 않게 하는 방법입니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 클라이언트 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다.  
  
 이 오버 로드를 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 둘 다 사용 하는 오버 로드를 호출 하는 메서드를 `key` 및 `type` 로 설정 된 형식 사용 하 여 매개 변수는 <xref:System.Web.UI.Page> 개체  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">검색할 클라이언트 스크립트 블록의 형식입니다.</param>
        <param name="key">검색할 클라이언트 스크립트 블록의 키입니다.</param>
        <summary>클라이언트 스크립트 블록이 키와 형식을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트 블록이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 중복 스크립트가 등록 되지 않게 하는 방법입니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 클라이언트 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 리소스에 액세스 하는 개체를 기반으로 형식을 지정할 수 있습니다. 예를 들어 사용 하는 경우는 `Page` 지정할 리소스에 액세스 하는 인스턴스는 `Page` 형식입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 메서드. 기존 클라이언트 스크립트 블록을 확인 하는 논리를 제거 된 경우 있습니다 됩니다 수 없습니다 두 개의 중복 된 클라이언트 스크립트 렌더링된 된 페이지의 HTML 소스 코드에서 때문에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 중복에 대 한 메서드를 확인 합니다. 불필요 한 계산을 위해 검사의 장점은입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 형식이 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 스크립트 포함이 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">검색할 클라이언트 스크립트 포함의 키입니다.</param>
        <summary>클라이언트 스크립트 포함이 지정한 키를 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트 포함이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 중복 스크립트가 등록 되지 않게 하는 방법입니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 클라이언트 스크립트 포함의 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 둘 다 사용 하는 오버 로드를 호출 하는 메서드를 `key` 및 `type` 로 설정 된 형식 사용 하 여 매개 변수를 <xref:System.Web.UI.Page> 개체.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">검색할 클라이언트 스크립트 포함의 형식입니다.</param>
        <param name="key">검색할 클라이언트 스크립트 포함의 키입니다.</param>
        <summary>클라이언트 스크립트 포함이 키와 형식을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>클라이언트 스크립트 포함이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 중복 클라이언트 스크립트를 등록 하려면 포함 되어 있습니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 클라이언트 스크립트 포함의 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 리소스에 액세스 하는 개체를 기반으로 형식을 지정할 수 있습니다. 예를 들어 리소스에 액세스할 때 페이지 인스턴스를 사용 하는 경우 지정 된 `Page` 형식입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> 메서드. 기존 클라이언트 스크립트 포함을 확인 하는 논리 제거 된 경우 있습니다 됩니다 수 없습니다 두 개의 중복 된 클라이언트 스크립트 렌더링된 된 페이지의 HTML 소스 코드에서 때문에 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 중복에 대 한 메서드를 확인 합니다. 불필요 한 계산을 위해 검사의 장점은입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 이 예제에서는 라는 JavaScript 파일 `Script_include.js`를 다음 콘텐츠로:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 포함 형식이 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>OnSubmit 문이 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">검색할 OnSubmit 문의 키입니다.</param>
        <summary>OnSubmit 문이 지정한 키를 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>OnSubmit 문이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 중복 OnSubmit 문이 등록을 방지 하는 방법입니다. 이 문이 필요한 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 문은 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키 및 유형으로 문은 중복으로 간주 됩니다.  
  
 이 오버 로드를 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 둘 다 사용 하는 오버 로드를 호출 하는 메서드를 `key` 및 `type` 로 설정 된 형식 사용 하 여 매개 변수는 <xref:System.Web.UI.Page> 개체  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">검색할 OnSubmit 문의 형식입니다.</param>
        <param name="key">검색할 OnSubmit 문의 키입니다.</param>
        <summary>OnSubmit 문이 지정한 키와 형식을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>OnSubmit 문이 등록되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 문이 중복 등록을 방지 하는 방법입니다. 이 문이 필요한 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 문은 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키 및 유형으로 문은 중복으로 간주 됩니다. 리소스에 액세스 하는 개체를 기반으로 형식을 지정할 수 있습니다. 예를 들어 사용 하는 경우는 `Page` 지정할 리소스에 액세스 하는 인스턴스는 `Page` 형식입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 메서드. 이라는 스크립트 `OnSubmitScript` 등록 된는 <xref:System.Web.UI.Page> 스크립트가 호출 될 페이지의 폼을 전송할 때 되도록 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">OnSubmit 문 형식이 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>시작 스크립트가 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">검색할 시작 스크립트의 키입니다.</param>
        <summary>시작 스크립트가 지정한 키를 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>시작 스크립트가 등록되면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 중복 스크립트가 등록 되지 않게 하는 방법입니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 시작 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 두 문자열을 사용 하는 오버 로드를 호출 하는 메서드 `key` 및 `type` 으로 설정 된 형식 사용 하 여 매개 변수는 <xref:System.Web.UI.Page> 개체  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">검색할 시작 스크립트의 형식입니다.</param>
        <param name="key">검색할 시작 스크립트의 키입니다.</param>
        <summary>시작 스크립트가 지정한 키와 형식을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 등록되는지 여부를 결정합니다.</summary>
        <returns>시작 스크립트가 등록되면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 중복 스크립트가 등록 되지 않게 하는 방법입니다. 이 스크립트를 사용 하려면 많은 양의 서버 리소스를 만들어야 하는 경우에 특히 중요 합니다.  
  
 클라이언트 시작 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 메서드. 기존 시작 스크립트 블록을 확인 하는 논리를 제거 된 경우 있습니다 됩니다 수 없습니다 두 개의 중복 된 시작 스크립트가 렌더링된 된 페이지의 HTML 소스 코드에서 때문에 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 중복에 대 한 메서드를 확인 합니다. 불필요 한 계산을 위해 검사의 장점은입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">시작 스크립트가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">등록할 배열 이름입니다.</param>
        <param name="arrayValue">등록할 배열 값입니다.</param>
        <summary>배열 이름과 배열 값을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체에 JavaScript 배열 선언을 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 등록 된 배열에 지정 된 이름으로 같은 이름의 있는지 여부를 확인 합니다 `arrayName` 매개 변수 및 경우에 지정 된 값을 추가 합니다.는 `arrayValue` 매개 변수. 기본 스토리지 메커니즘은 <xref:System.Collections.ArrayList>을 기반으로 하므로 중복이 허용됩니다. 경우 이름이 같은 등록 된 배열 합니다 `arrayName` 매개 변수가 없는, 만들어질 값는 `arrayValue` 매개 변수를 추가 합니다.  
  
 결과 JavaScript 배열에 문자열 리터럴을 원한다 면 단일 따옴표 (') 또는 큰따옴표를 이스케이프 (\\")에 `arrayValue` 매개 변수입니다. 값을 `arrayValue` 매개 변수는 단일 요소 이어야 합니다. 둘 이상의 값을 배열에 추가 하는 경우 사용 하 여 여러 호출을 확인 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 고 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 메서드. 이 예제에서는 배열 및 숨겨진된 값을 등록 하 고 정의 `OnClick` 의 이벤트는 `<input>` 배열의 두 값과 숨겨진된 값의 합계를 계산 하는 단추입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />가 <see langword="null" />인 경우</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">등록할 클라이언트 스크립트의 형식입니다.</param>
        <param name="key">등록할 클라이언트 스크립트의 키입니다.</param>
        <param name="script">등록할 클라이언트 스크립트 리터럴입니다.</param>
        <summary>형식, 키 및 스크립트 리터럴을 사용하여 클라이언트 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 지정 된 형식 및 키 쌍을 사용 하 여 하나의 스크립트 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 스크립트를 등록 하는 동안 스크립트의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 메서드를 지정된 된 키 및 유형 쌍을 사용 하 여 클라이언트 스크립트를 이미 등록 되어 있는지 여부를 확인 하 고 불필요 하 게 스크립트를 추가 하려는 시도 방지 합니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드를 확인 해야 스크립트에서 제공 되는지 확인 합니다 `script` 매개 변수에서 래핑됩니다는 `<script>` 요소 블록.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드 스크립트 블록을 렌더링된 된 페이지의 맨 위에 추가 합니다. 등록 된 순서에 출력 되는 스크립트 블록 보장이 없습니다. 사용 하 여 스크립트 블록의 순서가 중요 한 경우는 <xref:System.Text.StringBuilder> 개체를 단일 문자열에서 스크립트를 함께 수집 및 단일 클라이언트 스크립트 블록의 모든 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">등록할 클라이언트 스크립트의 형식입니다.</param>
        <param name="key">등록할 클라이언트 스크립트의 키입니다.</param>
        <param name="script">등록할 클라이언트 스크립트 리터럴입니다.</param>
        <param name="addScriptTags">스크립트 태그를 추가할지 여부를 나타내는 부울 값입니다.</param>
        <summary>형식, 키, 스크립트 리터럴 및 스크립트 태그를 추가할지 여부를 나타내는 부울 값을 사용하여 클라이언트 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 지정 된 형식 및 키 쌍을 사용 하 여 하나의 스크립트 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 스크립트를 등록 하는 동안 스크립트의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> 지정된 된 키 및 유형 쌍을 사용 하 여 클라이언트 스크립트를 이미 등록 되어 있는지 여부를 확인 하는 방법입니다. 이 스크립트를 추가 하는 동안 불필요 하 게 피할 수 있습니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드를 지정할 수 있습니다. 스크립트의 제공 여부를 합니다 `script` 매개 변수를 사용 하 여 래핑됩니다를 `<script>` 를 사용 하 여 요소 블록을 `addScriptTags` 매개 변수입니다. 설정 `addScriptTags` 에 `true` 스크립트 태그를 자동으로 추가 되어야 함을 나타냅니다.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드 스크립트 블록을 렌더링된 된 페이지의 맨 위에 추가 합니다. 등록 된 순서에 출력 되는 스크립트 블록 보장이 없습니다. 사용 하 여 스크립트 블록의 순서가 중요 한 경우는 <xref:System.Text.StringBuilder> 개체를 단일 문자열에서 스크립트를 함께 수집 및 단일 클라이언트 스크립트 블록의 모든 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드. 합니다 `addScriptTags` 매개 변수는 설정 `true` 시작 태그와 닫는 태그 스크립트에 포함 되므로 `script` 매개 변수입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 블록 형식이 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 스크립트 포함을 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">등록할 클라이언트 스크립트 포함의 키입니다.</param>
        <param name="url">등록할 클라이언트 스크립트 포함의 URL입니다.</param>
        <summary>키와 URL을 사용하여 <see cref="T:System.Web.UI.Page" /> 개체와 함께 클라이언트 스크립트를 등록하여 클라이언트에서 스크립트를 호출할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 스크립트 포함의 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 지정 된 형식 및 키 쌍을 사용 하 여 하나의 스크립트 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 스크립트를 등록 하는 동안 스크립트의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> 확인 여부 지정된 된 키를 사용 하 여 클라이언트 스크립트 포함 및 형식 쌍 이미 등록 되어 불필요 하 게 스크립트를 추가 하려는 시도 방지 하는 방법입니다.  
  
> [!NOTE]
>  클라이언트 URL를 해결 하려면 사용 된 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 메서드. 이 메서드는 경로를 확인 호출 하는 URL의 컨텍스트를 사용 합니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 메서드는 오버 로드를 호출 하는 `key`, `URL`, 및 `type` 매개 변수.  
  
 메서드는 렌더링된 된 페이지의 맨 위에 있는 스크립트 블록을 추가합니다.  
  
   
  
## Examples  
 구문, 사용법 및 예를 들어, 등의 관련된 정보를 참조 하세요. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">등록할 클라이언트 스크립트 포함의 형식입니다.</param>
        <param name="key">등록할 클라이언트 스크립트 포함의 키입니다.</param>
        <param name="url">등록할 클라이언트 스크립트 포함의 URL입니다.</param>
        <summary>형식, 키 및 URL을 사용하여 클라이언트 스크립트 포함을 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 메서드 *키* 하 고 *url* 는 스크립트를 식별 하는 매개 변수 뿐만 `type` 클라이언트 스크립트의 id를 지정 하려면 매개 변수를 포함 합니다. 리소스에 액세스 하는 개체를 기반으로 형식을 지정할 수 있습니다. 예를 들어 사용 하는 경우는 `Page` 지정할 리소스에 액세스 하는 인스턴스는 `Page` 형식입니다.  
  
> [!NOTE]
>  클라이언트 URL를 해결 하려면 사용 된 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 메서드. 이 메서드는 경로를 확인 호출 하는 URL의 컨텍스트를 사용 합니다.  
  
 이 메서드는 렌더링된 된 페이지의 맨 위에 있는 스크립트 블록을 추가합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 메서드. 기존 클라이언트 스크립트 포함을 확인 하는 논리 제거 된 경우는 여전히 없습니다 있을 중복 된 클라이언트 스크립트 렌더링된 된 페이지에 있으므로 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> 중복에 대 한 메서드를 확인 합니다. 불필요 한 계산을 위해 검사의 장점은입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 이 예제에는 같은 내용이 다음 콘텐츠로 라는 JavaScript 파일이 필요 합니다.  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 포함 형식이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">URL이 <see langword="null" />인 경우  
  
또는 
URL이 비어 있는 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">등록할 클라이언트 스크립트 리소스의 형식입니다.</param>
        <param name="resourceName">등록할 클라이언트 스크립트 리소스의 이름입니다.</param>
        <summary>형식과 리소스 이름을 사용하여 클라이언트 스크립트 리소스를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> WebResource.axd HTTP 처리기를 통해 어셈블리에서 컴파일된 리소스에 액세스 하는 경우 메서드가 사용 됩니다. 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 메서드를 사용 하 여 스크립트를 등록 합니다 <xref:System.Web.UI.Page> 개체 중복 스크립트를 방지 합니다. 이 메서드는 리소스 URL의 내용을 `<script>` 요소 블록입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 다음 코드 예제에서는 프로그래밍 방식으로 적용 하는 방법에 설명 합니다 <xref:System.Web.UI.WebResourceAttribute> 메타 데이터 특성에 제공 되는 리소스에 대 한 어셈블리를 표시 합니다.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 이 예제에서는 라는 JavaScript 파일 `Script_include.js`를 다음 콘텐츠로:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 컴파일 합니다 `Script_include.js` 파일에 리소스로 `Samples.AspNet.CS.Controls` 포함 된 어셈블리는 `ClientScriptResourceLabel` 클래스.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 리소스 형식이 <see langword="null" />인 경우

또는

클라이언트 리소스 이름이 <see langword="null" />인 경우  
  
또는 
클라이언트 리소스 이름의 길이가 0인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이름/값 쌍을 지정한 컨트롤의 사용자 지정(expando) 특성으로 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">사용자 지정 특성이 포함된 페이지에 있는 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <param name="attributeName">등록할 사용자 지정 특성 이름입니다.</param>
        <param name="attributeValue">사용자 지정 특성 값입니다.</param>
        <summary>컨트롤 ID, 특성 이름 및 특성 값이 제공되면 이름/값 쌍을 지정한 컨트롤의 사용자 지정(expando) 특성으로 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 메서드는 이름/값 쌍을 지정 된 사용자 지정 (expando) 특성으로 등록 <xref:System.Web.UI.Control>합니다. Expando 특성은 렌더링 된 컨트롤의 태그에 XHTML 호환성을 유지 하기 위해 JavaScript에서 동적으로 설정 됩니다. 사용자 지정 (expando) 특성의 값의 따옴표와 백슬래시는 이스케이프 됩니다. 따옴표와 백슬래시를 이스케이프 하려면 호출을 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 메서드를 오버 로드 하 고 설정 합니다 `encode` 매개 변수를 `false`입니다.  
  
 Expando 특성 없거나 expando 특성을 추가 하려면 컨트롤이 없는 경우 클라이언트 스크립트는 여전히 내보내지지만 컨트롤 영향을 주지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">사용자 지정 특성이 포함된 페이지에 있는 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <param name="attributeName">등록할 사용자 지정 특성 이름입니다.</param>
        <param name="attributeValue">사용자 지정 특성 값입니다.</param>
        <param name="encode">등록할 사용자 지정 특성을 인코딩할지 여부를 나타내는 부울 값입니다.</param>
        <summary>컨트롤 ID, 특성 이름, 특성 값 및 특성 값을 인코딩할지 여부를 나타내는 부울 값이 제공되면 이름/값 쌍을 지정한 컨트롤의 사용자 지정(expando) 특성으로 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 메서드는 이름/값 쌍을 지정 된 사용자 지정 (expando) 특성으로 등록 <xref:System.Web.UI.Control>합니다. Expando 특성은 렌더링 된 컨트롤의 태그에 XHTML 호환성을 유지 하기 위해 JavaScript에서 동적으로 설정 됩니다. 설정 된 `encode` 매개 변수를 `true` 따옴표와 expando 특성의 값에서 백슬래시를 이스케이프 해야 할 경우.  
  
 Expando 특성 없거나 expando 특성을 추가 하려면 컨트롤이 없는 경우 클라이언트 스크립트는 여전히 내보내지지만 컨트롤 영향을 주지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 렌더링 된 페이지 집합에서 클라이언트 스크립트를 `title` 특성을 `<span>` 요소입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>유효성 검사에 대한 이벤트 참조를 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 ID입니다.</param>
        <summary>이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 컨트롤 ID를 사용하여 유효성 검사에 대한 이벤트 참조를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용 및 예제에 대 한 참조를 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 메서드 및 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 메서드 유효성 검사 및 콜백 페이지에서 발생 하는 유효성을 검사 하는 방법에 대 한 콜백을 등록 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">클라이언트 JavaScript를 생성하여 다시 게시 이벤트를 시작하는 방법을 지정하는 <see cref="T:System.Web.UI.PostBackOptions" /> 개체입니다.</param>
        <summary><see cref="T:System.Web.UI.PostBackOptions" />를 사용하여 유효성 검사에 대한 이벤트 참조를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용 및 예제에 대 한 참조를 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 ID입니다.</param>
        <param name="argument">클라이언트 이벤트를 통해 전달되는 이벤트 인수입니다.</param>
        <summary>이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 컨트롤 ID와 이벤트 인수를 사용하여 유효성 검사에 대한 이벤트 참조를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 메서드 및 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 유효성 검사에 대 한 콜백을 등록 하 고 유효성을 검사할 콜백 페이지에서 발생 하는 메서드. 을 개선 하기 위해 예제와 같이 유효성 검사에서 유효성 검사를 수정할 수 있습니다 `argument` id 또는 역할과 같은 사용자 관련 정보를 포함 하도록 매개 변수  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 다음 코드 예제는 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 유효성 검사에 대 한 콜백을 등록 하는 방법입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">이 메서드가 <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" /> 메서드보다 먼저 호출되는 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">유효성 검사 구현 예제를 사용 하 여 클라이언트 콜백</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">등록할 숨겨진 필드의 이름입니다.</param>
        <param name="hiddenFieldInitialValue">등록할 필드의 초기 값입니다.</param>
        <summary>숨겨진 값을 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 메서드는 숨겨진 만듭니다 `<input>` 렌더링된 된 HTML 페이지에는 요소입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 고 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 메서드. 이 예제에서는 배열 및 숨겨진된 값을 등록 하 고 정의 `OnClick` 의 이벤트는 `<input>` 배열의 두 값과 숨겨진된 값의 합계를 계산 하는 단추입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">등록할 OnSubmit 문의 형식입니다.</param>
        <param name="key">등록할 OnSubmit 문의 키입니다.</param>
        <param name="script">등록할 OnSubmit 문의 스크립트 리터럴입니다.</param>
        <summary>형식, 키 및 스크립트 리터럴을 사용하여 OnSubmit 문을 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다. 이 문은 <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />을 전송할 때 실행됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 OnSubmit 문은 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키 및 유형으로 문은 중복으로 간주 됩니다. 페이지를 사용 하 여 지정 된 형식 및 키 쌍을 사용 하 여 문은 하나만 등록할 수 있습니다. 이미 등록 되어 있는 문을 등록 하는 동안 문의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> 메서드는 OnSubmit 문이 지정한 키 및 유형 쌍으로 이미 등록 되어 있는지 여부를 확인 하 여 불필요 하 게 스크립트를 추가 하려는 시도 방지 합니다.  
  
 합니다 `script` 의 매개 변수는 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 메서드 세미콜론 (;)를 사용 하 여 제대로 구분 되는 여러 개의 스크립트 명령을 포함할 수 있습니다.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 페이지가 제출 되 고 제출을 취소 하는 기회를 제공 하기 전에 실행 되는 스크립트를 추가 합니다.  
  
 HTML 폼에 대 한 자세한 내용은 및 `OnSubmit` 특성을 참조 합니다 [World Wide Web Consortium (W3C) 웹 사이트](https://go.microsoft.com/fwlink/?linkid=37125)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />인 경우</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>시작 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">등록할 시작 스크립트의 형식입니다.</param>
        <param name="key">등록할 시작 스크립트의 키입니다.</param>
        <param name="script">등록할 시작 스크립트 리터럴입니다.</param>
        <summary>형식, 키 및 스크립트 리터럴을 사용하여 시작 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 지정 된 형식 및 키 쌍을 사용 하 여 하나의 스크립트 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 스크립트를 등록 하는 동안 스크립트의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 메서드를 지정된 된 키 및 유형 쌍을 사용 하 여 시작 스크립트를 이미 등록 되어 있는지 여부를 확인 하 고 불필요 하 게 스크립트를 추가 하려는 시도 방지 합니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드를 확인 해야 스크립트에서 제공 되는지 확인 합니다 `script` 매개 변수를 사용 하 여 래핑됩니다를 `<script>` 요소 블록입니다.  
  
 추가 스크립트 블록을 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드는 페이지 로드가 완료 되 면 하기 전에 실행 페이지의 <xref:System.Web.UI.Control.OnLoad%2A> 이벤트가 발생 합니다. 등록 된 순서에 출력 되는 스크립트 블록 보장이 없습니다. 사용 하 여 스크립트 블록의 순서가 중요 한 경우는 <xref:System.Text.StringBuilder> 개체를 단일 문자열에서 스크립트를 함께 수집 및 단일 클라이언트 스크립트 블록의 모든 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드. 시작 태그와 닫는 스크립트 태그 내에 포함 된 참고는 `script` 매개 변수입니다. 추가 된 태그를 추가 매개 변수 설정에 따라 참조 하는 스크립트에 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">등록할 시작 스크립트의 형식입니다.</param>
        <param name="key">등록할 시작 스크립트의 키입니다.</param>
        <param name="script">등록할 시작 스크립트 리터럴입니다.</param>
        <param name="addScriptTags">스크립트 태그를 추가할지 여부를 나타내는 부울 값입니다.</param>
        <summary>형식, 키, 스크립트 리터럴 및 스크립트 태그를 추가할지 여부를 나타내는 부울 값을 사용하여 시작 스크립트를 <see cref="T:System.Web.UI.Page" /> 개체에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시작 스크립트는 해당 키 및 해당 형식에 따라 고유 하 게 식별 됩니다. 동일한 키와 형식을 사용 하 여 스크립트에는 중복으로 간주 됩니다. 지정 된 형식 및 키 쌍을 사용 하 여 하나의 스크립트 페이지를 사용 하 여 등록할 수 있습니다. 이미 등록 되어 있는 스크립트를 등록 하는 동안 스크립트의 중복을 만들지 않습니다.  
  
 호출 된 <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> 메서드를 지정된 된 키 및 유형 쌍을 사용 하 여 시작 스크립트를 이미 등록 되어 있는지 여부를 확인 하 고 불필요 하 게 스크립트를 추가 하려는 시도 방지 합니다.  
  
 이 오버 로드는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드를 지정할 수 있습니다. 스크립트의 제공 여부를 합니다 `script` 매개 변수를 사용 하 여 래핑됩니다를 `<script>` 를 사용 하 여 요소 블록을 `addScriptTags` 매개 변수입니다. 설정 `addScriptTags` 에 `true` 스크립트 태그를 자동으로 추가 되어야 함을 나타냅니다.  
  
 추가 스크립트 블록을 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드는 페이지 로드가 완료 되 면 하기 전에 실행 페이지의 <xref:System.Web.UI.Control.OnLoad%2A> 이벤트가 발생 합니다. 등록 된 순서에 출력 되는 스크립트 블록 보장이 없습니다. 사용 하 여 스크립트 블록의 순서가 중요 한 경우는 <xref:System.Text.StringBuilder> 개체를 단일 문자열에서 스크립트를 함께 수집 및 단일 클라이언트 스크립트 블록의 모든 등록 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드. 합니다 `addScriptTags` 매개 변수는 설정 `false` 시작 태그와 닫는 태그 스크립트에 포함 되므로 `script` 매개 변수입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 이벤트의 유효성을 검사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 ID입니다.</param>
        <summary><see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" /> 메서드를 사용하여 이벤트 유효성 검사에 대해 등록된 클라이언트 이벤트의 유효성을 검사합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">이벤트를 생성하는 클라이언트 컨트롤을 나타내는 고유 ID입니다.</param>
        <param name="argument">클라이언트 이벤트를 통해 전달되는 이벤트 인수입니다.</param>
        <summary><see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" /> 메서드를 사용하여 이벤트 유효성 검사에 대해 등록된 클라이언트 이벤트의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제는 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> 메서드 및 <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> 유효성 검사에 대 한 콜백을 등록 하 고 유효성을 검사할 콜백 페이지에서 발생 하는 메서드. 을 개선 하기 위해 여기에 표시 된 유효성 검사에서 유효성 검사를 수정할 수 있습니다 `argument` id 또는 역할과 같은 사용자 관련 정보를 포함 하도록 매개 변수  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="uniqueId" />이 <see langword="null" /> 또는 빈 문자열("")인 경우</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>