<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="69bb07b955e5ece89fcbab3701d6d05a40c3f5d8" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59349900" /></Metadata><TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IParserAccessor&#xA;    interface IUrlResolutionService&#xA;    interface IDataBindingsAccessor&#xA;    interface IControlBuilderAccessor&#xA;    interface IControlDesignerAccessor&#xA;    interface IExpressionsAccessor" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VSDesigner.WebForms.ControlCodeDomSerializer, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>모든 ASP.NET 서버 컨트롤이 공유하는 속성, 메서드 및 이벤트를 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 ASP.NET 서버 컨트롤을 개발할 때에서 파생 되는 기본 클래스입니다. <xref:System.Web.UI.Control> 모든 사용자 인터페이스 (UI) 특정 기능 수 없습니다. 파생 하는 UI가 없는 또는 고유한 UI를 렌더링 하는 다른 컨트롤을 결합 하는 컨트롤을 작성 하는 경우 <xref:System.Web.UI.Control>합니다. UI가 있는 컨트롤을 작성 하는 경우 파생 <xref:System.Web.UI.WebControls.WebControl> 또는에서 제어를 <xref:System.Web.UI.WebControls> 알맞은 시작 하는 네임 스페이스 사용자 지정 컨트롤에 대 한 지점입니다.  
  
 <xref:System.Web.UI.Control> 클래스는 사용자 지정 컨트롤, 사용자 정의 컨트롤을 페이지 등의 모든 ASP.NET 서버 컨트롤에 대 한 기본 클래스입니다. ASP.NET 페이지의 인스턴스는 합니다 <xref:System.Web.UI.Page> 클래스에서 상속 하는 <xref:System.Web.UI.Control> 클래스 및는.aspx 확장명을 가진 파일에 대 한 요청을 처리 합니다.  
  
 <xref:System.Web.UI.Control> 클래스 직접 또는 간접적으로 사용할 수는 사용자 인터페이스의 일부로 웹 응용 프로그램을 마우스와 이러한 보안 코드를 작성 하 고 응용 프로그램 보안을 위한 최선의 구현 되도록 방법이 필요에 대 한 합니다.  
  
 이러한 항목에 대 한 일반적인 내용은 참조 하세요. [개요의 웹 응용 프로그램 보안 위협을](https://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: 보안 정책에 대 한 모범 사례](https://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), 및 [주요 보안 개념](~/docs/standard/security/key-security-concepts.md)합니다. 자세한 내용은 참조 하세요. [표준 컨트롤 보호](https://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [방법: 안전 하 게 오류 메시지를 표시](https://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [방법: HTML 인코딩 문자열로 적용 하 여 웹 응용 프로그램에서 스크립트 악용 으로부터 보호할](https://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), 및 [유효성 검사 컨트롤 소개](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.0/2e4hd649(v=vs.85))합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 서버 컨트롤에서 파생 되는 <xref:System.Web.UI.Control> 클래스입니다. 합니다 `InnerContent` 재정의 클래스를 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 메서드를 확인 하는 경우 클래스에 자식 컨트롤이 페이지의 첫 번째 자식 컨트롤의 리터럴 컨트롤 인지 여부를 확인 합니다. 이러한 조건을 모두 만족 하는 경우 재정의 된 메서드 HTML 문자열을 씁니다 \<H2 > Your 메시지:를 닫는 리터럴 컨트롤의 내용과 \</H2 > Web Forms 페이지에는 태그입니다.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
    <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">사용자 지정 ASP.NET 서버 컨트롤 개발</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.Control" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Adapter : System.Web.UI.Adapters.ControlAdapter" Usage="System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 대한 브라우저별 어댑터를 가져옵니다.</summary>
        <value>이 컨트롤의 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />입니다. 대상 브라우저에 어댑터가 필요 없으면 <see langword="null" />을 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 웹 페이지 광범위 한 장치 및 웹에서 정보를 요청할 수 있는 브라우저에서 사용할 수 있습니다. <xref:System.Web.UI.Control.Adapter%2A> 속성에서 반환 된 <xref:System.Web.UI.Adapters.ControlAdapter> 요청 하는 장치 또는 브라우저의 화면에 컨트롤을 렌더링 하는 개체입니다.  
  
 어댑터에 대 한 자세한 내용은 참조 하세요. [아키텍처 개요의 적응형 컨트롤 동작](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">적응형 컨트롤 동작의 아키텍처 개요</related>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberSignature Language="F#" Value="abstract member AddedControl : System.Web.UI.Control * int -&gt; unit&#xA;override this.AddedControl : System.Web.UI.Control * int -&gt; unit" Usage="control.AddedControl (control, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">추가된 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <param name="index"><see cref="P:System.Web.UI.Control.Controls" /> 컬렉션의 컨트롤 인덱스입니다.</param>
        <summary>자식 컨트롤이 <see cref="T:System.Web.UI.Control" /> 개체의 <see cref="P:System.Web.UI.Control.Controls" /> 컬렉션에 추가된 후 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.AddedControl%2A> 에 컨트롤을 추가한 후에 즉시 메서드는 <xref:System.Web.UI.Control.Controls%2A> 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" />이 <see cref="T:System.Web.UI.WebControls.Substitution" /> 컨트롤입니다.</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member AddParsedSubObject : obj -&gt; unit&#xA;override this.AddParsedSubObject : obj -&gt; unit" Usage="control.AddParsedSubObject obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">구문 분석한 요소를 나타내는 <see cref="T:System.Object" />입니다.</param>
        <summary>XML 또는 HTML 요소가 구문 분석되었음을 서버 컨트롤에 알리고 서버 컨트롤의 <see cref="T:System.Web.UI.ControlCollection" /> 개체에 요소를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 자동으로 추가 재정의 하지 않으면 <xref:System.Web.UI.LiteralControl> 개체를 서버 컨트롤의 <xref:System.Web.UI.ControlCollection> 개체입니다. 이 컬렉션은 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 예제는 사용 하는 사용자 지정 서버 컨트롤의 <xref:System.Web.UI.Control.AddParsedSubObject%2A> 요소와이 컨트롤의 닫는 태그 사이 선언 하는 경우를 결정 하는 메서드는 <xref:System.Web.UI.WebControls.TextBox> 웹 서버 컨트롤입니다. 경우에 추가 됩니다는 <xref:System.Collections.ArrayList> 개체를 `items`입니다. 때 재정의 된 <xref:System.Web.UI.Control.CreateChildControls%2A> 메서드가 호출 되 고 반복 합니다 <xref:System.Collections.ArrayList> 각 개체를 추가 하 고는 <xref:System.Web.UI.ControlCollection> 사용자 지정 서버 컨트롤의.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="abstract member ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit&#xA;override this.ApplyStyleSheetSkin : System.Web.UI.Page -&gt; unit" Usage="control.ApplyStyleSheetSkin page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="page">컨트롤을 포함하는 <see cref="T:System.Web.UI.Page" />입니다.</param>
        <summary>페이지 스타일시트에 정의된 스타일 속성을 컨트롤에 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> 메서드 테마 디렉터리에 정의 된 스킨 속성을 기반으로 컨트롤에 스타일 속성을 설정 합니다. 적용 되는 스킨을 컨트롤에 대 한 기본 스킨 또는 스킨에 지정 된 된 <xref:System.Web.UI.Control.SkinID%2A> 속성입니다. <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> ASP.NET 페이지에 배치 하는 선언적 컨트롤에 대 한 메서드를 호출 합니다. 호출 해야 합니다는 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> 에 프로그래밍 방식으로 만든 모든 컨트롤에는 메서드 실행 시간 스타일에 대 한 컨트롤에 적용할 스킨 시트입니다. 테마 스킨은 자동으로 적용 됩니다. 테마 및 스타일 시트의 차이에 대 한 자세한 내용은 참조 하세요. [ASP.NET 테마 및 스킨](https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">스타일시트가 이미 적용된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeTemplateSourceDirectory : string with get, set" Usage="System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤이 포함된 <see cref="T:System.Web.UI.Page" /> 또는 <see cref="T:System.Web.UI.UserControl" /> 개체의 응용 프로그램 상대 가상 디렉터리를 가져오거나 설정합니다.</summary>
        <value>이 컨트롤이 포함된 페이지 또는 사용자 정의 컨트롤의 응용 프로그램 상대 가상 디렉터리입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> 현재 컨트롤이 포함 된 페이지 또는 사용자 정의 컨트롤에 응용 프로그램에 상대적인 경로 포함 하는 속성입니다. 예를 들어, 웹 페이지에 있는 경우 http://www.contoso.com/application/subdirectory, <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> 속성 반환 "~ / 하위 디렉터리"입니다.  
  
 가상 경로 ("application/하위")를 반환 하려면 사용 된 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.BeginRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.BeginRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">추적 데이터를 기록하는 개체입니다.</param>
        <param name="traceObject">추적 개체입니다.</param>
        <summary>렌더링 데이터의 디자인 타임 추적을 시작합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤의 데이터 바인딩이 포함된 컨트롤을 가져옵니다.</summary>
        <value>이 컨트롤의 데이터 바인딩이 포함된 <see cref="T:System.Web.UI.Control" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.BindingContainer%2A> 속성에 대 한 참조를 포함 합니다 <xref:System.Web.UI.Control> 현재 컨트롤에 대 한 데이터 바인딩 정보를 포함 하는 개체입니다.  
  
 <xref:System.Web.UI.Control.BindingContainer%2A> 속성은 동일 합니다 <xref:System.Web.UI.Control.NamingContainer%2A> 컨트롤 템플릿의 일부인 경우 제외 하 고 속성입니다. 이런 경우는 <xref:System.Web.UI.Control.BindingContainer%2A> 속성을 <xref:System.Web.UI.Control> 템플릿을 정의 하는 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberSignature Language="F#" Value="member this.BuildProfileTree : string * bool -&gt; unit" Usage="control.BuildProfileTree (parentId, calcViewState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">컨트롤 부모의 ID입니다.</param>
        <param name="calcViewState">뷰 상태 크기를 계산할지 여부를 나타내는 부울입니다.</param>
        <summary>서버 컨트롤에 대한 정보를 수집하고, 페이지에 대해 추적이 활성화된 경우 표시할 <see cref="P:System.Web.UI.Page.Trace" /> 속성에 이 정보를 전달합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 페이지의 UI 계층 구조에 대 한 필요한 정보를 수집 하 고 페이지에 전달 [ &lt;추적&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md) 속성입니다. 페이지 또는 응용 프로그램에 대 한 추적을 활성화 하면이 정보에 표시 됩니다는 `Control Tree` 추적 출력의 섹션입니다. 추적 출력을 페이지에 대 한 페이지의 끝에 추가 하지만 응용 프로그램의 루트 디렉터리에 저장 된 추적 뷰어 (trace.axd 파일)에서 응용 프로그램에 대 한 추적 출력을 볼 수 있습니다. 추적에 대 한 자세한 내용은 참조 하세요. [ASP.NET 추적 개요](https://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChildControlsCreated : bool with get, set" Usage="System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤의 자식 컨트롤이 만들어졌는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>자식 컨트롤이 만들어졌으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.OnDataBinding%2A> 사용자 지정 메서드의 <xref:System.Web.UI.WebControls.Repeater> 컨트롤입니다. 데이터 바인딩을 다시 발생할 때 자식 컨트롤을 만들 수 있는지 확인 합니다 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 속성이 `true` 후를 <xref:System.Web.UI.WebControls.RepeaterItem> 개체를 만들어 컨트롤을 추가할 <xref:System.Web.UI.ControlCollection> 개체.  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 다음 예제에서는 웹 페이지에서 사용자 지정 반복기 컨트롤을 사용 하는 방법에 설명 합니다.  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberSignature Language="F#" Value="member this.ClearCachedClientID : unit -&gt; unit" Usage="control.ClearCachedClientID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>캐시된 <see cref="P:System.Web.UI.Control.ClientID" /> 값을 <see langword="null" />로 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildControlState : unit -&gt; unit" Usage="control.ClearChildControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤의 자식 컨트롤에 대한 컨트롤 상태 정보를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildControlState%2A> 템플릿 기반 데이터 바인딩된 서버 컨트롤에서 데이터 바인딩된 자식 제어 하는 경우와 같은 새로운 자식 컨트롤이 생성 될 때 부모 컨트롤의 컨트롤 상태에 기록 된 자식 컨트롤 상태 정보를 재정의할 때 메서드를 사용 합니다. 호출을 <xref:System.Web.UI.Control.ClearChildControlState%2A> 메서드를 호출 하기 전에 빈 자식 컨트롤을 <xref:System.Web.UI.Control.SaveControlState%2A> 메서드 저장 하거나 전송 해야 하는 컨트롤 상태 정보의 크기를 줄입니다.  
  
 자식 컨트롤을 다시 만들 때를 <xref:System.Web.UI.Control> 개체는 <xref:System.Web.UI.Control.ClearChildControlState%2A> 새 컨트롤을 실수로 적용 되지 않습니다 있도록 자식 컨트롤 상태를 삭제 하는 방법입니다.  
  
 둘 다의 선택을 취소 하려면 자식 컨트롤 상태와 뷰 상태를 사용 합니다 <xref:System.Web.UI.Control.ClearChildState%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildState : unit -&gt; unit" Usage="control.ClearChildState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤의 모든 자식 컨트롤에 대한 뷰 상태 정보와 컨트롤 상태 정보를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildState%2A> 메서드는 자식 컨트롤의 뷰 상태 및 컨트롤 상태 정보를 모두 지웁니다. 둘 다 호출 하는 것과 동일 합니다 <xref:System.Web.UI.Control.ClearChildViewState%2A> 메서드 및 <xref:System.Web.UI.Control.ClearChildControlState%2A> 메서드.  
  
 자식 컨트롤을 다시 만들 때를 <xref:System.Web.UI.Control> 개체는 <xref:System.Web.UI.Control.ClearChildState%2A> 새 컨트롤을 실수로 적용 되지 않습니다 있도록 자식 상태를 삭제 하는 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 하는 방법에 설명 합니다 <xref:System.Web.UI.Control.OnDataBinding%2A> 템플릿 기반 데이터 바인딩된 컨트롤에 대 한 메서드. 컨트롤에 바인딩되는 데이터 원본 채워지면 컨트롤의 <xref:System.Web.UI.ControlCollection> 를 사용 하 여 컬렉션을 비우고 합니다 <xref:System.Web.UI.ControlCollection.Clear%2A> 메서드를 및 <xref:System.Web.UI.Control.ClearChildState%2A> 메서드는 자식 컨트롤에 대 한 저장 된 상태 정보를 제거 하는 데 사용 됩니다.  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberSignature Language="F#" Value="member this.ClearChildViewState : unit -&gt; unit" Usage="control.ClearChildViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤의 모든 자식 컨트롤에 대한 뷰 상태 정보를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 재정의 하는 경우에 일반적으로이 메서드는는 <xref:System.Web.UI.Control.DataBind%2A> 템플릿 기반 데이터 바인딩된 서버 컨트롤을 개발할 때 메서드. 이 메서드를 호출 하면 부모 서버 컨트롤에 데이터 바인딩될 때 재정의할 수에 자식 컨트롤의 뷰 상태 정보를 작성할 수 있습니다.  
  
 자식 컨트롤을 다시 만들 때를 <xref:System.Web.UI.Control>를 사용 하 여는 <xref:System.Web.UI.Control.ClearChildViewState%2A> 새 컨트롤을 실수로 적용 되지 않습니다 있도록 자식 뷰 상태를 삭제 하는 방법입니다.  
  
 이 메서드를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 템플릿 기반 ASP.NET 사용자 컨트롤을 만들](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <related type="Article" href="https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2">방법: 템플릿 기반 사용자 정의 컨트롤 만들기</related>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberSignature Language="F#" Value="member this.ClearEffectiveClientIDMode : unit -&gt; unit" Usage="control.ClearEffectiveClientIDMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 컨트롤 인스턴스 및 자식 컨트롤의 <see cref="P:System.Web.UI.Control.ClientIDMode" /> 속성을 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />로 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientID : string" Usage="System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET에서 생성하는 HTML 태그의 컨트롤 ID를 가져옵니다.</summary>
        <value>ASP.NET에서 생성하는 HTML 태그의 컨트롤 ID입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 서버 컨트롤은 HTML 요소로 렌더링 될 때 합니다 `id` HTML 요소의 특성의 값으로 설정 되는 <xref:System.Web.UI.Control.ClientID%2A> 속성입니다. 합니다 <xref:System.Web.UI.Control.ClientID%2A> 값은 사용 하 여 클라이언트 스크립트에서 HTML 요소에 액세스 하는 데 자주 사용 된 `document.getElementById` 메서드. ID 요소 스타일 지정을 CSS 규칙에도 자주 사용 됩니다. 예를 들어 다음과 같은 CSS 스타일 규칙이 선택 모든 `span` 요소를 `id` 특성 값 `ProductIDLabel` 설정 하 고 해당 `background-color` 특성을 `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET은 생성 하는 방법에 대 한 여러 알고리즘을 제공 합니다 <xref:System.Web.UI.Control.ClientID%2A> 속성 값입니다. 컨트롤에 대해 설정 하 여 사용할 알고리즘을 선택 하면 해당 <xref:System.Web.UI.Control.ClientIDMode%2A> 속성입니다. 알고리즘으로 식별 되는 <xref:System.Web.UI.ClientIDMode> 다음 표에 나열 된 열거형 값입니다.  
  
|값|설명|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|컨트롤의 <xref:System.Web.UI.Control.ClientID%2A> 값과 각 부모 명명 컨테이너의 <xref:System.Web.UI.Control.ID%2A> 값을 연결하여 <xref:System.Web.UI.Control.ID%2A> 값이 생성됩니다. 컨트롤의 여러 인스턴스가 렌더링되는 데이터 바인딩 시나리오에서는 컨트롤의 <xref:System.Web.UI.Control.ID%2A> 값 앞에 증분 값이 삽입됩니다. 각 세그먼트는 밑줄 문자(_)로 구분됩니다. 이 알고리즘은 ASP.NET 4 이전 버전의 ASP.NET에서 사용 되었습니다.|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 값은 <xref:System.Web.UI.Control.ID%2A> 속성의 값으로 설정되어 있습니다. 명명 컨테이너인 컨트롤은 해당 컨트롤에 포함된 모든 컨트롤에 대한 명명 컨테이너 계층의 최상위 컨테이너로 사용됩니다.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|이 알고리즘은 데이터 바인딩된 컨트롤에 있는 컨트롤에 사용됩니다. 컨트롤의 <xref:System.Web.UI.Control.ClientID%2A> 값과 부모 명명 컨테이너의 <xref:System.Web.UI.Control.ClientID%2A> 값을 연결하여 <xref:System.Web.UI.Control.ID%2A> 값이 생성됩니다. 컨트롤이 여러 행을 생성하는 데이터 바인딩된 컨트롤일 경우 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 속성에 지정된 데이터 필드의 값이 끝에 추가됩니다. <xref:System.Web.UI.WebControls.GridView> 컨트롤의 경우 여러 데이터 필드가 지정될 수 있습니다. 경우는 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 속성을 비워 두면, 일련 번호를 데이터 필드 값 대신 끝에 추가 됩니다. 각 세그먼트는 밑줄 문자(_)로 구분됩니다.|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|컨트롤은 해당 <xref:System.Web.UI.ClientIDMode> 컨트롤의 <xref:System.Web.UI.Control.NamingContainer%2A> 설정을 상속합니다.|  
  
 기본값인 <xref:System.Web.UI.Control.ClientIDMode%2A> 페이지에 대 한 <xref:System.Web.UI.ClientIDMode.Predictable>합니다. 기본값인 <xref:System.Web.UI.Control.ClientIDMode%2A> 컨트롤에 대 한 <xref:System.Web.UI.ClientIDMode.Inherit>합니다. 컨트롤에 대 한 기본값 이므로 <xref:System.Web.UI.ClientIDMode.Inherit>이므로 모드는 기본 생성 <xref:System.Web.UI.ClientIDMode.Predictable>합니다. 그러나 (이전 버전에서 ASP.NET 4 웹 프로젝트를 변환 하려면 Visual Studio를 사용 하는 경우 Visual Studio 자동으로 사이트 기본 설정 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config 파일에 있습니다.)  
  
 자세한 내용은 [ASP.NET 웹 서버 컨트롤 식별](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)을 참조하세요.  
  
   
  
## Examples  
 다음 예에서는 마스터 페이지에 대 한 콘텐츠 페이지 내에 있는 웹 사용자 컨트롤을 보여 줍니다. 사용자 정의 컨트롤을 포함 한 <xref:System.Web.UI.WebControls.DropDownList> 컨트롤 및 <xref:System.Web.UI.WebControls.Label> 컨트롤. 에 표시 되는 텍스트를 <xref:System.Web.UI.WebControls.Label> 컨트롤에서 사용자가 선택한 값에 의해 결정 되는 <xref:System.Web.UI.WebControls.DropDownList> 제어 합니다. 웹 페이지는이 값을 설정 하기 위해 서버에 다시 게시 하지 않아도 되도록 텍스트 값을 클라이언트 스크립트를 통해 설정 됩니다. 에 대해 렌더링 되는 HTML 요소에 대 한 참조를 가져오려고 합니다 <xref:System.Web.UI.WebControls.Label> 컨트롤 클라이언트 스크립트에서 컨트롤의 값을 알고 있어야 <xref:System.Web.UI.Control.ClientID%2A> 속성. 그러나 웹 페이지에서 아무 곳 이나 사용자 정의 컨트롤을 배치할 수 있습니다, 되므로 어떤 명명 컨테이너 컨트롤을 포함할지 미리 알 수 없습니다. 있는지를 <xref:System.Web.UI.Control.ClientID%2A> 값은 동일를 <xref:System.Web.UI.Control.ID%2A> 값을 설정 합니다 <xref:System.Web.UI.Control.ClientIDMode%2A> 값을 <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>.  
  
 다음 예제에서는 사용자 정의 컨트롤을 보여 줍니다.  
  
  
  
 다음 예제에서는 사용자 정의 컨트롤을 포함 하는 콘텐츠 페이지를 보여 줍니다.  
  
  
  
 다음 예제에서는 콘텐츠 페이지를 포함 하는 마스터 페이지를 보여 줍니다.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 컨트롤 식별</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">방법: ID 별로 JavaScript에서 액세스 제어</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">연습: 쉽게 데이터 바인딩된 컨트롤에 액세스 하려면 JavaScript에서</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">연습: JavaScript에서 액세스를 쉽게 웹 사용자 컨트롤에 있는 컨트롤 만들기</related>
        <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">ASP.NET 웹 페이지에서 클라이언트 스크립트</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDMode : System.Web.UI.ClientIDMode with get, set" Usage="System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.UI.Control.ClientID" /> 속성의 값을 생성하는 데 사용되는 알고리즘을 가져오거나 설정합니다.</summary>
        <value><see cref="P:System.Web.UI.Control.ClientID" /> 속성의 생성 방법을 나타내는 값입니다. 기본값은 <see cref="F:System.Web.UI.ClientIDMode.Inherit" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET은 생성 하는 방법에 대 한 여러 알고리즘을 제공 합니다 <xref:System.Web.UI.Control.ClientID%2A> 속성 값입니다. 컨트롤에 대해 설정 하 여 사용할 알고리즘을 선택 하면 해당 <xref:System.Web.UI.Control.ClientIDMode%2A> 속성입니다. 알고리즘으로 식별 되는 <xref:System.Web.UI.ClientIDMode> 다음 표에 나열 된 열거형 값입니다.  
  
|값|설명|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|컨트롤의 <xref:System.Web.UI.Control.ClientID%2A> 값과 각 부모 명명 컨테이너의 <xref:System.Web.UI.Control.ID%2A> 값을 연결하여 <xref:System.Web.UI.Control.ID%2A> 값이 생성됩니다. 컨트롤의 여러 인스턴스가 렌더링되는 데이터 바인딩 시나리오에서는 컨트롤의 <xref:System.Web.UI.Control.ID%2A> 값 앞에 증분 값이 삽입됩니다. 각 세그먼트는 밑줄 문자(_)로 구분됩니다. 이 알고리즘은 ASP.NET 4 이전 버전의 ASP.NET에서 사용 되었습니다.|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 값은 <xref:System.Web.UI.Control.ID%2A> 속성의 값으로 설정되어 있습니다. 명명 컨테이너인 컨트롤은 해당 컨트롤에 포함된 모든 컨트롤에 대한 명명 컨테이너 계층의 최상위 컨테이너로 사용됩니다.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|이 알고리즘은 데이터 바인딩된 컨트롤에 있는 컨트롤에 사용됩니다. 컨트롤의 <xref:System.Web.UI.Control.ClientID%2A> 값과 부모 명명 컨테이너의 <xref:System.Web.UI.Control.ClientID%2A> 값을 연결하여 <xref:System.Web.UI.Control.ID%2A> 값이 생성됩니다. 컨트롤이 여러 행을 생성하는 데이터 바인딩된 컨트롤일 경우 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 속성에 지정된 데이터 필드의 값이 끝에 추가됩니다. <xref:System.Web.UI.WebControls.GridView> 컨트롤의 경우 여러 데이터 필드가 지정될 수 있습니다. 경우는 <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> 속성을 비워 두면, 일련 번호를 데이터 필드 값 대신 끝에 추가 됩니다. 이 숫자 0부터 시작 하 고 각 행에 대해 1 씩 증가 됩니다. 각 세그먼트는 밑줄 문자(_)로 구분됩니다.|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|컨트롤은 해당 <xref:System.Web.UI.ClientIDMode> 컨트롤의 <xref:System.Web.UI.Control.NamingContainer%2A> 설정을 상속합니다.|  
  
 기본값인 <xref:System.Web.UI.Control.ClientIDMode%2A> 페이지에 대 한 <xref:System.Web.UI.ClientIDMode.Predictable>합니다. 기본값인 <xref:System.Web.UI.Control.ClientIDMode%2A> 컨트롤에 대 한 <xref:System.Web.UI.ClientIDMode.Inherit>합니다. 컨트롤에 대 한 기본값 이므로 <xref:System.Web.UI.ClientIDMode.Inherit>이므로 모드는 기본 생성 <xref:System.Web.UI.ClientIDMode.Predictable>합니다. 그러나 (이전 버전에서 ASP.NET 4 웹 프로젝트를 변환 하려면 Visual Studio를 사용 하는 경우 Visual Studio 자동으로 사이트 기본 설정 <xref:System.Web.UI.ClientIDMode.AutoID> Web.config 파일에 있습니다.)  
  
 자세한 내용은 [ASP.NET 웹 서버 컨트롤 식별](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)을 참조하세요.  
  
   
  
## Examples  
 다음 예와 <xref:System.Web.UI.WebControls.Label> 에 포함 된 컨트롤을 <xref:System.Web.UI.WebControls.ListView> 제어 합니다. 에 <xref:System.Web.UI.WebControls.ListView> 컨트롤을 <xref:System.Web.UI.Control.ClientIDMode%2A> 속성이로 설정 되어 <xref:System.Web.UI.ClientIDMode.Predictable> 및 <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> 속성 `ProductID`. 렌더링된 된 HTML에서 이렇게 세 `span` 3에 해당 하는 요소 `ProductIDLabel` 컨트롤입니다. 페이지를 실행 하는 경우, `id` 특성을 `span` 요소는 다음 값으로 설정 됩니다.  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7">ASP.NET 컨트롤 식별</related>
        <related type="Article" href="https://msdn.microsoft.com/library/fb58ed73-d8f7-401c-9560-d99dd9ca7db8">방법: ID 별로 JavaScript에서 액세스 제어</related>
        <related type="Article" href="https://msdn.microsoft.com/library/776f3747-7fa7-4851-ae27-f728ede1a564">연습: 쉽게 데이터 바인딩된 컨트롤에 액세스 하려면 JavaScript에서</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f0eaf202-61b6-4cd8-9604-6b7638fdf0ae">연습: JavaScript에서 액세스를 쉽게 웹 사용자 컨트롤에 있는 컨트롤 만들기</related>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientIDSeparator : char" Usage="System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.UI.Control.ClientID" /> 속성에 사용된 구분 문자를 나타내는 문자 값을 가져옵니다.</summary>
        <value>항상 밑줄 문자(_)를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.ClientID%2A> 값을 연결 하 여 생성 됩니다 합니다 <xref:System.Web.UI.Control.ID%2A> 컨트롤의 값 및 <xref:System.Web.UI.Control.UniqueID%2A> 부모 컨트롤의 값입니다. 생성 된 각 부품 <xref:System.Web.UI.Control.ID%2A> 속성은 구분 하 여는 <xref:System.Web.UI.Control.ClientIDSeparator%2A> 속성 값입니다. 값은 항상 밑줄 (_)을 반환합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 웹 요청에 대한 서버 컨트롤과 관련된 <see cref="T:System.Web.HttpContext" /> 개체를 가져옵니다.</summary>
        <value>현재 요청과 관련하여 지정된 <see cref="T:System.Web.HttpContext" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 액세스할 수는 <xref:System.Web.HttpContext> 현재 웹 요청에 대 한 개체입니다. 개체에 액세스 하는 속성을 제공 합니다 <xref:System.Web.HttpContext.Application%2A>, <xref:System.Web.HttpContext.Session%2A>를 <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A> 및 현재 HTTP 요청에 대 한 정보를 포함 하는 다른 개체입니다. 또한 구성 정보 및 집합 또는 요청에 대 한 일반 오류를 가져올 수 있도록 하는 메서드를 제공 합니다.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UI 계층 구조에서 지정된 서버 컨트롤의 자식 컨트롤을 나타내는 <see cref="T:System.Web.UI.ControlCollection" /> 개체를 가져옵니다.</summary>
        <value>지정된 서버 컨트롤에 대한 자식 컨트롤의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 페이지에 컨트롤을 열고 서버 컨트롤의 닫는 태그 사이의 선언적으로 추가 되 면 ASP.NET에 자동으로 추가 컨트롤 포함 된 서버 컨트롤의 <xref:System.Web.UI.ControlCollection>합니다. HTML 태그 또는 서버에서 처리 되지 않는 텍스트 문자열 취급 <xref:System.Web.UI.LiteralControl> 개체입니다. 다른 서버 컨트롤과 마찬가지로 컬렉션에 추가 합니다.  
  
 합니다 <xref:System.Web.UI.Control.Controls%2A> 속성의 인스턴스를 프로그래밍 방식으로 액세스할 수 있습니다.는 <xref:System.Web.UI.ControlCollection> 서버 컨트롤에 대 한 클래스입니다. 컬렉션에 컨트롤을 추가 하, 컬렉션에서 컨트롤을 제거 하거나 컬렉션에 있는 서버 컨트롤을 반복할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 서버 컨트롤의 자식 컨트롤을 추가 하는 방법을 보여 줍니다 <xref:System.Web.UI.ControlCollection> 개체를 통해 해당 <xref:System.Web.UI.Control.Controls%2A> 속성입니다.  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우는 <see cref="P:System.Web.UI.Control.Controls" /> 속성을 호출 하는 <see cref="M:System.Web.UI.Control.EnsureChildControls" /> 메서드. 또한 controls 컬렉션에 컨트롤을 프로그래밍 방식으로 추가할 계획인 경우이 권한을 추가할 컨트롤에서 재정의 된 <see cref="M:System.Web.UI.Control.CreateChildControls" /> 메서드.</para></block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="control.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>다시 게시 또는 렌더링하기 위한 준비 작업으로, 포함된 자식 컨트롤을 만들도록 컴퍼지션 기반 구현을 사용하는 서버 컨트롤에 알리기 위해 ASP.NET 페이지 프레임워크에 의해 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복합 또는 템플릿 기반 서버 컨트롤을 개발할 때이 메서드를 재정의 해야 합니다. 해당 재정의 제어 합니다 <xref:System.Web.UI.Control.CreateChildControls%2A> 메서드를 구현 해야 합니다 <xref:System.Web.UI.INamingContainer> 이름 충돌을 방지 하는 인터페이스입니다.  
  
 자세한 내용은 [웹 서버 컨트롤 템플릿](https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae) 하 고 [사용자 지정 ASP.NET 서버 컨트롤 개발](https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef)합니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 된 버전을 <xref:System.Web.UI.Control.CreateChildControls%2A> 메서드. 이 구현에서 복합 컨트롤 표시를 <xref:System.Web.UI.WebControls.TextBox> HTML을 렌더링 하는 두 개의 리터럴 컨트롤에 포함 하는 컨트롤입니다.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">사용자 지정 ASP.NET 서버 컨트롤 개발</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae">ASP.NET 웹 서버 컨트롤 템플릿</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection&#xA;override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="control.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤의 자식 컨트롤(리터럴 및 서버)을 보유할 새 <see cref="T:System.Web.UI.ControlCollection" /> 개체를 만듭니다.</summary>
        <returns>현재 서버 컨트롤의 자식 서버 컨트롤을 보유할 <see cref="T:System.Web.UI.ControlCollection" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 되는 컬렉션 개체를 만든 경우 사용자 지정 서버 컨트롤에서이 메서드를 재정의 합니다 <xref:System.Web.UI.ControlCollection> 클래스입니다. 그런 다음이 메서드의 재정의에서 해당 컬렉션 클래스를 인스턴스화할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Web.UI.Control.CreateControlCollection%2A> 의 인스턴스를 만드는 메서드를 `CustomControlCollection` 클래스에서 상속 하는 <xref:System.Web.UI.ControlCollection> 클래스입니다.  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 다음 코드 예제에서는 합니다 <xref:System.Web.UI.Control.CreateControlCollection%2A> 사용자 지정 서버 컨트롤의 메서드 재정의 <xref:System.Web.UI.Control.CreateChildControls%2A> 메서드. 새 컬렉션 작성 되어 다음 두 개의 자식 컨트롤을 채워집니다 `firstControl` 고 `secondControl`입니다.  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>호출된 서버 컨트롤과 그 자식 컨트롤 모두에 데이터 소스를 바인딩합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberSignature Language="F#" Value="abstract member DataBind : unit -&gt; unit&#xA;override this.DataBind : unit -&gt; unit" Usage="control.DataBind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>호출된 서버 컨트롤과 그 자식 컨트롤 모두에 데이터 소스를 바인딩합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤에 데이터 소스에서 바인딩할이 메서드를 사용 합니다. 이 메서드는 데이터베이스 쿼리를 통해 데이터 세트를 검색한 후 일반적으로 사용됩니다. 대부분의 컨트롤에는 일반적으로 수행 하지 할 경우이 메서드를 명시적으로 호출을 의미 하는 데이터 바인딩을 자동으로 수행 합니다.  
  
 이 메서드는 사용자 지정 템플릿 데이터 바인딩된 컨트롤을 만들 때 일반적으로 재정의 됩니다. 자세한 내용은 [방법: 템플릿 기반 ASP.NET 사용자 컨트롤을 만들](https://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) 하 고 [사용자 지정 데이터 바인딩 웹 서버 컨트롤 개발](https://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1)합니다. 서버 컨트롤에서 호출 되 면이 메서드는 모든 데이터 바인딩 식을 서버 컨트롤 및 해당 자식 컨트롤 중 하나를 확인 합니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.DataBind%2A> 사용자 지정 ASP.NET 서버 컨트롤의 메서드. 기본을 호출 하 여 시작 <xref:System.Web.UI.Control.OnDataBinding%2A> 메서드를 사용 합니다 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> 모든 자식 컨트롤을 삭제 하는 방법 및 <xref:System.Web.UI.Control.ClearChildViewState%2A> 메서드를 삭제 하는 모든 해당 자식 컨트롤의 뷰 상태 설정을 저장 합니다. 마지막으로, 합니다 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 속성이 `true` 컨트롤을 사용 하 여 새로 만든된 컨트롤의 뷰 상태 변경 내용을 추적 하도록 지시 하 고는 <xref:System.Web.UI.Control.TrackViewState%2A> 메서드. 이전에 저장 된 데이터를 사용 하 여 새 데이터를 확인 하는 컨트롤에 데이터 바인딩 충돌 하지 않는 경우이 일반적인 기술 <xref:System.Web.UI.Control.DataBind%2A> 메서드를 호출 합니다.  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">사용자 지정 ASP.NET 서버 컨트롤 개발</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 개요</related>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberSignature Language="F#" Value="abstract member DataBind : bool -&gt; unit&#xA;override this.DataBind : bool -&gt; unit" Usage="control.DataBind raiseOnDataBinding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding"><see cref="E:System.Web.UI.Control.DataBinding" /> 이벤트가 발생하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.DataBinding" /> 이벤트를 발생시키는 옵션을 사용하여, 호출된 서버 컨트롤과 모든 자식 컨트롤에 데이터 소스를 바인딩합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 사용자 지정 컨트롤을 재정의 하는 경우 시나리오에서 메서드를 <xref:System.Web.UI.Control.DataBind%2A> 메서드를 구현 합니다 <xref:System.Web.UI.IDataItemContainer> 인터페이스입니다. 이 시나리오에서는 사용자 지정 컨트롤 호출을 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 메서드를 `raiseOnDataBinding` 로 설정 `false` 기본 클래스의 되도록 <xref:System.Web.UI.Control.DataBind%2A> 메서드 호출을 가져옵니다.  
  
 합니다 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> 메서드를 호출 하는 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 메서드 `raiseOnDataBinding` 로 `true`합니다.  
  
> [!NOTE]
>  호출 된 <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> 메서드를 `raiseOnDataBinding` 로 설정 `false` 하면 자식 컨트롤을 사용 하 여 바인딩된 데이터를 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 개요</related>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberSignature Language="F#" Value="abstract member DataBindChildren : unit -&gt; unit&#xA;override this.DataBindChildren : unit -&gt; unit" Usage="control.DataBindChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>데이터 소스를 서버 컨트롤의 자식 컨트롤에 바인딩합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.Control.DataBindChildren%2A> 서버 컨트롤의 자식 컨트롤에 데이터 소스를 바인딩하는 메서드.  
  
> [!NOTE]
>  이 메서드는 서버 컨트롤에서 호출 되 면 컨트롤에 데이터 바인딩하지 않습니다. 서버 컨트롤과 모든 자식 컨트롤을 바인딩하려면 호출을 <xref:System.Web.UI.Control.DataBind%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef">사용자 지정 ASP.NET 서버 컨트롤 개발</related>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberSignature Language="F#" Value="member this.DataBinding : EventHandler " Usage="member this.DataBinding : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤에서 데이터 소스에 바인딩할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트에 대 한 기록 된 데이터 바인딩 논리를 수행 하는 서버 컨트롤을 알립니다.  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataItemContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>명명 컨테이너가 <see cref="T:System.Web.UI.IDataItemContainer" />를 구현할 경우 명명 컨테이너에 대한 참조를 가져옵니다.</summary>
        <value>명명 컨테이너입니다. <see cref="T:System.Web.UI.IDataItemContainer" />를 구현하는 명명 컨테이너의 계층 구조에서는 이 속성이 계층 구조의 최상위에 있는 명명 컨테이너를 반환하거나, 현재 <see cref="T:System.Web.UI.Control" /> 개체가 <see cref="T:System.Web.UI.IDataItemContainer" />를 구현하는 명명 컨테이너에 있지 않은 경우에는 <see langword="null" />을 반환합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataKeysContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>명명 컨테이너가 <see cref="T:System.Web.UI.IDataKeysControl" />를 구현할 경우 명명 컨테이너에 대한 참조를 가져옵니다.</summary>
        <value>명명 컨테이너입니다. <see cref="T:System.Web.UI.IDataKeysControl" />을 구현하는 명명 컨테이너의 계층 구조에서는 이 속성이 계층 구조의 최상위에 있는 명명 컨테이너를 반환하거나, 현재 <see cref="T:System.Web.UI.Control" /> 개체가 <see cref="T:System.Web.UI.IDataKeysControl" />을 구현하는 명명 컨테이너에 있지 않은 경우에는 <see langword="null" />을 반환합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DesignMode : bool" Usage="System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디자인 화면에서 컨트롤이 사용 중인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>디자이너에서 컨트롤이 사용 중이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.DesignMode%2A> 속성이 반환 `true` 컨트롤 디자이너의 컨텍스트에서 사용 되는 함을 나타내려면 합니다. 사용자 지정 컨트롤 디자인 타임 동작 런타임 동작 보다 다양 한 경우이 속성을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/wxh45wzs(v=vs.100)">ASP.NET 컨트롤 디자이너 개요</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="control.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤이 메모리에서 해제되기 전에 해당 서버 컨트롤에서 최종 정리 작업을 수행하도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Dispose%2A> 사용을 마치면 <xref:System.Web.UI.Control>를 호출합니다. <xref:System.Web.UI.Control.Dispose%2A> 메서드를 사용하면 <xref:System.Web.UI.Control>를 사용할 수 없게 됩니다. 이 메서드를 호출한 후 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 컨트롤에 대 한 모든 참조를 해제 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Web.UI.Control.Dispose%2A> 닫는 메서드를를 <xref:System.Web.UI.HtmlTextWriter> 제어 및 호출을 사용 하 여 연결 된 개체를 <xref:System.Web.UI.Control.Dispose%2A> 메서드를 <xref:System.Web.UI.WebControls.Button> 라는 컨트롤 `myButton`. 경우는 <xref:System.Exception> 때 발생 하는이 버전의 합니다 <xref:System.Web.UI.Control.Dispose%2A> 메서드가 호출 되는 컨트롤에 메시지를 씁니다 현재 <xref:System.Web.HttpResponse> 개체입니다.  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IComponent.Disposed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 페이지가 요청될 때 서버 컨트롤 주기의 마지막 단계로 서버 컨트롤이 메모리에서 해제될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트를 사용 하 여 데이터베이스 연결과 같은 중요 한 프로세서 시간을 필요로 하는 리소스가 해제 되어야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤에 테마를 적용할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>테마를 사용하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnableTheming%2A> 속성을 지정 된 컨트롤에 대 한 테마를 사용할 수 있는지 여부를 나타냅니다. 경우는 <xref:System.Web.UI.Control.EnableTheming%2A> 속성은 `true`를 적용할 컨트롤 스킨에 대 한 애플리케이션의 테마 디렉터리를 검색 합니다. 테마 디렉터리에 특정 컨트롤 스킨이 스킨 적용 되지 않습니다.  
  
 경우는 <xref:System.Web.UI.Control.EnableTheming%2A> 속성은 `false`, 테마 디렉터리는 검색 되지 않습니다 및 내용의 <xref:System.Web.UI.Control.SkinID%2A> 속성이 사용 되지 않습니다.  
  
 페이지, 컨테이너 또는 컨트롤 수준에서 테마를 사용할 수 있습니다. 컨트롤을 재정의할 수는 <xref:System.Web.UI.Control.EnableTheming%2A> 포함 하는 페이지 또는 해당 부모 컨트롤에 의해 값이 설정 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see langword="Page_PreInit" /> 이벤트가 이미 발생한 경우  
  
또는 
컨트롤이 <see langword="Controls" /> 컬렉션에 이미 추가된 경우</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET 테마 개요</related>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤이 해당 뷰 상태와 포함하고 있는 모든 자식 컨트롤의 뷰 상태를, 요청하는 클라이언트까지 유지하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>서버 컨트롤이 해당 뷰 상태를 유지하는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 뷰 상태에는 HTTP 요청 간에 상태를 유지 하는 서버 컨트롤을 수 있습니다. 컨트롤의 뷰 상태는 다음 조건이 모두 충족 되는 경우에 사용 됩니다.  
  
-   합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 페이지에 대 한 속성이 `true`합니다.  
  
-   합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 컨트롤에 대 한 속성이 `true`합니다.  
  
-   합니다 <xref:System.Web.UI.Control.ViewStateMode%2A> 컨트롤에 대 한 속성이로 설정 되어 <xref:System.Web.UI.ViewStateMode.Enabled> 상속 또는 <xref:System.Web.UI.ViewStateMode.Enabled> 설정 합니다.  
  
 자세한 내용은 <xref:System.Web.UI.Control.ViewStateMode%2A> 속성을 참조하세요.  
  
 서버 컨트롤의 뷰 상태는 모든 속성 값의 누적 된 것입니다. HTTP 요청에서 이러한 값을 유지 하기 위해 ASP.NET의 인스턴스를 사용 하 여 <xref:System.Web.UI.StateBag> 속성 값을 저장 하는 클래스입니다. 그런 다음이 값은 후속 요청 처리 되는 경우 숨겨진된 필드에 변수로 전달 됩니다. 뷰 상태에 대 한 자세한 내용은 참조 하세요. [ASP.NET 뷰 상태 개요](https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818)합니다.  
  
 적절 한 응용 프로그램의 성능을 향상 하기 위해 뷰 상태를 사용 하지 않도록 설정 하는 경우가 있습니다. 예를 들어, 서버 컨트롤에 데이터베이스 요청을 로드 하는 경우이 속성을 설정 `false`합니다. 이렇게 하지 않으면 데이터베이스 쿼리에서 재정의할 수 있는 서버 컨트롤에 뷰 상태를 로드 프로세서 시간 낭비 됩니다. 경우 <xref:System.Web.UI.Control.EnableViewState%2A> 는 `false`, 제어 상태를 뷰 상태 속성 처럼 해제할 수 없습니다와 컨트롤에 관련 된 속성 정보를 유지 하는 데 사용할 수 있습니다. 컨트롤 상태와 뷰 상태 간의 차이점에 대 한 자세한 내용은 참조 하세요. [컨트롤 상태 vs. 뷰 상태 예제](https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681)합니다.  
  
 사용 하도록 설정 하거나 ASP.NET 페이지에 대해 선언적으로 보기 상태를 사용 하지 않도록 설정 하는 방법에 대 한 정보를 참조 하세요 [ \@ 페이지](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ydy4x04a(v=vs.100))합니다.
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 속성을 `false`입니다.  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 상태 관리 개요</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681">컨트롤 상태 vs입니다. 뷰 상태 예제</related>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberSignature Language="F#" Value="member this.EndRenderTracing : System.IO.TextWriter * obj -&gt; unit" Usage="control.EndRenderTracing (writer, traceObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceObject" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">추적 데이터를 기록하는 개체입니다.</param>
        <param name="traceObject">추적 개체입니다.</param>
        <summary>렌더링 데이터의 디자인 타임 추적을 종료합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberSignature Language="F#" Value="abstract member EnsureChildControls : unit -&gt; unit&#xA;override this.EnsureChildControls : unit -&gt; unit" Usage="control.EnsureChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤에 자식 컨트롤이 있는지 확인합니다. 서버 컨트롤에 자식 컨트롤이 없으면 자식 컨트롤을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 먼저 현재 값을 확인 합니다 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 속성입니다. 이 값이 `false`, <xref:System.Web.UI.Control.CreateChildControls%2A> 메서드가 호출 됩니다.  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A> 메서드는 일반적으로 복합 컨트롤을 일부에 대 한 자식 컨트롤을 사용 하는 컨트롤에서 사용 또는 전체 기능입니다. <xref:System.Web.UI.Control.EnsureChildControls%2A> 메서드는 자식 컨트롤을 만들고 데이터 바인딩을 수행 하거나 다른 작업을 수행 하는 입력을 처리할 준비가 되었는지 확인 하기 위해 호출 됩니다.  
  
 <xref:System.Web.UI.WebControls.GridView> 컨트롤은 복합 컨트롤의 예입니다. 자식 컨트롤을 만들어와 같은 <xref:System.Web.UI.WebControls.Table>, <xref:System.Web.UI.WebControls.TableRow>, <xref:System.Web.UI.WebControls.TableCell>, <xref:System.Web.UI.WebControls.Label>, 및 <xref:System.Web.UI.WebControls.TextBox> 컨트롤의 HTML을 렌더링 하는 데 사용 되는 테이블을 <xref:System.Web.UI.WebControls.GridView> 생성 합니다.  
  
 대부분의 경우에서 사용자 지정 서버 컨트롤 개발자가이 메서드를 재정의할 필요가 없습니다. 이 메서드를 재정의 하는 경우에 기본 동작에 비슷한 방식으로 사용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.UI.Control.EnsureChildControls%2A> 메서드를 현재 서버 컨트롤에 자식 컨트롤이 있는지 확인 합니다. 다음 가져오거나를 <xref:System.Web.UI.WebControls.TextBox.Text%2A> 자식 속성 <xref:System.Web.UI.WebControls.TextBox> 현재 서버 컨트롤의 컨트롤을 웹 <xref:System.Web.UI.ControlCollection> 개체입니다.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberSignature Language="F#" Value="member this.EnsureID : unit -&gt; unit" Usage="control.EnsureID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ID가 할당되지 않은 컨트롤의 ID를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnsureID%2A> 메서드는 다른 컨트롤에 포함 된 컨트롤에 대 한 식별자를 생성 합니다. 식별자 값이 할당 되지 않은 컨트롤에 대해서만 생성 되는 <xref:System.Web.UI.Control.ID%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Events : System.ComponentModel.EventHandlerList" Usage="System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 대한 이벤트 처리기 대리자의 목록을 가져옵니다. 이 속성은 읽기 전용입니다.</summary>
        <value>이벤트 처리기 대리자의 목록입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 형식의 <xref:System.ComponentModel.EventHandlerList>, 대리자의 목록에서 항목을 찾는 선형 검색 알고리즘을 사용 하는 합니다. 선형 검색 알고리즘을 많은 수의 항목을 작업할 때 비효율적입니다. 따라서 큰 목록이 있으면이 속성을 사용 하 여 항목 느려집니다 찾기.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 이벤트를 만듭니다 `Click`를 추가 하 고 컨트롤의 처리기를 제거 하는 <xref:System.ComponentModel.EventHandlerList> 이벤트 페이지에서 호출 될 때 컬렉션입니다.  
  
 **참고** 이 예제에서는 컨트롤을 추가 하 고 해당 컨트롤이 유지 하는 목록에서 이벤트를 제거 하는 방법을 최적화 합니다. 사용자 지정 컨트롤을 만들고 이벤트를 정의 하려는 경우에 다음과 유사 하 게 코드를 사용 합니다. Visual Basic에서는 그렇지 않습니다 하지만 C#에서는이 기법을 사용할 수 있습니다.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 서버 컨트롤의 현재 명명 컨테이너를 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string -&gt; System.Web.UI.Control&#xA;override this.FindControl : string -&gt; System.Web.UI.Control" Usage="control.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">찾을 컨트롤의 식별자입니다.</param>
        <summary>지정된 <paramref name="id" /> 매개 변수를 사용하여 서버 컨트롤의 현재 명명 컨테이너를 검색합니다.</summary>
        <returns>지정된 컨트롤이나 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Web.UI.Control.FindControl%2A> 컨트롤을 다른 컨테이너 내에 있는 컨트롤에 액세스 하는 코드 숨김 페이지에서 또는 대상 컨트롤 호출자에 게 직접 액세스할 수 없는 다른 상황에서 함수에서 액세스할 수 있습니다. 이 메서드는 컨트롤을 찾습니다 컨트롤; 지정된 된 컨테이너에 직접 포함 된 경우에 즉, 메서드는 컨트롤 내에서 컨트롤의 계층 구조 전체에서 검색 하지 않습니다. 즉시 컨테이너 알 수 없는 경우 컨트롤을 찾는 방법에 대 한 자세한 내용은 참조 하세요. [방법: 서버 컨트롤에 ID로 액세스할](https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3)합니다.  
  
   
  
## Examples  
 다음 예제에서는 정의 `Button1_Click` 이벤트 처리기입니다. 이 처리기에 사용 하 여 호출 되 면 합니다 <xref:System.Web.UI.Control.FindControl%2A> 메서드를 사용 하 여 컨트롤을 찾기는 <xref:System.Web.UI.Control.ID%2A> 속성을 `TextBox2` 포함 페이지에서. 컨트롤이 있으면 부모를 사용 하 여 결정 됩니다 합니다 <xref:System.Web.UI.Control.Parent%2A> 속성과 부모 컨트롤의 <xref:System.Web.UI.Control.ID%2A> 페이지에 기록 됩니다. 경우 `TextBox2` 발견 되지 않으면 "컨트롤을 찾을 수 없음" 페이지에 기록 됩니다.  
  
> [!IMPORTANT]
>  이 예제에는 사용자 입력을 허용하는 텍스트 상자가 있으므로 보안상 위험할 수 있습니다. 기본적으로 ASP.NET 웹 페이지는 사용자 입력 내용에 스크립트 또는 HTML 요소가 포함되어 있지 않은지 확인합니다. 자세한 내용은 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)를 참조하세요.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3">방법: ID 별로 액세스 서버 컨트롤</related>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberSignature Language="F#" Value="abstract member FindControl : string * int -&gt; System.Web.UI.Control&#xA;override this.FindControl : string * int -&gt; System.Web.UI.Control" Usage="control.FindControl (id, pathOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">찾을 컨트롤의 식별자입니다.</param>
        <param name="pathOffset">페이지 컨트롤 계층 구조에서 명명 컨테이너에 도달하는 데 필요한 컨트롤 개수입니다.</param>
        <summary>현재 명명 컨테이너에서 특정 <paramref name="id" />와 함께 <paramref name="pathOffset" /> 매개 변수에 지정된 검색용 정수를 사용하여 서버 컨트롤을 검색합니다. 이 버전의 <see cref="Overload:System.Web.UI.Control.FindControl" /> 메서드를 재정의해서는 안됩니다.</summary>
        <returns>지정된 컨트롤이나 <see langword="null" />을 반환합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; unit&#xA;override this.Focus : unit -&gt; unit" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤에 입력 포커스를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.Control.Focus%2A> 컨트롤에 웹 페이지의 초기 포커스를 설정 하는 방법입니다. 선택 된 컨트롤을 사용 하 여 브라우저에서 페이지를 열 수 됩니다.  
  
 <xref:System.Web.UI.Control.Focus%2A> 메서드를 사용 하면 렌더링된 된 페이지에 내보낼 페이지 포커스 스크립트를 호출 합니다. HTML 사용 하 여 컨트롤을 페이지에 포함 되지 않습니다 `ID` 컨트롤을 일치 하는 특성은는 <xref:System.Web.UI.Control.Focus%2A> 에 메서드를 호출한 다음 페이지 포커스를 설정할 수 없습니다. 이 오류가 발생할 수 있는 예에는 사용자 정의 컨트롤의 자식 컨트롤에 포커스를 설정 하는 대신 사용자 정의 컨트롤에 포커스를 설정 하는 경우입니다. 이 시나리오에서 사용할 수 있습니다 합니다 <xref:System.Web.UI.Control.FindControl%2A> 메서드를 호출 하 고 사용자 정의 컨트롤의 자식 컨트롤을 찾을 해당 <xref:System.Web.UI.Control.Focus%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberSignature Language="F#" Value="abstract member GetDesignModeState : unit -&gt; System.Collections.IDictionary&#xA;override this.GetDesignModeState : unit -&gt; System.Collections.IDictionary" Usage="control.GetDesignModeState " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤의 디자인 타임 데이터를 가져옵니다.</summary>
        <returns>컨트롤의 디자인 타임 데이터가 들어 있는 <see cref="T:System.Collections.IDictionary" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.GetDesignModeState%2A> 메서드는 컨트롤에 대 한 디자인 타임 데이터를 반환 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>합니다 <see cref="M:System.Web.UI.Control.GetDesignModeState" /> 메서드가 반환 되는 <see langword="null" /> 기본적으로 합니다. 사용자 컨트롤에 필요한 디자인 타임 데이터를 제공 하려면이 메서드를 재정의 해야 합니다.</para></block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>루트 매개 변수 집합(루트 이름은 선택 사항)에 해당하는 URL을 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : obj -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">루트 매개 변수입니다.</param>
        <summary>루트 매개 변수 집합에 해당하는 URL을 가져옵니다.</summary>
        <returns>지정된 루트 매개 변수 집합에 해당하는 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 메서드. 이 메서드는 전달 되는 개체를 변환 `routeParameters` 에 <xref:System.Web.Routing.RouteValueDictionary> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> 명명 된 매개 변수가 있는 경로의 URL을 가져오려면 메서드 `productid` 및 `category`합니다. 이 예에서는 만들었다고 가정 된 <xref:System.Web.UI.WebControls.HyperLink> 라는 컨트롤을 `HyperLink1`입니다.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl routeParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeParameters">루트 매개 변수입니다.</param>
        <summary>루트 매개 변수 집합에 해당하는 URL을 가져옵니다.</summary>
        <returns>지정된 루트 매개 변수 집합에 해당하는 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 매개 변수가 있는 경로의 URL을 가져오려면이 메서드를 호출 하는 방법을 보여 줍니다 `productid` 고 `category`입니다. 이 예에서는 만들었다고 가정 된 <xref:System.Web.UI.WebControls.HyperLink> 라는 컨트롤을 `HyperLink1`입니다.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * obj -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeParameters">루트 매개 변수입니다.</param>
        <summary>루트 매개 변수 집합 및 루트 이름에 해당하는 URL을 가져옵니다.</summary>
        <returns>지정된 루트 매개 변수 집합 및 루트 이름에 해당하는 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 메서드. 이 메서드는 전달 되는 개체를 변환 `routeParameters` 에 <xref:System.Web.Routing.RouteValueDictionary> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자.  
  
   
  
## Examples  
 다음 예제에서는 라는 경로 URL을 가져오려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수에 `productid` 고 `category`입니다. 이 예에서는 만들었다고 가정 된 <xref:System.Web.UI.WebControls.HyperLink> 라는 컨트롤을 `HyperLink1`입니다.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberSignature Language="F#" Value="member this.GetRouteUrl : string * System.Web.Routing.RouteValueDictionary -&gt; string" Usage="control.GetRouteUrl (routeName, routeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeParameters">루트 매개 변수입니다.</param>
        <summary>루트 매개 변수 집합 및 루트 이름에 해당하는 URL을 가져옵니다.</summary>
        <returns>지정된 루트 매개 변수 집합 및 루트 이름에 해당하는 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 라는 경로 URL을 가져오려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수에 `productid` 고 `category`입니다. 이 예에서는 만들었다고 가정 된 <xref:System.Web.UI.WebControls.HyperLink> 라는 컨트롤을 `HyperLink1`입니다.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetUniqueIDRelativeTo : System.Web.UI.Control -&gt; string" Usage="control.GetUniqueIDRelativeTo control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="control">명명 컨테이너 내의 컨트롤입니다.</param>
        <summary>지정된 컨트롤의 <see cref="P:System.Web.UI.Control.UniqueID" /> 속성에서 접두사 부분을 반환합니다.</summary>
        <returns>지정된 컨트롤의 <see cref="P:System.Web.UI.Control.UniqueID" /> 속성의 접두사 부분입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.UniqueID%2A> 컨트롤의 속성을 컨트롤의 접두사를 추가 하 여 생성 <xref:System.Web.UI.Control.ID%2A> 속성입니다. 접두사는 이루어져는 <xref:System.Web.UI.Control.UniqueID%2A> 컨트롤의 속성의 명명 컨테이너는 구분 기호 문자를 사용 하 여 연결 합니다. 명명 컨테이너 페이지 인 경우에 접두사가 없습니다. 이 메서드는 접두사 문자열을 반환합니다. 접두사 문자열이 없는 없으면 반환 된 <xref:System.Web.UI.Control.UniqueID%2A> 컨트롤의 값입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="control" />의 <see cref="P:System.Web.UI.Control.NamingContainer" /> 속성이 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildViewState : bool" Usage="System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 서버 컨트롤의 자식 컨트롤에 저장된 뷰 상태 설정 값이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>자식 컨트롤에 저장된 뷰 상태 정보가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 불필요 한 호출을 방지할 수 있습니다는 <xref:System.Web.UI.Control.ClearChildViewState%2A> 서버 컨트롤의 자식 컨트롤의 뷰 상태 정보가 저장 하는 확인 하려면이 속성을 사용 하 여 메서드.  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberSignature Language="F#" Value="abstract member HasControls : unit -&gt; bool&#xA;override this.HasControls : unit -&gt; bool" Usage="control.HasControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤에 자식 컨트롤이 있는지 확인합니다.</summary>
        <returns>서버 컨트롤에 다른 컨트롤이 포함되어 있으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 단순히 불필요 하 수 있도록 하 여 성능 향상 될 수 있는 자식 컨트롤에서 알 수 없으면 확인 하므로 <xref:System.Web.UI.ControlCollection.Count%2A> 속성 호출 합니다. 이 속성을 호출 해야는 <xref:System.Web.UI.ControlCollection> 개체를 인스턴스화할 수 있습니다. 자식이 없는 경우이 개체를 만드는 서버 리소스가 낭비 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.UI.Control.HasControls%2A> 모든 컨트롤을 사용 하기 전에 있는지 확인 하는 방법을 <xref:System.Web.UI.ControlCollection.Count%2A> 속성을 반복 하는 <xref:System.Web.UI.ControlCollection> 개체.  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>합니다 <see cref="M:System.Web.UI.Control.HasControls" /> 메서드를 재정의 하 여 같은 메타 데이터 특성을 변경 합니다 <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />합니다. 특성을 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [특성](~/docs/standard/attributes/index.md)합니다.</para></block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberSignature Language="F#" Value="member this.HasEvents : unit -&gt; bool" Usage="control.HasEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이벤트가 컨트롤이나 자식 컨트롤에 등록되었는지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>이벤트가 등록되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤에 할당된 프로그래밍 ID를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 할당된 프로그래밍 ID입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤에서이 속성을 설정 합니다. 프로그래밍 방식 액세스를 서버 컨트롤의 속성, 이벤트 및 메서드를 제공 합니다. 선언 하 여 웹 개발자가이 속성을 설정할 수 있습니다는 <xref:System.Web.UI.Control.ID%2A> ASP.NET 서버 컨트롤의 여는 태그의 특성입니다.  
  
 부모 컨트롤의를 통해 해당 컨트롤에 대 한 참조를 가져올 수 있습니다이 속성은 선언적으로 또는 프로그래밍 방식으로 서버 컨트롤을 지정 하지 않으면 <xref:System.Web.UI.Control.Controls%2A> 속성입니다.  
  
> [!NOTE]
>  영숫자 문자 및 밑줄 (_)만 조합은이 속성에 대 한 유효한 값입니다. 공백이 나 다른 잘못 된 문자를 포함 하 여 ASP.NET 페이지 파서 오류가 발생 합니다.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 식별자를 구분하는 데 사용되는 문자를 가져옵니다.</summary>
        <value>구분 문자입니다. 기본값은 "$"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 문자를 <xref:System.Web.UI.Control.IdSeparator%2A> 속성은 자식 컨트롤에 대 한 컨트롤 식별자를 구분 하는 데 사용 됩니다. ID 구분 기호에 추가 되는 <xref:System.Web.UI.Control.ID%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberSignature Language="F#" Value="member this.Init : EventHandler " Usage="member this.Init : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤 주기의 첫 단계로 서버 컨트롤을 초기화할 때 이 이벤트가 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤 만들기 및 인스턴스를 설정 하는 데 필요한 초기화 단계를 수행 해야 합니다. 이 이벤트 내에서 뷰 상태 정보를 사용할 수 없습니다. 아직 설치 되지 않은 합니다. 다른 서버 컨트롤의 자식 또는이 컨트롤에는 부모 인지에 관계 없이이 이벤트는 동안 액세스 하지 않아야 합니다. 다른 서버 컨트롤은 생성 되 고 액세스할 준비가 되도록 특정 없습니다. 서버 컨트롤 이벤트에 대 한 자세한 내용은 참조 하세요. [ASP.NET Web Forms 서버 컨트롤 이벤트 모델](https://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 이벤트 처리기를 할당 `Calendar_Init`를 `Init` 이벤트를 <xref:System.Web.UI.WebControls.Calendar> 컨트롤입니다.  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsChildControlStateCleared : bool" Usage="System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤에 포함된 컨트롤이 컨트롤 상태를 가지는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 컨트롤의 자식에서 컨트롤 상태를 사용하지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberSignature Language="F#" Value="member this.IsLiteralContent : unit -&gt; bool" Usage="control.IsLiteralContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤에 리터럴 내용만 저장되어 있는지 확인합니다.</summary>
        <returns>서버 컨트롤에 리터럴 내용만 들어 있으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 될 때 `true`, 서버 컨트롤의 컬렉션에 단일 리터럴 컨트롤을 포함 합니다.  
  
   
  
## Examples  
 다음 예에서는 서버 컨트롤을 포함 하는 페이지가 다시 게시에 있는지 여부를 확인 합니다. 호출 된 경우는 <xref:System.Web.UI.Control.IsLiteralContent%2A> 컨트롤 리터럴 내용만 포함 하거나 다른 서버 컨트롤의 부모 컨트롤 여부를 확인 하는 방법입니다. 리터럴 내용만 포함 하는 경우는 <xref:System.Web.UI.Control.UniqueID%2A> 의 속성을 <xref:System.Web.UI.LiteralControl> 나타내는 콘텐츠 응답에 기록 되는 합니다.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTrackingViewState : bool" Usage="System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤에서 해당 뷰 상태의 변경 사항을 저장하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>컨트롤에서 해당 상태를 저장하도록 표시되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하는 샘플 사용자 지정 서버 컨트롤을 참조 하세요. [템플릿 기반 서버 컨트롤 예제](https://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.DataBind%2A> 사용자 지정 ASP.NET 서버 컨트롤의 메서드. 기본을 호출 하 여 시작 <xref:System.Web.UI.Control.OnDataBinding%2A> 메서드를 사용 하는 `ControlCollection` 개체입니다. <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> 모든 자식 컨트롤을 삭제 하는 방법 및 <xref:System.Web.UI.Control.ClearChildViewState%2A> 메서드를 삭제 하는 모든 해당 자식 컨트롤의 뷰 상태 설정을 저장 합니다. 마지막으로, 합니다 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 속성이 `true`합니다. 컨트롤을 사용 하 여는 <xref:System.Web.UI.Control.IsTrackingViewState%2A> 속성을 컨트롤에 대 한 뷰 상태 변경 내용 추적을 사용할 수 있는지 여부를 확인 합니다. 사용 하지 않는 경우는 <xref:System.Web.UI.Control.TrackViewState%2A> 메서드가 호출 됩니다.  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsViewStateEnabled : bool" Usage="System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤의 뷰 상태를 사용할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>컨트롤에 뷰 상태를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 뷰 상태 페이지, 컨테이너 또는 컨트롤 수준에서 사용할 수 있습니다. 페이지 또는 컨테이너 수준에서 보기 상태가 비활성화 되 면 뷰 상태는 페이지 또는 컨테이너에 포함 된 모든 컨트롤에 대 한 비활성화 됩니다. <xref:System.Web.UI.Control.IsViewStateEnabled%2A> 속성 페이지, 컨테이너 또는 컨트롤에서 뷰 상태가 사용 되는지 여부를 나타냅니다.  
  
 수는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성 및 <xref:System.Web.UI.Control.IsViewStateEnabled%2A> 속성 달라 야 합니다. 예를 들어 경우는 <xref:System.Web.UI.Page> 비활성화 상태 보기에 컨트롤을 포함 하는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성 일 수 있습니다 `true` 하는 동안 합니다 <xref:System.Web.UI.Control.IsViewStateEnabled%2A> 속성이 `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>페이지 개발자는 설정 된 <see cref="P:System.Web.UI.Control.EnableViewState" /> 속성 및 <see cref="P:System.Web.UI.Control.ViewStateMode" /> 뷰 상태 컨트롤을 사용 하 여 사용 중인 여부를 나타내는 속성을 합니다. 사용 된 <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> 속성 및 <see cref="P:System.Web.UI.Control.ViewStateMode" /> 컨트롤 및 모든 컨테이너에 대 한 보기 상태 사용 되는지 여부를 확인 하는 코드에서 속성입니다.</para></block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : EventHandler " Usage="member this.Load : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.Page" /> 개체에 서버 컨트롤을 로드할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 페이지 요청에서 발생 하도록 설정 되는 모든 처리 단계를 수행 하는 서버 컨트롤을 알립니다. 이 이벤트에서 상태 정보 보기 및 Web form POST 데이터를 액세스할 수 있습니다. 페이지의 컨트롤 계층 구조 내의 다른 서버 컨트롤에 액세스할 수도 있습니다.  
  
> [!NOTE]
>  컨트롤 중에서 사용자 지정 템플릿을 설정한 경우는 `Page_Load` 이벤트를 사용자 지정 템플릿에 있는 자식 컨트롤의 텍스트 값을 손실 됩니다. 이 이미 로드 된 양식 값 때문에 발생 합니다.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadControlState : obj -&gt; unit&#xA;override this.LoadControlState : obj -&gt; unit" Usage="control.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="savedState">복원할 컨트롤 상태를 나타내는 <see cref="T:System.Object" />입니다.</param>
        <summary><see cref="M:System.Web.UI.Control.SaveControlState" /> 메서드에서 저장한 이전 페이지 요청에서 컨트롤 상태 정보를 복원합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 서버 컨트롤에서 컨트롤 상태를 복원 하는 방법을 지정 해야 할 경우이 메서드를 재정의 합니다. 자세한 내용은 [ASP.NET 상태 관리 개요](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Web.UI.Control.LoadControlState%2A> 사용자 지정 ASP.NET 컨트롤에서 메서드. 이 메서드가 호출 되 면 컨트롤 상태를 컨트롤에 대 한 이전에 저장을 확인, 그렇다면 내부 속성을 설정 합니다. `currentIndex` 저장 된 값입니다.  
  
 <xref:System.Web.UI.Control.OnInit%2A> 메서드를 호출 하도록 재정의 됩니다는 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 메서드를 <xref:System.Web.UI.Control.Page%2A> 를 나타내는 사용자 지정 컨트롤에서 컨트롤 상태를 사용 하 합니다.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="abstract member LoadViewState : obj -&gt; unit&#xA;override this.LoadViewState : obj -&gt; unit" Usage="control.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">복원할 컨트롤 상태를 나타내는 <see cref="T:System.Object" />입니다.</param>
        <summary><see cref="M:System.Web.UI.Control.SaveViewState" /> 메서드로 저장한 이전 페이지 요청에서 뷰 상태 정보를 복원합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는.NET Framework 인프라에서 기본적으로 사용 하며 사용자 코드에서 직접 사용할 수 없습니다. 그러나 컨트롤 개발자가 사용자 지정 서버 컨트롤에서 해당 뷰 상태를 복원 하는 방법을 지정 하려면이 메서드를 재정의할 수 있습니다. 자세한 내용은 [ASP.NET 상태 관리 개요](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))합니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.LoadViewState%2A> 메서드는 사용자 지정 ASP.NET 서버 컨트롤에 대 한 합니다. 만듭니다는 <xref:System.Object> 배열에 전달 된 뷰 상태 정보를 포함 하는 `savedState` 매개 변수를의 기본 구현을 호출 하는 <xref:System.Web.UI.Control.LoadViewState%2A> 배열의 첫 번째 인덱스 위치에 대 한 메서드. 명명 된 변수는 다음 두 인덱스 위치에 저장 된 값을 할당 `UserText` 및 `PasswordText`, 각각.  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.LoadViewStateByID : bool" Usage="System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>인덱스 대신 <see cref="P:System.Web.UI.Control.ID" />별로 뷰 상태를 로드할 때 컨트롤이 참여하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>컨트롤이 <see cref="P:System.Web.UI.Control.ID" />별로 뷰 상태를 로드하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 부모 컨트롤을 생성 하는 자식 컨트롤에 뷰 상태를 로드 하는 경우이를 위해 각 자식 컨트롤의 부모 컨트롤의 위치 <xref:System.Web.UI.Control.Controls%2A> 컬렉션입니다. 처음에 뷰 상태를 적용 하면 모든 자식 컨트롤 수 있는 만들어지지 않았습니다. 이 경우 아직 만들지 않은 경우 컨트롤의 뷰 상태를 저장 하 고 나중에 자식 컨트롤을 만들 때 적용 됩니다.  
  
 자식 컨트롤에 뷰 상태를 적용 하려면 부모 컨트롤에 대 한 두 조건이 충족 되어야 합니다.  
  
-   포스트백에서 부모 컨트롤 만들어야 자식 컨트롤 이전 요청이 정확히 같은 순서로 컨트롤의 순서를 일관 된 상태로 유지 되도록 합니다.  
  
-   포스트백 후 만든 모든 자식 컨트롤의 부모 컨트롤의 끝에 추가 해야 <xref:System.Web.UI.Control.Controls%2A> 컬렉션입니다.  
  
 부모 컨트롤을 사용 하 여 뷰 상태를 로드할 수 있습니다 이러한 두 조건이 충족 되지 않으면, 자식 컨트롤의 지연 된 만들기의 경우와 같이, <xref:System.Web.UI.Control.ID%2A>합니다. 설정 하는 <xref:System.Web.UI.Control.LoadViewStateByID%2A> 속성을 `true`를 사용 하 여는 <xref:System.Web.UI.ViewStateModeByIdAttribute> 부모 컨트롤에 대 한 메타 데이터 특성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPathSecure : string -&gt; string" Usage="control.MapPathSecure virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">상대 URL 또는 루트 상대 URL입니다.</param>
        <summary>가상 경로(절대 또는 상대)가 매핑되는 실제 경로를 가져옵니다.</summary>
        <returns>요청된 파일에 대한 실제 경로를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 파일을 읽을 수 있는 권한이 있고 System.Web.dll 같은 완전히 신뢰할 수 있는.dll 파일의 일부인 서버 컨트롤에서 사용할 수 있습니다. 이렇게 하면 보안 위반을 방지할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.UI.Control.MapPathSecure%2A> 메서드를 포함 하는 가상 디렉터리의 실제 경로 가져올 <xref:System.Web.UI.Page> 또는 <xref:System.Web.UI.UserControl> 개체입니다.  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="virtualPath" />이 <see langword="null" /> 또는 빈 문자열("")인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamingContainer : System.Web.UI.Control" Usage="System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>동일한 <see cref="P:System.Web.UI.Control.ID" /> 속성 값을 사용하는 서버 컨트롤을 구별하기 위해 고유의 네임스페이스를 만드는 서버 컨트롤의 명명 컨테이너에 대한 참조를 가져옵니다.</summary>
        <value>서버 컨트롤의 명명 컨테이너입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 웹 응용 프로그램의 각 페이지 컨트롤 계층을 포함 합니다. 이 계층 구조 컨트롤을 사용자에 게 표시 되는 UI를 생성 하는지 여부에 종속 되지 않습니다. 지정된 된 컨트롤에 대 한 명명 컨테이너는를 구현 하는 계층 구조에서 위에 있는 부모 컨트롤을 <xref:System.Web.UI.INamingContainer> 인터페이스입니다. 이 인터페이스를 구현 하는 서버 컨트롤에 대 한 고유한 네임 스페이스를 만듭니다는 <xref:System.Web.UI.Control.ID%2A> 자식 서버 컨트롤의 속성 값입니다. 사용할 수는 <xref:System.Web.UI.Control.NamingContainer%2A> 해당 부모 컨테이너에 대 한 참조를 가져올 명명 컨테이너의 자식 컨트롤의 속성입니다.  
  
 서버 컨트롤에 대 한 고유한 네임 스페이스를 만들고는 같은 데이터를 웹 서버 컨트롤을 바인딩할 때 특히 중요 합니다 <xref:System.Web.UI.WebControls.Repeater> 고 <xref:System.Web.UI.WebControls.DataList> 서버 컨트롤입니다. 명명 컨테이너에 이러한 자식 컨트롤의 각 인스턴스는 하면 데이터 원본에서 여러 항목 반복 하는 컨트롤의 자식 서버 컨트롤의 여러 인스턴스를 만들 때 <xref:System.Web.UI.Control.UniqueID%2A> 충돌 하지 않는 속성 값입니다. 페이지에 대 한 기본 명명 컨테이너는 인스턴스는 <xref:System.Web.UI.Page> 해당 페이지가 요청 될 때 생성 되는 클래스입니다.  
  
 합니다 <xref:System.Web.UI.Control.ClientID%2A> 요소의 렌더링 되는 값을 포함 하는 속성 `id` HTML 태그의 특성입니다. 에 할당 하는 값에 따라 합니다 <xref:System.Web.UI.Control.ClientIDMode%2A> 속성에 대해 생성 되는 값을 <xref:System.Web.UI.Control.ClientID%2A> 속성의 ID를 포함 될 수 있습니다를 <xref:System.Web.UI.Control.NamingContainer%2A> 개체입니다. 설정한 경우 <xref:System.Web.UI.Control.ClientIDMode%2A> 하 <xref:System.Web.UI.ClientIDMode.Static>의 <xref:System.Web.UI.Control.ClientID%2A> 값의 ID를 포함 되지 않습니다는 <xref:System.Web.UI.Control.NamingContainer%2A> 개체입니다. 설정한 경우 <xref:System.Web.UI.Control.ClientIDMode%2A> 중 하나를 <xref:System.Web.UI.ClientIDMode.AutoID> 또는 <xref:System.Web.UI.ClientIDMode.Predictable>의 <xref:System.Web.UI.Control.ClientID%2A> 값의 ID를 포함 합니다를 <xref:System.Web.UI.Control.NamingContainer%2A> 개체입니다. 자세한 내용은 [ASP.NET 웹 서버 컨트롤 식별](https://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)을 참조하세요.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Web.UI.Control.NamingContainer%2A> 속성입니다.  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnBubbleEvent : obj * EventArgs -&gt; bool&#xA;override this.OnBubbleEvent : obj * EventArgs -&gt; bool" Usage="control.OnBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 소스입니다.</param>
        <param name="args">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary>서버 컨트롤의 이벤트가 페이지의 UI 서버 컨트롤 계층 구조에 전달되었는지 여부를 확인합니다.</summary>
        <returns>이벤트가 취소되었으면 <see langword="true" />를 반환하고, 그렇지 않으면 <see langword="false" />를 반환합니다. 기본값은 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 서버 컨트롤의 <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> 및 <xref:System.Web.UI.WebControls.GridView> 웹 컨트롤 이벤트를 발생 하는 자식 컨트롤을 포함할 수 있습니다. 예를 들어, 각 행에는 <xref:System.Web.UI.WebControls.GridView> 컨트롤 템플릿에 의해 동적으로 생성 하는 하나 이상의 단추를 포함할 수 있습니다. 대신 개별적으로 이벤트를 발생 시키는 각 단추에 중첩된 된 컨트롤에서 이벤트는 "버블링"-즉, 명명 컨테이너에 전송 됩니다. 명명 컨테이너를 차례로 라는 일반 이벤트를 발생 시킵니다 <xref:System.Web.UI.WebControls.GridView.RowCommand> 매개 변수 값을 사용 하 여 합니다. 이러한 값을 사용 하면 원래 이벤트를 발생 하는 개별 컨트롤을 확인할 수 있습니다. 이 단일 이벤트에 응답 하 여 자식 컨트롤에 대 한 개별 이벤트 처리 메서드를 작성 하지 않아도 방지할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 된 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 사용자 지정 ASP.NET 서버 컨트롤에서 `ParentControl`합니다. 이 메서드는 자식 컨트롤의 `ParentControl` 호출을 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 메서드. 이 경우는 `ParentControl` 클래스는 포함 하는 ASP.NET 페이지, 첫 번째 나타내는 두 문자열을 쓰고는 해당 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 메서드를 호출한, 두 번째 식별의 소스 제어는 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 메서드.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataBinding : EventArgs -&gt; unit&#xA;override this.OnDataBinding : EventArgs -&gt; unit" Usage="control.OnDataBinding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.DataBinding" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 연관 된 데이터 바인딩 논리를 수행 하는 서버 컨트롤을 알립니다.  
  
 처리 하려는 경우는 <xref:System.Web.UI.Control.DataBinding> 경우가 이벤트 처리 메서드를 재정의 해야 합니다. 이렇게 하면에 연결 된 모든 대리자는 <xref:System.Web.UI.Control.DataBinding> 이벤트가 호출 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 하는 방법에 설명 합니다 <xref:System.Web.UI.Control.OnDataBinding%2A> 자식 컨트롤을 데이터 원본에서 부모 컨트롤을 추가 하는 방법입니다.  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 개요</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="control.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 ASP.NET의 <xref:System.Web.UI.Control.Init> 이벤트입니다. 사용자 지정 컨트롤을 개발 하는 경우에 추가 처리를 제공 하기 위해이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 기본 컨트롤의 호출 <xref:System.Web.UI.Control.OnInit%2A> 이벤트에 구독자에 게 알리는 메서드.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="control.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.Load" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 ASP.NET의 <xref:System.Web.UI.Control.Load> 이벤트입니다. 사용자 지정 컨트롤을 개발 하는 경우에 추가 처리를 제공 하기 위해이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 기본 컨트롤의 호출 <xref:System.Web.UI.Control.OnLoad%2A> 이벤트에 구독자에 게 알리는 메서드.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="control.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 ASP.NET의 <xref:System.Web.UI.Control.PreRender> 이벤트입니다. 사용자 지정 컨트롤을 개발 하는 경우에 추가 처리를 제공 하기 위해이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 기본 컨트롤의 호출 <xref:System.Web.UI.Control.OnPreRender%2A> 이벤트에 구독자에 게 알리는 메서드.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="control.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 들어 있는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.Unload" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 ASP.NET의 <xref:System.Web.UI.Control.Unload> 이벤트입니다. 사용자 지정 컨트롤을 개발 하는 경우에 추가 처리를 제공 하기 위해이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 기본 컨트롤의 호출 <xref:System.Web.UI.Control.OnUnload%2A> 이벤트에 구독자에 게 알리는 메서드.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string -&gt; System.IO.Stream" Usage="control.OpenFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">해당 파일의 경로입니다.</param>
        <summary>파일을 읽는 데 사용되는 <see cref="T:System.IO.Stream" />을 가져옵니다.</summary>
        <returns>해당 파일을 참조하는 <see cref="T:System.IO.Stream" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.OpenFile%2A> 메서드가 반환 되는 <xref:System.IO.Stream> 에 지정 된 파일의 내용을 읽는 데 사용할 수 있는 개체를 `path` 매개 변수. Path 매개 변수 중 하나는 상대 하거나 루트 URL 프로토콜 없이 수 (같은 "~ / mySite/myFile.txt), 또는 실제 경로 로컬 ("c:\mySite\myFile.txt") 또는 UNC ("\\\myServer\myFile.txt ").  
  
 <xref:System.Web.UI.Control.OpenFile%2A> 메서드는 지정된 된 파일에 대 한 액세스를 제어 하는 데 파일 액세스 보안을 사용 합니다. 파일에 대 한 사용 권한이 현재 ASP.NET 사용자 없는 경우 파일을 열 수 없습니다 하 고는 <xref:System.Web.HttpException> 액세스가 거부 되었음을 나타내는 예외가 throw 됩니다. 경우는 `path` 매개 변수는 상대 경로 지정 하면 예외에는 요청한 파일의 실제 경로 대 한 정보에 포함 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">지정된 파일에 대한 액세스가 거부된 경우</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page with get, set" Usage="System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤이 들어 있는 <see cref="T:System.Web.UI.Page" /> 인스턴스에 대한 참조를 가져옵니다.</summary>
        <value>서버 컨트롤이 들어 있는 <see cref="T:System.Web.UI.Page" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의이 값에는 서버 컨트롤을 포함 하는.aspx 파일의 이름을 반영 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> 메서드를 재정의합니다. 사용 하 여는 <xref:System.Web.UI.Page> 속성에 액세스 합니다 <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> 속성이이 컨트롤이 포함 된 페이지 로드 된 처음으로 포스트백의 결과인 하는지 여부를 결정 합니다.  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">컨트롤이 <see cref="T:System.Web.UI.WebControls.Substitution" /> 컨트롤인 경우</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Web.UI.Control" Usage="System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지 컨트롤 계층 구조에서 서버 컨트롤의 부모 컨트롤에 대한 참조를 가져옵니다.</summary>
        <value>서버 컨트롤의 부모 컨트롤에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 페이지를 요청할 때마다 해당 페이지에서 서버 컨트롤 계층 구조가 빌드됩니다. 이 속성을 사용 하면 프로그래밍을 하는 계층 구조에 현재 서버 컨트롤의 부모 컨트롤을 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 새 <xref:System.Web.UI.Control> 페이지에 개체 `myControl1`에 지정 된 컨트롤에는 <xref:System.Web.UI.Control.FindControl%2A> 메서드를 호출 합니다. 호출 컨트롤을 반환 하는 경우 코드를 사용 하는 <xref:System.Web.UI.Control.Parent%2A> 포함 된 컨트롤을 식별 하는 속성 `myControl1`합니다. 연결 된 부모 컨트롤에 있는 경우 문자열 "텍스트 상자의 부모가"를 <xref:System.Web.UI.Control.ID%2A> 부모 컨트롤의 속성에 기록 된 <xref:System.Web.UI.Control.Page%2A>. 부모 컨트롤이 없으면 문자열 "제어 not found"가 기록 됩니다.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberSignature Language="F#" Value="member this.PreRender : EventHandler " Usage="member this.PreRender : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.Control" /> 개체가 로드된 후, 렌더링 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트를 사용 하 여 서버 컨트롤을 페이지로 렌더링 되기 전에 업데이트를 수행 합니다. 이 이벤트 도중 서버 컨트롤의 뷰 상태의 변경 내용을 저장할 수 있습니다. 렌더링 단계에서 이러한 변경 내용은 저장 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.RaiseBubbleEvent : obj * EventArgs -&gt; unit" Usage="control.RaiseBubbleEvent (source, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">이벤트 소스입니다.</param>
        <param name="args">이벤트 데이터가 포함된 <see cref="T:System.EventArgs" /> 개체입니다.</param>
        <summary>이벤트 소스와 해당 정보를 컨트롤의 부모 컨트롤에 할당합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 서버 컨트롤의 <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> 및 <xref:System.Web.UI.WebControls.GridView> 웹 컨트롤 이벤트를 발생 하는 자식 컨트롤을 포함할 수 있습니다. 예를 들어, 각 행에는 <xref:System.Web.UI.WebControls.GridView> 컨트롤 템플릿에 의해 동적으로 생성 하는 하나 이상의 단추를 포함할 수 있습니다. 대신 개별적으로 이벤트를 발생 시키는 각 단추에 중첩된 된 컨트롤에서 이벤트는 "버블링"-즉, 컨트롤의 부모에 전송 됩니다. 부모에서 라는 일반 이벤트를 발생 시킵니다 <xref:System.Web.UI.WebControls.GridView.RowCommand> 매개 변수 값을 사용 하 여 합니다. 이러한 값을 사용 하면 원래 이벤트를 발생 하는 개별 컨트롤을 확인할 수 있습니다. 이 단일 이벤트에 응답 하 여 자식 컨트롤에 대 한 개별 이벤트 처리 메서드를 작성 하지 않아도 방지할 수 있습니다.  
  
 만든 컨트롤을 처리 하거나 재정의 하 여 거품형된 이벤트를 발생 시킬 수 있습니다이 메서드를 재정의할 수는 없지만는 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에는 사용자 지정 클래스를 만드는 방법을 보여 줍니다 `ChildControl`재정의를 <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> 메서드를 호출 하는 <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> 전송 하는 메서드를 <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> 부모 ASP.NET 서버 컨트롤에 이벤트입니다. 인스턴스를 포함 하는 ASP.NET 페이지의 단추를 클릭할 때 `ChildControl`를 발생 시킵니다 합니다 <xref:System.Web.UI.Control.OnBubbleEvent%2A> 의 인스턴스를 포함 하는 부모 컨트롤에서 메서드 `ChildControl` 쓰고 문자열 "ChildControl 클래스 메서드는 OnClick 페이지에 "라고 합니다.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RemovedControl : System.Web.UI.Control -&gt; unit&#xA;override this.RemovedControl : System.Web.UI.Control -&gt; unit" Usage="control.RemovedControl control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">제거된 <see cref="T:System.Web.UI.Control" />입니다.</param>
        <summary>자식 컨트롤이 <see cref="T:System.Web.UI.Control" /> 개체의 <see cref="P:System.Web.UI.Control.Controls" /> 컬렉션에서 제거된 후 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.RemovedControl%2A> 에서 컨트롤을 제거한 후에 즉시 메서드는 <xref:System.Web.UI.Control.Controls%2A> 컬렉션입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">컨트롤이 <see cref="T:System.Web.UI.WebControls.Substitution" /> 컨트롤인 경우</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">서버 컨트롤 콘텐츠를 받는 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체입니다.</param>
        <summary>클라이언트에서 렌더링할 콘텐츠를 쓰는 지정된 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체에 서버 컨트롤 콘텐츠를 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 서버 컨트롤을 개발할 때 ASP.NET 페이지에 대 한 콘텐츠를 생성 하려면이 메서드를 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Web.UI.Control.Render%2A> 메서드. <xref:System.Web.UI.Control.HasControls%2A> 메서드는 서버 컨트롤에 저장 된 모든 자식 컨트롤에 있는지 여부를 결정 하는 해당 <xref:System.Web.UI.ControlCollection> 를 통해 액세스할 수 있는 개체는 <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> 속성입니다. 경우 <xref:System.Web.UI.Control.HasControls%2A> 반환 true이 고 컬렉션의 첫 번째 서버 컨트롤은 리터럴 텍스트, 리터럴 텍스트를 HTML 문자열에 추가 됩니다.  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">렌더링된 콘텐츠를 받는 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체입니다.</param>
        <summary>클라이언트에 렌더링할 콘텐츠를 쓰는 지정된 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체에 서버 컨트롤의 자식 컨트롤 콘텐츠를 출력합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 모든 ASP Active Server Pages () 코드 페이지를 렌더링 하는 ASP.NET에 알립니다. ASP 코드가 없는 페이지에 있는 경우이 메서드 렌더링 모든 자식 서버 컨트롤에 대 한 제어 합니다. 이 메서드는 <xref:System.Web.UI.Control.Render%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.RenderChildren%2A> 사용자 지정 서버 컨트롤의 메서드입니다. 현재 컨트롤 자식 컨트롤에 있는지 여부를 결정 해당 <xref:System.Web.UI.ControlCollection> 개체입니다. 사용 하 여이 경우는 <xref:System.Web.UI.ControlCollection.Count%2A> 컬렉션을 반복 하는 속성입니다. 사용 하 여 각 자식 컨트롤을 만날는 <xref:System.Web.UI.Control.RenderControl%2A> 컨트롤 및 해당 자식 컨트롤을 포함 하는 페이지의 모든 부모를 렌더링 하는 방법입니다.  
  
 재정의 된 <xref:System.Web.UI.Control.Render%2A> 메서드를 다음 재정의 된 호출 <xref:System.Web.UI.Control.RenderChildren%2A> 메서드.  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>서버 컨트롤 콘텐츠를 출력하고, 추적 기능이 설정된 경우에는 컨트롤에 대한 추적 정보를 저장합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderControl : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="control.RenderControl writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">컨트롤 콘텐츠를 받는 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체입니다.</param>
        <summary>제공된 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체로 서버 컨트롤 콘텐츠를 출력하고 추적을 사용하는 경우 컨트롤에 대한 추적 정보를 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤의 <xref:System.Web.UI.Control.Visible%2A> 속성이 `true`,이 메서드는 페이지에 대 한 추적을 사용할지 결정 합니다. 그렇다면 컨트롤과 연결 된 추적 정보를 저장 하 고 페이지에 서버 컨트롤 콘텐츠를 렌더링 합니다.  
  
 이 메서드를 렌더링 하는 동안 페이지에서 자동으로 호출 하지만 사용자 지정 컨트롤 개발자가 재정의할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.RenderChildren%2A> 사용자 지정 서버 컨트롤의 메서드입니다. 현재 컨트롤 자식 컨트롤에 있는지 여부를 결정 해당 <xref:System.Web.UI.ControlCollection> 개체입니다. 사용 하 여이 경우는 <xref:System.Web.UI.ControlCollection.Count%2A> 컬렉션을 반복 하는 속성입니다. 사용 하 여 각 자식 컨트롤을 만날는 <xref:System.Web.UI.Control.RenderControl%2A> 컨트롤 및 해당 자식 컨트롤을 포함 하는 페이지의 모든 자식을 렌더링 하는 방법입니다. 합니다 <xref:System.Web.UI.XhtmlTextWriter> 하 여이 메서드에 전달 되는 개체를 인스턴스화할는 <xref:System.Web.UI.Page.Render%2A> 메서드.  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberSignature Language="F#" Value="member this.RenderControl : System.Web.UI.HtmlTextWriter * System.Web.UI.Adapters.ControlAdapter -&gt; unit" Usage="control.RenderControl (writer, adapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="writer">컨트롤 콘텐츠를 받는 <see cref="T:System.Web.UI.HtmlTextWriter" />입니다.</param>
        <param name="adapter">렌더링을 정의하는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />입니다.</param>
        <summary>제공된 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체를 사용하여 제공된 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 개체에 서버 컨트롤 콘텐츠를 출력합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 웹 페이지 광범위 한 장치 및 웹에서 정보를 요청할 수 있는 브라우저에서 사용할 수 있습니다. <xref:System.Web.UI.Control.Adapter%2A> 속성에서 반환 된 <xref:System.Web.UI.Adapters.ControlAdapter> 요청 하는 장치 또는 브라우저의 화면에 컨트롤을 렌더링 하는 개체입니다.  
  
 어댑터에 대 한 자세한 내용은 참조 하세요. [아키텍처 개요의 적응형 컨트롤 동작](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))합니다.  
  
 서버 컨트롤의 <xref:System.Web.UI.Control.Visible%2A> 속성이 `true` 페이지에 대 한 추적을 사용할 수 하 고 컨트롤과 연결 된 추적 정보가 캡처됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우는 <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> 지정 컨트롤에서 추적 정보 바르게 캡처되는지 확인 합니다. 기본 클래스 메서드를 호출 합니다.</para></block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100)">적응형 컨트롤 동작의 아키텍처 개요</related>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderingCompatibility : Version with get, set" Usage="System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>렌더링된 HTML이 호환될 ASP.NET 버전을 지정하는 값을 가져옵니다.</summary>
        <value>렌더링된 HTML이 호환될 ASP.NET 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET이이 속성의 값을 설정 합니다 `controlRenderingCompatibilityVersion` 특성을 `pages` Web.config 파일의 요소. 경우는 `controlRenderingCompatibilityVersion` Web.config 파일에서 특성을 설정 하지 않으면, 기본값은 현재 버전의 ASP.NET입니다.  
  
> [!CAUTION]
>  이 속성에 대 한 공용 set 접근자는 없지만 set 접근자는.NET Framework 인프라를 지원 하며 코드에서 직접 사용할 수 없습니다. 코드에서이 값을 설정 하는 경우 효과 예측 가능한 아닙니다.  
  
 각 릴리스의 ASP.NET 이전 버전에서 다르게 HTML을 렌더링 될 수 있습니다. ASP.NET 3.5의 예를 들어, 경우를 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> 의 속성을 <xref:System.Web.UI.WebControls.Label> 컨트롤은 `false`, 기본적으로 ASP.NET는 다음과 같이 렌더링 됩니다.를 `span` 요소입니다 `disabled` 특성은 "disabled"로 설정 합니다. 기본적으로 ASP.NET 4에는 `span` 연계 스타일 시트 (CSS)를 사용 하 여 요소가 렌더링 됩니다 `class` 특성 대신는 `disabled` 특성. 이 비활성화 된 컨트롤의 모양을 지정할 수 있습니다 하 고 잘못 된 HTML 렌더링 방지 됩니다. (HTML 4.0 및 XHTML 1.1 합니다 `span` 요소를 지원 하지 않습니다는 `disabled` 특성입니다.)  
  
 웹 응용 프로그램 HTML 렌더링을 변경 하는 경우 제대로 작동 하지는 코드를 포함할 수 있습니다. 이 문제를 방지 하려면 설정할 수 있습니다는 `controlRenderingCompatibilityVersion` 특성을 `pages` 호환성을 유지 하려면 이전 버전을 나타내기 위해 Web.config 파일의 요소입니다. 예를 들어, 설정 하는 경우는 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 속성을 `3.5`, 비활성화 된 <xref:System.Web.UI.WebControls.Label> 컨트롤 렌더링 됩니다는 `disabled` 특성 및 CSS 클래스가 아닙니다.  
  
> [!NOTE]
>  이 속성을 설정할 수 있는 가장 오래 된 버전은 `3.5`합니다.  
  
 파일을 Visual Studio를 사용 하 여 이전 버전에서 ASP.NET 4로 웹 프로젝트를 업그레이드 하는 경우 이전 버전과 호환성을 유지 하려면 Visual Studio를 자동으로 설정 합니다 `controlRenderingCompatibilityVersion` Web.config 파일의 특성 `3.5`합니다. ASP.NET 4에 도입 된 알고리즘을 사용 하 여 HTML을 렌더링 하는 업그레이드 된 웹 사이트를 하려는 경우에 변경 하거나 제거할 수 있습니다는 `controlRenderingCompatibilityVersion` 특성입니다.  
  
 대부분의 경우이 속성에 의해 제어 동작은 자동 및 검사할 필요가 없습니다를 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 코드에서 속성입니다. 그러나 사용자 지정 컨트롤을 프로그래밍 하는 경우이 속성의 설정에 따라 컨트롤의 동작을 변경 하는 코드를 포함 해야 할 수도 있습니다. 예를 들어, ASP.NET 4에 대 한 사용자 지정 컨트롤을 구성 될 수 <xref:System.Web.UI.WebControls.Label> 컨트롤 및 사용자 지정 컨트롤 변경 하는 JavaScript 코드를 생성 하 여 비활성화 된 컨트롤의 모양을 지정할 수는 `aspNetDisabled` 클래스입니다. 이 경우 예상된 대로 작동 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 는 `4.0` 이상. 하면 동일한를 가져오려고 하지만 적용 <xref:System.Web.UI.Control.RenderingCompatibility%2A> 는 `3.5`, 사용자 지정 컨트롤의 코드는 컨트롤을 설정 해야 합니다 `CssClass` 속성을 "aspNetDisabled" 경우를 <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> 속성이 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberSignature Language="F#" Value="abstract member ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter&#xA;override this.ResolveAdapter : unit -&gt; System.Web.UI.Adapters.ControlAdapter" Usage="control.ResolveAdapter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>지정된 컨트롤을 렌더링하는 컨트롤 어댑터를 가져옵니다.</summary>
        <returns>컨트롤을 렌더링하는 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 광범위 한 장치에서 웹 페이지를 요청을 처리할 수 있는 ASP.NET 웹 페이지는 볼 수 있습니다. <xref:System.Web.UI.Control.ResolveAdapter%2A> 메서드 컨트롤 어댑터를 반환 해야 ASP.NET 페이지를 요청 하는 특정 브라우저 또는 장치에 컨트롤을 렌더링에 대 한 합니다.  
  
 반환 되는 특정 어댑터 형식의 하위 형식에 따라 달라 집니다는 <xref:System.Web.UI.Control> 렌더링 되는 클래스입니다.  
  
 어댑터에 대 한 자세한 내용은 참조 하세요. [아키텍처 개요의 적응형 컨트롤 동작](https://docs.microsoft.com/previous-versions/aspnet/67276kc5(v=vs.100))합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="abstract member ResolveClientUrl : string -&gt; string&#xA;override this.ResolveClientUrl : string -&gt; string" Usage="control.ResolveClientUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">현재 페이지에 대한 상대 URL입니다.</param>
        <summary>브라우저에 사용할 수 있는 URL을 가져옵니다.</summary>
        <returns>브라우저에서 사용할 수 있는 지정된 리소스의 정규화된 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 메서드가 반환 URL 문자열을 사용 하기 적합 한 클라이언트에서 리소스에 액세스할 웹 서버의 이미지 파일과 같은 추가 페이지에 연결 합니다.  
  
> [!NOTE]
>  이 메서드에서 반환 된 URL의 컨트롤을 인스턴스화하는 소스 파일을 포함 하는 폴더에 상대적입니다. 이 속성을 같은 상속 된 컨트롤 <xref:System.Web.UI.UserControl> 및 <xref:System.Web.UI.MasterPage>, 컨트롤을 기준으로 정규화 된 URL을 반환 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" />가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberSignature Language="F#" Value="member this.ResolveUrl : string -&gt; string" Usage="control.ResolveUrl relativeUrl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl"><see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> 속성과 관련된 URL입니다.</param>
        <summary>URL을 요청 클라이언트에서 사용할 수 있는 URL로 변환합니다.</summary>
        <returns>변환된 URL입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 `relativeUrl` 절대 URL을 포함 하는 매개 변수를 URL은 변경 하지 않고 반환 합니다. 경우는 `relativeUrl` 상대 URL을 포함 하는 매개 변수, URL이 브라우저는 URL을 확인할 수 있도록 현재 요청 경로 대해 잘못 된 상대 URL로 변경 됩니다.  
  
 예를 들어 다음 시나리오를 고려할 수 있습니다.  
  
-   클라이언트는 연결 된 이미지가 있는 사용자 지정 컨트롤이 포함 된 ASP.NET 페이지를 요청 했습니다.  
  
-   ASP.NET 페이지는 /Store/page1.aspx에 있습니다.  
  
-   사용자 정의 컨트롤은 /Store/UserControls/UC1.ascx에 있습니다.  
  
-   이미지 파일은 /UserControls/Images/Image1.jpg에 있습니다.  
  
 사용자 정의 컨트롤의 상대 경로 (즉, /Store/UserControls/Images/Image1.jpg) 이미지를 전달 하는 경우는 <xref:System.Web.UI.Control.ResolveUrl%2A> 메서드를 메서드/images/image1.jpg 값을 반환 합니다.  
  
 이 메서드는 사용 된 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 절대 URL을 확인할 속성입니다. 반환 된 URL은 클라이언트 사용 됩니다.  
  
 웹 사이트의 리소스 경로에 대 한 자세한 내용은 참조 하세요. [ASP.NET 웹 프로젝트 경로](https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd)합니다.  
  
> [!NOTE]
>  모바일 웹 페이지와 응용 프로그램이 쿠키 없는 세션에 의존 하거나 쿠키 없는 세션을 필요로 하는 모바일 브라우저에서 요청을 받을 수, 하는 경우 사용 하 여 물결표 ("\~") 경로 새 세션을 만드는 실수로 발생할 수 있습니다 및 세션 데이터를 잠재적으로 손실 됩니다. 와 같은 경로 사용 하 여 속성을 설정 하려면 "\~/*경로"* 를 호출 하 여 경로 확인 합니다 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> 와 같은 인수를 사용 하 여 "\~/*경로"* 속성에 할당 합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.UI.WebControls.Image> 웹 서버 컨트롤 개체 및 사용 합니다 <xref:System.Web.UI.Control.ResolveUrl%2A> 하 여 저장 된 이미지에 경로 설정 하는 메서드는 <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> 속성.  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeUrl" /> 매개 변수에 <see langword="null" />이 들어 있으면 발생하는 경우</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
        <related type="Article" href="https://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd">ASP.NET 웹 사이트 경로</related>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveControlState : unit -&gt; obj&#xA;override this.SaveControlState : unit -&gt; obj" Usage="control.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>페이지가 서버에 다시 게시된 후 발생한 서버 컨트롤 상태의 변경을 저장합니다.</summary>
        <returns>서버 컨트롤의 현재 상태를 반환합니다. 컨트롤과 연결된 상태가 없으면 이 메서드가 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.Control.SaveControlState%2A> 특정 컨트롤의 작업에 필요한 상태 정보를 저장 하는 방법입니다. 이 컨트롤 상태 데이터는 컨트롤의 뷰 상태 데이터를 개별적으로 저장 됩니다.  
  
 컨트롤 상태를 사용 하 여 사용자 지정 컨트롤을 호출 해야 합니다는 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 메서드는 <xref:System.Web.UI.Control.Page%2A> 컨트롤 상태를 저장 하기 전에 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 재정의 <xref:System.Web.UI.Control.SaveControlState%2A> 사용자 지정 ASP.NET 컨트롤에서 메서드. 이 메서드가 호출 되 면 확인 여부를 내부 속성이 `currentIndex` 기본이 아닌 값으로 설정 됩니다 하 고 그렇다면 컨트롤 상태 값을 저장 합니다.  
  
 <xref:System.Web.UI.Control.OnInit%2A> 메서드를 호출 하도록 재정의 됩니다는 <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> 메서드를 <xref:System.Web.UI.Control.Page%2A> 를 나타내는 사용자 지정 컨트롤에서 컨트롤 상태를 사용 하 합니다.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>HTML에 저장 된 변수로 문자열 개체를 클라이언트에 반환 컨트롤 상태를 저장 하면 <see langword="HIDDEN" /> 요소입니다. 컨트롤에서 사용 하 여 상태 정보를 추출 하려면이 메서드를 재정의 합니다.  
  
컨트롤 상태는 적은 양의 페이지 인덱스 또는 키워드와 같은 중요 한 데이터를 위한 것입니다. 컨트롤 상태를 사용 하 여 많은 양의 데이터에 대 한 페이지 성능이 저하 될 수 있습니다. 자세한 내용은 [ASP.NET 상태 관리 개요](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))합니다.</para></block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 상태 관리 개요</related>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveViewState : unit -&gt; obj&#xA;override this.SaveViewState : unit -&gt; obj" Usage="control.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>페이지가 서버에 다시 게시된 이후 발생한 서버 컨트롤 뷰 상태의 변경을 저장합니다.</summary>
        <returns>서버 컨트롤의 현재 뷰 상태를 반환합니다. 컨트롤과 연결된 뷰 상태가 없으면 이 메서드는 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 뷰 상태는 서버 컨트롤의 속성 값의 누적 된 것입니다. 이러한 값은 자동으로 서버 컨트롤의 배치 <xref:System.Web.UI.Control.ViewState%2A> 인스턴스인 속성의는 <xref:System.Web.UI.StateBag> 클래스. 그런 다음이 속성의이 값은 상태 저장 서버 컨트롤 수명 주기의 단계 후에 문자열 개체를 유지 합니다. 자세한 내용은 [ASP.NET 페이지 수명 주기 개요](https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)합니다.  
  
 HTML에 저장 된 변수로 문자열 개체가이 클라이언트에 반환 뷰 상태가 저장 되 면 `HIDDEN` 요소입니다. 사용 하 여 뷰 상태를 사용자 지정 뷰 상태를 사용 하 여 사용자 지정 서버 컨트롤을 만들 때 명시적으로 관리할 수 있습니다 합니다 <xref:System.Web.UI.Control.SaveViewState%2A> 고 <xref:System.Web.UI.Control.LoadViewState%2A> 메서드. 자세한 내용은 [ASP.NET 상태 관리 개요](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))합니다. 사용자 지정 세션 상태 공급자 구현에 대 한 내용은 참조 하세요 [세션 상태 저장소 공급자 구현](https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66)합니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.SaveViewState%2A> 사용자 지정 ASP.NET 서버 컨트롤의 메서드. 컨트롤에 자식 컨트롤이 있는지 여부를 결정이 메서드를 호출 하면 포함 하는 <xref:System.Web.UI.Page> 포스트백의 결과인 개체입니다. 모두 true 인 경우 변경 합니다 <xref:System.Web.UI.WebControls.Label.Text%2A> 의 속성을 <xref:System.Web.UI.WebControls.Label> 웹 서버 컨트롤을 읽기 `Custom Control Has Saved State`. 그런 다음 컨트롤의 뷰 상태를 명명 된 개체의 배열로 저장 `allStates`합니다.  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 상태 관리 개요</related>
        <related type="Article" href="https://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66">세션 상태 저장소 공급자 구현</related>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetDesignModeState : System.Collections.IDictionary -&gt; unit&#xA;override this.SetDesignModeState : System.Collections.IDictionary -&gt; unit" Usage="control.SetDesignModeState data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">컨트롤의 디자인 타임 데이터가 들어 있는 <see cref="T:System.Collections.IDictionary" />입니다.</param>
        <summary>컨트롤에 대한 디자인 타임 데이터를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.SetDesignModeState%2A> 메서드는 컨트롤에 대 한 디자인 타임 데이터를 저장 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>사용자 컨트롤에 필요한 디자인 타임 데이터를 저장 하려면이 메서드를 재정의 해야 합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberSignature Language="F#" Value="member this.SetRenderMethodDelegate : System.Web.UI.RenderMethod -&gt; unit" Usage="control.SetRenderMethodDelegate renderMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">서버 컨트롤을 렌더링할 수 있도록 대리자에게 전달할 필수 정보입니다.</param>
        <summary>이벤트 처리기 대리자를 할당하여 서버 컨트롤과 그 콘텐츠를 부모 컨트롤로 렌더링합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 구현 으로만;에 대 한 제공 되며 호출 하지 말아야 직접.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>디자인 시간 렌더링 데이터 추적을 위한 추적 데이터를 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj -&gt; unit" Usage="control.SetTraceData (traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">추적 데이터 키입니다.</param>
        <param name="traceDataValue">추적 데이터 값입니다.</param>
        <summary>추적 데이터 키와 추적 데이터 값을 사용하여 렌더링 데이터의 디자인 타임 추적을 위한 추적 데이터를 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberSignature Language="F#" Value="member this.SetTraceData : obj * obj * obj -&gt; unit" Usage="control.SetTraceData (tracedObject, traceDataKey, traceDataValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataKey" Type="System.Object" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="traceDataValue" Type="System.Object" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="tracedObject">추적된 개체입니다.</param>
        <param name="traceDataKey">추적 데이터 키입니다.</param>
        <param name="traceDataValue">추적 데이터 값입니다.</param>
        <summary>추적 개체, 추적 데이터 키와 추적 데이터 값을 사용하여 렌더링 데이터의 디자인 타임 추적을 위한 추적 데이터를 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디자인 화면에서 렌더링될 때 현재 컨트롤을 호스팅하는 컨테이너 관련 정보를 가져옵니다.</summary>
        <value>컨트롤이 호스팅되는 컨테이너에 관련된 정보가 포함된 <see cref="T:System.ComponentModel.ISite" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사이트에 바인딩합니다를 <xref:System.ComponentModel.Component> 개체를 <xref:System.ComponentModel.Container> 개체 및 둘 간의 통신을 사용 하도록 설정 합니다. 또한 컨테이너에서 해당 구성 요소를 관리할 수 있는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">컨트롤이 <see cref="T:System.Web.UI.WebControls.Substitution" /> 컨트롤인 경우</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 적용할 스킨을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 적용할 스킨의 이름입니다. 기본값은 <see cref="F:System.String.Empty" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스킨을 컨트롤에서 사용 가능한 테마 디렉터리에 하나 이상의 스킨 파일에 포함 됩니다. <xref:System.Web.UI.Control.SkinID%2A> 속성 컨트롤에 적용 하려면 이러한 스킨 지정 합니다. 특정 컨트롤에 스킨을 관련이 다른 유형의 컨트롤 간의 스킨 설정을 공유할 수 없습니다.  
  
 설정 하지 않으면 경우는 <xref:System.Web.UI.Control.SkinID%2A> 속성, 컨트롤을 사용 하 여 기본 스킨이 정의 된 경우. 예를 들어 없이 스킨 ID가에 대 한 정의 <xref:System.Web.UI.WebControls.Image> 컨트롤을 모두 스킨이 적용 됩니다 <xref:System.Web.UI.WebControls.Image> 컨트롤 ID로 스킨을 명시적으로 참조 하지 않는 및 테마를 사용 하지 않도록 설정 하려면 설정 되지 않은 합니다. 스킨 ID 사용 하 여 정의 된 경우는 <xref:System.Web.UI.WebControls.Image> 컨트롤 스킨이만 적용 됩니다 <xref:System.Web.UI.WebControls.Image> 컨트롤 <xref:System.Web.UI.Control.SkinID%2A> 속성은 해당 id와 같습니다.  
  
 지정 된 스킨이 테마 디렉터리의 스킨 파일에 없는 경우 <xref:System.Web.UI.Control.SkinID%2A> 속성에는 <xref:System.ArgumentException> 런타임 시 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">스타일시트가 이미 적용된 경우  
  
또는 
<see langword="Page_PreInit" /> 이벤트가 이미 발생한 경우  
  
또는 
컨트롤이 <see langword="Controls" /> 컬렉션에 이미 추가된 경우</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
        <related type="Article" href="https://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3">ASP.NET 테마 개요</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System::Web::UI::IControlBuilderAccessor::ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />를 참조하십시오.</summary>
        <value>컨트롤을 빌드한 <see cref="T:System.Web.UI.ControlBuilder" />이거나, 작성기가 사용되지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IControlBuilderAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />를 참조하십시오.</summary>
        <returns>컨트롤 상태의 <see cref="T:System.Collections.IDictionary" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IControlDesignerAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="data">컨트롤의 디자인 타임 데이터가 들어 있는 <see cref="T:System.Collections.IDictionary" />입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />를 참조하십시오.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IControlDesignerAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="owner">컨트롤의 소유자입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />를 참조하십시오.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IControlDesignerAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 <xref:System.Web.UI.IControlDesignerAccessor> 인터페이스 컨트롤에 디자인 타임 동작을 수행 하는 컨트롤 디자이너에서 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="owner" />가 현재 컨트롤로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System::Web::UI::IControlDesignerAccessor::UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />를 참조하십시오.</summary>
        <value>컨트롤에 대한 정보가 포함된 <see cref="T:System.Collections.IDictionary" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IControlDesignerAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System::Web::UI::IDataBindingsAccessor::DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />를 참조하십시오.</summary>
        <value>데이터 바인딩의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IDataBindingsAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IDataBindingsAccessor::HasDataBindings { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />를 참조하십시오.</summary>
        <value>컨트롤에 데이터 바인딩 논리가 포함되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IDataBindingsAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System::Web::UI::IExpressionsAccessor::Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />를 참조하십시오.</summary>
        <value>컨트롤의 속성과 식을 나타내는 <see cref="T:System.Web.UI.ExpressionBindingCollection" /> 개체가 들어 있는 <see cref="T:System.Web.UI.ExpressionBinding" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IExpressionsAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IExpressionsAccessor::HasExpressions { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />를 참조하십시오.</summary>
        <value>컨트롤에 식을 통해 설정된 속성이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IExpressionsAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">추가할 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />를 참조하십시오.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.Control> 인스턴스가 <xref:System.Web.UI.IParserAccessor> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TemplateControl : System.Web.UI.TemplateControl with get, set" Usage="System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤이 포함된 템플릿의 참조를 가져오거나 설정합니다.</summary>
        <value>이 컨트롤이 포함된 <see cref="T:System.Web.UI.TemplateControl" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.Control> 인스턴스가 컨트롤 템플릿의 일부인는 <xref:System.Web.UI.Control.TemplateControl%2A> 속성 포함 하는 컨트롤에 대 한 참조를 포함 합니다. 자세한 내용은 참조는 <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> 설명서.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplateSourceDirectory : string" Usage="System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.Page" /> 또는 현재 서버 컨트롤이 들어 있는 <see cref="T:System.Web.UI.UserControl" />의 가상 디렉터리를 가져옵니다.</summary>
        <value>페이지 또는 서버 컨트롤이 들어 있는 사용자 정의 컨트롤의 가상 디렉터리입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 속성 현재 컨트롤이 포함 된 페이지 또는 사용자 정의 컨트롤에 대 한 경로 지정 합니다. 예를 들어, 웹 페이지에 있는 경우 http://www.contoso.com/application/subdirectory, <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 속성 "application/하위"를 반환 합니다.  
  
 응용 프로그램에 상대적인 가상 경로를 반환 ("~ / 하위")를 사용 하 여는 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> 속성을 두 번입니다. 처음으로 사용 됩니다는 <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> 컨트롤이 상주 하는 디렉터리의 경로를 가져오는 메서드를 호출 합니다. 두 번째에 있는 <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> 메서드 호출의 해당 디렉터리 내에 포함 된 모든 파일 목록을 가져올 수 있습니다.  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberSignature Language="F#" Value="abstract member TrackViewState : unit -&gt; unit&#xA;override this.TrackViewState : unit -&gt; unit" Usage="control.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버 컨트롤의 뷰 상태 변경 사항 추적 작업을 실행하여 서버 컨트롤의 <see cref="T:System.Web.UI.StateBag" /> 개체에 변경 사항이 저장되도록 합니다. 이 개체는 <see cref="P:System.Web.UI.Control.ViewState" /> 속성을 통해 액세스할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 자동으로 끝날 때의 <xref:System.Web.UI.Control.Init> 서버 컨트롤의 수명 주기 이벤트입니다.  
  
 템플릿 기반 데이터 바인딩된 컨트롤을 개발 하는 경우이 메서드를 호출 합니다. 이 메서드를 재정의 하는 경우 필수 항목인 서버 컨트롤의 뷰 상태 변경 사항을 모니터링 하는 ASP.NET 경고는 <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 재정의 <xref:System.Web.UI.Control.DataBind%2A> 사용자 지정 ASP.NET 서버 컨트롤의 메서드. 기본을 호출 하 여 시작 <xref:System.Web.UI.Control.OnDataBinding%2A> 메서드를 사용 합니다 <xref:System.Web.UI.ControlCollection.Clear%2A> 모든 자식 컨트롤을 삭제 하는 방법 및 <xref:System.Web.UI.Control.ClearChildViewState%2A> 메서드를 삭제 하는 모든 해당 자식 컨트롤의 뷰 상태 설정을 저장 합니다. 마지막으로, 합니다 <xref:System.Web.UI.Control.ChildControlsCreated%2A> 속성이 `true`합니다. 컨트롤을 사용 하 여는 <xref:System.Web.UI.Control.IsTrackingViewState%2A> 속성을 컨트롤에 대 한 뷰 상태 변경 내용 추적을 사용할 수 있는지 여부를 확인 합니다. 사용 하지 않는 경우는 <xref:System.Web.UI.Control.TrackViewState%2A> 메서드가 호출 됩니다.  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueID : string" Usage="System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤에 대해 계층적으로 정규화된 고유 식별자를 가져옵니다.</summary>
        <value>서버 컨트롤에 대한 정규화된 식별자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에서 다른 합니다 <xref:System.Web.UI.Control.ID%2A> 속성에는 <xref:System.Web.UI.Control.UniqueID%2A> 서버 컨트롤의 명명 컨테이너에 대 한 식별자를 포함 하는 속성. 이 식별자는 페이지 요청이 처리 될 때 자동으로 생성 됩니다.  
  
 이 속성은 반복 되는 데이터 바인딩 서버 컨트롤에 포함 된 서버 컨트롤을 구별 하는 데 특히 중요 합니다. 반복 되는 컨트롤 <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList>, <xref:System.Web.UI.WebControls.DetailsView>, <xref:System.Web.UI.WebControls.FormView>, 및 <xref:System.Web.UI.WebControls.GridView> 웹 서버 컨트롤 (또는 데이터 바인딩된 경우 반복 기능을 포함 하는 사용자가 만든 사용자 지정 서버 컨트롤) 역할을 합니다 명명 컨테이너의 자식에 대 한 컨트롤입니다. 즉,이 만들어지는 고유한 네임 스페이스를 해당 자식에 대 한 컨트롤을 해당 <xref:System.Web.UI.Control.ID%2A> 속성 값 충돌 하지 않습니다.  
  
 예를 들어, ASP.NET을 포함 하는 경우 <xref:System.Web.UI.WebControls.Label> 웹 서버 컨트롤을 <xref:System.Web.UI.WebControls.Repeater> 서버 컨트롤과 할당을 <xref:System.Web.UI.WebControls.Label> 컨트롤은 <xref:System.Web.UI.Control.ID%2A> 속성 값 `MyLabel`, 및 <xref:System.Web.UI.WebControls.Repeater> 는 <xref:System.Web.UI.Control.ID%2A> 의`MyRepeater`. 데이터를 바인딩하는 경우는 <xref:System.Web.UI.WebControls.Repeater> 에 <xref:System.Collections.ArrayList> 결과 세 가지 항목을 가진 개체 <xref:System.Web.UI.Control.UniqueID%2A> 의 각 인스턴스에 대 한 속성을 <xref:System.Web.UI.WebControls.Label> 서버 컨트롤은 `MyRepeater$ctl00$MyLabel`, `MyRepeater$ctl01$MyLabel`, 및 `MyRepeater$ctl02$MyLabel`.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Collections.ArrayList> 개체 하 고 세 개의 텍스트 문자열을 사용 하 여 채웁니다 바인딩하는 <xref:System.Web.UI.WebControls.Repeater> 웹 서버 컨트롤의 데이터에 <xref:System.Collections.ArrayList> 페이지가 로드 될 때. 코드는 <xref:System.Web.UI.Control.UniqueID%2A> 데이터 바인딩 중에 생성 된 각 자식 컨트롤의 속성입니다. 코드의 세 가지 버전을 생성 합니다 <xref:System.Web.UI.WebControls.Label> 컨트롤 및 쓰기 해당 `UniqueID` 페이지로 속성 값.  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : EventHandler " Usage="member this.Unload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>서버 컨트롤이 메모리에서 언로드될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤 최종 정리, 파일, 데이터베이스 연결을 닫는 개체 인스턴스를 언로드하기 직전에 컨트롤의 수명 주기 중이 단계에서 삭제 등을 수행 해야 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 소개</related>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>잠재적으로 위험한 값이 있는지 확인하기 위해 컨트롤에서 브라우저의 클라이언트 입력을 검사하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤이 클라이언트 입력을 확인하는지 여부를 결정하는 값입니다. 가능한 값은 <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> 및 <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />입니다. 기본값은 <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />입니다. 즉, 컨트롤은 부모로부터 값을 가져옵니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요청 유효성 검사에 대 한 자세한 내용은 참조 하세요. <xref:System.Web.UnvalidatedRequestValues>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewState : System.Web.UI.StateBag" Usage="System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>같은 페이지에 대한 여러 개의 요청 전반에 서버 컨트롤의 뷰 상태를 저장하고 복원할 수 있도록 하는 상태 정보 사전을 가져옵니다.</summary>
        <value>서버 컨트롤의 뷰 상태 정보가 들어 있는 <see cref="T:System.Web.UI.StateBag" /> 클래스의 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 서버 컨트롤의 뷰 상태는 모든 속성 값의 누적 된 것입니다. HTTP 요청에서 이러한 값을 유지 하기 위해 ASP.NET 서버 컨트롤이 사용이 속성을 인스턴스의 <xref:System.Web.UI.StateBag> 클래스, 속성 값을 저장 합니다. 그런 다음이 값은 후속 요청이 처리 될 때 HTML 숨겨진된 input 요소를 변수로 전달 됩니다. 서버 컨트롤의 뷰 상태를 저장 하는 방법에 대 한 자세한 내용은 참조 하세요. [ASP.NET 상태 관리 개요](https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100))합니다.  
  
 기본적으로 모든 서버 컨트롤의 보기 상태 사용 하지만 비활성화 하려고 있는 경우도 있습니다. 자세한 내용은 [ASP.NET 성능 개요](https://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b)합니다.  
  
 사전 및 사용 하는 방법에 대 한 정보를 참조 하세요 [컬렉션 및 데이터 구조](~/docs/standard/collections/index.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 구현 하는 방법을 보여 줍니다는 `Text` 저장 하 고 해당 컨트롤에서 해당 값을 검색 하는 속성 <xref:System.Web.UI.Control.ViewState%2A> 속성입니다.  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 상태 관리 개요</related>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateIgnoresCase : bool" Usage="System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.StateBag" /> 개체가 대/소문자를 구분하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.StateBag" /> 인스턴스가 대/소문자를 구분하지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대/소문자를 고려 하지 않고 해당 뷰 상태를 저장 하는 사용자 지정 서버 컨트롤을 만든 경우이 메서드를 재정의 합니다. 에 저장할 수 있으므로 여러 개체 키가 동일 하지만 다른 대/소문자를 사용 하 여 작업을 수행 하면를 <xref:System.Web.UI.StateBag> 연관 된 <xref:System.Web.UI.Control.ViewState%2A> 속성.  
  
   
  
## Examples  
 다음 예제에서는 재정의 하는 방법에 설명 합니다 <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> 반환할 속성 `true`합니다.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateMode : System.Web.UI.ViewStateMode with get, set" Usage="System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤의 뷰 상태 모드를 가져오거나 설정합니다.</summary>
        <value>이 컨트롤의 뷰 상태 모드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Web.UI.Control.ViewStateMode%2A> 속성 페이지의 뷰 상태를 비활성화 하는 경우에 개별 컨트롤의 뷰 상태를 사용 하도록 설정 합니다. 뷰 상태 및 컨트롤 상태에 대 한 자세한 내용은 참조는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성입니다.  
  
 페이지의 뷰 상태를 사용 하지 않도록 설정 하 고 페이지의 특정 컨트롤에 사용 하도록 설정 합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 페이지 및 컨트롤의 속성 `true`설정를 <xref:System.Web.UI.Control.ViewStateMode%2A> 속성 페이지의 <xref:System.Web.UI.ViewStateMode.Disabled>, 설정 및는 <xref:System.Web.UI.Control.ViewStateMode%2A> 속성을 컨트롤을 <xref:System.Web.UI.ViewStateMode.Enabled>입니다.  
  
 기본값은 <xref:System.Web.UI.Control.ViewStateMode%2A> 페이지에 대 한 속성이 <xref:System.Web.UI.ViewStateMode.Enabled>합니다. 기본값은 <xref:System.Web.UI.Control.ViewStateMode%2A> 페이지에서 웹 서버 컨트롤에 대 한 속성이 <xref:System.Web.UI.ViewStateMode.Inherit>합니다. 결과적으로 페이지 또는 페이지의 값은 컨트롤 수준에서이 속성을 설정 하지 않으면 경우는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성 뷰 상태 동작을 결정 합니다.  
  
 <xref:System.Web.UI.Control.ViewStateMode%2A> 페이지 또는 컨트롤의 속성이 경우에만 적용 합니다 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이 `true`합니다. 경우는 <xref:System.Web.UI.Control.EnableViewState%2A> 속성이로 설정 되어 `false`, 뷰 상태의 경우에도 해제 됩니다 합니다 <xref:System.Web.UI.Control.ViewStateMode%2A> 속성이 <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">이 속성을 <see cref="T:System.Web.UI.ViewStateMode" /> 열거형 이외의 값으로 설정하려고 한 경우</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <related type="Article" href="https://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce(v=vs.100)">ASP.NET 상태 관리 개요</related>
        <related type="Article" href="https://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818">ASP.NET 뷰 상태 개요</related>
        <related type="Article" href="https://msdn.microsoft.com/en-us/library/C90FA3D7-788A-47D2-A80F-138122A1D8EE">뷰 상태를 제어합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지에서 서버 컨트롤이 UI로 렌더링되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤이 페이지에 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 `false`, 서버 컨트롤 렌더링 되지 않습니다. 페이지의 레이아웃을 구성할 때이 점을 고려해 야 합니다.  
  
> [!NOTE]
>  컨테이너 컨트롤 렌더링 되지 않습니다 하는 경우 포함 된 모든 컨트롤 렌더링 되지 것입니다. 설정 하는 경우에 합니다 <xref:System.Web.UI.Control.Visible%2A> 는 개별 컨트롤의 속성 `true`합니다. 개별 컨트롤 반환 하는 경우 `false` 에 대 한 합니다 <xref:System.Web.UI.Control.Visible%2A> 가 명시적으로 설정한 경우에 속성 `true`합니다. (즉, 합니다 `Visible` 부모 컨트롤의 속성이 `false`, 자식 컨트롤에 해당 설정을 상속 하 고 설정을 모든 로컬 설정 보다 우선 합니다.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>