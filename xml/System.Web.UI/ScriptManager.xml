<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4cf22665a19a92d8f68797a3118b5e9283b6d953" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53223892" /></Metadata><TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler, System.Web.UI.IScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler, class System.Web.UI.IScriptManager" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler, IScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler, System::Web::UI::IScriptManager" />
  <TypeSignature Language="F#" Value="type ScriptManager = class&#xA;    inherit Control&#xA;    interface IPostBackDataHandler&#xA;    interface IPostBackEventHandler&#xA;    interface IScriptManager" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IScriptManager</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET AJAX 스크립트 라이브러리 및 스크립트 파일, 부분 페이지 렌더링, 웹 및 응용 프로그램 서비스에 대한 클라이언트 프록시 클래스 생성을 관리합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목 내용:  
  
-   [소개](#introduction)  
  
-   [부분 페이지 렌더링](#partial_page_rendering)  
  
-   [ScriptManager 컨트롤을 사용 하 여 마스터 페이지, 사용자 컨트롤 및 기타 하위 구성 요소를 사용 하 여](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [스크립트 관리 및 등록](#script_management_and_registration)  
  
-   [웹 서비스 참조](#web_service_references)  
  
-   [지역화](#localization)  
  
-   [오류 처리](#error_handling)  
  
-   [선언 구문](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>소개  
 <xref:System.Web.UI.ScriptManager> 컨트롤은 ASP.NET의 Ajax 기능 중앙입니다. 컨트롤을 페이지에 있는 모든 ASP.NET Ajax 리소스를 관리합니다. 여기에 브라우저에 Microsoft Ajax Library 스크립트를 다운로드 하 고 사용 하 여 사용할 수 있는 부분 페이지 업데이트를 조정 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다. 또한는 <xref:System.Web.UI.ScriptManager> 컨트롤을 사용 하면 다음을 수행할 수 있습니다.  
  
-   부분 페이지 업데이트와 호환 되는 스크립트를 등록 합니다. 스크립트 및 핵심 라이브러리 간에 종속성을 관리 하기 위해 등록 하는 모든 스크립트는 Microsoft Ajax Library 스크립트 후 로드 됩니다.  
  
-   지정 여부 릴리스 또는 디버그 스크립트를 브라우저에 전송 됩니다.  
  
-   웹 서비스 메서드를 사용 하 여 웹 서비스를 등록 하 여 스크립트에서 액세스할 수 있도록는 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
-   이러한 서비스를 등록 하 여 클라이언트 스크립트에서 응용 프로그램 서비스 ASP.NET 인증, 역할 및 프로필에 대 한 액세스를 제공 합니다 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
-   브라우저에서 함수와 ECMAScript (JavaScript), 문화권별 표시를 사용 합니다.  
  
-   사용 하 여 포함 된 스크립트 파일 또는 독립 실행형 스크립트 파일에 대 한 지역화 리소스에 액세스를 <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> 의 속성을 <xref:System.Web.UI.ScriptReference> 컨트롤입니다.  
  
-   구현 하는 서버 컨트롤 등록 합니다 <xref:System.Web.UI.IExtenderControl> 또는 <xref:System.Web.UI.IScriptControl> 와 상호 작용는 <xref:System.Web.UI.ScriptManager> 클라이언트 구성 요소 및 동작에 필요한 스크립트는 렌더링 되도록 합니다.  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>부분 페이지 렌더링  
 부분 페이지 렌더링을 지 원하는 ASP.NET 페이지의 기능이 다음 요인에 의해 제어 됩니다.  
  
-   합니다 <xref:System.Web.UI.ScriptManager> 컨트롤의 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 속성이 있어야 `true` (기본값).  
  
-   하나 이상 있어야 <xref:System.Web.UI.UpdatePanel> 페이지의 컨트롤입니다.  
  
-   합니다 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 속성이 있어야 `true` (기본값). 경우는 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 속성이 명시적으로 설정 되지 않은 경우, 해당 값은 브라우저의 기능에 기반 합니다.  
  
 값을 재정의할 수는 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 속성 중 또는 페이지의 이전에 런타임에 <xref:System.Web.UI.Control.Init> 이벤트입니다. 페이지의이 속성을 변경 하려고 하면 <xref:System.Web.UI.Control.Init> 이벤트가 발생 했음을 <xref:System.InvalidOperationException> 예외가 throw 됩니다.  
  
 부분 페이지 렌더링에 지원 되는 경우는 <xref:System.Web.UI.ScriptManager> 컨트롤이 비동기 포스트백과 부분 페이지 업데이트를 사용 하도록 설정 하는 스크립트를 렌더링 합니다. 업데이트 페이지의 일부를 사용 하 여 지정 된 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다. <xref:System.Web.UI.ScriptManager> 컨트롤이 비동기 포스트백을 처리 하 고 업데이트 해야 페이지의 영역만 새로 고칩니다. 부분 페이지 렌더링에 대 한 자세한 내용은 참조 하세요. [부분 페이지 렌더링 개요](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)합니다. 업데이트를 유도 하는 조건에 대 한 자세한 내용은 참조 하세요. [UpdatePanel 컨트롤 개요](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a)합니다.  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>ScriptManager 컨트롤을 사용 하 여 마스터 페이지, 사용자 컨트롤 및 기타 하위 구성 요소를 사용 하 여  
 페이지를 하나만 포함할 수 있습니다 <xref:System.Web.UI.ScriptManager> 해당 계층 구조에서 제어 합니다. 부모 페이지에 이미 있는 경우 서비스 및 중첩 된 페이지, 사용자 정의 컨트롤 또는 구성 요소에 대 한 스크립트를 등록 하는 <xref:System.Web.UI.ScriptManager> 컨트롤을 사용 하 여는 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다. 자세한 내용은 참조 하세요. [UpdatePanel 컨트롤을 사용 하 여 마스터 페이지를 사용 하 여](https://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>스크립트 관리 및 등록  
 <xref:System.Web.UI.ScriptManager> 컨트롤을 사용 하면 페이지의 일부로 다음 렌더링 되는 스크립트를 등록할 수 있습니다. <xref:System.Web.UI.ScriptManager> 컨트롤 등록 메서드를 다음 세 가지 범주로 나눌 수 있습니다.  
  
-   Microsoft Ajax Library에 대 한 스크립트 종속성은 유지 되도록 보장 하는 메서드를 등록 합니다.  
  
-   등록 메서드는 Microsoft Ajax Library에 종속 되지 않지만와 호환 되는 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다.  
  
-   등록 메서드 작업을 지 원하는 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다.  
  
 만들고 ASP.NET에서 Ajax 스크립트를 사용 하는 방법에 대 한 자세한 내용은 참조 하세요. [Microsoft Ajax Library를 사용 하 여 사용자 지정 클라이언트 스크립트를 만드는](https://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899)합니다.  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>Microsoft Ajax Library에 종속 된 스크립트를 등록 합니다.  
 Microsoft Ajax Library에 대 한 모든 종속성은 유지 되도록 보장 하는 방식으로 스크립트 파일을 등록 하려면 다음 메서드를 사용할 수 있습니다.  
  
|메서드|정의|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|구현 하는 서버 컨트롤을 등록 합니다 <xref:System.Web.UI.IScriptControl> 클라이언트 개체를 정의 하는 데 사용 되는 인터페이스입니다. <xref:System.Web.UI.ScriptManager> 컨트롤이 클라이언트 개체를 지 원하는 스크립트를 렌더링 합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|구현 하는 서버 컨트롤을 등록 합니다 <xref:System.Web.UI.IExtenderControl> 클라이언트 개체를 정의 하는 데 사용 되는 인터페이스입니다. <xref:System.Web.UI.ScriptManager> 컨트롤이 클라이언트 개체를 지 원하는 스크립트를 렌더링 합니다.|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>부분 페이지 업데이트 호환 스크립트를 등록합니다.  
 다음 메서드를 사용 하 여 Microsoft Ajax Library에 종속 되지 않은 하지만와 호환 되는 스크립트 파일을 등록 하려면 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다. 유사한 메서드에 해당 하는 이러한 메서드는 <xref:System.Web.UI.ClientScriptManager> 제어 합니다. 렌더링 스크립트 내에서 사용할 경우는 <xref:System.Web.UI.UpdatePanel> 컨트롤의 메서드를 호출 하는 선택 되어 있는지 확인 합니다는 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
|메서드|정의|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|JavaScript 배열 값을 추가합니다. 배열 존재 하지 않는 경우 만들어집니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|렌더링 된 `script` 페이지를 연 후 요소 `<form>` 태그입니다. 스크립트는 문자열 매개 변수로 지정 됩니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|렌더링 된 `script` 페이지를 연 후 요소 `<form>` 태그입니다. 스크립트 콘텐츠를 설정 하 여 지정 된 `src` 특성 스크립트 파일을 가리키는 URL을 합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|렌더링 된 `script` 페이지를 연 후 요소 `<form>` 태그입니다. 스크립트 콘텐츠 어셈블리 리소스 이름으로 지정 됩니다. `src` 어셈블리에서 명명된 된 스크립트를 검색 하는 HTTP 처리기를 호출 하 여 URL을 사용 하 여 특성은 자동으로 채워집니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|지정 된 컨트롤을 태그에는 사용자 지정 이름/값 특성 쌍 (expando)를 렌더링합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|숨겨진된 필드를 렌더링합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|대 한 응답으로 실행 되는 스크립트를 등록 합니다 `form` 요소의 `submit` 이벤트입니다. `onSubmit` 특성에 지정 된 스크립트를 참조 합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|페이지의 닫기 직전에 시작 스크립트 블록을 렌더링 `</form>` 태그입니다. 스크립트를 렌더링 하는 문자열 매개 변수로 지정 됩니다.|  
  
 메서드를 등록 하면 해당 스크립트에 대 한 형식/키 쌍을 지정 합니다. 동일한 형식/키 쌍을 사용 하 여 스크립트를 이미 등록 되어 새 스크립트 등록 되지 않았습니다. 마찬가지로, 이미 있는 형식/리소스 이름 쌍을 사용 하 여 스크립트를 등록 하는 경우 존재 합니다 `script` 리소스를 참조 하는 요소는 다시 추가 되지 않습니다. 이전에 등록 된 특성의 expando 특성을 등록 하면 예외가 throw 됩니다. 배열 값의 중복 등록 허용 됩니다.  
  
 호출 하는 경우는 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 또는 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 메서드를 인라인 함수를 실행 하는 스크립트를 등록 하지 않도록 합니다. 이벤트 처리기와 같이 함수 정의 또는 응용 프로그램에 대 한 사용자 지정 클래스 정의가 포함 된 스크립트를 등록 합니다.  
  
### <a name="registration-methods-for-updatepanel-controls"></a>UpdatePanel 컨트롤에 대 한 등록 메서드  
 다음 방법을 사용 하 여 사용 하는 경우 부분 페이지 업데이트를 사용자 지정할 수 있습니다 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다.  
  
|메서드|정의|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|컨트롤을 비동기 포스트백의 트리거로 등록합니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|부분 페이지 렌더링 도중 사용자 지정 데이터를 컨트롤로 보냅니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|내에 있는 컨트롤에 대 한 삭제 스크립트를 등록 한 <xref:System.Web.UI.UpdatePanel> 제어 합니다. 스크립트는 <xref:System.Web.UI.UpdatePanel> 컨트롤이 업데이트되거나 삭제될 때 실행됩니다. Dispose 메서드는 Microsoft Ajax Library의 일부 이며 구성 요소는 더 이상 사용 하는 경우 리소스를 해제 해야 하는 클라이언트 구성 요소에 사용 됩니다.|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|컨트롤 전체 포스트백의 트리거로 등록합니다. 이 메서드는 내부 컨트롤에 대 한 사용을 <xref:System.Web.UI.UpdatePanel> 비동기 포스트백을 수행 하는 컨트롤입니다.|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>웹 서비스 참조  
 만들어 클라이언트 스크립트에서 호출할 웹 서비스를 등록할 수 있습니다는 <xref:System.Web.UI.ServiceReference> 개체에 추가 하는 <xref:System.Web.UI.ScriptManager.Services%2A> 의 컬렉션을 <xref:System.Web.UI.ScriptManager> 컨트롤입니다. 각각에 대 한 ASP.NET 클라이언트 프록시 개체를 생성 <xref:System.Web.UI.ServiceReference> 개체는 <xref:System.Web.UI.ScriptManager.Services%2A> 컬렉션입니다. 프로그래밍 방식으로 추가할 수 있습니다 <xref:System.Web.UI.ServiceReference> 개체는 <xref:System.Web.UI.ScriptManager.Services%2A> 런타임 시 웹 서비스를 등록 하는 컬렉션입니다.  
  
 스크립트에서 웹 서비스에 액세스 하는 방법에 대 한 자세한 내용은 참조 하세요. [웹 서비스를 ASP.NET AJAX의 클라이언트 스크립트를 노출](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8) 하 고 [ASP.NET AJAX의 클라이언트 스크립트에서 웹 서비스 호출](https://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0)합니다.  
  
<a name="localization"></a>   
## <a name="localization"></a>지역화  
 <xref:System.Web.UI.ScriptManager> 컨트롤 어셈블리 또는 독립 실행형 스크립트 파일에 포함 된 스크립트 파일 중 하나는 적절 한 지역화 된 스크립트 파일을 가리키는 렌더링된 된 페이지에 대 한 참조를 생성 합니다.  
  
 경우는 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 속성이 `true`, <xref:System.Web.UI.ScriptManager> 있을 경우 컨트롤에서 현재 문화권에 대 한 지역화 된 리소스 (예: 지역화 된 문자열) 검색 합니다. <xref:System.Web.UI.ScriptManager> 컨트롤 지역화 된 리소스를 사용 하 여 다음 기능을 제공 합니다.  
  
-   **스크립트 어셈블리에 포함 된 파일**합니다. <xref:System.Web.UI.ScriptManager> 컨트롤 브라우저로 보낼 culture 별 또는 대체 문화권 스크립트 파일을 결정 합니다. 이렇게 하기 위해 문화권별을 사용 하 여 <xref:System.Resources.NeutralResourcesLanguageAttribute> 어셈블리 특성, (있는 경우)는 어셈블리와 브라우저의 UI 문화권을 사용 하 여 패키지 된 리소스입니다.  
  
-   **독립 실행형 스크립트 파일**합니다. <xref:System.Web.UI.ScriptManager> 컨트롤을 사용 하 여 지원 되는 UI 문화권의 목록 정의 <xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A> 의 속성을 <xref:System.Web.UI.ScriptReference> 개체입니다.  
  
-   **디버그 모드에서**합니다. <xref:System.Web.UI.ScriptManager> 컨트롤 디버그 정보를 포함 하는 culture 별 스크립트 파일을 렌더링 하려고 합니다. 예를 들어, 디버그 모드에서 페이지는 현재 문화권이로 설정 된 경우 컨트롤 렌더링와 같은 이름을 가진 스크립트 파일을 `scriptname`.en MX.debug.js, 파일이 있는 경우. 적절 한 대체 문화권에 대 한 디버그 파일 렌더링 되는 파일이 없으면  
  
 리소스를 지역화 하는 방법에 대 한 자세한 내용은 참조 하세요. [구성 요소 라이브러리 개요에 대 한 지역화 리소스](https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb)합니다.  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>오류 처리  
 비동기 포스트백 도중 페이지 오류가 발생 하는 경우는 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 이벤트가 발생 합니다. 서버의 오류가 클라이언트로 전송 되는 방식에 따라 달라 집니다 합니다 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을는 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 속성 및 Web.config 파일의 사용자 지정 오류 섹션. 자세한 내용은 [UpdatePanel 컨트롤에 대 한 오류 처리 사용자 지정](https://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0)합니다.  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>선언 구문  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 다음 예제에서는 표시 사용에 대 한 다양 한 시나리오는 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
 **부분 페이지 업데이트를 사용 하도록 설정**  
  
 다음 예제에서는 사용 하는 방법을 보여 줍니다는 <xref:System.Web.UI.ScriptManager> 부분 페이지 업데이트를 사용 하도록 제어 합니다. 이 예제는 <xref:System.Web.UI.WebControls.Calendar> 및 <xref:System.Web.UI.WebControls.DropDownList> 컨트롤 내에 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다. 기본적으로 값을 <xref:System.Web.UI.UpdatePanel.UpdateMode%2A> 속성은 <xref:System.Web.UI.UpdatePanelUpdateMode.Always>, 값과는 <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 속성은 `true`. 따라서 패널의 자식 컨트롤이 비동기 포스트백이 발생 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **부분 페이지 업데이트 오류 처리 및 스크립트를 등록 합니다.**  
  
 다음 예제에서는 사용자 지정 오류 부분 페이지 업데이트 하는 동안 처리를 제공 하는 방법을 보여 줍니다. 부분 페이지 업데이트 중에 오류가 발생 하는 경우에 기본적으로 JavaScript 메시지 상자가 표시 됩니다. 이 예제에서는 사용자 지정 오류에 대 한 처리기를 제공 하 여 처리를 사용 하는 방법에 설명 합니다 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 이벤트를 설정 하 고는 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 이벤트 처리기에서 속성. 설정할 수도 있습니다는 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 부분 페이지 업데이트 중에 오류가 발생 하는 경우 Web.config 파일의 사용자 지정 오류 섹션이 사용 되는 방법을 지정 하려면 속성입니다. 이 예제에서는 기본값인은 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을 사용 합니다. 이 Web.config 파일을 요소에 있으면 해당 요소는 결정 오류가 표시 되는 방식을 의미 합니다. 자세한 내용은 [customErrors 요소 (ASP.NET 설정 스키마)](https://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6)합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **브라우저에 표시 되는 시간과 날짜를 세계화**  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> 속성 클라이언트 스크립트는 브라우저에서 문화권별 날짜 및 시간을 표시할 수 있습니다. 예에서는 `Culture` 지시문의 특성이로 설정 된 `auto`합니다. 결과적으로, 첫 번째 언어에서 현재 브라우저 설정에 지정 된 문화권 및 UI 문화권 페이지를 결정 합니다. 자세한 내용은 [방법: ASP.NET 웹 페이지 세계화를 위한 문화권 및 UI 문화권 설정](https://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0)합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
    <related type="Article" href="https://msdn.microsoft.com/library/fceeb3c5-c59f-46a9-af4f-b0d7155a1efc">Sys.WebForms.PageRequestManager 클래스</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자에서 사용 되는 내부 필드를 초기화 합니다 <xref:System.Web.UI.ScriptManager> 페이지, 제어 및 배포 정보를 추적 하는 컨트롤입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>기록점을 만들어 브라우저의 기록 스택에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 메서드 오버 로드를 사용 하는 브라우저에서 서버 상태 및 필요에 따라 기록 항목의 제목을 정의할 수 있습니다. 기록 점을 만든 경우에 직렬화 되 고 암호화 된 데이터 웹 페이지의 URL로 추가 되 고 브라우저의 기록 스택에 항목이 포함 됩니다. 모든 후속 서버 탐색 이벤트가 발생할 때 페이지를 다시 만들를 상태 데이터를 사용할 수 있습니다. 자세한 내용은 [브라우저 기록 서버를 사용 하 여 컨트롤 관리](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : System.Collections.Specialized.NameValueCollection * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (state, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">상태에 대한 데이터를 포함하는 키/값 쌍의 컬렉션입니다.</param>
        <param name="title">브라우저의 기록 스택에 이 상태의 제목으로 추가될 텍스트입니다.</param>
        <summary>지정된 상태 데이터 컬렉션 및 상태 제목을 사용하여 기록점을 만들고 브라우저의 기록 스택에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태 데이터에 대해 둘 이상의 키/값 쌍을 저장 하려는 경우 기록 점을 만들려면이 메서드를 사용 합니다. 기록 점을 만든 경우에 직렬화 되 고 암호화 된 데이터 웹 페이지의 URL로 추가 되 고 브라우저의 기록 스택에 항목이 포함 됩니다. 경우는 `title` 매개 변수는 `null`, 웹 페이지의 제목이 기록 스택에 상태 항목의 제목으로 사용 됩니다.  
  
 모든 후속 서버 탐색 이벤트가 발생할 때 페이지를 다시 만들를 상태 데이터를 사용할 수 있습니다. 자세한 내용은 [브라우저 기록 서버를 사용 하 여 컨트롤 관리](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">웹 페이지의 상태를 식별하는 키/값 쌍의 키 부분입니다.</param>
        <param name="value">웹 페이지의 상태를 식별하는 키/값 쌍의 값 부분입니다.</param>
        <summary>지정된 상태 키 및 상태 값을 사용하여 기록점을 만들고 브라우저의 기록 스택에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태를 식별 하는 값을 저장 하려는 경우 기록 점을 만들려면이 메서드를 사용 합니다. 기록 점을 만든 경우에 직렬화 되 고 암호화 된 데이터 웹 페이지의 URL로 추가 되 고 브라우저의 기록 스택에 항목이 포함 됩니다. 기록 스택의 상태 항목의 제목으로 웹 페이지의 제목이 사용 됩니다.  
  
 모든 후속 서버 탐색 이벤트가 발생할 때 페이지를 다시 만들를 상태 데이터를 사용할 수 있습니다. 자세한 내용은 [브라우저 기록 서버를 사용 하 여 컨트롤 관리](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberSignature Language="F#" Value="member this.AddHistoryPoint : string * string * string -&gt; unit" Usage="scriptManager.AddHistoryPoint (key, value, title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">웹 페이지의 상태를 식별하는 키/값 쌍의 키 부분입니다.</param>
        <param name="value">웹 페이지의 상태를 식별하는 키/값 쌍의 값 부분입니다.</param>
        <param name="title">브라우저의 기록 스택에 이 상태의 제목으로 추가될 텍스트입니다.</param>
        <summary>지정된 상태 키, 상태 값 및 상태 제목을 사용하여 기록점을 만들고 브라우저의 기록 스택에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상태 및 상태 제목을 식별 하는 값을 저장 하려는 경우 기록 점을 만들려면이 메서드를 사용 합니다. 기록 점을 만든 경우에 직렬화 되 고 암호화 된 데이터 웹 페이지의 URL로 추가 되 고 브라우저의 기록 스택에 항목이 포함 됩니다. 경우는 `title` 매개 변수는 `null`, 웹 페이지의 제목이 기록 스택에 상태 항목의 제목으로 사용 됩니다.  
  
 모든 후속 서버 탐색 이벤트가 발생할 때 페이지를 다시 만들를 상태 데이터를 사용할 수 있습니다. 자세한 내용은 [브라우저 기록 서버를 사용 하 여 컨트롤 관리](https://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkAssembly : System.Reflection.Assembly" Usage="System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지의 구성 요소에서 사용하는 AJAX 프레임워크 어셈블리를 가져옵니다.</summary>
        <value>AJAX 프레임워크 어셈블리입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberSignature Language="F#" Value="member this.AjaxFrameworkMode : System.Web.UI.AjaxFrameworkMode with get, set" Usage="System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에 Microsoft Ajax 클라이언트 라이브러리의 클라이언트 스크립트를 포함하는 방법을 지정하는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Web.UI.AjaxFrameworkMode" /> 열거형 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> 속성을 모든 Microsoft Ajax 스크립트 파일을 모든 Microsoft Ajax 스크립트 파일을 사용 하지 않도록 설정 하거나 명시적으로 개별 스크립트 파일을 포함 하도록 합니다.  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A> 속성을 `Explicit` 하려면 스크립트를 명시적으로 지정할 수 있음을 나타냅니다.  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowCustomErrorsRedirect : bool with get, set" Usage="System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 포스트백 도중 오류가 발생할 경우 Web.config 파일의 사용자 지정 오류 섹션이 사용되는지 여부를 결정하는 값을 가져오거나 설정합니다.</summary>
        <value>비동기 포스트백 도중 발생하는 오류 동작을 결정하는 데 Web.config 파일의 사용자 지정 오류 설정이 사용되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 비동기 포스트백 도중 페이지 오류가 있을 때 이벤트가 발생 합니다. 서버의 오류가 클라이언트로 전송 하는 방법에 따라 달라 집니다를 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 속성 및 Web.config 파일의 사용자 지정 오류 섹션.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackError : EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " Usage="member this.AsyncPostBackError : System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 포스트백 도중 페이지 오류가 있는 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 비동기 포스트백 도중 페이지 오류가 있을 때 이벤트가 발생 합니다. 서버의 오류가 클라이언트로 전송 하는 방법에 따라 달라 집니다를 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 속성 및 Web.config 파일의 사용자 지정 오류 섹션.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 이벤트가 설정를 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> server 예외 오류 메시지에 속성 (하는 클라이언트에 전송 됨).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackErrorMessage : string with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 포스트백 도중 처리되지 않은 서버 예외가 발생할 경우 클라이언트에 전송되는 오류 메시지를 가져오거나 설정합니다.</summary>
        <value>오류 메시지입니다. 기본값은 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 비동기 포스트백 도중 페이지 오류가 있을 때 이벤트가 발생 합니다. 서버의 오류가 클라이언트로 전송 하는 방법에 따라 달라 집니다를 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 속성 및 Web.config 파일의 사용자 지정 오류 섹션.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 이벤트가 설정를 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> server 예외 오류 메시지에 속성 (하는 클라이언트에 전송 됨).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackSourceElementID : string" Usage="System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 포스트백을 발생시킨 컨트롤의 고유 ID를 가져옵니다.</summary>
        <value>컨트롤에 ID가 지정되어 있으면 컨트롤의 고유 ID이고, 그러지 않으면 빈 문자열("")입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A> 속성 중 하나일 수 있는 비동기 포스트백을 발생 시킨 컨트롤 ID의 값을 포함 합니다.  
  
-   내에 있는 컨트롤에서 포스트백을 <xref:System.Web.UI.UpdatePanel> 컨트롤 <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 속성이 `true` (기본값).  
  
-   에 대 한 트리거 역할을 하는 컨트롤의 포스트백을 <xref:System.Web.UI.UpdatePanel> 제어 합니다.  
  
-   호출 하 여 등록 된 컨트롤의 포스트백 합니다 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 메서드의 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPostBackTimeout : int with get, set" Usage="System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답을 받지 못한 경우 비동기 포스트백 제한 시간이 초과되기 전까지의 시간(초)을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>제한 시간(초)을 나타내는 정수입니다. 기본값은 90 초입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationService : System.Web.UI.AuthenticationServiceManager" Usage="System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스와 관련된 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.AuthenticationServiceManager> 이 속성에 의해 반환 되는 개체는 페이지를 사용 하 여 등록 된 인증 서비스를 나타냅니다. 인증 서비스에서 정의할 수 있습니다 합니다 <xref:System.Web.UI.ScriptManager> 제어 나 관련 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다.  
  
 ASP.NET 인증 서비스를 사용할 수도 있고 사용자 지정 인증 서비스를 사용할 수 있습니다. 사용자 지정 서비스를 포함 하 여 태그에 추가할 수 있습니다는 `AuthenticationService` 요소 내는 `asp:ScriptManager` 페이지에서 다음 예제에서와 같이 요소입니다.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 또한 프로그래밍 방식으로 구성할 수 있습니다는 <xref:System.Web.UI.AuthenticationServiceManager> 개체입니다. 서비스에 등록 되는 <xref:System.Web.UI.ScriptManager> 페이지의 컨트롤 <xref:System.Web.UI.Control.PreRender> 수명 주기 단계입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientNavigateHandler : string with get, set" Usage="System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에서 <see href="https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93">Sys.Application.navigate</see> 이벤트를 처리하는 메서드의 이름을 가져오거나 설정합니다.</summary>
        <value>처리 하는 메서드의 이름을 합니다 [Sys.Application.navigate](https://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) 클라이언트에서 이벤트입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositeScript : System.Web.UI.CompositeScriptReference" Usage="System.Web.UI.ScriptManager.CompositeScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지를 지원하는 복합 스크립트에 대한 참조를 가져옵니다.</summary>
        <value>복합 스크립트에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 자세한 내용은 [복합 스크립트로 클라이언트 스크립트 결합](https://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EmptyPageUrl : string with get, set" Usage="System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>빈 웹 페이지에 대한 URL을 가져오거나 설정합니다.</summary>
        <value>대상 웹 페이지가 비어 있는 경우 사용할 URL입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A> 속성은 Ajax 브라우저 기록을 지원 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdn : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 페이지가 CDN(Content Delivery Network) 경로에서 클라이언트 스크립트 참조를 로드하는지 여부를 결정합니다.</summary>
        <value>CDN 경로에서 클라이언트 스크립트 참조가 로드되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 하지 마십시오 `true` 설정 하는 경우 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 에 `true` 이미 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableCdnFallback : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>CDN(Content Delivery Network)을 사용할 수 없는 경우에 로드할 스크립트의 로컬 복사본을 사용하도록 설정합니다.</summary>
        <value>대체 CDN 값을 사용할 수 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableHistory : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableHistory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지에서 기록점 관리를 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>웹 페이지가 기록점을 브라우저의 기록 스택에 추가하는 기능을 지원하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.EnableHistory%2A> 웹 페이지에서 기록 관리를 사용 하도록 설정 하려면 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePageMethods : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 페이지의 공용 정적 페이지 메서드를 클라이언트 스크립트에서 호출할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>ASP.NET 페이지의 정적 페이지 메서드를 웹 메서드 같은 클라이언트 스크립트에서 호출할 수 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 페이지에 정적 페이지 메서드를 추가 하 고 웹 메서드로 표시할 수 있습니다. 그런 다음 별도.asmx 파일을 만들지 않고 있지만 웹 서비스의 일부인 것 처럼 이러한 메서드 스크립트에서 호출할 수 있습니다. 가져오기 페이지에 웹 메서드를 만들려면 합니다 <xref:System.Web.Services> 네임 스페이스 추가 <xref:System.Web.Services.WebMethodAttribute> 특성을 노출 하려는 각 정적 메서드에 합니다. 메서드는 공용 표시 되어야 합니다.  
  
 자세한 내용은 [웹 서비스를 ASP.NET AJAX의 클라이언트 스크립트를 노출](https://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnablePartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지의 부분 렌더링을 활성화한 다음 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤을 사용하여 페이지의 영역을 개별적으로 업데이트할 수 있도록 하는 값을 가져오거나 설정합니다.</summary>
        <value>부분 렌더링이 활성화되어 전체 페이지 업데이트가 발생하지 않으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 합니다 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 속성은 `true`, 부분 페이지 렌더링 발생 하지 않을 수 있습니다. 브라우저 부분 페이지 렌더링을 지원 하지 않을 수 또는 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 속성이 `false`합니다.  
  
 값을 재정의할 수는 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 속성 중 또는 페이지의 이전에 런타임에 <xref:System.Web.UI.Control.Init> 이벤트입니다. 페이지의이 속성을 변경 하려고 하면 <xref:System.Web.UI.Control.Init> 이벤트가 발생 했음을 <xref:System.InvalidOperationException> 예외가 throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">페이지의 <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 이벤트가 발생한 후에 <see cref="E:System.Web.UI.Control.Init" /> 속성이 설정된 경우</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptGlobalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤이 문화권별 정보의 구문 분석 및 형식 지정을 지원하는 스크립트를 렌더링하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>문화권별 정보를 표시할 수 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A> 속성이 `true`, 문화권별 형식 정보를 표시 하는 메서드와 같은 세계화 된 ECMAScript (JavaScript) 함수입니다. 브라우저에서 서버 코드 또는 웹 사이트의 구성 파일에는 문화권을 설정할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/69b34e6d-d590-4d03-a763-b7ae54b47d74">클라이언트 스크립트를 사용 하 여 날짜를 지역화 합니다.</related>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableScriptLocalization : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤이 지역화된 버전의 스크립트 파일을 렌더링하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>지역화된 스크립트 파일이 렌더링되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 속성이 `true`, <xref:System.Web.UI.ScriptManager> 있을 경우 개체는 현재 문화권에 대 한 스크립트 파일을 검색 합니다. 예를 들어, 페이지 CustomScript.js 이라고 하는 스크립트 파일을 지정할 수 있습니다. Fr-CA에 문화권을 설정 하는 경우는 <xref:System.Web.UI.ScriptManager> 개체는 fr-ca 스크립트 파일을 검색 하려고 합니다.  
  
> [!NOTE]
>  스크립트 파일을 두 번 렌더링 되지 않도록 방지 하기 위해는 <xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A> 비동기 포스트백 도중 속성을 수정 하지 않아야 합니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb">구성 요소 라이브러리 개요에 대 한 리소스를 지역화</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSecureHistoryState : bool with get, set" Usage="System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기록 상태 문자열을 암호화할 것인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>기록 상태 문자열을 암호화해야 하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  이 속성은 ***되지*** 로 설정할 `false` 프로덕션 웹 사이트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrent : System.Web.UI.Page -&gt; System.Web.UI.ScriptManager" Usage="System.Web.UI.ScriptManager.GetCurrent page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page"><see cref="T:System.Web.UI.ScriptManager" />를 검색할 페이지 인스턴스입니다.</param>
        <summary>지정된 <see cref="T:System.Web.UI.ScriptManager" /> 개체의 <see cref="T:System.Web.UI.Page" /> 인스턴스를 가져옵니다.</summary>
        <returns>선택한 <see cref="T:System.Web.UI.Page" /> 개체의 현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스이거나, 인스턴스가 정의되지 않은 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 정적 메서드를 사용 하 여 확인 여부를 <xref:System.Web.UI.ScriptManager> 컨트롤의 페이지에서 또는의 메서드 및 속성에 액세스 하는 <xref:System.Web.UI.ScriptManager> ID 알 수 없는 되는 경우 제어  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredArrayDeclarations : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;" Usage="scriptManager.GetRegisteredArrayDeclarations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 ECMAScript(JavaScript) 배열 선언의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns>배열 선언이 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredClientScriptBlocks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredClientScriptBlocks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에 등록된 클라이언트 스크립트 블록의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns>클라이언트 스크립트 블록이 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클라이언트 스크립트 블록에 등록 된 합니다 <xref:System.Web.UI.ScriptManager> 내에 있는 컨트롤을 사용 하 여 사용에 대 한 제어를 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredDisposeScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;" Usage="scriptManager.GetRegisteredDisposeScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 <see langword="dispose" /> 스크립트의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns><see langword="dispose" /> 스크립트가 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A `dispose` 스크립트를 실행 하는 경우는 <xref:System.Web.UI.UpdatePanel> 컨트롤을 업데이트 하거나 삭제 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredExpandoAttributes : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;" Usage="scriptManager.GetRegisteredExpandoAttributes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 사용자 지정(expando) 특성의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns>사용자 지정 특성이 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 특성을 읽고 클라이언트 스크립트를 통해 설정할 수 있는 이름/값 쌍은입니다.  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredHiddenFields : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;" Usage="scriptManager.GetRegisteredHiddenFields " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 숨겨진 필드의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns>숨겨진 필드가 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredOnSubmitStatements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredOnSubmitStatements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 <see langword="onsubmit" /> 문의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns><see langword="onsubmit" /> 문이 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `onsubmit` 문은 양식이 제출 되 면 실행 되는 ECMAScript (JavaScript)입니다.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberSignature Language="F#" Value="member this.GetRegisteredStartupScripts : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;" Usage="scriptManager.GetRegisteredStartupScripts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이전에 <see cref="T:System.Web.UI.Page" /> 개체에 등록된 시작 스크립트의 읽기 전용 컬렉션을 검색합니다.</summary>
        <returns>시작 스크립트가 들어 있는 제네릭 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시작 스크립트는 컨트롤이 시작 될 때 실행 되는 컨트롤과 연결 된 클라이언트 스크립트입니다.  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberSignature Language="F#" Value="member this.GetStateString : unit -&gt; string" Usage="scriptManager.GetStateString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>웹 페이지의 상태를 나타내는 키/값 쌍을 포함하는 문자열을 검색합니다.</summary>
        <returns>웹 페이지의 상태를 나타내는 키/값 쌍을 포함하는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디버그 버전의 클라이언트 스크립트 라이브러리가 렌더링되는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 요청이 디버그 모드에서 실행되고 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 속성이 반환 `false` 다음 조건 중 하나가 충족 될 경우:  
  
-   구성 파일의 요소에는 `retail` 특성이로 설정 된 `true`합니다. 이 다른 모든 설정을 재정의합니다.  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 속성이로 설정 되어 `Auto` 또는 `Inherit`, 및 디버깅에서 활성화 되지 않은 `compilation` 응용 프로그램 루트 Web.config 파일의 섹션입니다.  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 속성은 `Release`로 설정됩니다.  
  
    > [!NOTE]
    >  `debug` 지시문의 특성 Ajax 사용 ASP.NET 응용 프로그램에 영향을 주지 않습니다. 합니다 <xref:System.Web.UI.ScriptManager> 컨트롤 및 Web.config 파일에서 설정만 사용 하 여 해당 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 및 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 디버그 스크립트를 렌더링할지 여부를 결정 하는 속성입니다.  
  
 자세한 내용은 [디버깅 및 추적 Ajax Applications Overview](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInAsyncPostBack : bool" Usage="System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 포스트백이 부분 렌더링 모드에서 실행되고 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>현재 포스트백이 부분 렌더링 모드에서 실행되고 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 함께에서 속성을 <xref:System.Web.UI.Page.IsPostBack%2A> 속성에서 초기 페이지 로드, 부분 페이지 업데이트를의 전체 페이지 업데이트를 구분 하기 위해 <xref:System.Web.UI.Control.Load>, <xref:System.Web.UI.Page.InitComplete>, 또는 <xref:System.Web.UI.Control.PreRender> 이벤트.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNavigating : bool" Usage="System.Web.UI.ScriptManager.IsNavigating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Web.UI.ScriptManager.Navigate" /> 이벤트가 현재 처리되고 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="E:System.Web.UI.ScriptManager.Navigate" />가 처리되고 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Web.UI.ScriptManager.IsNavigating%2A> 속성을 여부를 <xref:System.Web.UI.ScriptManager.Navigate> 이벤트가 발생 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberSignature Language="F#" Value="abstract member LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool&#xA;override this.LoadPostData : string * System.Collections.Specialized.NameValueCollection -&gt; bool" Usage="scriptManager.LoadPostData (postDataKey, postCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">컨트롤의 키 식별자입니다.</param>
        <param name="postCollection">들어오는 모든 게시 데이터의 컬렉션입니다.</param>
        <summary>브라우저에서 서버로 게시되는 폼 데이터를 읽고 비동기 포스트백의 원본을 확인합니다.</summary>
        <returns>포스트백을 실행한 후에 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤의 상태가 변경되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ScriptManager.LoadPostData%2A> 메서드는 주로 컨트롤 개발자가 기능을 확장할 수는 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LoadScriptsBeforeUI : bool with get, set" Usage="System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지 UI 태그가 로드되기 전이나 후에 스크립트가 로드되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>UI 태그가 로드되기 전에 스크립트가 로드되면 <see langword="true" />이고, UI 태그가 로드된 후 스크립트가 로드되면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 속성을 결정 하는 방법을 스크립트는 <xref:System.Web.UI.ScriptManager.Scripts%2A> 컬렉션 페이지 UI에 대 한 태그를 기준으로 로드 됩니다.  
  
 경우는 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 속성은 `true`, `script` 페이지의 UI 태그가 로드 되기 전에 요소가 렌더링 됩니다. 이 시나리오에서는 UI 요소는 스크립트에 정의 된 경우 UI는 완전 하 게 작동을 로드할 때. 그러나 스크립트는 인스턴스가 아직 만들어지지 않은 태그에서 UI 요소에 액세스 하는 경우 오류가 발생할 수 있습니다. 를 액세스 하기 전에 UI 요소가 로드 했는지 확인 하려면 클래스의 이벤트를 처리 합니다.  
  
 경우는 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A> 속성은 `false`, `script` 페이지의 UI 태그 렌더링 된 후 요소가 렌더링 됩니다. 이 시나리오에서는 UI가 더 빨리 로드 하지만 하지 않을 완벽 하 게 작동 추가 UI 요소를 정의 하는 스크립트 로드를 완료 하지 못한 경우.  
  
 이 속성을 설정 하지 마십시오 `true` 설정 하는 경우 <xref:System.Web.UI.ScriptManager.EnableCdn%2A> 에 `true` 이미 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " Usage="member this.Navigate : System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 브라우저의 **뒤로** 또는 **앞으로** 단추를 클릭하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 브라우저의을 클릭 하면 **다시** 단추 기록 점을 상태 데이터를 포함 하는 Url을 포함할 수 있는 이전에 본 Url이 브라우저 탐색 합니다. 웹 페이지에서 클라이언트 코드에서 기록 상태 데이터를 URL에 포함 되어 있는지를 감지 하면 서버 페이지를 요청을 하면 합니다. 포스트백 이벤트로 작동 하며 <xref:System.Web.UI.ScriptManagerProxy> 서버 컨트롤에서 발생 합니다 `Navigate` 이벤트입니다. 이 이벤트를 처리 하 고 이벤트에 전달 되는 상태 데이터를 사용 하 여 웹 응용 프로그램에서 필요에 따라 페이지를 다시 만들 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit&#xA;override this.OnAsyncPostBackError : System.Web.UI.AsyncPostBackErrorEventArgs -&gt; unit" Usage="scriptManager.OnAsyncPostBackError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">오류 이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 비동기 포스트백 도중 페이지 오류가 있을 때 이벤트가 발생 합니다. 서버의 오류가 클라이언트로 전송 하는 방법에 따라 달라 집니다를 <xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A> 속성을 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> 속성 및 Web.config 파일의 사용자 지정 오류 섹션.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.ScriptManager.AsyncPostBackError> 이벤트가 설정를 <xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A> server 예외 오류 메시지에 속성 (하는 클라이언트에 전송 됨).  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="scriptManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.Init" /> 이벤트를 발생시키고 페이지에 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤이 하나만 있는지 확인합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">페이지에 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스가 두 개 이상인 경우</exception>
        <block subset="none" type="overrides"><para>이 메서드를 재정의 하는 경우 호출 기본 <see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" /> 부분 페이지 렌더링을 위해 메서드 스크립트 파일이 올바르게 처리 합니다.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 개요</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="scriptManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Web.UI.Control.PreRender" /> 이벤트를 발생시킨 후 부분 페이지 업데이트를 위한 스크립트 파일 및 서비스를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DOM에 대 한 내용은 참조는 [문서 개체 모델 (DOM) 수준 1 사양은](https://go.microsoft.com/fwlink/?LinkId=73305) World Wide Web Consortium (W3C) 웹 사이트.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">부분 페이지를 요청한 브라우저에서 DOM Level 1.0 이상을 지원하지 않는 경우</exception>
        <block subset="none" type="overrides"><para>이 메서드를 재정의 하는 경우 호출 기본 <see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" /> 부분 페이지 렌더링에 대 한 메서드는 스크립트 블록 및 서비스가 올바르게 처리 합니다.</para></block>
        <related type="Article" href="https://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991">ASP.NET 페이지 수명 주기 개요</related>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveCompositeScriptReference : System.Web.UI.CompositeScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveCompositeScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">복합 스크립트 참조를 나타내는 개체입니다.</param>
        <summary><see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit&#xA;override this.OnResolveScriptReference : System.Web.UI.ScriptReferenceEventArgs -&gt; unit" Usage="scriptManager.OnResolveScriptReference e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">현재 스크립트를 나타내는 개체입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에서 관리하는 각 스크립트 참조에 대해 <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 합니다 <xref:System.Web.UI.ScriptManager.OnPreRender%2A> 이벤트 처리기를 각각에 대해 한 번씩 <xref:System.Web.UI.ScriptReference> 에 <xref:System.Web.UI.ScriptManager.Scripts%2A> 컬렉션입니다.  
  
 <xref:System.Web.UI.ScriptManager.ResolveScriptReference> 중복 스크립트 항목 확인 된 후 이벤트가 발생 합니다.  
  
 부분 페이지 업데이트 중 또는 다시 게시 될 때 개별 스크립트 블록의 동작에 영향을 줄이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProfileService : System.Web.UI.ProfileServiceManager" Usage="System.Web.UI.ScriptManager.ProfileService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스와 관련된 <see cref="T:System.Web.UI.ProfileServiceManager" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.ProfileServiceManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ProfileServiceManager> 이 속성에 의해 반환 되는 개체는 페이지를 사용 하 여 등록 프로필 서비스를 나타냅니다. 프로필 서비스에서 정의할 수 있습니다 합니다 <xref:System.Web.UI.ScriptManager> 제어 나 관련 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다.  
  
 ASP.NET 프로필 서비스를 사용할 수도 있고 사용자 지정 프로필 서비스를 사용할 수 있습니다. 사용자 지정 서비스를 포함 하 여 태그에 추가할 수 있습니다는 `ProfileService` 요소 내는 `asp:ScriptManager` 페이지에서 다음 예제에서와 같이 요소.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 또한 프로그래밍 방식으로 구성할 수 있습니다는 <xref:System.Web.UI.ProfileServiceManager> 개체입니다. 서비스에 등록 되는 <xref:System.Web.UI.ScriptManager> 페이지의 컨트롤 <xref:System.Web.UI.Control.PreRender> 수명 주기 단계입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : string -&gt; unit&#xA;override this.RaisePostBackEvent : string -&gt; unit" Usage="scriptManager.RaisePostBackEvent eventArgument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">웹 페이지의 기록 상태를 나타내는 키/값 쌍의 문자열입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤이 발생시킨 포스트백 이벤트를 처리하고 웹 페이지의 기록 상태를 로드합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberSignature Language="F#" Value="abstract member RaisePostDataChangedEvent : unit -&gt; unit&#xA;override this.RaisePostDataChangedEvent : unit -&gt; unit" Usage="scriptManager.RaisePostDataChangedEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>서버에 포스트백될 때 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에 대한 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A> 메서드는 주로 컨트롤 개발자가 기능을 확장할 수는 <xref:System.Web.UI.ScriptManager> 제어 합니다. 기본 구현에는 <xref:System.Web.UI.ScriptManager> 제어 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 ECMAScript(JavaScript) 배열 선언을 등록한 후 해당 배열을 페이지에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (control, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">배열을 등록하는 컨트롤입니다.</param>
        <param name="arrayName">등록할 배열의 이름입니다.</param>
        <param name="arrayValue">등록할 배열 값입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 ECMAScript(JavaScript) 배열 선언을 등록한 후 해당 배열을 페이지에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 부분 페이지 렌더링과와 호환 되는 클라이언트 스크립트 배열을 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드는 배열을 등록 하면 `control` 내에 있는 컨트롤을 나타냅니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 배열에는 비동기 포스트백이 발생할 때마다 등록 하려면 사용 된 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 하지 않는 부분 페이지 업데이트와 관련 된 배열에 초기 페이지 렌더링 시 한 번만 등록 하려는 경우 사용 하 여 배열을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 메서드 같은지에 지정 된 이름의 배열을 `arrayName` 매개 변수는 이미 등록 합니다. 따라서 메서드에 지정 된 값에 추가 `arrayValue`합니다. 등록할 배열 기반으로 하므로 <xref:System.Collections.ArrayList> 클래스 중복이 허용 됩니다. 경우에 이름의 등록 된 배열이 `arrayName` 존재 하지 않는 만든 값 `arrayValue` 에 추가 됩니다.  
  
 문자열 리터럴은 배열에 포함 하려면 작은따옴표 (')를 사용 하거나 큰따옴표를 이스케이프 (\\")에서 `arrayValue`합니다.  
  
 JavaScript 배열에서 구분 기호로 쉼표 (,)를 처리 한다는 note 합니다. 쉼표로 구분 된 문자열을 전달 하 여 여러 배열 값을 지정할 수 있습니다 `arrayValue`합니다. 두 항목을 쉼표로 구분 `arrayValue` 호출 하는 것과 같습니다는 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 메서드 두 시간 마다 한 번 항목입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="static member RegisterArrayDeclaration : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterArrayDeclaration (page, arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">배열을 등록하는 페이지 개체입니다.</param>
        <param name="arrayName">등록할 배열의 이름입니다.</param>
        <param name="arrayValue">등록할 배열 값입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 ECMAScript(JavaScript) 배열 선언을 등록한 후 해당 배열을 페이지에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A> 부분 페이지 렌더링과와 호환 되는 클라이언트 스크립트 배열을 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드는 비동기 포스트백이 발생할 때마다 배열을 등록 합니다. 배열 내에 있는 컨트롤을 등록 하는 <xref:System.Web.UI.UpdatePanel> 배열 업데이트 될 경우에 등록 되도록 컨트롤을 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 하지 않는 부분 페이지 업데이트와 관련 된 배열에 초기 페이지 렌더링 시 한 번만 등록 하려는 경우 사용 하 여 배열을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayName" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterAsyncPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterAsyncPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">비동기 포스트백을 위해 등록할 컨트롤입니다.</param>
        <summary>컨트롤을 비동기 포스트백의 트리거로 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 메서드를 사용 하면 동기 포스트백 하는 대신 비동기 포스트백을 수행 하도록 해당 트리거로 웹 서버 컨트롤을 등록할 수 있습니다. 때를 <xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A> 의 속성을 <xref:System.Web.UI.UpdatePanel> 로 설정 되어 `true` (기본값) 인 내에 있는 컨트롤을 포스트백는 <xref:System.Web.UI.UpdatePanel> 컨트롤이 비동기 포스트백 컨트롤로 자동으로 등록 됩니다.  
  
 사용 하 여 합니다 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 외부 컨트롤을 등록 하는 메서드는 <xref:System.Web.UI.UpdatePanel> 비동기 포스트백에 대 한 잠재적으로 업데이트 패널의 콘텐츠를 업데이트 하는 트리거로 사용 되는 컨트롤입니다. 업데이트 하는 <xref:System.Web.UI.UpdatePanel> 프로그래밍 방식으로 제어를 호출 합니다 <xref:System.Web.UI.UpdatePanel.Update%2A> 메서드.  
  
 사용 하 여 트리거가 선언적으로 추가할 수 있습니다는 `Triggers` 의 요소는 <xref:System.Web.UI.UpdatePanel> 제어 합니다. Visual Studio에서 디자이너를 사용 **UpdatePanelTrigger 컬렉션 편집기** 대화 상자.  
  
   
  
## Examples  
 다음 예제에서는 호출 하는 방법을 보여 줍니다는 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 등록 하는 메서드를 <xref:System.Web.UI.WebControls.Button> 컨트롤을 업데이트 하면는 <xref:System.Web.UI.UpdatePanel> 컨트롤의 콘텐츠입니다. 합니다 <xref:System.Web.UI.WebControls.Button> 컨트롤 내에 있지는 <xref:System.Web.UI.UpdatePanel> 제어 합니다. 두 개의 단추가 표시 됩니다. `Button1` 및 `Button2`합니다. `Button1` 패널의 콘텐츠를 새로 고칩니다 및 `Button2` 전체 페이지를 새로 고칩니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 다음 예제에서는 호출 하는 방법을 보여 줍니다 합니다 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A> 업데이트 되도록 사용자를 등록 하는 방법 제어는 <xref:System.Web.UI.UpdatePanel> 컨트롤의 콘텐츠입니다. 첫 번째 예제 사용자 정의 컨트롤을 사용 하는 페이지를 보여 줍니다. 두 번째 예제 사용자 정의 컨트롤을 보여 줍니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">페이지가 비동기 포스트백 컨트롤로 등록된 경우
또는

등록된 컨트롤이 <see cref="T:System.Web.UI.INamingContainer" />, <see cref="T:System.Web.UI.IPostBackDataHandler" /> 또는 <see cref="T:System.Web.UI.IPostBackEventHandler" /> 인터페이스를 구현하지 않는 경우</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트 블록을 등록한 후 페이지에 스크립트 블록을 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 스크립트 블록을 등록하는 컨트롤입니다.</param>
        <param name="type">클라이언트 스크립트 블록의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 <see langword="typeof" /> 연산자(C#) 또는 <see langword="GetType" /> 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 블록의 고유 식별자입니다.</param>
        <param name="script">스크립트입니다.</param>
        <param name="addScriptTags">스크립트 블록을 <see langword="&lt;script&gt;" /> 및 <see langword="&lt;/script&gt;" /> 태그로 묶으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트 블록을 등록한 후 페이지에 스크립트 블록을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 부분 페이지 렌더링과와 호환 되는 클라이언트 스크립트 블록을 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드를 사용 하 여 등록 된 클라이언트 스크립트 블록 페이지로 전송 됩니다 경우에만 `control` 내에 있는 컨트롤을 나타냅니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 비동기 포스트백이 발생할 때마다 스크립트 블록을 등록 하려면는 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 하는 경우 `addScriptTags` 됩니다 `true`의 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 메서드를 추가 `<script>` 스크립트 블록 태그입니다. 전달 `false` 만들려는 경우 `<script>` 특정 특성을 설정 하려는 경우 같은 태그를 직접 `<script>` 태그입니다. 하는 경우 `addScriptTags` 됩니다 `false` 고 `script` 여러 스크립트 블록을 포함 하는 매개 변수, 예외가 throw 됩니다.  
  
 합니다 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A> 메서드를 연 후 페이지에 스크립트 블록을 추가 해도 `<form>` 태그입니다. 스크립트 블록이 등록 된 동일한 순서로 출력할 보장이 없습니다. 스크립트 블록의 순서가 중요 한 경우에 스크립트 블록을 단일 문자열로 연결 (사용 하 여 예를 들어를 <xref:System.Text.StringBuilder> 개체), 단일 클라이언트 스크립트 블록으로 등록 합니다.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 블록 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트 블록을 등록하는 컨트롤이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">스크립트 블록을 등록하는 컨트롤이 페이지의 컨트롤 트리에 있지 않은 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptBlock : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptBlock (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">클라이언트 스크립트 블록을 등록하는 페이지 개체입니다.</param>
        <param name="type">클라이언트 스크립트 블록의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 <see langword="typeof" /> 연산자(C#) 또는 <see langword="GetType" /> 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 블록의 고유 식별자입니다.</param>
        <param name="script">등록할 스크립트입니다.</param>
        <param name="addScriptTags">스크립트 블록을 <see langword="&lt;script&gt;" /> 및 <see langword="&lt;/script&gt;" /> 태그로 묶으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트 블록을 등록한 후 페이지에 스크립트 블록을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 스크립트 블록을 등록 하는 경우 스크립트는 비동기 포스트백이 발생할 때마다 렌더링 됩니다. 내에 있는 컨트롤에 대 한 스크립트 블록을 등록 하려면를 <xref:System.Web.UI.UpdatePanel> 스크립트는 등록 되도록 경우에만 합니다 <xref:System.Web.UI.UpdatePanel> 컨트롤이 업데이트를 사용 하 여를 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">스크립트 블록 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트 블록을 등록하는 페이지가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트 파일을 등록한 후 페이지에 스크립트 파일 참조를 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (control, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 스크립트 파일을 등록하는 컨트롤입니다.</param>
        <param name="type">클라이언트 스크립트 파일의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 파일의 고유 식별자입니다.</param>
        <param name="url">스크립트 파일의 URL입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트 파일을 등록한 후 페이지에 스크립트 파일 참조를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 부분 페이지 업데이트에 참여 하는 페이지의 일부나 페이지에 대 한 클라이언트 스크립트 파일을 등록 하는 방법입니다. 이 메서드를 사용 하 여 등록 된 클라이언트 스크립트 파일 페이지로 전송 됩니다 경우에만 합니다 `control` 내에 있는 컨트롤을 나타냅니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 비동기 포스트백이 발생할 때마다 스크립트 파일을 등록 하려면는 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 메서드는 페이지의 클라이언트 스크립트 파일을 렌더링 하 여 등록을 `script` 여는 태그를 포함 하는 요소는 `src` 특성. 합니다 `url` 매개 변수는 설정 하는 데 사용 되는 `src` 특성입니다. Url를 해결 하려면 사용 된 <xref:System.Web.UI.Control.ResolveClientUrl%2A> 메서드. 이 메서드는 경로를 확인에 대 한 호출의 URL의 컨텍스트를 사용 합니다.  
  
 모두를 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 고 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 메서드 스크립트 파일을 브라우저에 렌더링 합니다. 이미 동일한 형식 및 키 (스크립트 파일) 또는 동일한 유형 및 리소스 이름 (포함된 된 리소스)를 사용 하 여 스크립트를 렌더링 하는 경우 스크립트를 다시 렌더링 되지 않습니다.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 파일 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트 파일을 등록하는 컨트롤이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">스크립트 파일을 등록하는 컨트롤이 페이지의 컨트롤 트리에 있지 않은 경우  
  
\- 또는 - 
 <paramref name="url" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="url" />가 비어 있는 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptInclude : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptInclude (page, type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">클라이언트 스크립트 파일을 등록하는 페이지 개체입니다.</param>
        <param name="type">클라이언트 스크립트 파일의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 파일의 고유 식별자입니다.</param>
        <param name="url">스크립트 파일의 URL입니다.</param>
        <summary>비동기 포스트백이 발생할 때마다 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 클라이언트 스크립트를 등록한 후 페이지에 스크립트 파일 참조를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 스크립트 파일을 등록 하는 경우 스크립트는 비동기 포스트백이 발생할 때마다 렌더링 됩니다. 스크립트 파일 내에 있는 컨트롤에 등록 하는 <xref:System.Web.UI.UpdatePanel> 스크립트는 등록 되도록 경우에만 <xref:System.Web.UI.UpdatePanel> 컨트롤이 업데이트를 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 스크립트 파일 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트 파일을 등록하는 페이지가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="url" />가 비어 있는 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부분 페이지 렌더링에 참여하는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트를 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Control * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (control, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">스크립트를 등록하는 컨트롤입니다.</param>
        <param name="type">클라이언트 스크립트의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="resourceName">리소스의 식별자입니다.</param>
        <summary>부분 페이지 렌더링에 참여하는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 부분 페이지 렌더링과와 호환 되는 스크립트를 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드를 사용 하 여 등록 된 스크립트 리소스 등록 된 경우에만 `control` 내에 있는 컨트롤을 나타냅니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 비동기 포스트백이 발생할 때마다 스크립트를 등록 하려면 사용 된 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 메서드는 HTTP 처리기를 통해 어셈블리의 리소스에 액세스할 때 사용 됩니다. 리소스 URL의 콘텐츠를 포함 하는이 메서드는 `script` 요소입니다.  
  
 모두를 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A> 하며 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A> 메서드 스크립트 파일 브라우저에 로드 합니다. 동일한 형식 및 키 (스크립트 파일) 또는 동일한 유형 및 리소스 이름 (포함된 된 리소스)를 사용 하 여 스크립트는 이미 로드 된 스크립트를 다시 로드 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 리소스 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트를 등록하는 컨트롤이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException">스크립트를 등록하는 컨트롤이 페이지의 컨트롤 트리에 있지 않은 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterClientScriptResource : System.Web.UI.Page * Type * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterClientScriptResource (page, type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">스크립트를 등록하는 페이지 개체입니다.</param>
        <param name="type">클라이언트 스크립트의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="resourceName">리소스의 식별자입니다.</param>
        <summary>포스트백이 발생할 때마다 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트 파일을 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 스크립트 파일을 등록 하는 경우 스크립트는 비동기 포스트백이 발생할 때마다 렌더링 됩니다. 내에 있는 컨트롤에 대 한 스크립트를 등록 하는 <xref:System.Web.UI.UpdatePanel> 스크립트가 등록 되도록 경우에만 <xref:System.Web.UI.UpdatePanel> 컨트롤은 업데이트를 사용 하 여를 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트 블록을 등록 하려는 경우는 스크립트 블록을 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">클라이언트 리소스 <paramref name="type" />이 <see langword="null" />인 경우  
  
\- 또는 - 
스크립트를 등록하는 페이지가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부분 페이지 렌더링 도중 사용자 지정 데이터를 컨트롤로 보냅니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">데이터를 받는 컨트롤입니다.</param>
        <param name="dataItem">컨트롤로 보내는 데이터입니다.</param>
        <summary>부분 페이지 렌더링 도중 사용자 지정 데이터를 컨트롤로 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 내에서 데이터를 받는 컨트롤 인지에 관계 없이 비동기 포스트백 도중 클라이언트에 서버에서 데이터 보내기 위한 메서드를 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 비동기 포스트백 중에 메서드를 호출할 수 있습니다. 비동기 포스트백 인지 확인 하려면 사용 된 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 속성입니다. 이 메서드는 명명 된 매개 변수를 사용 하는 오버 로드를 호출 `isJsonSerialized` 로 설정 된 `false`합니다. 경우는 `isJsonSerialized` 매개 변수는 설정 `false`, 문자열은 JavaScript 개체 표기법 (JSON)으로 serialize 되지 않습니다. JSON 형식에 대 한 자세한 내용은 참조는 [JSON 소개](https://go.microsoft.com/fwlink/?LinkId=77297) 웹 사이트입니다.  
  
 등록 된 데이터 항목을 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 메서드 중에 클라이언트 스크립트에서 액세스할 수 있습니다. 그리고 및 개체의 이벤트입니다. 이러한 이벤트를 처리할 때 사용자 지정 데이터를 이벤트 인수 개체에 전달 됩니다. 예를 들어, 이벤트 처리기를 제공 하는 경우 사용자 지정 데이터 속성을 노출 하는 클래스에 전달 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 데이터를 보내는 방법 <xref:System.Web.UI.WebControls.Label> 비동기 포스트백 도중 페이지의 컨트롤입니다. 합니다 <xref:System.Web.UI.WebControls.Label> 컨트롤은 내부 수 없습니다.는 <xref:System.Web.UI.UpdatePanel> 제어 합니다.  
  
> [!NOTE]
>  이 예제에서 전송 되는 데이터 설명만입니다. 실제 응용 프로그램을 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 서버에서 사용자 지정 데이터를 전송 하는 방법입니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 메서드가 포스트백 도중에 호출되는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" />이 이미 <paramref name="control" />에 등록된 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="F#" Value="member this.RegisterDataItem : System.Web.UI.Control * string * bool -&gt; unit" Usage="scriptManager.RegisterDataItem (control, dataItem, isJsonSerialized)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">데이터를 받는 페이지 컨트롤입니다.</param>
        <param name="dataItem">컨트롤로 보내는 데이터입니다.</param>
        <param name="isJsonSerialized"><paramref name="dataItem" />이 JSON으로 serialize됨을 나타내면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary>부분 페이지 렌더링 도중 사용자 지정 데이터를 컨트롤로 보내고, 데이터가 JSON(JavaScript Object Notation) 형식인지 여부를 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 합니다 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 내에서 데이터를 받는 컨트롤 인지에 관계 없이 비동기 포스트백 도중 클라이언트에 서버에서 데이터 보내기 위한 메서드는 <xref:System.Web.UI.UpdatePanel> 제어 합니다.  
  
 경우는 `dataItem` 에 등록 하는 매개 변수 `control` JSON으로 serialize 되지 않습니다 설정 합니다 `isJsonSerialized` 매개 변수를 `false`입니다. 이렇게 하면 클라이언트에 전송 되는 각 문자열에 대 한 함수를 사용할 필요가 없습니다. JSON 형식에 대 한 자세한 내용은 참조는 [JSON 소개](https://go.microsoft.com/fwlink/?LinkId=77297) 웹 사이트입니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 비동기 포스트백 중에 메서드를 호출할 수 있습니다. 비동기 포스트백 인지 확인 하려면 사용 된 <xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A> 속성입니다.  
  
 사용 하 여 등록 된 데이터 항목을 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 메서드 중에 클라이언트 스크립트에서 액세스할 수 있습니다. 그리고 및 개체의 이벤트입니다. 이러한 이벤트를 처리할 때 사용자 지정 데이터를 이벤트 인수 개체에 전달 됩니다. 예를 들어, 이벤트 처리기를 제공 하는 경우 사용자 지정 데이터 속성을 노출 하는 클래스에 전달 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 두 개의 데이터를 보내는 방법 <xref:System.Web.UI.WebControls.Label> 비동기 포스트백 도중 페이지의 컨트롤입니다. 합니다 <xref:System.Web.UI.WebControls.Label> 컨트롤은 내부 수 없습니다.는 <xref:System.Web.UI.UpdatePanel> 제어 합니다. 이 예제에서는 사용 하지 않는 오버 로드는 `isJsonSerialized` 매개 변수입니다. 이 고, 그렇지 개체의 속성을 검색 하기 위한 절차는 오버 로드 하는 사용 하지 않은 경우와 동일 합니다.  
  
> [!NOTE]
>  이 예제에서 전송 되는 데이터 설명만입니다. 실제 응용 프로그램을 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A> 서버에서 사용자 지정 데이터를 전송 하는 방법입니다. 예를 들어, 요소 안에 있지 않은 클라이언트를 표시 하거나 숨길 것인지에 대 한 정보를 보낼 데이터 항목을 사용할 수 있습니다는 <xref:System.Web.UI.UpdatePanel> 제어 합니다.  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 메서드가 포스트백 도중에 호출되는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dataItem" />이 이미 <paramref name="control" />에 등록된 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberSignature Language="F#" Value="member this.RegisterDispose : System.Web.UI.Control * string -&gt; unit" Usage="scriptManager.RegisterDispose (control, disposeScript)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control"><see langword="dispose" /> 스크립트의 컨트롤입니다.</param>
        <param name="disposeScript"><see langword="dispose" /> 스크립트입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤에 대해 <see langword="dispose" /> 스크립트를 등록합니다. 스크립트는 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤이 업데이트되거나 삭제될 때 실행됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 합니다 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 등록 하는 방법 `dispose` 내에 있는 컨트롤에 대 한 스크립트는 <xref:System.Web.UI.UpdatePanel> 컨트롤입니다. 비동기 포스트백 도중 <xref:System.Web.UI.UpdatePanel> 컨트롤 업데이트, 삭제, 가져오거나 만들 수 있습니다. 패널이 업데이트 되거나 삭제 되 면 `dispose` 내에 있는 컨트롤에 대해 등록 된 스크립트는 <xref:System.Web.UI.UpdatePanel> 라고 합니다. 일반적인 페이지 개발 시나리오 필요가 없습니다를 호출 하 여 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 메서드.  
  
 합니다 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 메서드 사용 하기 위한 스크립트를 등록 하거나에서 상속 된 컨트롤을 만들 컨트롤 개발자가는 <xref:System.Web.UI.IScriptControl> 인터페이스입니다. 예를 들어 사용할 수 있습니다는 `dispose` composition을 사용해 서 클라이언트 컨트롤을 개발 하는 경우 스크립트입니다. 컨트롤에 구현 <xref:System.Web.UI.IScriptControl> 개별 컨트롤을 렌더링 합니다. 등록 합니다 `dispose` 와 같은 정의 된 클라이언트 구성 요소에 해당 하지 않는 모든 항목 메서드의 `Sys.TextBox`합니다. Microsoft Ajax Library에서 클라이언트 구성 요소에 해당 하는 요소를 작성 하는 사용자 지정 컨트롤을 하는 경우에 등록 필요가 없습니다를 `dispose` 때문에 스크립트 `dispose` 자동으로 호출 됩니다. 따라서 사용 된 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 메서드는 Microsoft Ajax Library의 일부 이며 구성 요소는 더 이상 사용 하는 경우 리소스를 해제 해야 하는 클라이언트 구성 요소에 대 한 합니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A> 메서드는 컨트롤에 대 한 여러 번 호출할 수 있습니다. 여러 스크립트 집계 됩니다. 스크립트를 삭제 하는 순서는 스크립트가 등록 된 순서와 일치 합니다.  
  
 등록 하는 경우는 `dispose` 에 없는 컨트롤에 대 한 스크립트는 <xref:System.Web.UI.UpdatePanel> 컨트롤 예외가 throw 됩니다. `dispose` 간 스크립트 라고는 및 클래스의 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="disposeScript" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />이 페이지에 없는 경우  
  
\- 또는 - 
 <paramref name="control" />이 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있지 않은 경우</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="static member RegisterExpandoAttribute : System.Web.UI.Control * string * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterExpandoAttribute (control, controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">expando 특성을 등록하는 컨트롤입니다.</param>
        <param name="controlId">페이지에 사용자 지정 특성이 포함된 컨트롤입니다.</param>
        <param name="attributeName">등록할 사용자 지정 특성 이름입니다.</param>
        <param name="attributeValue">사용자 지정 특성 값입니다.</param>
        <param name="encode">등록되는 사용자 지정 특성을 인코드하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 이름/값 쌍을 지정된 컨트롤의 사용자 지정(expando) 특성으로 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> 부분 페이지 렌더링과와 호환 되는 컨트롤에 대 한 사용자 지정 (expando) 속성을 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A> 메서드 이름/값 쌍을 지정된 된 컨트롤에 대 한 사용자 지정 특성으로 등록 합니다. 속성은 렌더링 된 컨트롤의 태그에 XHTML 호환성을 유지 하기 위해 ECMAScript (JavaScript)에서 동적으로 설정 됩니다. 설정할 `encode` 에 `true` 동적 속성의 값의 모든 문자를 이스케이프 해야 합니다.  
  
 동적 속성은 추가할 수 있는 컨트롤이 없으면 스크립트 오류를 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />이 페이지의 컨트롤 트리에 있지 않은 경우  
  
\- 또는 - 
 <paramref name="controlId" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="controlId" />가 비어 있는 경우  
  
\- 또는 - 
 <paramref name="attributeName" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="attributeName" />가 비어 있는 경우  
  
\- 또는 - 
 <paramref name="attributeName" />은(는) 이미 등록되어 있습니다.</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)&#xA;override this.RegisterExtenderControl : 'ExtenderControl * System.Web.UI.Control -&gt; unit (requires 'ExtenderControl :&gt; System.Web.UI.Control and 'ExtenderControl :&gt; System.Web.UI.IExtenderControl)" Usage="scriptManager.RegisterExtenderControl (extenderControl, targetControl)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl"><see cref="T:System.Web.UI.IExtenderControl" /> 인터페이스를 구현하는 컨트롤입니다.</typeparam>
        <param name="extenderControl">등록할 extender 컨트롤입니다.</param>
        <param name="targetControl">extender 컨트롤이 확장하는 스크립트 컨트롤입니다.</param>
        <summary>Extender 컨트롤을 현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 주로 컨트롤 개발자가 사용 합니다. 호출을 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> 메서드 중 사용자 지정 ASP.NET Ajax extender 컨트롤에서 해당 `onInit` 컨트롤을 등록 하려면 해당 페이지를 사용 하 여 이벤트 처리기입니다. ASP.NET Ajax extender 컨트롤은 부분 페이지 렌더링에 참여 하려면 등록 되어야 합니다.  
  
 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A> 메서드 extender 컨트롤을 확장 하는 대상 스크립트 컨트롤의 내부 목록에는 지정 된 extender 컨트롤을 추가 합니다. 이 목록은 동안 처리 되는 <xref:System.Web.UI.Control.PreRender> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extenderControl" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="targetControl" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>숨겨진 필드를 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Control * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (control, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">숨겨진 필드를 등록하는 컨트롤입니다.</param>
        <param name="hiddenFieldName">등록할 숨겨진 필드의 이름입니다.</param>
        <param name="hiddenFieldInitialValue">숨겨진 필드의 초기 값입니다.</param>
        <summary><see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 컨트롤에 대해 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 숨겨진 필드를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 부분 페이지 렌더링과와 호환 되는 숨겨진된 필드를 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드 내에서 필드를 등록 하는 경우 숨겨진된 필드를 등록 한 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 숨겨진된 필드는 비동기 포스트백이 발생할 때마다에 등록 하려면 사용 된 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 숨겨진된 필드를 등록 하려는 경우 숨겨진된 필드를 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 합니다 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 메서드는 숨겨진 만듭니다 `input` 렌더링된 된 HTML 페이지에는 요소입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="hiddenFieldName" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />이 페이지의 컨트롤 트리에 있지 않은 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="static member RegisterHiddenField : System.Web.UI.Page * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterHiddenField (page, hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">숨겨진 필드를 등록하는 페이지 개체입니다.</param>
        <param name="hiddenFieldName">등록할 숨겨진 필드의 이름입니다.</param>
        <param name="hiddenFieldInitialValue">숨겨진 필드의 초기 값입니다.</param>
        <summary>비동기 포스트백이 발생할 때마다 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 숨겨진 필드를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A> 부분 페이지 렌더링과와 호환 되는 숨겨진된 필드를 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드는 비동기 포스트백이 발생할 때마다 숨겨진된 필드를 등록 합니다. 내에 있는 컨트롤에 대 한 숨겨진된 필드를 등록 하는 <xref:System.Web.UI.UpdatePanel> 필드 패널을 업데이트 하는 경우에 등록 되도록 컨트롤을 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 숨겨진된 필드를 등록 하려는 경우 숨겨진된 필드를 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="hiddenFieldName" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>부분 페이지 렌더링에 참여하는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트를 리소스 이름별로 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Control * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (control, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">스크립트를 등록하는 컨트롤입니다.</param>
        <param name="resourceName">리소스의 식별자입니다.</param>
        <summary>부분 페이지 렌더링에 참여하는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트를 리소스 이름별로 등록합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="static member RegisterNamedClientScriptResource : System.Web.UI.Page * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterNamedClientScriptResource (page, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">스크립트를 등록하는 페이지 개체입니다.</param>
        <param name="resourceName">리소스의 식별자입니다.</param>
        <summary>부분 페이지 렌더링에 참여하는 컨트롤과 함께 사용할 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 어셈블리에 포함된 클라이언트 스크립트를 리소스 이름별로 등록합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>폼이 전송될 때 실행되는 ECMAScript(JavaScript) 코드를 등록합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Control * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (control, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control"><see langword="onsubmit" /> 문을 등록하는 컨트롤입니다.</param>
        <param name="type">클라이언트 스크립트 문의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 문의 고유 식별자입니다.</param>
        <param name="script">등록할 스크립트입니다.</param>
        <summary>폼이 전송될 때 실행되는 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤과 함께 사용되는 컨트롤에 대해 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 ECMAScript(JavaScript) 코드를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 폼을 제출 하기 전에 실행 되는 스크립트를 추가 전송을 수정 하거나 취소할 수 있습니다.  
  
 사용할 합니다 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 렌더링 하는 메서드는 `onsubmit` 문 부분 페이지 렌더링을 사용 하 여 호환 되는 및에 Microsoft Ajax Library 종속성이 없습니다. 내에서 문을 등록 하는 경우에이 방법을 사용 하 여 등록 된 JavaScript 코드 페이지로 전송 됩니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 비동기 포스트백이 발생할 때마다를 사용 하 여 코드를 등록 하려면 사용 된 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 하지 않는 부분 페이지 업데이트에 사용 하 여 초기 페이지 렌더링 시 한 번만 코드를 등록 하려는 경우 JavaScript 코드를 등록 하려는 경우는 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 합니다 *스크립트* 의 매개 변수는 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A> 메서드 세미콜론 (;)를 사용 하 여 구분 되는 여러 개의 스크립트 명령을 포함 될 수 있습니다.  
  
 HTML 폼에 대 한 자세한 내용은 및 `onsubmit` 이벤트를 참조 합니다 [World Wide Web Consortium (W3C) 웹 사이트](https://go.microsoft.com/fwlink/?linkid=37125)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />이 페이지의 컨트롤 트리에 있지 않은 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="static member RegisterOnSubmitStatement : System.Web.UI.Page * Type * string * string -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterOnSubmitStatement (page, type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page"><see langword="onsubmit" /> 문을 등록하는 페이지 개체입니다.</param>
        <param name="type">클라이언트 스크립트 문의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 문의 고유 식별자입니다.</param>
        <param name="script">등록할 스크립트입니다.</param>
        <summary>폼이 전송될 때 실행되는 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤과 함께 사용되는 컨트롤에 대해 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 ECMAScript(JavaScript) 코드를 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 JavaScript 코드를 등록 하면 스크립트가 비동기 포스트백이 발생할 때마다 포함 되어야 합니다.  
  
> [!NOTE]
>  이전 비동기 포스트백의 코드는 제거 되지 않습니다. 코드에 대 한 기존 코드를 추가 하는 새 비동기 포스트백을 `onsubmit` 문입니다.  
  
 내에 있는 컨트롤에 대 한 코드를 등록 하는 <xref:System.Web.UI.UpdatePanel> 코드는 등록 되도록 경우에만 합니다 <xref:System.Web.UI.UpdatePanel> 컨트롤은 업데이트를 사용 하 여를 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29> 이 메서드의 오버 로드 합니다.  
  
 하지 않는 부분 페이지 업데이트에 사용 하 여 초기 페이지 렌더링 시 한 번만 코드를 등록 하려는 경우 JavaScript 코드를 등록 하려는 경우는 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterPostBackControl : System.Web.UI.Control -&gt; unit&#xA;override this.RegisterPostBackControl : System.Web.UI.Control -&gt; unit" Usage="scriptManager.RegisterPostBackControl control" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">포스트백을 위해 등록할 컨트롤입니다.</param>
        <summary>컨트롤을 포스트백의 트리거로 등록합니다. 이 메서드는 비동기 포스트백을 수행하는 <see cref="T:System.Web.UI.UpdatePanel" /> 컨트롤 내에 있는 포스트백 컨트롤을 구성하는 데 사용됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A> 내에 있는 포스트백 컨트롤을 등록 하는 메서드는 <xref:System.Web.UI.UpdatePanel> 트리거로 사용 되는 컨트롤입니다. 이 메서드를 사용 하 여 등록 된 컨트롤에만 업데이트 하는 대신 전체 페이지를 업데이트 합니다 <xref:System.Web.UI.UpdatePanel> 컨트롤의 콘텐츠입니다. 포스트백 컨트롤 외부에 있는이 메서드를 사용 하 여 등록을 <xref:System.Web.UI.UpdatePanel> 이러한 컨트롤은 기본적으로 비동기 포스트백을 수행 하지 않기 때문에 컨트롤에 영향을 미치지 않습니다.  
  
 사용 하 여 트리거가 선언적으로 추가할 수 있습니다는 `Triggers` 의 요소는 <xref:System.Web.UI.UpdatePanel> 제어 합니다. Visual Studio에서 디자이너를 사용 **UpdatePanelTrigger 컬렉션 편집기** 대화 상자.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)&#xA;override this.RegisterScriptControl : 'ScriptControl -&gt; unit (requires 'ScriptControl :&gt; System.Web.UI.Control and 'ScriptControl :&gt; System.Web.UI.IScriptControl)" Usage="scriptManager.RegisterScriptControl scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl"><see cref="T:System.Web.UI.IScriptControl" /> 인터페이스를 구현하는 컨트롤입니다.</typeparam>
        <param name="scriptControl">등록할 스크립트 컨트롤입니다.</param>
        <summary>스크립트 컨트롤을 현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 주로 컨트롤 개발자가 사용 합니다. 호출을 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> 메서드 중 사용자 지정 ASP.NET Ajax 스크립트 컨트롤에서 해당 `onInit` 컨트롤을 등록 하려면 해당 페이지를 사용 하 여 이벤트 처리기입니다. ASP.NET Ajax 스크립트 컨트롤 부분 페이지 렌더링에 참여 하려면 등록 되어야 합니다.  
  
 합니다 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A> 메서드 중에 처리 되는 스크립트 컨트롤의 내부 목록에는 지정 된 extender 컨트롤을 추가 합니다 <xref:System.Web.UI.Control.PreRender> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="scriptControl" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트 컨트롤, 구성 요소 또는 동작을 나타내는 클라이언트 개체를 지원하는 스크립트를 반환하려면 <see cref="T:System.Web.UI.ScriptControl" /> 또는 <see cref="T:System.Web.UI.ExtenderControl" /> 클래스를 다시 호출하도록 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에 지시합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IExtenderControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors extenderControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">스크립트 설명자가 등록되는 extender 컨트롤입니다.</param>
        <summary>클라이언트 컨트롤, 구성 요소 또는 동작을 나타내는 클라이언트 개체를 지원하도록 렌더링해야 하는 인스턴스 스크립트를 반환하기 위해 <see cref="T:System.Web.UI.ExtenderControl" /> 클래스를 다시 호출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ExtenderControl> 클래스를 <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> 에서 메서드는 <xref:System.Web.UI.Control.Render%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 하는 경우는 <see cref="T:System.Web.UI.ExtenderControl" /> 클래스를 재정의 합니다 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 있지만 메서드는 기본 클래스 메서드를 호출 하지 않으면 호출 해야 합니다는 <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" /> 메서드. 그러면는 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 나타내는 클라이언트 개체를 지원 하는 인스턴스 스크립트를 렌더링 하는 컨트롤입니다.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberSignature Language="F#" Value="abstract member RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit&#xA;override this.RegisterScriptDescriptors : System.Web.UI.IScriptControl -&gt; unit" Usage="scriptManager.RegisterScriptDescriptors scriptControl" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">스크립트 설명자가 등록되는 스크립트 컨트롤입니다.</param>
        <summary>클라이언트 컨트롤, 구성 요소 또는 동작을 나타내는 클라이언트 개체를 지원하도록 렌더링해야 하는 인스턴스 스크립트를 반환하기 위해 <see cref="T:System.Web.UI.ScriptControl" /> 클래스를 호출합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ScriptControl> 클래스를 <xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A> 메서드 중 해당 <xref:System.Web.UI.Control.Render%2A> 이벤트입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 하는 경우는 <see cref="T:System.Web.UI.ScriptControl" /> 클래스를 재정의 합니다 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 있지만 메서드는 기본 클래스 메서드를 호출 하지 않으면 호출 해야 합니다는 <see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" /> 메서드. 그러면는 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 나타내는 클라이언트 개체를 지원 하는 인스턴스 스크립트를 렌더링 하는 컨트롤입니다.</para></block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 시작 스크립트 블록을 등록하고 해당 스크립트 블록을 페이지에 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Control * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (control, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">클라이언트 스크립트 블록을 등록하는 컨트롤입니다.</param>
        <param name="type">클라이언트 스크립트 블록의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 블록의 고유 식별자입니다.</param>
        <param name="script">등록할 스크립트입니다.</param>
        <param name="addScriptTags">스크립트 블록을 <see langword="&lt;script&gt;" /> 및 <see langword="&lt;/script&gt;" /> 태그로 묶으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 <see cref="T:System.Web.UI.UpdatePanel" /> 내에 있는 컨트롤에 대해 시작 스크립트 블록을 등록한 후 해당 스크립트 블록을 페이지에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 부분 페이지 렌더링과와 호환 되는 페이지에 대 한 시작 스크립트 블록을 등록 하는 방법에 Microsoft Ajax Library 종속성이 없습니다. 이 메서드를 사용 하 여 등록 된 시작 스크립트 블록 내에서 블록을 등록 하는 경우에 페이지로 전송 됩니다는 <xref:System.Web.UI.UpdatePanel> 업데이트 되는 컨트롤입니다. 비동기 포스트백이 발생할 때마다 시작 스크립트 블록을 등록 하려면는 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트를 등록 하려는 경우는 시작 스크립트를 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 렌더링 되는 스크립트 블록을 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 메서드는 페이지 로드가 완료 되 면 하기 전에 실행 페이지의 클라이언트 `onload` 이벤트가 발생 합니다. 시작 스크립트 블록은 렌더링된 된 ASP.NET 페이지의 맨 아래에서 바로 앞의 `</form>` 태그입니다.  
  
 사용 하 여 등록 된 시작 스크립트 블록 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A> 등록 된 동일한 순서로 출력할 보장이 없습니다. 사용 하 여 시작 스크립트 블록의 순서가 중요 한 경우는 <xref:System.Text.StringBuilder> 개체를 단일 문자열로의 스크립트 블록을 수집 하 고 다음 단일 시작 스크립트로 모든이 등록 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" />가 <see langword="null" />인 경우  
  
\- 또는 - 
 <paramref name="type" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="control" />이 페이지의 컨트롤 트리에 있지 않은 경우</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="static member RegisterStartupScript : System.Web.UI.Page * Type * string * string * bool -&gt; unit" Usage="System.Web.UI.ScriptManager.RegisterStartupScript (page, type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">클라이언트 스크립트 블록을 등록하는 페이지 개체입니다.</param>
        <param name="type">클라이언트 스크립트 블록의 형식입니다. 이 매개 변수는 일반적으로 스크립트를 등록하는 컨트롤의 형식을 검색하기 위해 typeof 연산자(C#) 또는 GetType 연산자(Visual Basic)를 사용하여 지정됩니다.</param>
        <param name="key">스크립트 블록의 고유 식별자입니다.</param>
        <param name="script">등록할 스크립트입니다.</param>
        <param name="addScriptTags">스크립트 블록을 <see langword="&lt;script&gt;" /> 및 <see langword="&lt;/script&gt;" /> 태그로 묶으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤을 사용하여 비동기 포스트백이 발생할 때마다 시작 스크립트 블록을 등록하고 페이지에 스크립트 블록을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 포함 된 비동기 포스트백이 발생할 때마다 시작 스크립트 블록을 등록 합니다. 내에 있는 컨트롤에 대 한 스크립트 블록을 등록 하려면를 <xref:System.Web.UI.UpdatePanel> 스크립트 블록은 등록 되도록 경우에만 합니다 <xref:System.Web.UI.UpdatePanel> 컨트롤이 업데이트를 사용 하 여는 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29> 이 메서드의 오버 로드 합니다.  
  
 부분 페이지 업데이트와 관련 되지 않으며 사용 하 여 초기 페이지 렌더링 시 한 번만 스크립트를 등록 하려는 경우는 시작 스크립트를 등록 하려는 경우는 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> 메서드는 <xref:System.Web.UI.ClientScriptManager> 클래스입니다. 에 대 한 참조를 가져올 수 있습니다 합니다 <xref:System.Web.UI.ClientScriptManager> 에서 개체를 <xref:System.Web.UI.Page.ClientScript%2A> 페이지의 속성입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="scriptManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">페이지에 쓸 컨트롤의 내용을 받는 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Web.UI.HtmlTextWriter" /> 개체를 사용하여 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤의 내용을 브라우저에 렌더링합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 컨트롤 개발자가 확장 된 <xref:System.Web.UI.ScriptManager> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>이 메서드를 재정의 하는 경우 호출 기본 <see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" /> 메서드는 클래스를 정의 하는 클라이언트 스크립트 페이지의 렌더링 되도록 합니다.</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveCompositeScriptReference : EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " Usage="member this.ResolveCompositeScriptReference : System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>복합 스크립트가 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에 등록될 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberSignature Language="F#" Value="member this.ResolveScriptReference : EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " Usage="member this.ResolveScriptReference : System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.UI.ScriptManager.Scripts" /> 컬렉션의 멤버가 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤에 등록될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 한 번의 각 멤버에 대 한 합니다 <xref:System.Web.UI.ScriptManager.Scripts%2A> 페이지의 컬렉션 <xref:System.Web.UI.Control.PreRender> 이벤트입니다. 이 이벤트를 사용 하 여 페이지에 스크립트를 렌더링 하기 전에 모든 업데이트를 수행 하 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RoleService : System.Web.UI.RoleServiceManager" Usage="System.Web.UI.ScriptManager.RoleService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스와 관련된 <see cref="T:System.Web.UI.RoleServiceManager" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.RoleServiceManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.RoleServiceManager> 이 속성에 의해 반환 되는 개체는 페이지를 사용 하 여 등록 역할 서비스를 나타냅니다. 역할 서비스를 정의할 수 있습니다 합니다 <xref:System.Web.UI.ScriptManager> 제어 나 관련 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다. ASP.NET 역할 서비스를 사용할 수도 있고 사용자 지정 역할 서비스를 사용할 수 있습니다. 포함 하 여 태그에 사용자 지정 서비스를 추가할 수 있습니다는 `RoleService` 내부 요소는 `asp:ScriptManager` 페이지에서 다음 예제에서와 같이 요소:  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 또한 프로그래밍 방식으로 구성할 수 있습니다는 <xref:System.Web.UI.RoleServiceManager> 개체입니다. 서비스에 등록 되는 <xref:System.Web.UI.ScriptManager> 페이지의 컨트롤 <xref:System.Web.UI.Control.PreRender> 수명 주기 단계입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptMode : System.Web.UI.ScriptMode with get, set" Usage="System.Web.UI.ScriptManager.ScriptMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>디버그 또는 릴리스 버전의 클라이언트 스크립트 라이브러리가 렌더링되는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>현재 모드를 나타내는 열거형 값입니다. 기본값은 <see cref="F:System.Web.UI.ScriptMode.Auto" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 속성을 지정 하는지 여부를 <xref:System.Web.UI.ScriptManager> 컨트롤 렌더링 디버그 또는 릴리스 버전의 클라이언트 스크립트 라이브러리가 해야 합니다. 이 값은 page 지시문에서 구성 파일에 설정 된 값으로 대체 될 수 있습니다.  
  
 다음 표에서이 속성에 대 한 유효한 값을 나열합니다.  
  
|값|정의|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|디버그 버전의 클라이언트 스크립트 라이브러리는 웹 페이지의 경우는 `retail` 구성 요소의 특성이로 설정 된 `false`합니다. 그렇지 않은 경우 릴리스 버전의 클라이언트 스크립트 라이브러리가 사용 됩니다.|  
|<xref:System.Web.UI.ScriptMode.Inherit>|적용할 때 합니다 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 의 속성을 <xref:System.Web.UI.ScriptManager> 개체를이 값은 동일 <xref:System.Web.UI.ScriptMode.Auto>.|  
|<xref:System.Web.UI.ScriptMode.Debug>|디버그 버전의 클라이언트 스크립트 라이브러리는 경우가 아니면 웹 페이지에 사용 되는 `retail` 구성 요소의 특성이로 설정 된 `true`합니다.|  
|<xref:System.Web.UI.ScriptMode.Release>|경우가 아니면 웹 페이지에서 클라이언트 스크립트 라이브러리의 릴리스 버전 되는 `retail` 구성 요소의 특성이로 설정 된 `false`합니다.|  
  
> [!NOTE]
>  `debug` 지시문의 특성 Ajax 사용 ASP.NET 응용 프로그램에 영향을 주지 않습니다. 합니다 <xref:System.Web.UI.ScriptManager> 컨트롤 및 Web.config 파일에서 설정만 사용 하 여 해당 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A> 및 <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 디버그 스크립트를 렌더링할지 여부를 결정 하는 속성입니다.  
  
 자세한 내용은 [디버깅 및 추적 Ajax Applications Overview](https://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Web.UI.ScriptManager.ScriptMode" />속성이 <see cref="T:System.Web.UI.ScriptMode" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptPath : string with get, set" Usage="System.Web.UI.ScriptManager.ScriptPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET AJAX 및 사용자 지정 스크립트 파일의 경로를 빌드하는 데 사용되는 위치의 루트 경로를 가져오거나 설정합니다.</summary>
        <value>스크립트 파일이 저장되는 위치입니다. 기본값은 빈 문자열("")이며 상대 경로로 해석됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 속성을 사용 하면 상대 절대를 지정할 수 있습니다 또는 페이지의 모든 스크립트에 대 한 응용 프로그램 상대 URL을 차단 합니다. 여기에 현재 등록 된 사용자 지정 및 제 3 자 스크립트 블록 <xref:System.Web.UI.ScriptManager> 인스턴스. 합니다 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 속성은 일반적으로 선언적 특성으로 설정 된 `ScriptManager` 코드에도 페이지 있지만 요소를 설정할 수 있습니다.  
  
 경우는 `path` 특성 또는 <xref:System.Web.UI.ScriptReferenceBase.Path%2A> 에 대 한 속성을 <xref:System.Web.UI.ScriptReference> 개체를 <xref:System.Web.UI.ScriptManager.Scripts%2A> 컬렉션 경로 값을 재정의 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 값 <xref:System.Web.UI.ScriptReference> 인스턴스.  
  
 없으면 <xref:System.Web.UI.ScriptReferenceBase.Path%2A> 값을 지정 합니다 <xref:System.Web.UI.ScriptManager> 컨트롤에 정의 된 디렉터리를 검색를 <xref:System.Web.UI.ScriptManager.ScriptPath%2A> 속성과 확인 스크립트에서 참조 해당 <xref:System.Web.UI.ScriptReference.Name%2A> 또는 <xref:System.Web.UI.ScriptReference.Assembly%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScriptResourceMapping : System.Web.UI.ScriptResourceMapping" Usage="System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.ScriptResourceMapping" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.ScriptResourceMapping" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정적 <xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A> 속성에서 반환 된 <xref:System.Web.UI.ScriptResourceMapping> 스크립트 리소스 (스크립트 리디렉션)의 위치를 나타내는 매핑의 컬렉션을 포함할 수 있는 개체입니다. 이 매핑 컬렉션 기반 이름 또는 이름/어셈블리 쌍으로 매핑될 수 있으며를 가리킬 수 있습니다는 <xref:System.Web.UI.ScriptResourceDefinition> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 하는 방법을 보여 줍니다는 <xref:System.Web.UI.ScriptResourceDefinition> 에서 참조할 수 있는 개체를 <xref:System.Web.UI.ScriptManager> 개체입니다. Global.asax 파일에 다음 코드를 추가 합니다 `Application_Start` 이벤트입니다.  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 ASP.NET Web Forms 페이지 (.aspx 파일)에 대 한 태그에서 안에 다음 태그를 추가 합니다 `form` 요소와 모든 요소 또는 jQuery 스크립트를 사용 하는 코드입니다.  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scripts : System.Web.UI.ScriptReferenceCollection" Usage="System.Web.UI.ScriptManager.Scripts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>각각 클라이언트에 렌더링되는 스크립트 파일을 나타내는 <see cref="T:System.Web.UI.ScriptReferenceCollection" /> 개체가 포함된 <see cref="T:System.Web.UI.ScriptReference" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Web.UI.ScriptReferenceCollection" /> 인스턴스의 <see cref="T:System.Web.UI.ScriptManager" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ScriptReferenceCollection> 이 속성에 의해 반환 되는 개체의 컬렉션인 <xref:System.Web.UI.ScriptReference> 스크립트 파일을 각각 나타내는 개체입니다. 컬렉션에 사용자 지정 스크립트 파일 및 ASP.NET에 Ajax 기능을 위해 필요한 모든 스크립트 파일에 대 한 참조가 포함 되어 있습니다. 렌더링할 사용자 지정 스크립트 파일에서 정의할 수 있습니다 합니다 <xref:System.Web.UI.ScriptManager> 제어 나 관련 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다.  
  
 태그의 컬렉션에 추가 하 여 스크립트 파일을 추가할 수 있습니다 `asp:ScriptReference` 요소를 사용 하는 `Scripts` 노드 내는 `asp:ScriptManager` 페이지에서 다음 예제에서와 같이 요소입니다.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 추가할 수도 있습니다는 <xref:System.Web.UI.ScriptReference> 개체를 <xref:System.Web.UI.ScriptManager.Scripts%2A> 사용 하 여 프로그래밍 방식으로 컬렉션을 <xref:System.Collections.ObjectModel.Collection%601.Add%2A> 메서드의 <xref:System.Web.UI.ScriptReferenceCollection> 클래스.  
  
 합니다 <xref:System.Web.UI.ScriptManager> 제어 하는 동안 컨트롤의 스크립트 파일을 등록 <xref:System.Web.UI.Control.PreRender> 이벤트입니다.  
  
 <xref:System.Web.UI.ScriptManager.Scripts%2A> 핵심 Microsoft Ajax Library 스크립트 컬렉션에 없습니다. 핵심 라이브러리의 스크립트를 자동으로 렌더링 됩니다. 등록할 필요가 없습니다를 <xref:System.Web.UI.ScriptManager> 제어 합니다. 그러나 코어 스크립트 또는 모든 제어 스크립트를 재정의 하 고 스크립트의 다른 버전으로 대체 하려는 경우 버전을 추가할 수는 <xref:System.Web.UI.ScriptManager.Scripts%2A> 컬렉션입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Services : System.Web.UI.ServiceReferenceCollection" Usage="System.Web.UI.ScriptManager.Services" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET이 클라이언트에서 AJAX 기능을 위해 노출하는 각 웹 서비스에 대해 <see cref="T:System.Web.UI.ServiceReference" /> 개체가 포함된 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Web.UI.ScriptManager" /> 인스턴스에 대한 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.ServiceReferenceCollection> 이 속성에 의해 반환 되는 개체의 컬렉션인 <xref:System.Web.UI.ServiceReference> 각각에 등록 된 웹 서비스를 나타내는 개체를 <xref:System.Web.UI.ScriptManager> 제어 합니다. 서비스를 정의할 수 있습니다 합니다 <xref:System.Web.UI.ScriptManager> 제어 나 관련 <xref:System.Web.UI.ScriptManagerProxy> 제어 합니다.  
  
 서비스를 추가 하 여 태그의 컬렉션에 추가할 수 있습니다는 `asp:ServiceReference` 요소를 `Services` 요소 내는 `asp:ScriptManager` 다음 예제에서와 같이 페이지의 인스턴스.  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 또한 프로그래밍 방식으로 추가할 수 있습니다는 <xref:System.Web.UI.ServiceReference> 개체를 <xref:System.Web.UI.ScriptManager.Services%2A> 사용 하 여 컬렉션을 <xref:System.Collections.ObjectModel.Collection%601.Add%2A> 메서드의 <xref:System.Web.UI.ServiceReferenceCollection> 클래스.  
  
 서비스에 등록 됩니다 합니다 <xref:System.Web.UI.ScriptManager> 페이지의 <xref:System.Web.UI.Control.PreRender> 수명 주기 단계입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>브라우저 포커스를 지정된 컨트롤로 설정합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="scriptManager.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">포커스를 받는 컨트롤의 ID입니다.</param>
        <summary>브라우저 포커스를 ID로 지정된 컨트롤로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드처럼 작동 합니다 <xref:System.Web.UI.Page.SetFocus%2A> 에 대 한 메서드는 <xref:System.Web.UI.Page> 클래스입니다. 두 메서드는 지정 된 ID 사용 하 여 컨트롤이 웹 페이지에 있는 활성 컨트롤을 만듭니다. 합니다 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드는 <xref:System.Web.UI.ScriptManager> 클래스 비동기 포스트백 도중 포커스를 설정 하는 데 사용 됩니다. 포스트백 및 페이지를 처음 렌더링할 때 중 합니다 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드 호출을 <xref:System.Web.UI.Page.SetFocus%2A> 메서드의 <xref:System.Web.UI.Page> 클래스.  
  
 경우에 대 한 여러 호출을 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드에 대 한 마지막 호출에서 컨트롤 포커스를 받을.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="scriptManager.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">포커스를 받을 컨트롤입니다.</param>
        <summary>브라우저 포커스를 지정된 컨트롤로 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드처럼 작동 합니다 <xref:System.Web.UI.Page.SetFocus%2A> 에 대 한 메서드는 <xref:System.Web.UI.Page> 클래스입니다. 두 메서드는 지정된 된 컨트롤이 웹 페이지에 있는 활성 컨트롤을 만듭니다. 합니다 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드는 <xref:System.Web.UI.ScriptManager> 클래스 비동기 포스트백 도중 포커스를 설정 하는 데 사용 됩니다. 포스트백 및 페이지를 처음 렌더링할 때 중 합니다 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드 호출을 <xref:System.Web.UI.Page.SetFocus%2A> 메서드의 <xref:System.Web.UI.Page> 클래스.  
  
 경우에 대 한 여러 호출을 <xref:System.Web.UI.ScriptManager.SetFocus%2A> 메서드를 마지막 호출에 지정 된 컨트롤이 포커스를 받을.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SupportsPartialRendering : bool with get, set" Usage="System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에서 부분 페이지 렌더링을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>클라이언트에서 부분 페이지 렌더링을 지원하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A> 속성이 `false`의 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 속성에서 반환 `false`합니다.  
  
 부분 페이지 렌더링 지원 되는지 여부를 확인 하려면 기본 검사 반환 `true` 다음 조건에 해당할 경우:  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A> 1.0 보다 크거나 같은 경우 속성 값 이어야 합니다.  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A> 1.0 보다 크거나 같은 경우 속성 값 이어야 합니다.  
  
-   합니다 <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> 속성 값 설정 해야 `true`합니다.  
  
 경우는 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 속성을 명시적으로 설정 하면 이러한 검사는 사용 되지 않습니다.  
  
 컨트롤 개발자가 사용 해야는 <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A> 부분 페이지 렌더링을 지원 하는지 여부를 결정 하는 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 속성이 <see langword="false" />로, <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 속성이 <see langword="true" />로 설정된 경우  
  
\- 또는 - 
<see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 이벤트가 발생한 후 <see cref="E:System.Web.UI.Control.Init" /> 속성이 설정된 경우</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">컨트롤의 키 식별자입니다.</param>
        <param name="postCollection">들어오는 모든 게시 데이터의 컬렉션입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />를 참조하세요.</summary>
        <returns>포스트백을 실행한 후에 <see cref="T:System.Web.UI.ScriptManager" /> 컨트롤의 상태가 변경되었으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.ScriptManager> 인스턴스가 <xref:System.Web.UI.IPostBackDataHandler> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Web.UI.ScriptManager> 인스턴스가 <xref:System.Web.UI.IPostBackDataHandler> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">웹 페이지의 기록 상태를 나타내는 키/값 쌍의 문자열입니다.</param>
        <summary><see cref="T:System.Web.UI.ScriptManager" /> 컨트롤이 포스트백 이벤트를 처리하고 웹 페이지의 기록 상태를 로드할 수 있도록 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::IScriptManager::IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.ScriptManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 값을 설정할 수 없도록 기본 <see cref="P:System.Web.UI.Control.Visible" /> 클래스에서 상속된 <see cref="T:System.Web.UI.Control" /> 속성을 재정의합니다.</summary>
        <value>모든 경우에 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.UI.Control.Visible%2A> 속성에서 재정의 되는 <xref:System.Web.UI.ScriptManager> 이 값을 설정할 수 없도록 하는 클래스입니다. <xref:System.NotImplementedException> 값이이 속성에 할당 되 면 발생 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><see cref="P:System.Web.UI.ScriptManager.Visible" /> 속성에 값이 할당된 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>