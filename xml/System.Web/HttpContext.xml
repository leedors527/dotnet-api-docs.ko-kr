<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5c28d1607bddef09bcbbd3625eed267c59eed3d5" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57928063" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>개별 HTTP 요청에 대한 HTTP 관련 정보를 모두 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상속 된 클래스는 <xref:System.Web.IHttpModule> 하 고 <xref:System.Web.IHttpHandler> 인터페이스에 대 한 참조가 제공 됩니다는 <xref:System.Web.HttpContext> 현재 HTTP 요청에 대 한 개체입니다. 내장 함수에 대 한 액세스를 제공 하는 개체 <xref:System.Web.HttpContext.Request%2A>하십시오 <xref:System.Web.HttpContext.Response%2A>, 및 <xref:System.Web.HttpContext.Server%2A> 요청에 대 한 속성입니다.  
  
> [!IMPORTANT] 
> 이 개체는 가비지 수집에 대 한 준비 때는 <xref:System.Web.HttpRequest> 완료 됩니다. 요청 완료 후 용도 같은 정의 되지 않은 동작이 발생할 수 있습니다는 <xref:System.NullReferenceException>합니다.
>
> 이 개체는만 ASP.NET에서 제어 하는 스레드에서 사용할 수 있습니다. 백그라운드 스레드에서 사용은 정의 되지 않은 동작이 발생할 수 있습니다.

## Examples  
 다음 예제에는 액세스의 속성을 표시 하는 방법을 보여 줍니다.는 <xref:System.Web.HttpContext> 개체입니다. 현재 HTTP 요청 컨텍스트를 사용 하 여 액세스를 <xref:System.Web.UI.Page.Context%2A> 의 속성을 <xref:System.Web.UI.Page> 개체입니다.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">컨텍스트의 문제</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.HttpContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpWorkerRequest" /> 개체입니다.</param>
        <summary>지정된 작업자 요청 개체를 사용하는 <see cref="T:System.Web.HttpContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpRequest" /> 개체입니다.</param>
        <param name="response">현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpResponse" /> 개체입니다.</param>
        <summary>지정된 요청과 응답 개체를 사용하여 <see cref="T:System.Web.HttpContext" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청을 받습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">사용자 함수입니다.</param>
        <summary>지정된 사용자 함수를 사용하는 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청을 허용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> 메서드 오버 로드 하 고 전달 `null` 에 대 한는 `options` 매개 변수입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">요청이 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">사용자 함수입니다.</param>
        <param name="options">옵션 개체입니다.</param>
        <summary>지정된 사용자 함수 및 옵션 개체를 사용하는 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청을 허용합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.NotSupportedException">요청이 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">예외 컬렉션에 추가할 <see cref="T:System.Exception" />입니다.</param>
        <summary>현재 HTTP 요청에 대한 예외 컬렉션에 예외를 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP 컨텍스트 개체입니다.</param>
        <summary>요청의 HTTP 부분이 종료될 때 발생하는 가상 이벤트를 발생시킵니다.</summary>
        <returns>구독 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트가 발생 하기 전에 <xref:System.Web.WebSockets.AspNetWebSocket> 연결을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 요청을 처리하는 동안 누적된 오류의 배열을 가져옵니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Exception" /> 개체의 배열입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 작업을 예상하지 못한 경우 ASP.NET 요청의 일부를 처리하는 중에 비동기 작업이 허용되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>비동기 API가 사용되면 안 되는 때에 사용될 경우 ASP.NET에서 예외를 throw하면 <see langword="false" />이고, 그렇지 않으면 <see langword="true" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 플래그 설정 하지 않으면 `true`, ASP.NET 비동기 API를 오용 하는 응용 프로그램을 감지한 경우 예외가 throw 됩니다. 이 있는 비동기 작업은 예상 되지 않는 한 파이프라인 처리 요청에는 포함 하는 동안 비동기 메서드를 호출 하려는 경우 또는 비동기 모듈 또는 처리기를 완료 신호를 보낼 때 비동기 작업 중인 경우 발생할 수 있습니다. 이 동작은 안전망 맞지 않는 비동기 코드 패턴을 예상 하 고 부작용이 있을 작성 하는 경우 초기에 알 수 있도록 하기 위한 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpApplicationState" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpApplicationState" />입니다.  
  
현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpApplication" /> 개체를 가져오려면 <see cref="P:System.Web.HttpContext.ApplicationInstance" />를 사용합니다. (ASP.NET에서는 ASP.NET과 기본 ASP의 혼동을 피하기 위해 <see langword="Application" /> 대신 <see langword="ApplicationInstance" />를 속성이름으로 사용하여 현재 <see cref="T:System.Web.HttpApplication" /> 인스턴스를 참조합니다. 기본 ASP에서 <see langword="Application" />은 전역 애플리케이션 상태 사전을 참조합니다.)</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpApplication" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpApplication" />입니다.  
  
ASP.NET에서는 ASP.NET과 기본 ASP의 혼동을 피하기 위해 <see langword="ApplicationInstance" /> 대신 <see langword="Application" />를 속성 이름으로 사용하여 현재 <see cref="T:System.Web.HttpApplication" /> 인스턴스를 참조합니다. 기본 ASP에서 <see langword="Application" />은 전역 응용 프로그램 상태 사전을 참조합니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">웹 애플리케이션은 통합된 모드의 IIS 7.0에서 실행 중이고, null이 아닌 값을 <see langword="null" />로 변경하려는 시도가 있었습니다.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비동기 미리 로드 모드와 관련된 플래그를 포함하는 개체를 가져오거나 설정합니다.</summary>
        <value>비동기 미리 로드 모드와 관련된 플래그를 포함하는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음으로이 속성에 액세스할 비동기 미리 로드 모드에 대 한 플래그를 포함 하는 개체에서 로드 되는 <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> 구성 파일에서 설정 합니다.  
  
 이 속성을 프로그래밍 방식으로 설정할 수 있지만 속성이 ASP.NET 요청 파이프라인의 `ExecuteRequestHandler` 단계 전에 설정된 경우에만 속성 값 변경이 적용됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 애플리케이션 도메인에 대한 <see cref="T:System.Web.Caching.Cache" /> 개체를 가져옵니다.</summary>
        <value>현재 애플리케이션 도메인에 대한 <see cref="T:System.Web.Caching.Cache" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인스턴스가 두 개는 <xref:System.Web.Caching.Cache> 응용 프로그램 도메인당 클래스입니다. 결과적으로 <xref:System.Web.Caching.Cache> 에서 반환 되는 개체를 <xref:System.Web.HttpContext.Cache%2A> 속성이 <xref:System.Web.Caching.Cache> 응용 프로그램 도메인의 모든 요청에 대 한 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 HTTP 요청에 대한 오류를 모두 지웁니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpContext" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpContext" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 정적 속성은 <xref:System.Web.HttpContext> 클래스입니다. 속성 저장소를 <xref:System.Web.HttpContext> 현재 요청에 적용 되는 인스턴스. 이 인스턴스의 속성은 비정적 속성의 <xref:System.Web.HttpContext> 클래스입니다.  
  
 사용할 수도 있습니다는 <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> 속성에 액세스 합니다 <xref:System.Web.HttpContext> 현재 HTTP 요청에 대 한 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Web.HttpContext.Current%2A> 속성에 액세스 합니다 <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> 및 <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> 메서드 및 <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> 속성입니다. 이 예에서는 세 가지 사용자 지정 예외를 사용 하 여 만듭니다는 <xref:System.Web.HttpContext.AddError%2A> 사용 하 여 메서드를 <xref:System.Web.HttpContext.AllErrors%2A> 배열에 대 한 이러한 예외를 로드 하는 속성입니다. 그런 다음 배열을 포함 하는 페이지 작성 하 고 사용 하는 <xref:System.Web.HttpContext.ClearError%2A> 의 모든 오류를 지우려면 메서드는 <xref:System.Web.UI.Page.Context%2A> 속성.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 실행 중인 처리기를 나타내는 <see cref="T:System.Web.IHttpHandler" /> 개체를 가져옵니다.</summary>
        <value>현재 실행 중인 처리기를 나타내는 <see cref="T:System.Web.IHttpHandler" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 참조 되는 현재 실행 중인 처리기를 <xref:System.Web.HttpContext.CurrentHandler%2A> 속성에서 참조 되는 처리기 보다 다를 수 있습니다는 <xref:System.Web.HttpContext.Handler%2A> 속성입니다. 다른 처리기를 사용 하 여 요청 되었을 때 발생할 수 있습니다 합니다 <xref:System.Web.HttpServerUtility.Execute%2A> 메서드 또는 <xref:System.Web.HttpServerUtility.Transfer%2A> 메서드. 현재 실행 중인 처리기를 처리 완료 되 면 이전에 결정된 처리기 복원 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP 처리기 및 HTTP 모듈 개요</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 처리 중인 <see cref="T:System.Web.HttpApplication" /> 이벤트를 나타내는 <see cref="T:System.Web.RequestNotification" /> 값을 가져옵니다.</summary>
        <value><see cref="T:System.Web.RequestNotification" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성의 통합된 파이프라인 모드가 필요한 [!INCLUDE[iisver](~/includes/iisver-md.md)] 이상.NET Framework 버전 3.0입니다. 사용 가능한 경우 속성은 반환 된 <xref:System.Web.RequestNotification> 값입니다. 값을 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성에서 이벤트를 나타냅니다는 <xref:System.Web.HttpApplication> 인스턴스는 요청을 처리 하 고 현재.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성은 설정할 수 없습니다. 대신에 의해 설정 된 [!INCLUDE[iisver](~/includes/iisver-md.md)] ASP.NET 파이프라인에서 요청을 처리 하는 중입니다. 설정 된 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성 컴파일 오류가 발생 합니다.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> .NET Framework 버전 3.5에서에서 도입 되었습니다.  자세한 내용은 [버전 및 종속성](~/docs/framework/migration-guide/versions-and-dependencies.md)을 참조하세요.  
  
   
  
## Examples  
 다음 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성의 이벤트를 확인 하는 <xref:System.Web.HttpApplication> 현재 요청을 처리 하는 개체를 처리 합니다. 예제에서는 이벤트 처리기의 몇 가지 이벤트를 처리 합니다 <xref:System.Web.HttpApplication> 개체 및 <xref:System.Web.HttpContext.CurrentNotification%2A> 속성 처리 중인 각 이벤트에 대 한 코드는 호출을 결정 합니다.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">이 작업에 [!INCLUDE[iisver](~/includes/iisver-md.md)]의 통합 파이프라인 모드와 .NET Framework 버전 3.0 이상이 필요합니다.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">개체의 <see cref="M:System.IDisposable.Dispose" /> 메서드는 요청의 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 연결 부분이 완료되는 경우에 호출되어야 합니다.</param>
        <summary>이 요청의 <see cref="M:System.IDisposable.Dispose" /> 연결 부분이 완료될 때 호출할 개체의 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 메서드를 사용하도록 설정합니다.</summary>
        <returns>구독 토큰입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IDisposable.Dispose%2A> 요청의 HTTP 부분이 후 대상 개체의 메서드가 호출 되 고 <xref:System.Web.WebSockets.AspNetWebSocket> 연결 종료 합니다. <xref:System.Web.HttpContext> 개체를 검사할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 요청을 처리하는 동안 누적된 오류가 있으면 첫 번째 오류를 가져옵니다.</summary>
        <value>현재 HTTP 요청/응답 프로세스의 첫 번째 <see cref="T:System.Exception" />이거나 HTTP 요청을 처리하는 동안 오류가 발생하지 않은 경우 <see langword="null" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">정보가 요청된 응용 프로그램 구성 태그입니다.</param>
        <summary>현재 응용 프로그램에 대해 요청된 구성 정보를 반환합니다.</summary>
        <returns>구성 정보가 들어 있는 개체입니다. 반환된 구성 섹션을 사용하기 전에 적절한 구성 형식으로 캐스팅합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetAppConfig%2A> 메서드는 사용되지 않습니다. 사용 하 여는 <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> 메서드를 <xref:System.Web.Configuration.WebConfigurationManager> 클래스를 현재 응용 프로그램에 대 한 구성 정보를 가져옵니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">정보가 요청된 구성 태그입니다.</param>
        <summary>현재 HTTP 요청에 대해 요청된 구성 정보를 반환합니다.</summary>
        <returns>섹션이 없는 경우 지정된 <see cref="T:System.Configuration.ConfigurationSection" />인 <see langword="null" />이고, 런타임에 액세스할 수 없는 섹션인 경우 내부 개체입니다. 반환된 개체를 사용하기 전에 적절한 구성 형식으로 캐스팅합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.GetConfig%2A> 메서드는 사용되지 않습니다. 사용 하 여는 <xref:System.Web.HttpContext.GetSection%2A> 메서드를 현재 HTTP 요청에 대 한 구성 정보를 가져옵니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>응용 프로그램 수준의 리소스를 가져옵니다.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET 웹 사이트 레이아웃</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 속성을 나타내는 문자열입니다.</param>
        <param name="resourceKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성을 나타내는 문자열입니다.</param>
        <summary>지정된 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 및 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성에 따라 응용 프로그램 수준의 리소스 개체를 가져옵니다.</summary>
        <returns>요청된 응용 프로그램 수준 리소스 개체를 나타내는 <see cref="T:System.Object" />이며, 리소스 개체를 찾을 수 없거나 리소스 개체를 찾았지만 요청된 속성이 없는 경우 null입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> 에 지정 된 문화권을 사용 하 여 전역 리소스를 반환 하는 메서드는 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> 속성입니다.  
  
> [!NOTE]
>  일부 편집 환경와 같은 [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]를 편집기에는 디자인 타임 throw 할 수 있습니다 <xref:System.Resources.MissingManifestResourceException> 전역 리소스 키 이름에 마침표 (.)를 사용 하는 경우는 예외입니다. 그러나이 편집 또는 파일을 저장 하는 기능에는 영향을 주지 않습니다 하 고 오류를 무시할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">지정된 <paramref name="classKey" /> 매개 변수를 찾을 수 없는 리소스 개체의 경우  
  
또는 
주 어셈블리에 중립 문화권에 대한 리소스가 포함되어 있지 않은데 적절한 위성 어셈블리가 없기 때문에 이러한 리소스가 필요한 경우</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET 웹 사이트 레이아웃</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">리소스 패키징 및 배포</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 속성을 나타내는 문자열입니다.</param>
        <param name="resourceKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성을 나타내는 문자열입니다.</param>
        <param name="culture">요청된 리소스의 <see cref="T:System.Globalization.CultureInfo" /> 개체를 나타내는 문자열입니다.</param>
        <summary>지정된 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> 및 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성과 <see cref="T:System.Globalization.CultureInfo" /> 개체에 따라 응용 프로그램 수준의 리소스 개체를 가져옵니다.</summary>
        <returns>요청된 응용 프로그램 수준 리소스 개체를 나타내며 특정 문화권에 맞게 지역화된 <see cref="T:System.Object" />이며, 리소스 개체를 찾을 수 없거나 리소스 개체를 찾았지만 요청된 속성이 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo> 개체는 리소스가 지역화 된 문화권을 나타내는입니다. 리소스가이 문화권에 대 한 지역화 되지 않으면, 조회를 적절 한 리소스를 찾기 위한 대체 (fallback) 프로세스가 실행 됩니다. 자세한 내용은 [리소스 패키지 및 배포](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)를 참조하세요.  
  
> [!NOTE]
>  Visual Web Developer와 같은 일부 편집 환경에서는 편집기에는 디자인 타임 throw 할 수 있습니다 <xref:System.Resources.MissingManifestResourceException> 전역 리소스 키 이름에 마침표 (.)를 사용 하는 경우는 예외입니다. 그러나이 편집 또는 파일을 저장 하는 기능에는 영향을 주지 않습니다 하 고 오류를 무시할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">지정된 <paramref name="classKey" /> 매개 변수를 찾을 수 없는 리소스 개체의 경우  
  
또는 
주 어셈블리에 중립 문화권에 대한 리소스가 포함되어 있지 않은데 적절한 위성 어셈블리가 없기 때문에 이러한 리소스가 필요한 경우</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">리소스 패키징 및 배포</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>페이지 수준의 리소스를 가져옵니다.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET 웹 사이트 레이아웃</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">리소스 패키징 및 배포</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">로컬 리소스 개체의 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 속성입니다.</param>
        <param name="resourceKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성을 나타내는 문자열입니다.</param>
        <summary>지정된 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 및 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성에 따라 페이지 수준의 리소스 개체를 가져옵니다.</summary>
        <returns>요청된 페이지 수준 리소스 개체를 나타내는 <see cref="T:System.Object" />이거나 일치하는 리소스 개체를 찾았지만 <paramref name="resourceKey" /> 매개 변수가 아니면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.GetLocalResourceObject%2A> 에 지정 된 문화권을 사용 하 여 로컬 리소스를 반환 하는 메서드는 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">지정된 <paramref name="virtualPath" /> 매개 변수에 대해 찾을 수 없는 리소스 개체의 경우</exception>
        <exception cref="T:System.ArgumentException">지정된 <paramref name="virtualPath" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException">페이지에 대한 리소스 클래스가 없는 경우</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET 웹 사이트 레이아웃</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">리소스 패키징 및 배포</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">방법: 리소스 값을 프로그래밍 방식으로 검색</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">로컬 리소스 개체의 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 속성입니다.</param>
        <param name="resourceKey">요청된 리소스 개체의 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성을 나타내는 문자열입니다.</param>
        <param name="culture">요청된 리소스 개체의 <see cref="T:System.Globalization.CultureInfo" /> 개체를 나타내는 문자열입니다.</param>
        <summary>지정된 <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> 및 <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> 속성과 <see cref="T:System.Globalization.CultureInfo" /> 개체에 따라 페이지 수준의 리소스 개체를 가져옵니다.</summary>
        <returns>요청된 로컬 리소스 개체를 나타내며 특정 문화권에 맞게 지역화된 <see cref="T:System.Object" />이거나 일치하는 리소스 개체를 찾았지만 <paramref name="resourceKey" /> 매개 변수가 아니면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리소스가이 문화권에 대 한 지역화 되지 않으면, 조회를 적절 한 리소스를 찾기 위한 대체 (fallback) 프로세스가 실행 됩니다. 자세한 내용은 [리소스 패키지 및 배포](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)를 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">지정된 <paramref name="virtualPath" /> 매개 변수에 대해 찾을 수 없는 리소스 개체의 경우</exception>
        <exception cref="T:System.ArgumentException">지정된 <paramref name="virtualPath" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <exception cref="T:System.InvalidOperationException">페이지에 대한 리소스 클래스가 없는 경우</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">응용 프로그램의 리소스</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">ASP.NET 웹 사이트 레이아웃</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">리소스 패키징 및 배포</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">방법: 리소스 값을 프로그래밍 방식으로 검색</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">구성 섹션 경로(XPath 형식)와 구성 요소 이름입니다.</param>
        <summary>현재 응용 프로그램의 기본 구성에 대해 지정된 구성 섹션을 가져옵니다.</summary>
        <returns>섹션이 없는 경우 지정된 <see cref="T:System.Configuration.ConfigurationSection" />인 <see langword="null" />이고, 런타임에 액세스할 수 없는 섹션인 경우 내부 개체입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 요청을 처리하는 <see cref="T:System.Web.IHttpHandler" /> 개체를 가져오거나 설정합니다.</summary>
        <value>HTTP 요청을 처리하는 <see cref="T:System.Web.IHttpHandler" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Handler%2A> 속성에는 HTTP 요청을 처리 하는 처리기에 대 한 참조를 포함 합니다. 요소 또는 사용자 코드에 정의 된 사용자 지정 처리기를 사용 하 여 처리기를 지정할 수 있습니다. 처리기에 대 한 자세한 내용은 참조 하세요. [HTTP 처리기 및 HTTP 모듈 개요](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b)합니다.  
  
 에 대 한 참조를 <xref:System.Web.HttpContext.Handler%2A> 속성 같은 서버 쪽 메서드에 의해 변경 된 현재 페이지 후에 그대로 유지 되는 <xref:System.Web.HttpServerUtility.Execute%2A> 메서드 또는 <xref:System.Web.HttpServerUtility.Transfer%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP 처리기 및 HTTP 모듈 개요</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대해 사용자 지정 오류를 사용할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>사용자 지정 오류를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청이 디버그 모드인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>요청이 디버그 모드이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpApplication" /> 이벤트가 처리를 완료한 직후 ASP.NET 파이프라인의 현재 처리 지점인 값을 가져옵니다.</summary>
        <value>사용자 지정 오류를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.IsPostNotification%2A> 속성에서 통합된 모드 에서만 지원 됩니다 [!INCLUDE[iisver](~/includes/iisver-md.md)] 이상 및.NET Framework 3.0. 속성을 나타내는 부울 값을 반환 사용 가능한 경우 이벤트 여부를 <xref:System.Web.HttpApplication> 개체 처리가 완료 되었습니다.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> 속성은 설정할 수 없습니다. 제공 하는 대신 [!INCLUDE[iisver](~/includes/iisver-md.md)] ASP.NET 런타임에 각 알림에 대 한 합니다. 설정 된 <xref:System.Web.HttpContext.IsPostNotification%2A> 속성 컴파일 오류가 발생 합니다.  
  
 시나리오에서 여기서의 여러 이벤트를 <xref:System.Web.HttpApplication> 개체는 하나의 이벤트 처리기에서 처리를 사용할 수 있습니다 합니다 <xref:System.Web.HttpContext.IsPostNotification%2A> 함께에서 속성을 <xref:System.Web.RequestNotification> 정확 하 게 현재 응용 프로그램 수명 주기에서 작업 하는 위치를 결정 하는 열거형 요청이 되었습니다.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> .NET Framework 버전 3.5에서에서 도입 되었습니다.  자세한 내용은 [버전 및 종속성](~/docs/framework/migration-guide/versions-and-dependencies.md)을 참조하세요.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법에 설명 합니다 <xref:System.Web.HttpContext.IsPostNotification%2A> 속성의 이벤트를 확인 하는 <xref:System.Web.HttpApplication> 개체에서 모든 연결 된 이벤트 처리기를 처리를 완료 합니다. 이 예제의 사용자 지정 이벤트 처리기의 몇 가지 이벤트를 처리 합니다 <xref:System.Web.HttpApplication> 개체 및 <xref:System.Web.HttpContext.IsPostNotification%2A> 속성은 확인 코드는 호출 하는 데 특정 이벤트를 처리 한 후입니다.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">이 작업에 [!INCLUDE[iisver](~/includes/iisver-md.md)]의 통합 파이프라인 모드와 .NET Framework 3.0 이상이 필요합니다.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청에 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청이 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>요청이 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 반환 `true` 초기 요청에 포함 하는 경우 <xref:System.Web.WebSockets.AspNetWebSocket> 핸드셰이크 및 `WebSocket` iis 모듈은 active입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결이 HTTP 연결에서 <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 연결로 업그레이드되고 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>연결이 업그레이드 중이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 요청을 수행하는 동안 <see cref="T:System.Web.IHttpModule" /> 인터페이스와 <see cref="T:System.Web.IHttpHandler" /> 인터페이스 간에 데이터를 구성하고 공유하는 데 사용할 수 있는 키/값 컬렉션을 가져옵니다.</summary>
        <value>지정된 키에서 컬렉션의 개별 값에 대한 액세스를 제공하는 <see cref="T:System.Collections.IDictionary" /> 키/값 컬렉션입니다.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">컨텍스트의 문제</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요청에 대한 페이지 계측 서비스 인스턴스에 대한 참조를 가져옵니다.</summary>
        <value>이 요청에 대한 페이지 계측 서비스 인스턴스입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 처리기에 대한 <see cref="T:System.Web.IHttpHandler" /> 개체를 가져옵니다.</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> 인스턴스이며, 그렇지 않고 이전 처리기가 없으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.PreviousHandler%2A> 현재 요청을 실행 하기 전에 속성은 마지막 처리기입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">HTTP 처리기 및 HTTP 모듈 개요</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 사용자 프로필에 대한 <see cref="T:System.Web.Profile.ProfileBase" /> 개체를 가져옵니다.</summary>
        <value>응용 프로그램 구성 파일에 프로필 속성에 대한 정의가 포함되어 있으면 <see cref="T:System.Web.Profile.ProfileBase" />이고, 그렇지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.Profile%2A> 속성 형식이 안전한 API를 사용 하 여 구조화 된 데이터의 영구 저장소에 사용 됩니다. 경우는 <xref:System.Web.HttpContext.Profile%2A> 속성에 액세스 하지만 값이 없으면 빈 인스턴스 반환 됩니다. `null` 반환 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">요청을 처리해야 하는 개체입니다.</param>
        <summary>요청에 대한 처리기를 지정할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 하는 경우 `handler` 에 `null`, 기본 처리기는 요청을 처리 하는 데 사용 됩니다. 설정할 수 있습니다 `handler` 비동기 처리기 또는 동기 처리기입니다. 처리기를 구현 해야 합니다는 <xref:System.Web.IHttpHandler> 인터페이스입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> 이벤트가 발생한 이후 <see cref="E:System.Web.HttpApplication.MapRequestHandler" /> 메서드가 호출된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpRequest" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpRequest" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.Request%2A> 속성의 메서드와 속성을 프로그래밍 방식 액세스를 제공 합니다 <xref:System.Web.HttpRequest> 클래스입니다. ASP.NET 페이지에 대 한 기본 참조를 포함 하기 때문에 <xref:System.Web> 네임 스페이스 (포함 하는 합니다 <xref:System.Web.HttpContext> 클래스)의 멤버를 참조할 수 있습니다 <xref:System.Web.HttpRequest> .aspx 페이지에 대 한 정규화 된 클래스 참조를 사용 하지 않고 <xref:System.Web.HttpContext>합니다. 예를 들어 사용할 수 있습니다 `Request.Browser` 클라이언트 브라우저의 기능을 가져오려고 합니다. 그러나의 멤버를 사용 하려는 경우 <xref:System.Web.HttpRequest> 에서 ASP.NET 코드 숨김 모듈에 대 한 참조를 포함 해야 합니다는 <xref:System.Web> 모듈에 대 한 정규화 된 참조 모두 현재 요청/응답 컨텍스트 네임 스페이스 및 클래스의 <xref:System.Web> 사용 하려는. 예를 들어, 코드 숨김 페이지에 지정 해야 합니다는 정규화 된 이름을 `HttpContext.Current.Request.Browser`입니다.  
  
> [!NOTE]
>  ASP.NET이이 속성을 사용 하려고 하면 예외가 throw 됩니다 때는 <xref:System.Web.HttpRequest> 개체를 사용할 수 없습니다. 예를 들어이 Application_Start 메서드에서 호출 되는 메서드 또는 Global.asax 파일의 Application_Start 메서드에서 true 것입니다. 해당 시점에 없는 HTTP 요청을 아직 만들지 않았습니다 했습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">웹 애플리케이션은 통합 모드의 IIS 7하에 실행되고 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 응답에 대한 <see cref="T:System.Web.HttpResponse" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 응답에 대한 <see cref="T:System.Web.HttpResponse" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.Response%2A> 속성의 메서드와 속성을 프로그래밍 방식 액세스를 제공 합니다 <xref:System.Web.HttpResponse> 클래스입니다. ASP.NET 페이지에 대 한 기본 참조를 포함 하기 때문에 <xref:System.Web> 네임 스페이스 (포함 하는 합니다 <xref:System.Web.HttpContext> 클래스)의 멤버를 참조할 수 있습니다 <xref:System.Web.HttpContext> .aspx 페이지에 대 한 정규화 된 클래스 참조를 사용 하지 않고 <xref:System.Web.HttpContext>합니다. 예를 들어 사용할 수 있습니다 `Response.Write("some output")` 출력을 HTTP 출력 스트림에 쓸 수 있습니다. 그러나의 멤버를 사용 하려는 경우 <xref:System.Web.HttpResponse> 에서 ASP.NET 코드 숨김 모듈에 대 한 참조를 포함 해야 합니다는 <xref:System.Web> 네임 스페이스 모듈 및 현재 활성 요청/응답 컨텍스트 및 클래스에 대 한 정규화 된 참조입니다. <xref:System.Web> 사용 하려는입니다. 예를 들어, 코드 숨김 페이지에 지정 해야 합니다는 정규화 된 이름을 `HttpContext.Current.Response.Write("some output")`입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">웹 애플리케이션은 통합 모드의 IIS 7하에 실행되고 있습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요청한 URL이 나타내는 경로가 아닌 다른 경로로 리소스에 대한 요청을 리디렉션합니다. <see cref="Overload:System.Web.HttpContext.RewritePath" />는 쿠키를 사용하지 않는 세션 상태에서 URL의 세션 ID를 제거하는 데 사용됩니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">내부 재작성 경로입니다.</param>
        <summary>지정한 경로를 사용하여 URL을 다시 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 메서드 요청된 URL에서 표시 되는 것을 다른 경로로 리소스에 대 한 요청을 리디렉션합니다. 서버 리소스에 대 한 클라이언트의 요청이 올바르게 해결 되도록 가상 경로 다시 설정 해야 할 경우는이 메서드의 오버 로드를 사용 합니다 `rebaseClientPath` 매개 변수는 매개 변수를 설정 하 고 `false`입니다.  
  
 URL 재작성 웹 응용 프로그램의 페이지를 재구성 하 고는 이전 Url를 책갈피에 추가한 사람들을 계속 사용할 수 페이지 이동한 후 있는지 확인 하려는 경우 유용 합니다. URL 재작성 투명 하 게 새 페이지 위치로 요청을 전달할 수 있습니다.  
  
 검색 엔진 친화적인 되 고 최적화 되는 Url을 사용 하도록 사이트를 사용 하도록 설정 하려는 경우는 더 강력한 대안 ASP.NET 라우팅을 사용 하는 것입니다. 자세한 내용은 [ASP.NET 라우팅에서](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법의 <xref:System.Web.HttpContext.RewritePath%2A> 웹 사이트 웹 사이트에서 파일 구조를 반영 하지 않는 Url에 응답할 수 있도록 하는 방법입니다. 첫 번째 코드 블록에 RewritePath.aspx 이라고 하는 ASP.NET 웹 페이지입니다. 쿼리 문자열이 필요합니다. 사이트의 이름이 WebSite1, URL `http://localhost/WebSite1/RewritePath.aspx?page=1` 브라우저에 "1 페이지"를 표시 합니다. 웹 페이지에 나오는 코드 블록을 `Application_BeginRequest` Global.asax 파일에 이벤트 처리기입니다. 이 코드 Url에 대 한 같은 요청을 가로채서 `http://localhost/WebSite1/page1` 처리 되기 전에 RewritePath.aspx 데 필요한 형식으로 변환 합니다. 따라서 URL `http://localhost/WebSite1/page1` RewritePath.aspx 브라우저에서 "1 페이지"를 표시 하는 쿼리 문자열 매개 변수를 사용 하 여 호출 합니다. 경우와 같은 URL `http://localhost/WebSite1/page1` 수신 되 면 오버 로드 <xref:System.Web.HttpContext.RewritePath%2A> 가 호출에 대 한 값을 제공할 수 있도록는 <xref:System.Web.HttpRequest.PathInfo%2A> 속성 뿐만 아니라 쿼리 문자열 매개 변수입니다.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">연습: ASP.NET Web Forms 응용 프로그램에서 라우팅 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">내부 재작성 경로입니다.</param>
        <param name="rebaseClientPath">가상 경로를 다시 설정하려면 <see langword="true" />로 지정하고 가상 경로를 변경하지 않고 유지하려면 <see langword="false" />로 지정합니다.</param>
        <summary>지정된 경로와 서버 리소스의 가상 경로가 수정되었는지 여부를 지정하는 부울 값을 사용하여 URL을 다시 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> 메서드를 호출 합니다 <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> 메서드를 `rebaseClientPath` 매개 변수 설정 `true`. 리소스에 대 한 경로 구성 하는 데 사용 되는 가상 경로 수정 되지 되도록 설정 합니다 `rebaseClientPath` 매개 변수를 `false`입니다. 설정 하려는 일반적인 시나리오 `rebaseClientPath` 에 `false` URL 다시 작성 해야 하 고 테마를 사용 하 고 요청된 된 리소스가 아닌 다른 폴더에 있는 리소스에 URL을 리디렉션하는 경우.  
  
 URL 재작성 웹 응용 프로그램의 페이지를 재구성 하 고는 이전 Url를 책갈피에 추가한 사람들을 계속 사용할 수 페이지 이동한 후 있는지 확인 하려는 경우 유용 합니다. URL 재작성 투명 하 게 새 페이지 위치로 요청을 전달할 수 있습니다.  
  
 검색 엔진 친화적인 되 고 최적화 되는 Url을 사용 하도록 사이트를 사용 하도록 설정 하려는 경우는 더 강력한 대안 ASP.NET 라우팅을 사용 하는 것입니다. 자세한 내용은 [ASP.NET 라우팅에서](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)합니다.  
  
   
  
## Examples  
 코드 예제를 참조 하세요.를 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">연습: ASP.NET Web Forms 응용 프로그램에서 라우팅 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">내부 재작성 경로입니다.</param>
        <param name="pathInfo">리소스에 대한 추가 경로 정보입니다. 자세한 내용은 <see cref="P:System.Web.HttpRequest.PathInfo" />를 참조하십시오.</param>
        <param name="queryString">요청 쿼리 문자열입니다.</param>
        <summary>지정된 경로, 경로 정보 및 쿼리 문자열 정보를 사용하여 URL을 다시 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.RewritePath%2A> 메서드 URL을 변경 하지 않고 다른 리소스는 리소스에 대 한 요청을 리디렉션합니다.  
  
 `filePath` 매개 변수는 `pathInfo` 매개 변수 콘텐츠입니다. URL에 대 한 http://www.microsoft.com/virdir/page.html/tail서 `filePath` 매개 변수는 http://www.microsoft.com/virdir/page.html, 및 `pathInfo` 매개 변수는 비상 합니다.  
  
 URL 재작성 웹 응용 프로그램의 페이지를 재구성 하 고는 이전 Url를 책갈피에 추가한 사람들을 계속 사용할 수 페이지 이동한 후 있는지 확인 하려는 경우 유용 합니다. URL 재작성 투명 하 게 새 페이지 위치로 요청을 전달할 수 있습니다.  
  
 검색 엔진 친화적인 되 고 최적화 되는 Url을 사용 하도록 사이트를 사용 하도록 설정 하려는 경우는 더 강력한 대안 ASP.NET 라우팅을 사용 하는 것입니다. 자세한 내용은 [ASP.NET 라우팅에서](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)합니다.  
  
   
  
## Examples  
 이 메서드 오버 로드의 예제를 포함 하 여 코드 예제를 참조 하세요.를 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">연습: ASP.NET Web Forms 응용 프로그램에서 라우팅 사용</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">요청을 처리하는 리소스에 대한 가상 경로입니다.</param>
        <param name="pathInfo">URL 리디렉션에 사용할 추가 경로 정보입니다. 자세한 내용은 <see cref="P:System.Web.HttpRequest.PathInfo" />를 참조하십시오.</param>
        <param name="queryString">URL 리디렉션에 사용할 요청 쿼리 문자열입니다.</param>
        <param name="setClientFilePath">클라이언트 리소스에 사용되는 파일 경로를 <paramref name="filePath" /> 매개 변수 값으로 설정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>지정된 가상 경로, 경로 정보, 쿼리 문자열 정보 및 클라이언트 파일 경로가 다시 작성 경로로 설정되었는지 여부를 지정하는 부울 값을 사용하여 URL을 다시 작성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `filePath` 매개 변수는의 콘텐츠를 포함 하지 않습니다는 `pathInfo` 매개 변수입니다. URL에 대 한 http://www.microsoft.com/virdir/page.html/tail서 `filePath` 매개 변수는 http://www.microsoft.com/virdir/page.html, 및 `pathInfo` 매개 변수는 비상 합니다.  
  
 리소스에 대 한 경로 구성 하는 데 사용 되는 가상 경로 수정 되지 되도록 설정 합니다 `setClientFilePath` 매개 변수를 `false`입니다. 설정 하려는 일반적인 시나리오 `setClientFilePath` 에 `false` URL 다시 작성 해야 하 고 테마를 사용 하 고 요청된 된 리소스가 아닌 다른 폴더에 있는 리소스에 URL을 리디렉션하는 경우.  
  
 URL 재작성 웹 응용 프로그램의 페이지를 재구성 하 고는 이전 Url를 책갈피에 추가한 사람들을 계속 사용할 수 페이지 이동한 후 있는지 확인 하려는 경우 유용 합니다. URL 재작성 투명 하 게 새 페이지 위치로 요청을 전달할 수 있습니다.  
  
 검색 엔진 친화적인 되 고 최적화 되는 Url을 사용 하도록 사이트를 사용 하도록 설정 하려는 경우는 더 강력한 대안 ASP.NET 라우팅을 사용 하는 것입니다. 자세한 내용은 [ASP.NET 라우팅에서](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)합니다.  
  
   
  
## Examples  
 코드 예제를 참조 하세요.를 <xref:System.Web.HttpContext.RewritePath%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> 매개 변수가 현재 응용 프로그램의 루트 디렉터리에 없는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">연습: ASP.NET Web Forms 응용 프로그램에서 라우팅 사용</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>처리하고 있는 웹 요청에 사용되는 메서드를 제공하는 <see cref="T:System.Web.HttpServerUtility" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.HttpServerUtility" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.Server%2A> 속성의 메서드와 속성을 프로그래밍 방식 액세스를 제공 합니다 <xref:System.Web.HttpServerUtility> 클래스입니다. ASP.NET 페이지에 대 한 기본 참조를 포함 하기 때문에 <xref:System.Web> 네임 스페이스 (포함 하는 합니다 <xref:System.Web.HttpContext> 클래스)의 멤버를 참조할 수 있습니다 <xref:System.Web.HttpContext> .aspx 페이지에 대 한 정규화 된 클래스 참조를 사용 하지 않고 <xref:System.Web.HttpContext>합니다. 예를 들어 사용할 수 있습니다 `Server.CreateObject("MyCOMComponent")` 서버의 COM 개체의 인스턴스를 만들려고 합니다. 그러나의 멤버를 사용 하려는 경우 <xref:System.Web.HttpServerUtility> 에서 ASP.NET 코드 숨김 모듈에 대 한 참조를 포함 해야 합니다는 <xref:System.Web> 모듈에 대 한 정규화 된 참조 모두 현재 요청/응답 컨텍스트 네임 스페이스 및 클래스의 <xref:System.Web> 사용 하려는. 예를 들어, 코드 숨김 페이지에 지정 해야 합니다는 정규화 된 이름을 `HttpContext.Current.Server.CreateObject("MyCOMComponent")`입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 <see cref="T:System.Web.SessionState.HttpSessionState" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 요청에 대한 <see cref="T:System.Web.SessionState.HttpSessionState" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.Session%2A> 속성의 메서드와 속성을 프로그래밍 방식 액세스를 제공 합니다 <xref:System.Web.SessionState.HttpSessionState> 클래스입니다.  
  
 세션 상태를 사용 하기 위해 사용 하도록 설정 해야 합니다. 세션 상태를 사용 하는 방법에 대 한 정보를 참조 하세요 **구성 세션 상태** 에 [ASP.NET 세션 상태 개요](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)합니다.  
  
 세션 상태에서 값을 저장 하는 방법에 대 한 정보를 참조 하세요. [방법: 세션 상태에서 값을 저장](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165)합니다. 세션 상태에서 값을 읽는 방법에 대 한 자세한 내용은 [방법: 세션 상태에서 값을 읽는](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5)합니다.  
  
   
  
## Examples  
 다음 예제에서는 세션 상태에서 값을 저장 하는 방법 및 세션 상태에서 값을 읽는 방법을 보여 줍니다.  
  
 이러한 예제에는 다음이 필요합니다.  
  
-   세션 상태가 사용 하도록 설정 하는 ASP.NET 응용 프로그램입니다.  
  
-   액세스할 수 있는 Web Forms 페이지 클래스는 <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> 속성 또는 액세스할 수 있는 모든 클래스는 <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> 속성입니다.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">필요한 세션 상태 동작의 유형을 지정하는 열거형 값 중 하나입니다.</param>
        <summary>HTTP 요청을 지원하기 위해 필요한 세션 상태 동작의 유형을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 기본 구현에서 HTTP 요청 처리기를 구현 하 여 세션 상태가 필요한 지 여부를 나타냅니다 합니다 <xref:System.Web.SessionState.IRequiresSessionState> 인터페이스 또는 <xref:System.Web.SessionState.IReadOnlySessionState> 인터페이스입니다. 합니다 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> 메서드 및 <xref:System.Web.SessionState.SessionStateBehavior> 열거형을 사용 하면 요청을 처리 하는 데 필요한 어떤 유형의 세션 상태 지원과 대 한 자세한 세부 정보를 제공할 수 있습니다. 자세한 내용은 <xref:System.Web.SessionState.SessionStateBehavior> 열거형을 참조하세요.  
  
 합니다 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> 메서드를 호출 하기 전에 <xref:System.Web.HttpApplication.AcquireRequestState> 파이프라인 이벤트입니다. 이 이벤트 전후 동안 발생 하는 호출 하면는 <xref:System.InvalidOperationException> 예외입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="E:System.Web.HttpApplication.AcquireRequestState" /> 이벤트가 발생한 이후 메서드가 호출된 경우</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Security.UrlAuthorizationModule" /> 개체가 현재 요청에 대한 인증 확인을 건너뛰어야 하는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Web.Security.UrlAuthorizationModule" />에서 인증 확인을 건너뛰어야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpContext.SkipAuthorization%2A> 속성 익명 연결을 허용 하는 페이지로 리디렉션하는 인증 모듈에서 고급 사용을 위한 것입니다. 폼 인증 모듈이 고 Passport 인증 모듈 둘 다 설정 <xref:System.Web.HttpContext.SkipAuthorization%2A> 구성된 로그온 페이지로 리디렉션할 때. 설정 <xref:System.Web.HttpContext.SkipAuthorization%2A> 필요는 `ControlPrincipal` 플래그가 설정 됩니다. 에 대 한 자세한 합니다 `ControlPrincipal` 플래그를 참조 하십시오 <xref:System.Security.Permissions.SecurityPermissionFlag>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">서비스 공급자를 설정할 <see cref="T:System.Web.HttpContext" /> 서비스의 형식입니다.</param>
        <summary>현재 서비스 형식에 대한 개체를 반환합니다.</summary>
        <returns><see cref="T:System.Web.HttpContext" />이며, 그렇지 않고 서비스가 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 내부에 대 한 액세스 권한을 얻으려고 유용 <xref:System.Web.HttpWorkerRequest> 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청 시간이 경과될 경우 이 요청을 서비스 중인 스레드에서 ASP.NET 런타임이 <see cref="M:System.Threading.Thread.Abort" />를 호출해야 하는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>스레드가 시간 초과될 때 <see cref="M:System.Threading.Thread.Abort" />를 호출하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리기를 사용 하는 모듈에는 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> 협조적 취소를 구현 하는 속성 사용 하지 않도록 설정 하려는 경우는 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> ASP.NET 요청 시간이 초과 되 면 기본적으로 수행 하는 동작입니다. 이 속성을 설정 `false` ASP.NET에서 중단 되지 않고 취소 및 정리 루틴 실행 되는 되도록 할 수 있습니다.  
  
 이 속성을 설정 하는 경우 `false`, ASP.NET는 자동으로 "요청 시간이 초과 되었습니다" 오류 페이지 표시 제한 시간을 초과 합니다. 응용 프로그램은 응답 콘텐츠를 적절 하 게 설정 하는 일을 담당 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청의 초기 타임스탬프를 가져옵니다.</summary>
        <value>현재 HTTP 요청의 타임스탬프입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 타임 스탬프를 <xref:System.Web.HttpContext.Timestamp%2A> 속성은 서버의 현지 시간 및 인스턴스화하는 동안 설정 되는 <xref:System.Web.HttpContext> 개체입니다. 현지 시간에 UTC 시간을 더한 UTC 오프셋 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 응답에 대한 <see cref="T:System.Web.TraceContext" /> 개체를 가져옵니다.</summary>
        <value>현재 HTTP 응답에 대한 <see cref="T:System.Web.TraceContext" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 요청에 대한 보안 정보를 가져오거나 설정합니다.</summary>
        <value>현재 HTTP 요청에 대한 보안 정보입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpContext.User%2A> 속성의 메서드와 속성을 프로그래밍 방식 액세스를 제공 합니다 <xref:System.Security.Principal.IPrincipal> 인터페이스입니다.  
  
 ASP.NET 페이지에 대 한 기본 참조를 포함 하기 때문에 <xref:System.Web> 네임 스페이스 (포함 하는 합니다 <xref:System.Web.HttpContext> 클래스)의 멤버를 참조할 수 있습니다 <xref:System.Web.HttpContext> .aspx 페이지에 대 한 정규화 된 클래스 참조를 사용 하지 않고 <xref:System.Web.HttpContext>합니다. 예를 들어 사용할 수 있습니다 `User.Identity.Name` 로그온 사용자의 이름 대신 현재 프로세스를 실행 합니다. 그러나의 멤버를 사용 하려는 경우 <xref:System.Security.Principal.IPrincipal> 에서 ASP.NET 코드 숨김 모듈에 대 한 참조를 포함 해야 합니다는 <xref:System.Web> 모듈에 대 한 정규화 된 참조 모두 현재 요청/응답 컨텍스트 네임 스페이스 및 클래스의 <xref:System.Web> 사용 하려는. 예를 들어, 코드 숨김 페이지에 지정 해야 합니다는 정규화 된 이름을 `HttpContext.Current.User.Identity.Name`입니다.  
  
   
  
## Examples  
 다음 예에서는 현재 사용자의 속성에 액세스 하는 방법을 보여 줍니다는 <xref:System.Web.HttpContext.User%2A> 속성입니다. 웹 페이지의 제목을 설정 하려면 해당 속성이 사용 됩니다.  
  
 응용 프로그램에서 Windows 인증을 사용 하는 경우 사용자 이름에 도메인이 포함 됩니다. 예를 들어, 페이지 제목에 "도메인 \ 사용자 이름에 대 한 홈 페이지" 것입니다.  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">MVC 4와 함께 OAuth 공급자 사용</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">ASP.NET 4.5 Web Forms-체크 아웃 및 지불 PayPal 사용 하 여 시작</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">NerdDinner-인증 및 권한 부여를 사용 하 여 보안 응용 프로그램</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 연결을 위해 서버에서 클라이언트로 전송된 협상된 프로토콜을 가져옵니다.</summary>
        <value>협상된 프로토콜입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에서 요청한 프로토콜의 순서 있는 목록을 가져옵니다.</summary>
        <value><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 요청한 프로토콜이며, 요청이 아닌 경우나 목록에 없을 경우는 <see langword="null" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>