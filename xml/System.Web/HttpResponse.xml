<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="356ebbd6238b9f781144ed7b9b8bbf72fee4cd10" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53393358" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ASP.NET 작업에서 받은 HTTP 응답 정보를 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메서드 및 속성의는 <xref:System.Web.HttpResponse> 클래스를 통해 노출 되는 <xref:System.Web.HttpApplication.Response%2A> 의 속성을 <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, 및 <xref:System.Web.UI.UserControl> 클래스.  
  
 다음 메서드는 <xref:System.Web.HttpResponse> 클래스 다시 게시 시나리오 에서만 지원 됩니다 및 비동기 post에 없는 시나리오를 백업 합니다.  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 부분 페이지 업데이트를 사용 하는 경우 사용 <xref:System.Web.UI.UpdatePanel> 컨트롤을 다시 게시를 사용 하 여 전체 페이지를 업데이트 하는 대신 페이지의 선택된 영역을 업데이트 합니다. 자세한 내용은 [UpdatePanel 컨트롤 개요](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) 하 고 [부분 페이지 렌더링 개요](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)합니다.  
  
   
  
## Examples  
 다음 예제에서는 페이지가 요청 될 때 세 가지 겹치는 사각형을 그립니다. 코드를 설정 하 여 시작 합니다 <xref:System.Web.HttpResponse.ContentType%2A> 을 image/jpeg, 속성으로 JPEG 이미지를 전체 페이지를 렌더링할 수 있도록 합니다. 호출 된 <xref:System.Web.HttpResponse.Clear%2A> 불필요 한 콘텐츠 없음이 응답과 함께 전송 되도록 하는 방법입니다. 코드를 다음으로 설정 하 여 <xref:System.Web.HttpResponse.BufferOutput%2A> 속성을 요청 하는 클라이언트로 전송 되기 전에 페이지를 완전히 처리 되도록를 true로 합니다. 사각형을 그리는 데 사용 되는 두 개체가 만들어집니다:는 <xref:System.Drawing.Bitmap> 및 <xref:System.Drawing.Graphics> 개체입니다. 페이지에서 생성 된 변수는 가장 큰 사각형 안에 표시 되는 문자열과 사각형을 그릴 좌표로 사용 됩니다.  
  
 세 개의 사각형이 내부에 표시 되는 문자열을 그릴 때를 <xref:System.Drawing.Bitmap> 에 저장 됩니다는 <xref:System.IO.Stream> 연관 된 개체를 <xref:System.Web.HttpResponse.OutputStream%2A> 속성과 해당 형식으로 JPEG로 설정 됩니다. 호출 된 <xref:System.Drawing.Image.Dispose%2A> 및 <xref:System.Drawing.Graphics.Dispose%2A> 두 그리기 개체에서 사용 하는 리소스를 해제 하는 방법입니다. 코드를 호출 하는 마지막으로 <xref:System.Web.HttpResponse.Flush%2A> 요청 하는 클라이언트에 대 한 버퍼링 된 응답을 보내는 방법.  
  
> [!NOTE]
>  코드에는 <xref:System.Web.HttpResponse> 키워드로 개체 라고 `Response`합니다. 예를 들어 `Response.Clear()` 가리킵니다는 <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> 메서드. 합니다 <xref:System.Web.UI.Page> 라는 속성이 클래스 <xref:System.Web.UI.Page.Response%2A> 의 현재 인스턴스를 노출 하는 <xref:System.Web.HttpResponse>합니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">사용자 지정 HTTP 출력을 활성화하는 <see cref="T:System.IO.TextWriter" /> 개체입니다.</param>
        <summary><see cref="T:System.Web.HttpResponse" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 .NET Framework 인프라를 지원하며 사용자 코드에서 직접 사용할 수 없습니다.  
  
 속성과 메서드를 <xref:System.Web.HttpResponse> 클래스가 내장 함수를 통해 노출 됩니다 <xref:System.Web.HttpContext.Response%2A> asp.net에서 개체입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">응용 프로그램 종속성 목록에 추가할 파일, 캐시 키 또는 <see cref="T:System.Web.Caching.CacheDependency" />입니다.</param>
        <summary>응답이 출력 캐시에 저장되어 있는 상태에서 지정된 종속성이 변경될 때 보다 편리하게 응답을 무효화할 수 있도록 캐시 종속성 집합을 응답에 연결합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpResponse.AddCacheDependency%2A> 메서드를 사용 하면 캐시 된 응답이 사이 종속성 및 <xref:System.Web.Caching.CacheDependency> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 캐시 종속성을 사용 하 여 만들 하는 방법에 설명 합니다 <xref:System.Web.HttpResponse.AddCacheDependency%2A> 메서드 및 <xref:System.Web.Caching.CacheDependency> 개체입니다.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencies" /> 매개 변수가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.InvalidOperationException">이 메서드는 캐시된 응답이 이미 만들어진 후 캐시 처리 파이프라인에서 너무 늦게 호출되었습니다.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>캐시에 있는 다른 항목에 종속된 캐시된 응답의 유효성을 검사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">현재 캐시된 응답이 종속된 항목의 키가 들어 있는 <see cref="T:System.Collections.ArrayList" />입니다.</param>
        <summary>캐시에 있는 다른 항목에 종속된 캐시된 응답의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 참조 하는 경우는 `cacheKeys` 캐시에서 제거 되 고 매개 변수, 현재 항목의 캐시 된 응답이 잘못 되었습니다.  
  
   
  
## Examples  
 다음 예제에서는 출력 캐시 되는 ASP.NET 페이지를 사용 하는 방법을 보여 줍니다. 코드 페이지를 만듭니다는 <xref:System.Collections.ArrayList> 에 저장 된 항목과 연관 된 키의 개체는 <xref:System.Web.Caching.Cache> 개체입니다. 다음으로 코드를 전달 합니다 <xref:System.Collections.ArrayList> 에 대 한 호출에서 매개 변수로 <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> 메서드. 그러면 출력 캐시 응답 유효 하지 않은 경우 지정 된 파일 중 하나는 <xref:System.Collections.ArrayList> 변경 합니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">캐시된 응답이 종속된 항목 키의 배열입니다.</param>
        <summary>캐시에 있는 다른 항목에 종속된 캐시된 항목의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 같은 경우에 `cacheKey`캐시에서 제거 되 고 s, 현재 항목의 캐시 된 응답이 잘못 되었습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">캐시된 응답이 종속된 항목의 키입니다.</param>
        <summary>캐시에 있는 다른 항목에 종속된 캐시된 응답의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 해당 하는 항목을 `cacheKey` 매개 변수는 캐시에서 제거, 현재 항목의 캐시 된 응답이 잘못 되었습니다.  
  
   
  
## Examples  
 다음 예제는 출력 캐시 되는 ASP.NET 사용자 컨트롤입니다. 컨트롤 호출에 대 한 코드를 <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> 에 저장 된 항목의 키를 사용 하 여 메서드를 <xref:System.Web.Caching.Cache> 개체가 매개 변수로 전달 합니다. 캐시에 항목이 없으면 출력 캐시에 저장 된 컨트롤의 응답 무효화 됩니다. 이 후속 요청에 새 버전의 컨트롤의 응답에 추가할 출력 캐시를 의미 합니다.  
  
 다음으로 코드를 사용 하 여 관련 된 항목이 있는지 여부를 확인을 `bookData` 키에 저장 됩니다는 `Cache` 개체를 두 줄 텍스트 결과 따라 달라 집니다 중 하나를 표시 합니다. 그런 다음 코드를 설정 합니다 <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> 의 속성을 <xref:System.Web.UI.WebControls.DataGrid> 라고 하는 컨트롤 `dgBooks`, 사용자 지정에 대 한 호출을 사용 하 여 `DataHelper` 클래스의 공유 `GetBookData` 메서드를 채웁니다를 <xref:System.Web.UI.WebControls.DataGrid> 사용 하 여는 <xref:System.Web.UI.Control.DataBind%2A> 메서드.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 응답이 종속된 파일 이름 컬렉션에 파일 이름 그룹을 추가합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">추가할 파일의 컬렉션입니다.</param>
        <summary>현재 응답이 종속된 파일 이름 컬렉션에 파일 이름 그룹을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 ASP.NET 페이지 출력 캐시 되는 경우 코드 페이지를 만듭니다는 <xref:System.Collections.ArrayList> 파일 경로 및 다음 전달 합니다 <xref:System.Collections.ArrayList> 에 대 한 호출에서 매개 변수로 <xref:System.Web.HttpResponse.AddFileDependencies%2A> 메서드. 이렇게 하면 경우에 잘못 된 출력 캐시 된 응답에 지정 된 파일 중 하나는 <xref:System.Collections.ArrayList> 변경 합니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">추가할 파일 배열입니다.</param>
        <summary>현재 응답이 종속된 파일 이름 컬렉션에 파일 이름 배열을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 파일 이름 배열을 추가 합니다 <xref:System.Web.HttpResponse.AddFileDependencies%2A> 파일 종속성 목록입니다. 파일 변경 되 면 캐시 된 응답을 무효화 됩니다.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">추가할 파일의 이름입니다.</param>
        <summary>현재 응답이 종속된 파일 이름 컬렉션에 하나의 파일 이름을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 경우는 <xref:System.Web.HttpResponse.AddFileDependency%2A> 파일 종속성을 추가 하는 방법 출력 캐싱을 프로그래밍 방식으로 또는 선언적으로 지정 해야 합니다. 예를 들어, 출력 캐싱 선언적으로 지정 하려면 지시문을 사용 합니다. 자세한 내용은 [방법: 파일 종속성을 사용 하 여 페이지 출력 캐시](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db)합니다.  
  
   
  
## Examples  
 다음 예제에서는 단일 파일 이름을 추가 하는 방법의 <xref:System.Web.HttpResponse.AddFileDependency%2A> 파일 종속성 목록입니다. 파일이 변경 되 면 캐시 된 응답을 무효화 됩니다.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">ASP.NET 페이지 캐시</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><paramref name="value" />를 추가할 HTTP 헤더의 이름입니다.</param>
        <param name="value">헤더에 추가할 문자열입니다.</param>
        <summary>HTTP 헤더를 출력 스트림에 추가합니다. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />는 이전 버전 ASP와의 호환성을 위해 제공됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> 동일 <xref:System.Web.HttpResponse.AppendHeader%2A> 이전 버전의 ASP와의 호환성을 위해서만 제공 됩니다. Asp.net을 사용 하 여 <xref:System.Web.HttpResponse.AppendHeader%2A>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">콜백 메서드입니다.</param>
        <summary>이 요청에 대해 응답 헤더를 보내기 직전에 ASP.NET 런타임이 호출할 콜백을 등록합니다.</summary>
        <returns>OnSendingHeaders 의사 이벤트에 구독을 나타내는 <see cref="T:System.Web.ISubscriptionToken" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  네이티브 모듈 응답을 먼저 플러시합니다 경우 AddOnSendingHeaders 메서드가 호출 되지 않습니다.  
  
 의사 (pseudo) 이벤트가 OnSendingHeaders 응용 프로그램별 구독 보다는 요청별 구독은 IHttpModule 수준 파이프라인 이벤트에서 서로 다릅니다. 의도 인지는 콜백 응답 상태 코드를 수정할 수 있습니다 응답 쿠키 또는 헤더를 설정할 수 있습니다. 다른 사용 정보 및 주의 사항:  
  
-   이 메서드는 IIS 통합된 파이프라인 모드 파이프라인에서 실행 하는 경우에 및 현재 요청에 대 한 응답 헤더를 보낸 아직 하지 않은 경우에 유효 합니다.  
  
-   ASP.NET 런타임은에서 콜백이 호출 되는 스레드에 대 한 모든 것을 보장 하지 않습니다. 예를 들어 콜백을 호출할 수 있습니다 동기적으로 백그라운드 스레드에서 백그라운드 플러시를 수행 하는 경우. <xref:System.Web.HttpContext.Current%2A> 이러한 스레드 사용 가능 하도록 보장 되지 않습니다.  
  
-   콜백 응답 엔터티 본문을 조작 하는 또는 플러시가 발생 하는 모든 메서드를 호출 하지 해야 합니다. 예를 들어, 콜백 호출 하지 해야 <xref:System.Web.HttpResponse.Redirect%2A>처럼 해당 메서드는 응답 엔터티 본문을 조작할 수 있습니다.  
  
-   콜백만 단기 실행 동기 코드를 포함 해야 합니다. 비동기 작업을 호출 하거나 이러한 작업에서 대기 하려고 하면 교착 상태가 될 수 있습니다.  
  
-   콜백을 예외를 throw 하면 안 그렇지 않으면 동작이 정의 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">출력 스트림에 추가할 <see cref="T:System.Web.HttpCookie" />입니다.</param>
        <summary>내장 쿠키 컬렉션에 HTTP 쿠키를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 명명 된 새 쿠키를 만들고 `LastVisit`, 쿠키의 값을 현재 날짜 및 시간으로 설정 하 고 해당 쿠키를 현재 쿠키 컬렉션에 추가 합니다. 쿠키 컬렉션에서 모든 쿠키를 클라이언트에 보내집니다는 `Set-Cookie` 출력 스트림에 HTTP 헤더입니다.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 쿠키를 추가하는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">출력 스트림에 추가할 HTTP 헤더의 이름입니다.</param>
        <param name="value">헤더에 덧붙일 문자열입니다.</param>
        <summary>HTTP 헤더를 출력 스트림에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 경우는 <xref:System.Web.HttpResponse.AppendHeader%2A> 캐시 관련 헤더를 보내고 동시에 캐시 개체 모델을 사용 하는 메서드 (<xref:System.Web.HttpResponse.Cache%2A>) 캐싱과 관련 된 HTTP 응답 헤더 캐시 정책을 설정 하려면 (`Cache-Control`, `Expires`, `Last-Modified`합니다 `Pragma`, 및 `Vary`) 캐시 개체 모델을 사용 하는 경우에 삭제 될 수 있습니다. 이 동작을 통해 ASP.NET 가장 제한적인 설정 유지 관리 합니다. 예를 들어, 사용자 정의 컨트롤을 포함 하는 페이지를 것이 좋습니다. 이러한 컨트롤 캐시 정책이 충돌 하는 경우 가장 제한적인 캐시 정책을 사용 됩니다. 하나의 사용자 정의 컨트롤 헤더를 설정 하는 경우 "`Cache-Control: Public`"및 제한적인 헤더를 설정 하는 다른 사용자 정의 컨트롤"`Cache-Control: Private`"에 대 한 호출을 통해 <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, 해당 "`Cache-Control: Private`" 헤더를 응답으로 전송 됩니다.  
  
 목록은 표준 http/1.1 헤더에서 14, "헤더 필드 정의" 섹션을 참조 합니다 [Hypertext Transfer Protocol-HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) World Wide Web Consortium (W3C) 웹 사이트에 대 한 사양입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.HttpResponse.AppendHeader%2A> 사용자 지정 헤더를 추가 하는 방법의 <xref:System.Web.HttpResponse> 요청 하는 클라이언트에 전송 하는 개체.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 헤더가 덧붙여진 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">로그 파일에 추가할 텍스트입니다.</param>
        <summary>사용자 지정 로그 정보를 IIS(인터넷 정보 서비스) 로그 파일에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로그 파일에 기록 하는 데 지정된 된 문자열에 허용 하려면 먼저 활성화 해야 합니다는 **URI 쿼리** 옵션을 **확장 로깅 속성** IIS 작업에 대 한 로그인 하려는 사이트에 대 한 대화 상자 .  
  
 IIS 6.0에서 확장 로그를 사용자 지정 하려면 다음이 단계를 수행 합니다.  
  
1.  로컬 컴퓨터 노드를 확장 하는 IIS 관리자에서 웹 또는 FTP 사이트 폴더를 확장 하 고, 웹 또는 FTP 사이트를 마우스 오른쪽 단추로 클릭 및 클릭 **속성**합니다.  
  
2.  클릭 합니다 **웹 또는 FTP 사이트** 탭을 선택한 후 합니다 **로깅을 사용 하도록 설정** 확인란 (선택 되지 않은 이미) 하는 경우.  
  
3.  에 **활성 로그 형식** 상자를 클릭 합니다 **W3C 확장 로그 파일 형식**합니다.  
  
4.  클릭 **속성**합니다.  
  
5.  클릭 합니다 **고급** 탭, 로그, 클릭 하려는 속성을 선택 **확인**합니다.  
  
   
  
## Examples  
 다음 예제에서는 로그에 문자열을 추가 하는 방법을 보여 줍니다.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Windows Server 2003 제품 도움말</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">리소스에 대한 가상 경로입니다.</param>
        <summary>세션이 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 세션 상태를 사용하고 있는 경우 가상 경로에 세션 ID를 추가한 다음 조합된 경로를 반환합니다. <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 세션 상태가 사용되지 않을 경우 <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />는 원본 가상 경로를 반환합니다.</summary>
        <returns>세션 ID가 삽입된 <paramref name="virtualPath" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 절대 Href를 생성 하려면 쿠키 없는 세션에만 사용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 라는 문자열 변수를 선언 `urlConverted`의 결과로 설정 하 고는 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 메서드 호출 합니다. 그런 다음 변수 값을 <xref:System.Web.UI.WebControls.HyperLink> 컨트롤의 <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> 속성입니다.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">콜백 개체입니다.</param>
        <param name="state">응답 상태입니다.</param>
        <summary>현재 버퍼링된 응답을 클라이언트에 보냅니다.</summary>
        <returns>비동기 결과 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 기본 <xref:System.Web.HttpWorkerRequest> 개체가 비동기 플러시 작업을 지원 하 고이 메서드는 비동기 모듈 이벤트 또는 비동기 처리기에서 플러시 작업을 비동기적으로 수행 됩니다. 그렇지 않으면 플러시 작업을 동기적으로 수행 됩니다. IIS 6.0 이상용 비동기 플러시가 지원 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">응답을 이미 완료한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">출력 스트림에 쓸 바이트입니다.</param>
        <summary>HTTP 출력 스트림에 이진 문자로 구성된 문자열을 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 버퍼로 텍스트 파일을 읽고 버퍼 HTTP 출력 스트림에 씁니다.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>출력의 버퍼링 여부 및 전체 응답의 처리가 완료된 다음에 출력을 보내는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>클라이언트에 대한 출력이 버퍼링되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpResponse.Buffer%2A> 속성을 위해 되지를 <xref:System.Web.HttpResponse.BufferOutput%2A> 속성 이전 버전의 ASP와의 호환성을 위해서만 제공 됩니다. Asp.net을 사용 하 여 <xref:System.Web.HttpResponse.BufferOutput%2A>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>출력의 버퍼링 여부 및 전체 페이지의 처리가 완료된 다음에 출력을 보내는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>클라이언트에 대한 출력이 버퍼링되면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.HttpResponse.ContentType%2A> 속성을 image/jpeg, 응답에 대 한 호출을 <xref:System.Web.HttpResponse.Clear%2A> 응답에 추가 될 수는 설정한 다른 콘텐츠를 제거 하는 방법은 <xref:System.Web.HttpResponse.BufferOutput%2A> 속성을 전체 페이지 수 있도록 true로 모든 콘텐츠를 요청 하는 클라이언트에 전송 되기 전에 처리 합니다.  
  
 전체 예제를 참조 하세요.를 <xref:System.Web.HttpResponse> 클래스입니다.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>웹 페이지의 캐싱 정책(만료 시간, 개인 정보 설정 및 vary 절 등)을 가져옵니다.</summary>
        <value>현재 응답의 캐싱 정책에 대한 정보가 들어 있는 <see cref="T:System.Web.HttpCachePolicy" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 HTTP 출력 스트림에 현재 캐시 정책의 속성을 씁니다.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpCacheability" /> 열거형 값 중 하나와 일치하는 <see langword="Cache-Control" /> HTTP 헤더를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Web.HttpCacheability" /> 열거형 값의 문자열 표현입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 값 `Private`, `Public`, 및 `No-Cache` 은 문자열이 며 따옴표로 묶어야 합니다 (""). 경우는 <xref:System.Web.HttpResponse.CacheControl%2A> 속성 중 하나가 일치 하지 않는 값으로 설정 되는 <xref:System.Web.HttpCacheability> 열거형 값은 <xref:System.ArgumentException> throw 됩니다. 경우는 <xref:System.Web.HttpResponse.CacheControl%2A> 속성이 설정 되지 않은로 설정 된 응답의 캐시 가능성 <xref:System.Web.HttpCacheability.NoCache>합니다.  
  
 합니다 `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, 및 <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> 속성 사용 되지 않습니다. 대신의 메서드를 <xref:System.Web.HttpCachePolicy> 클래스를 통해 사용할 수는 <xref:System.Web.HttpResponse.Cache%2A> (IIS (인터넷 정보 서비스)를 제어 하는 내장 개체 출력 캐시 및 클라이언트 캐시 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">설정된 문자열 값이 <see cref="T:System.Web.HttpCacheability" /> 열거형 값 중 하나와 일치하지 않는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>출력 스트림의 HTTP 문자 집합을 가져오거나 설정합니다.</summary>
        <value>출력 스트림의 HTTP 문자 집합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Charset` 속성 설정할 수 있습니다 `null` HTTP 표시 하지 않으려면 `Content-Type` 헤더입니다.  
  
   
  
## Examples  
 다음 예제에서는 출력 스트림의 문자 집합을 중앙 유럽어 (ISO) 인지 여부를 확인 합니다.  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">헤더를 보낸 후에 <see langword="Charset" /> 속성을 설정한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>버퍼 스트림에서 모든 콘텐츠 출력을 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A> 메서드 헤더 정보를 제거 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.HttpResponse.ContentType%2A> 속성을 image/jpeg, 응답에 대 한 호출을 <xref:System.Web.HttpResponse.Clear%2A> 응답에 추가 될 수는 설정한 다른 콘텐츠를 제거 하는 방법은 <xref:System.Web.HttpResponse.BufferOutput%2A> 속성을 전체 페이지 수 있도록 true로 모든 콘텐츠를 요청 하는 클라이언트에 전송 되기 전에 처리 합니다.  
  
 전체 예제를 참조 하세요.를 <xref:System.Web.HttpResponse> 클래스입니다.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>버퍼 스트림에서 모든 콘텐츠 출력을 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A> 메서드 헤더 정보를 제거 하지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 버퍼 스트림에서 모든 콘텐츠를 지웁니다.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>버퍼 스트림에서 모든 헤더를 지웁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Web.HttpResponse.ClearHeaders%2A> 헤더 없이 현재 응답과 함께 전송 되도록 하는 방법입니다. 이 기술은 ASP.NET 응답 예: JPEG 파일 이미지를 생성 하는 경우에 특히 중요할 수 있습니다. 이 예제는 <xref:System.Web.HttpResponse.ContentType%2A> 을 image/jpeg 속성이 설정 되어 있습니다.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 헤더가 지워진 경우</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트가 끊긴 경우, 작동한 <see cref="T:System.Threading.CancellationToken" /> 개체를 가져옵니다.</summary>
        <value>취소 토큰입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 API는 스레드로부터 안전 합니다. 그러나 취소 토큰을 사용 해야 하는 방법에 몇 가지 제한 사항이 있습니다. 이 잘못 사용 하면 경합, 교착 상태 또는 기타 예기치 않은 동작이 발생할 수 있습니다. 다음 지침에 유의 합니다.  
  
-   요청이 끝날 때 취소 토큰의 ASP.NET에서는 삭제 하기 때문에 단일 요청의 범위를 벗어나는이 API를 호출 하지 않으면을 확인 합니다. 보장이 없습니다 토큰이 삭제 되기 전에 적이 취소 된 상태로 전환 됩니다. 예를 들어, 클라이언트 연결이 끊긴 필요 없이 요청 완료 되 면 토큰 취소 먼저 하지 않고 삭제 됩니다.  
  
-   기다리지는 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, 비동기 알림의 목적이 무산이 고 교착 상태가 발생할 수 있습니다.  
  
-   호출 하지 마십시오 합니다 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 원래에 콜백을 호출 하는 오버 로드 <xref:System.Threading.SynchronizationContext> 개체입니다.  
  
-   사용 하지 않는 합니다 <xref:System.Web.HttpContext> 개체나 다른 스레드로부터 안전한 ASP.NET 내장 함수 내에서 개체를 제공 하는 콜백입니다는 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 메서드. 다른 ASP.NET 동시 콜백을 실행 될 수 있습니다 또는 응용 프로그램 코드입니다.  
  
-   단기 실행 콜백 메서드 및 비차단 유지 합니다.  
  
-   콜백 메서드 내에서 예외가 throw 되지 않도록 하기 위해 모든 노력을 확인 합니다.  
  
 이 속성에는의 정보 서비스 (IIS (인터넷) 통합된 모드에서 7.5 이상만 지원 됩니다. 오른쪽 IIS 버전 또는 파이프라인 모드 없이 호출 하는 경우는 <xref:System.PlatformNotSupportedException> throw 됩니다. IIS 버전을 확인 하려면 사용 하 여 <xref:System.Web.HttpRuntime.IISVersion%2A>입니다. 파이프라인 모드를 확인 하려면 <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클라이언트에 대한 소켓 연결을 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드 갑작스러운 방식으로 클라이언트에 대 한 연결을 종료 하 고 일반 HTTP 요청 처리를 위해이 아닙니다. 메서드는 서버, 클라이언트 또는 사이 삭제 하는 장소에 버퍼링 되는 응답 데이터를 일으킬 수 있는 클라이언트를 재설정 패킷을 보냅니다.  
  
 그러나 일반적으로 호출 해야 <xref:System.Web.HttpApplication.CompleteRequest%2A> 대신로 이동 하려는 경우는 <xref:System.Web.HttpApplication.EndRequest> 이벤트 및 클라이언트에 대 한 응답 송신 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>출력 스트림의 HTTP 문자 집합을 가져오거나 설정합니다.</summary>
        <value>현재 응답의 문자 집합에 대한 정보가 들어 있는 <see cref="T:System.Text.Encoding" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 `ContentEncoding` 의 ASP.NET 구성 파일을 지정할 수 있습니다 합니다 [세계화 요소 (ASP.NET 설정 스키마)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) 섹션입니다. 경우 <xref:System.Web.HttpResponse.ContentEncoding%2A> 클라이언트에 의해 지정 된 기본 구성 설정이 재정의 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 문자 집합을 출력 스트림에 인코딩을에 대 한 알기 쉬운 설명을 씁니다.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Web.HttpResponse.ContentEncoding" />를 <see langword="null" />로 설정하려고 했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>출력 스트림의 HTTP MIME 형식을 가져오거나 설정합니다.</summary>
        <value>출력 스트림의 HTTP MIME 형식입니다. 기본값은 "<see langword="text/html" />"입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.HttpResponse.ContentType%2A> 속성을 image/jpeg, 응답에 대 한 호출을 <xref:System.Web.HttpResponse.Clear%2A> 응답에 추가 될 수는 설정한 다른 콘텐츠를 제거 하는 방법은 <xref:System.Web.HttpResponse.BufferOutput%2A> 속성을 전체 페이지 수 있도록 true로 모든 콘텐츠를 요청 하는 클라이언트에 전송 되기 전에 처리 합니다.  
  
 전체 예제를 참조 하세요.를 <xref:System.Web.HttpResponse> 클래스입니다.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.HttpResponse.ContentType" /> 속성은 <see langword="null" />로 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답 쿠키 컬렉션을 가져옵니다.</summary>
        <value>응답 쿠키 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 두 내장 쿠키 컬렉션을 포함합니다. 통해 액세스할 수 있는 컬렉션을 <xref:System.Web.HttpRequest.Cookies%2A> 의 컬렉션 <xref:System.Web.HttpRequest> 서버에 클라이언트에서 전송 된 쿠키가 들어를 `Cookie` 헤더. 통해 액세스할 수 있는 컬렉션을 <xref:System.Web.HttpResponse.Cookies%2A> 의 컬렉션 <xref:System.Web.HttpResponse> 서버에서 생성 하 고 클라이언트에 전송 된 새 쿠키를 포함는 `Set-Cookie` 헤더입니다.  
  
 사용 하 여 쿠키를 추가한 후는 <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> 쿠키에서 즉시 사용할 수는 컬렉션을 <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> 응답이 클라이언트로 전송 되지 않은 경우에 컬렉션.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 새 쿠키를 만들고 `LastVisit`, 쿠키의 값을 현재 날짜 및 시간으로 설정 하 고 쿠키를 현재 쿠키 컬렉션에 추가 합니다. 쿠키 컬렉션에서 모든 쿠키를 클라이언트에 보내집니다는 `Set-Cookie` 출력 스트림에 HTTP 헤더입니다.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 응답에 대해 커널 캐싱을 사용하지 않도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 커널 캐싱을 지원 되지 않는 경우이 메서드는 영향을 주지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 응답에 대한 IIS 사용자 모드 캐싱을 사용하지 않도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS 사용자 모드 캐싱을 지원 되지 않는 경우이 메서드는 아무 작업도 수행 하지 않고 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 버퍼링된 출력을 모두 클라이언트에 보내고 페이지 실행을 중지한 다음 <see cref="E:System.Web.HttpApplication.EndRequest" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 ASP.NET 이전의 COM 기반 웹 프로그래밍 기술 사용 하 여 호환성을 위해, ASP-를 사용 하 여 호환성을 위해서만 제공 됩니다. 로 이동 하려는 경우는 <xref:System.Web.HttpApplication.EndRequest> 를 호출 하는 것이 좋습니다는 이벤트를 클라이언트에 응답을 보내려면 <xref:System.Web.HttpApplication.CompleteRequest%2A> 대신 합니다.  
  
 동작을 모방 하는 `End` ASP에서 메서드를이 메서드가 발생 시 키 려는 <xref:System.Threading.ThreadAbortException> 예외입니다. 이 시도가 성공 하면 사이트의 성능이 저하 되 하 호출 스레드가 중단 됩니다. 호출한 후 코드가 없는 경우에는 <xref:System.Web.HttpResponse.End%2A> 메서드를 실행 합니다.  
  
 경우는 <xref:System.Web.HttpResponse.End%2A> 메서드를 발생 시킬 수 없는 경우는 <xref:System.Threading.ThreadAbortException>, 대신 클라이언트에 응답 바이트를 플러시합니다. 즉, 동기적으로 사이트의 성능이 저하 수도 있습니다.  
  
 두 경우 모두 (여부는 <xref:System.Threading.ThreadAbortException> 예외가 발생 했습니다.), 응답 파이프라인 바로 이동 합니다 <xref:System.Web.HttpApplication.EndRequest> 이벤트.  
  
 합니다 <xref:System.Web.HttpApplication.CompleteRequest%2A> 메서드 예외가 발생 하지 않으며 호출 후 코드는 <xref:System.Web.HttpApplication.CompleteRequest%2A> 메서드 실행 될 수 있습니다. 바일 후속 코드의 실행을 방지 하는 경우의 성능 저하 <xref:System.Web.HttpResponse.End%2A> 허용 호출할 수 있습니다 <xref:System.Web.HttpResponse.End%2A> 대신 <xref:System.Web.HttpApplication.CompleteRequest%2A>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException"><see cref="M:System.Web.HttpResponse.End" />에 대한 호출이 현재 요청을 종료했습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">비동기 결과 개체입니다.</param>
        <summary>비동기 플러시 작업을 완료합니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">비동기 플러시가 지원되지 않으며 <paramref name="asyncResult" /> 매개 변수는 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException">비동기 플러시가 지원되지 않으며 <paramref name="asyncResult" /> 매개 변수를 <c>FlushAsyncResult</c> 개체로 캐스팅할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>브라우저에서 캐시되는 페이지가 만료되기까지의 시간(분)을 가져오거나 설정합니다. 사용자가 만료되기 전과 동일한 페이지로 돌아가면 캐시된 버전이 표시됩니다. <see cref="P:System.Web.HttpResponse.Expires" />는 이전 버전 ASP와의 호환성을 위해 제공됩니다.</summary>
        <value>페이지가 만료되기까지의 시간(분)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> 및 <xref:System.Web.HttpResponse.CacheControl%2A> 속성이 사용 되지 않고 있으므로 메서드를 <xref:System.Web.HttpCachePolicy> 클래스를 통해 사용할 수는 <xref:System.Web.HttpResponse.Cache%2A> (IIS (인터넷 정보 서비스)를 제어 하는 내장 개체 출력 캐시 및 클라이언트에 캐시 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐시된 정보를 캐시에서 제거할 절대 날짜 및 시간을 가져오거나 설정합니다. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" />는 이전 버전 ASP와의 호환성을 위해 제공됩니다.</summary>
        <value>페이지가 만료되는 날짜 및 시간입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, 및 <xref:System.Web.HttpResponse.CacheControl%2A> 속성이 사용 되지 않고 있으므로 메서드를 <xref:System.Web.HttpCachePolicy> 클래스를 통해 사용할 수는 <xref:System.Web.HttpResponse.Cache%2A> (IIS (인터넷 정보 서비스)를 제어 하는 내장 개체 출력 캐시 및 클라이언트에 캐시 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>전송 전에 HTTP 엔터티 본문을 수정하는 데 사용되는 래핑 필터 개체를 가져오거나 설정합니다.</summary>
        <value>출력 필터 역할을 하는 <see cref="T:System.IO.Stream" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들 때를 `Stream` 개체 및 설정 합니다 <xref:System.Web.HttpResponse.Filter%2A> 속성을는 `Stream` 개체를 모든 HTTP 보낸 출력 <xref:System.Web.HttpResponse.Write%2A> 필터를 통과 합니다.  
  
   
  
## Examples  
 다음 예제는 설정 하는 ASP.NET 페이지는 <xref:System.Web.HttpResponse.Filter%2A> 속성의 새 인스턴스를 합니다 `UpperCaseFilter` 클래스를 사용자 지정 <xref:System.IO.Stream> 대문자를 통과 하는 모든 텍스트를 변환 하는 클래스입니다. 요청에 대 한 정보를 텍스트 파일로 저장 됩니다 차례로 <xref:System.Web.HttpResponse.Filter%2A> 속성을 설정 합니다. 코드를 호출 하는 응답 필터를 배치한 후 합니다 <xref:System.Web.HttpRequest.MapPath%2A> 메서드 라는 텍스트 파일의 절대 경로를 `TestFile.txt` 응답의 내용에 대 한 소스로 사용 하는 합니다. 만든 후 새 <xref:System.IO.StreamReader> 처음부터 끝을 호출 하 고 텍스트 파일을 읽을 개체의 <xref:System.Web.HttpResponse.Write%2A> 페이지에 있는 파일의 콘텐츠를 표시 하는 방법입니다.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">해당 엔터티에 필터링을 사용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 버퍼링된 모든 출력을 클라이언트에 보냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 현재 버퍼링 된 출력을 클라이언트로 보낼 수 있습니다. <xref:System.Web.HttpResponse.Flush%2A> 메서드 요청을 처리 하는 동안 여러 번 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Drawing.Graphics.Save%2A> 저장 하는 방법을 <xref:System.Drawing.Bitmap> 개체는 <xref:System.Web.HttpResponse.OutputStream%2A> 속성 및 변환 된 이미지를 JPEG 형식. 코드를 호출 합니다 `Dispose` 메서드를 <xref:System.Drawing.Bitmap> 개체 및 <xref:System.Drawing.Graphics> 개체를 사용 하 던 리소스를 해제 합니다. 그런 다음 호출 하는 <xref:System.Web.HttpResponse.Flush%2A> 요청 하는 클라이언트에 대 한 응답의 콘텐츠를 전송 하는 메서드.  
  
 전체 예제를 참조 하세요.를 <xref:System.Web.HttpResponse> 클래스입니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">응답을 보낸 다음에 캐시가 플러시된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 버퍼링된 모든 출력을 클라이언트에 비동기로 보냅니다.</summary>
        <returns>비동기 작업을 나타내는 <see cref="T:System.Threading.Tasks.Task" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 헤더 출력 스트림의 인코딩을 나타내는 <see cref="T:System.Text.Encoding" /> 개체를 가져오거나 설정합니다.</summary>
        <value>현재 헤더의 문자 집합에 대한 정보가 들어 있는 <see cref="T:System.Text.Encoding" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 속성은 사용 하지 않도록 설정 하거나 변경 하는 기능 제공 합니다 <xref:System.Text.Encoding> 개체를 사용 하 여 응답 헤더에는 <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, 또는 <xref:System.Text.UTF8Encoding> 개체입니다. 기본 인코딩 값은는 <xref:System.Text.UTF8Encoding> 클래스입니다.  
  
 유형을 변경 하 여는 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 속성을 늘릴 수 있습니다 잠재적으로 위험을 특정 악의적 공격 또는 원인 중요 한 데이터를 응답 헤더를 통해 보낼 수 있습니다. 헤더 주입 공격 방지할 수 있습니다, 부분적으로 두어는 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 기본 설정에 대 한 응답의 속성입니다. 공격 취약 한 응용 프로그램에 대 한 응답 헤더의 일부로 데이터를 위임 다시 표시할 수 있습니다. 경우는 <xref:System.Web.HttpResponse.HeaderEncoding%2A> 연속 헤더에 줄 또는 헤더 데이터를 응답 스트림에 보내기 전에 검사할지 신뢰할 수 없는 데이터의 결과에 따라 모든 헤더가 생성 되는 경우에 대 한 요구 사항으로 인해 사용 불가능 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">인코딩 값이 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Web.HttpException">인코딩 값이 <see cref="P:System.Text.Encoding.Unicode" />인 경우  
  
또는 
헤더가 이미 전송된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답 헤더의 컬렉션을 가져옵니다.</summary>
        <value>응답 헤더의 <see cref="T:System.Collections.Specialized.NameValueCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpResponse.Headers%2A> 속성 에서만 지원 됩니다는 [!INCLUDE[iisver](~/includes/iisver-md.md)] 통합된 파이프라인 모드 이상 및.NET Framework 3.0. 액세스 하려는 경우는 <xref:System.Web.HttpResponse.Headers%2A> 속성과 같은 두 조건 중 하나가 충족 되지 않으면를 <xref:System.PlatformNotSupportedException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">작업을 수행하려면 통합 파이프라인 모드의 [!INCLUDE[iisver](~/includes/iisver-md.md)] 및 .NET Framework 버전 3.0 이상이 있어야 합니다.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">IIS 7.0으로 ASP.NET 응용 프로그램 업그레이드: IIS 7.0 통합 모드와 클래식 모드 간의 차이점</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답 헤더를 썼는지를 나타내는 값을 가져옵니다.</summary>
        <value>응답 헤더를 썼으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트가 아직 서버에 연결되어 있는지를 나타내는 값을 가져옵니다.</summary>
        <value>클라이언트가 현재 연결되어 있으면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpResponse.IsClientConnected%2A> 속성이 반환 `false` 다음 조건에 해당할 경우:  
  
-   클라이언트 연결이 종료 되었습니다. 이 경우 발생할 수 있습니다는 <xref:System.Web.HttpResponse.Close%2A> 메서드가 호출 되었는지 클라이언트 웹 페이지의 실행을 중지 하거나 다른 페이지를 탐색할 경우 또는 합니다.  
  
-   합니다 <xref:System.Web.HttpWorkerRequest> 요청을 처리 하는 개체가 `null` 또는 <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> 메서드가 반환 되는 `false`합니다. 사용자 지정 하는 경우 <xref:System.Web.HttpWorkerRequest> 요청을 처리 하는 개체는 <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> 사용자 지정 조건에 따라 메서드를 설정할 수 있습니다. 예를 들어, 사용자 지정 작업자 요청 기간 후 시간 초과 강제할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.HttpResponse.IsClientConnected%2A> 속성 페이지를 요청 하는 클라이언트 서버에 연결 된 상태로 남아 있는지를 확인 합니다. 하는 경우 <xref:System.Web.HttpResponse.IsClientConnected%2A> 가 true 이면 호출을 <xref:System.Web.HttpResponse.Redirect%2A> 메서드와 클라이언트에는 다른 페이지가 표시 됩니다. 하는 경우 <xref:System.Web.HttpResponse.IsClientConnected%2A> 가 false 이면 코드에서 호출 된 <xref:System.Web.HttpResponse.End%2A> 메서드 및 모든 페이지 처리가 종료 됩니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트가 새 위치로 이동되는지를 나타내는 부울 값을 가져옵니다.</summary>
        <value>위치 응답 헤더 값이 현재 위치와 다르면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> 속성을 <xref:System.Web.HttpResponse.RedirectLocation%2A> 속성 테스트를 확인할 지 여부를 절대 URI를 http에서 클라이언트로 전송 `Location` 헤더 현재 URI와 무엇 보다 다릅니다. 되는 새 의도 한 URI 로 전송 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나가는 HTTP 응답 스트림에 대한 텍스트 출력을 활성화합니다.</summary>
        <value>클라이언트에 대한 사용자 지정 출력을 활성화하는 <see cref="T:System.IO.TextWriter" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제는 포함 된 ASP.NET 페이지는 <xref:System.Web.UI.WebControls.TextBox> 컨트롤을 해당 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> 속성으로 설정 <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>합니다. 페이지의 코드에서 사용자가 입력 하는 텍스트를 가져와 <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>를 사용 하 여는 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 메서드 HTML로 인코딩 및 <xref:System.Web.HttpResponse.Output%2A> 페이지에 인코딩된 문자열을 표시 하는 속성.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나가는 HTTP 콘텐츠 본문에 대한 이진 출력을 활성화합니다.</summary>
        <value>나가는 HTTP 콘텐츠 본문의 원시 콘텐츠를 나타내는 IO <see cref="T:System.IO.Stream" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 경우.NET Framework 버전 2.0 사용 하 여 시작 합니다 <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> 반환한 IO 스트림의 메서드는 <xref:System.Web.HttpResponse.OutputStream%2A> 속성을 다음과 같은 예외가 throw 될 수 있습니다:  
  
-   <xref:System.ArgumentOutOfRangeException>경우는 `offset` 또는 `count` 매개 변수는 음수 또는 경우에는 `buffer` 매개 변수의 길이에서 `offset` 매개 변수는 0 보다 작거나 합니다.  
  
-   <xref:System.ArgumentNullException>를 하는 경우는 `buffer` 매개 변수는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Drawing.Image.Save%2A> 저장 하는 방법을 <xref:System.Drawing.Bitmap> 개체를 <xref:System.Web.HttpResponse.OutputStream%2A> 속성 이미지를 JPEG 형식으로 변환 합니다. 코드에서 Dispose 메서드를 호출 합니다 <xref:System.Drawing.Bitmap> 개체 및 <xref:System.Drawing.Graphics> 개체를 사용 하 던 리소스를 해제 합니다. 마지막으로 코드를 호출 합니다 <xref:System.Web.HttpResponse.Flush%2A> 요청 하는 클라이언트에 대 한 응답의 콘텐츠를 전송 하는 메서드.  
  
 전체 예제를 참조 하세요.를 <xref:System.Web.HttpResponse> 클래스입니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="OutputStream" />를 사용할 수 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="PICS-Label" /> 헤더에 추가할 문자열입니다.</param>
        <summary>HTTP <see langword="PICS-Label" /> 헤더를 출력 스트림에 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 플랫폼에 대 한 인터넷 콘텐츠 선택 (그림)는 콘텐츠 레이블 지정에 대 한 World Wide Web Consortium (W3C) 표준입니다. PICS 등급 시스템을 만들기 위한 언어 기본적으로 합니다.  
  
 모든 값일 수 PICS 레이블로 지정 합니다. ASP.NET에는 레이블을 확인 하지 않습니다. 문자열의 최대 길이 255 자입니다. PICS 표준 및 구문에 대 한 자세한 내용은 참조는 [World Wide Web 컨소시엄](https://go.microsoft.com/fwlink/?LinkID=37125) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제는 이미지를 표시 하는 ASP.NET 페이지입니다. 페이지 코드 호출을 <xref:System.Web.HttpResponse.Pics%2A> 메서드를 HTTP 설정 `PICS-Label` 헤더 응답에 대 한 합니다. 매개 변수로 전달 되는 문자열을 <xref:System.Web.HttpResponse.Pics%2A> 메서드 인터넷 콘텐츠 등급 연결 (ICRA) 웹 사이트에서 생성 된 등급 레이블을 나타냅니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>약속된 개체의 수준을 올립니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">푸시 요청의 URL입니다. 서버가 클라이언트에 푸시하려고 하는 상대 리소스의 가상 경로여야 합니다.</param>
        <summary>이 API는 HTTP 2.0 클라이언트에 푸시 약속을 보내는 응용 프로그램을 지원합니다. <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 사양 섹션 8.2: 서버 푸시</see>에서 Http2 서버 푸시와 관련된 자세한 내용을 찾을 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 비결 이며 응용 프로그램에 따라 달라 지는 논리가 없어야 합니다. 일부 경우에 성능상의 이점이 목적 으로만 사용 됩니다. 푸시 요청을 완전히 무시 하는 여러 조건을 (프로토콜 및 구현) 있습니다. 예상 실행 후 제거는 기반으로 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">푸시 요청의 URL입니다. 서버가 클라이언트에 푸시하려고 하는 상대 리소스의 가상 경로여야 합니다.</param>
        <param name="method">푸시 요청에 의해 사용되는 http 요청 메서드입니다.</param>
        <param name="headers">푸시 요청에 사용되는 http 요청 헤더입니다.</param>
        <summary>이 API는 HTTP 2.0 클라이언트에 푸시 약속을 보내는 응용 프로그램을 지원합니다. <see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 사양 섹션 8.2: 서버 푸시</see>에서 Http2 서버 푸시와 관련된 자세한 내용을 찾을 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 비결 이며 응용 프로그램에 따라 달라 지는 논리가 없어야 합니다. 일부 경우에 성능상의 이점이 목적 으로만 사용 됩니다. 푸시 요청을 완전히 무시 하는 여러 조건을 (프로토콜 및 구현) 있습니다. 예상 실행 후 제거는 기반으로 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클라이언트를 새 URL로 리디렉션합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">대상 위치입니다. 이것은 응용 프로그램 관련 가상 경로일 수 있습니다.</param>
        <summary>요청을 새 URL로 리디렉션하고 새 URL을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Web.HttpResponse.Redirect%2A> 호출과 같습니다 <xref:System.Web.HttpResponse.Redirect%2A> 로 설정 하는 두 번째 매개 변수를 사용 하 여 `true`입니다.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> 호출 <xref:System.Web.HttpResponse.End%2A> throw 하는 <xref:System.Threading.ThreadAbortException> 완료 되 면 예외입니다. 이 예외는 웹 응용 프로그램 성능에 나쁜 영향을 미칩니다. 이 오버 로드 하는 대신 사용 하는 권장 따라서를 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> 오버 로드 하 고 전달 `false` 에 대 한 합니다 `endResponse` 매개 변수를 호출 합니다 <xref:System.Web.HttpApplication.CompleteRequest%2A> 메서드. 자세한 내용은 <xref:System.Web.HttpResponse.End%2A> 메서드를 참조하세요.  
  
> [!NOTE]
>  모바일 페이지에만 응용 프로그램이 쿠키 없는 세션을 사용 하거나 쿠키 없는 세션을 요구 하는 모바일 디바이스에서 요청을 받을 수, 하는 경우 사용 하 여 물결표 (\~) 경로에서 새 세션을 만들고 세션 손실 될 수 있습니다 데이터입니다. 와 같은 경로 사용 하 여 모바일 컨트롤의 속성을 설정 하려면 "\~/path"를 사용 하 여 경로 확인할 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/path" 속성에 할당 하기 전에 합니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다. 대체 방법으로 다른 페이지로 컨트롤을 전송 하는 <xref:System.Web.HttpServerUtility.Transfer%2A> 메서드. <xref:System.Web.HttpServerUtility.Transfer%2A> 방법은 일반적으로 더 효율적 때문에 클라이언트에 왕복을 수행 하지는 않습니다. 자세한 내용은 [방법: 다른 페이지로 리디렉션 사용자](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)합니다.  
  
   
  
## Examples  
 다음 예제에서는 다른 웹 사이트를 무조건 리디렉션이 되도록합니다.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 후 리디렉션이 시도되는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">대상 위치입니다.</param>
        <param name="endResponse">현재 페이지 실행을 종료해야 하는지 여부를 나타냅니다.</param>
        <summary>클라이언트를 새 URL로 리디렉션합니다. 새 URL을 지정하고 현재 페이지 실행을 종료해야 하는지를 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 절대 URL (예를 들어 http://www.contoso.com/default.aspx) 또는 대상 위치에 대 한 상대 URL (예: Default.aspx)를 지정할 수 있지만 일부 브라우저는 상대 URL을 거부할 수 있습니다.  
  
 이 메서드를 사용할 때이 페이지 처리기에 한 페이지와 다른 페이지에 대 한 새 요청을 시작 설정에 대 한 요청을 종료 하 `endResponse` 하 `false` 호출을 <xref:System.Web.HttpApplication.CompleteRequest%2A> 메서드. 지정 하는 경우 `true` 에 대 한는 `endResponse` 매개 변수를이 메서드를 호출 합니다 <xref:System.Web.HttpResponse.End%2A> throw 하는 원래 요청에 대 한 메서드를 <xref:System.Threading.ThreadAbortException> 완료 되 면 예외입니다. 이 예외는 전달 중인 웹 응용 프로그램 성능에 부정적 `false` 에 대 한는 `endResponse` 매개 변수를 사용 하는 것이 좋습니다. 자세한 내용은 <xref:System.Web.HttpResponse.End%2A> 메서드를 참조하세요.  
  
> [!NOTE]
>  모바일 페이지에 대 한 응용 프로그램이 쿠키 없는 세션을 사용 하거나 쿠키 없는 세션을 요구 하는 모바일 디바이스에서 요청을 받을 수, 하는 경우 사용 하 여 물결표 (\~) 경로 새 세션을 만들고 수 세션 데이터가 손실 될 수 있습니다. 와 같은 경로 사용 하 여 모바일 컨트롤의 속성을 설정 하려면 "\~/path"를 사용 하 여 경로 확인할 <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "\~/path" 속성에 할당 하기 전에 합니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다. 대체 방법으로 다른 페이지로 컨트롤을 전송 하는 <xref:System.Web.HttpServerUtility.Transfer%2A> 메서드. <xref:System.Web.HttpServerUtility.Transfer%2A> 방법은 일반적으로 더 효율적 때문에 클라이언트에 왕복을 수행 하지는 않습니다. 자세한 내용은 [방법: 다른 페이지로 리디렉션 사용자](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Web.HttpResponse.IsClientConnected%2A> 속성 페이지를 요청 하는 클라이언트 서버에 연결 된 상태로 남아 있는지를 확인 합니다. 하는 경우 <xref:System.Web.HttpResponse.IsClientConnected%2A> 가 true 이면 호출을 <xref:System.Web.HttpResponse.Redirect%2A> 메서드와 클라이언트에는 다른 페이지가 표시 됩니다. 하는 경우 <xref:System.Web.HttpResponse.IsClientConnected%2A> 가 false 이면 코드에서 호출 된 <xref:System.Web.HttpResponse.End%2A> 메서드 및 모든 페이지 처리가 종료 됩니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />에 줄 바꿈 문자가 포함되어 있는 경우</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 후 리디렉션이 시도되는 경우</exception>
        <exception cref="T:System.ApplicationException">페이지 요청이 콜백의 결과인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP <see langword="Location" /> 헤더의 값을 가져오거나 설정합니다.</summary>
        <value>HTTP <see langword="Location" /> 헤더에서 클라이언트로 전송되는 절대 URI입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 HTTP 301 응답 코드를 사용 하 여 영구 리디렉션 코드 경우 리디렉션 URL을 지정 하려면이 속성을 사용 하는 방법을 보여 줍니다.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더가 이미 기록되었습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요청한 URL에서 지정한 URL로의 영구 리디렉션을 수행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">요청을 리디렉션할 위치입니다.</param>
        <summary>요청한 URL에서 지정한 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> 메서드 오버 로드는 응답에서 301 HTTP 상태 코드를 제공 하 고 요청을 리디렉션할 URL을 포함 합니다. HTTP 상태 코드를 301는 HTTP 응답의 표준 코드입니다. 영구 리디렉션을 있고 리디렉션 위치를 제공 하는 것을 나타냅니다.  
  
 호출 된 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> 메서드 오버 로드는 응답을 종료 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />에 줄 바꿈 문자(<c>\n</c>)가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">요청을 리디렉션할 위치입니다.</param>
        <param name="endResponse">응답을 종료하려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</param>
        <summary>요청한 URL에서 지정한 URL로의 영구 리디렉션을 수행하고, 응답을 완료하는 옵션을 제공합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 메서드 오버 로드는 응답에서 301 HTTP 상태 코드를 제공 하 고 요청을 리디렉션할 URL을 포함 합니다. 이 메서드 오버 로드는 또한 리디렉션을 수행 된 후 응답을 완료 또는 종료 여부를 지정 하는 옵션을 제공 합니다. HTTP 상태 코드를 301는 HTTP 응답의 표준 코드입니다. 영구 리디렉션을 있고 리디렉션 위치를 제공 하는 것을 나타냅니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="url" />에 줄 바꿈 문자(<c>\n</c>)가 포함되어 있습니다.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>경로 매개 변수 값, 경로 이름 또는 둘 다 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값을 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 되는 개체를 변환 `routeValues` 에 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 하려면 호출 됩니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 매개 변수를 포함 하는 경로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <summary>경로 이름을 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 된 경로 이름을 변환 `routeName` 를 사용 하 여 URL에는 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Products`합니다.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값을 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드를 호출 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 합니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 매개 변수를 포함 하는 경로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값, 및 경로 이름을 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 되는 개체를 변환 `routeValues` 에 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 하려면 호출 됩니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수를 포함 하 고 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값, 및 경로 이름을 사용하여 새 URL로 요청을 리디렉션합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드를 호출 하는 URL을 확인 합니다.  
  
 ASP.NET 302 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수를 포함 하 고 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>경로 매개 변수 값, 경로 이름 또는 둘 다 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값을 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 되는 개체를 변환 `routeValues` 에 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 하려면 호출 됩니다.  
  
 ASP.NET 301 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 매개 변수를 포함 하는 경로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <summary>경로 이름을 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 된 경로 이름을 변환 `routeName` 를 사용 하 여 URL에는 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드.  
  
 ASP.NET 301 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Products`합니다.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값을 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드를 호출 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 합니다.  
  
 ASP.NET 301 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 매개 변수를 포함 하는 경로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>새 URL에 해당하는 경로 매개 변수 값 및 경로 이름을 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.RedirectPermanent%2A> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드는 전달 되는 개체를 변환 `routeValues` 에 <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> 사용 하 여 개체를 <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> 생성자. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 하려면 호출 됩니다.  
  
 ASP.NET 301 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수를 포함 하 고 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">경로의 이름입니다.</param>
        <param name="routeValues">경로 매개 변수 값입니다.</param>
        <summary>경로 매개 변수 값 및 경로 이름을 사용하여 요청한 URL에서 새 URL로의 영구 리디렉션을 수행합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 코딩 편의 위해 제공 됩니다. 호출 하는 것과 동일 합니다 <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> 로 설정 하는 두 번째 매개 변수를 사용 하 여 메서드 `false`합니다.  
  
 이 메서드를 호출 합니다 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> 메서드 URL을 확인 합니다.  
  
 ASP.NET 301 HTTP 상태 코드를 반환 하 여 리디렉션을 수행 합니다.  
  
   
  
## Examples  
 다음 예제에서는 명명 된 경로로 리디렉션할 하려면이 메서드를 호출 하는 방법을 보여 줍니다 `Product` 명명 된 매개 변수를 포함 하 고 `productid` 고 `category`입니다.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">경로가 지정한 경로 매개 변수에 해당하지 않습니다.</exception>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 리디렉션하려는 경우</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 라우팅</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>기본 출력 캐시 제공자를 사용하여 출력 캐시에서 캐시된 항목을 제거합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">캐시에서 제거되는 항목에 대한 가상 절대 경로입니다.</param>
        <summary>기본 출력 캐시 공급자와 관련된 모든 캐시된 항목을 캐시에서 제거합니다. 이 메서드는 정적입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 출력 캐시 공급자와 연관 된 출력 캐시 항목을 제거 하려면이 메서드를 호출 합니다. 호출 된 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> 웹 사이트 구성 파일에 지정 된 사용자 지정 출력 캐시 공급자와 연관 된 출력 캐시 항목을 제거 하는 방법입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />가 절대 가상 경로가 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">캐시에서 제거되는 항목의 가상 절대 경로입니다.</param>
        <param name="providerName">지정한 경로와 관련된 출력 캐시 아티팩트를 제거하는 데 사용되는 제공자입니다.</param>
        <summary>지정한 출력 캐시 공급자를 사용하여 지정된 경로와 관련된 모든 출력 캐시 항목을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 웹 사이트 구성 파일에 지정 된 사용자 지정 출력 캐시 공급자와 연관 된 출력 캐시 항목을 제거 하려면이 메서드를 호출 합니다. 기본 출력 캐시 공급자와 연관 된 출력 캐시 항목을 제거 하려면 호출을 <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> 메서드 오버 로드 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />은(는) 잘못된 경로입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">컬렉션에서 업데이트할 쿠키입니다.</param>
        <summary><b>HttpResponse.SetCookie</b> 메서드가 내부적으로만 사용되기 때문에 코드에서 호출해야 합니다. 대신, 다음 예제와 같이 <b>HttpResponse.Cookies.Set</b> 메서드를 호출할 수 있습니다.<br /> 쿠키 컬렉션에서 기존 쿠키를 업데이트합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 기존 쿠키의 값을 업데이트 합니다.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 쿠키를 설정하려고 시도한 경우</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에 반환되는 <see langword="Status" /> 줄을 설정합니다.</summary>
        <value>상태 코드를 설정하면 HTTP 출력 상태를 설명하는 문자열이 클라이언트에 반환됩니다. 기본값은 200(OK)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> 위해 되지 <xref:System.Web.HttpResponse.StatusDescription%2A> 이전 버전의 ASP와의 호환성을 위해서만 제공 됩니다. Asp.net을 사용 하 여 <xref:System.Web.HttpResponse.StatusDescription%2A> 대신 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">상태가 잘못된 상태 코드로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에 반환되는 출력의 HTTP 상태 코드를 가져오거나 설정합니다.</summary>
        <value>클라이언트에 반환되는 HTTP 출력의 상태를 나타내는 정수입니다. 기본값은 200(OK)입니다. 올바른 상태 코드의 해당 항목을 참조 하세요 [Http 상태 코드](https://go.microsoft.com/fwlink/?LinkId=73157)합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 출력 스트림의 상태 코드를 확인합니다. 상태 코드 200 없는 경우에 추가 코드가 실행 됩니다.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 <see cref="P:System.Web.HttpResponse.StatusCode" />가 설정된 경우</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>클라이언트에 반환되는 출력의 HTTP 상태 문자열을 가져오거나 설정합니다.</summary>
        <value>클라이언트에 반환되는 HTTP 출력의 상태를 설명하는 문자열입니다. 기본값은 "OK"입니다. 올바른 상태 코드의 해당 항목을 참조 하세요 [Http 상태 코드](https://go.microsoft.com/fwlink/?LinkId=73157)합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 출력 스트림의 상태 문자열을 확인 합니다. 상태가 "ok" 이면 추가 코드가 실행 됩니다.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">HTTP 헤더를 보낸 다음에 <paramref name="StatusDescription" />가 설정된 경우</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">선택한 값의 길이가 512보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응답의 상태 코드를 정규화하는 값을 가져오거나 설정합니다.</summary>
        <value>[!INCLUDE[iisver](~/includes/iisver-md.md)] 하위 상태 코드를 나타내는 정수 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Web.HttpResponse.SubStatusCode%2A> 속성의 통합된 파이프라인 모드 에서만 지원 됩니다 [!INCLUDE[iisver](~/includes/iisver-md.md)] 이상 및.NET Framework 버전 3.0입니다. 설정한 경우 합니다 <xref:System.Web.HttpResponse.SubStatusCode%2A> 속성인 상태 로깅됩니다 [!INCLUDE[iisver](~/includes/iisver-md.md)] 실패 한 요청 추적을 구성 하는 경우. 추적 구성 되어 있는지 여부에 관계 없이, 코드를 요청 하는 마지막 응답의 일부로 전송 되지 않습니다. 자세한 내용은 [문제를 해결 하지 못했습니다 요청을 사용 하 여 실패 한 요청 추적 IIS 7.0에서](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Web.HttpResponse.SubStatusCode%2A> 속성에 대 한 이벤트 처리기에는 <xref:System.Web.HttpApplication> 인스턴스의 <xref:System.Web.HttpApplication.PostAuthenticateRequest> 이벤트. 웹 응용 프로그램의 App_Code 폴더에 코드 파일을 저장 하 고 모듈을 등록 하려면 Web.config 파일을 구성 합니다. 자세한 내용은 [연습: 만들기 및 사용자 지정 HTTP 모듈을 등록](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453)합니다.  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">작업을 수행하려면 통합 파이프라인 모드의 [!INCLUDE[iisver](~/includes/iisver-md.md)] 및 .NET Framework 버전 3.0 이상이 있어야 합니다.</exception>
        <exception cref="T:System.Web.HttpException">모든 HTTP 헤더를 보낸 다음에 상태 코드가 설정된 경우</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>연결이 비동기 플러시 작업을 지원하는지를 나타내는 값을 가져옵니다.</summary>
        <value>연결에서 비동기 플러시 작업을 지원하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값을 반환 합니다 <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 콘텐츠를 클라이언트에 보낼지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>출력하지 않으려면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 검사 하는지 여부를 <xref:System.Web.HttpRequest.IsSecureConnection%2A> 속성이 false로 설정 됩니다. 이 경우는 <xref:System.Web.HttpResponse.SuppressContent%2A> 전송에서 응답을 중지 하려면 true로 설정 합니다.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 HTTP 응답에 대한 기본 <c>Cache Control: private</c> 헤더를 표시하지 않을 것인지 표시하는 값을 가져오거나 설정합니다.</summary>
        <value><see langword="true" /> 기본 표시 하지 않으려면 <c>Cache Control: 사설</c> 현재 HTTP 응답에 대 한 헤더가 고, 그렇지 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 ASP.NET 보냅니다는 `Cache-Control: private` 응답 헤더가이 응답에는 명시적 캐시 정책을 지정 하지 않으면. 이 속성을 사용 하면 요청 단위로이 기본 응답 헤더를 억제 합니다. 헤더를 여전히 억제할 수 있습니다 전체 응용 프로그램 설정 <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> 에 [httpRuntime 요소 (ASP.NET 설정 스키마)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) 또는 [outputCache 요소 (ASP.NET 설정 스키마)캐싱에](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 기본값을 표시 하지 않을 때 주의 해야 `Cache-Control: private` 프록시와 같은 헤더 및 다른 매개 지점 처리할 수 있습니다이 헤더가 없는 응답을 캐시할 수 있도록 기본적으로 합니다. 중요 한 정보의 부주의 한 캐싱을이 처리 될 수 있습니다. 참조 [RFC 2616, 초로 13.4](http://tools.ietf.org/html/rfc2616) 자세한 내용은 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로그인 페이지에 대한 폼 인증 리디렉션이 억제되어야 하는지를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>폼 인증 리디렉션을 억제해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 폼 인증 변환 HTTP 401 상태 코드 302 로그인 페이지로 리디렉션합니다. 이 특정 부류의 인증이 성공 하면 되지만 권한 부여와 같은 오류를 수행 하지 못하거나 현재 요청이 AJAX 또는 웹 서비스 요청을 인지 하는 경우에 적절 하지 않습니다. 이 속성에는 리디렉션 동작을 표시 하지 않으려면 원래 상태 코드를 클라이언트로 전송 하는 방법을 제공 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 파일을 메모리에 버퍼링하지 않고 HTTP 응답 출력 스트림에 직접 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 출력에 쓸 파일의 이름입니다.</param>
        <summary>지정된 파일을 메모리에 버퍼링하지 않고 HTTP 응답 출력 스트림에 직접 씁니다.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 매개 변수가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 출력에 쓸 파일의 이름입니다.</param>
        <param name="offset">HTTP 출력에 쓸 파일의 시작 위치입니다.</param>
        <param name="length">전송할 바이트 수입니다.</param>
        <summary>지정된 파일 부분을 메모리에 버퍼링하지 않고 HTTP 응답 출력 스트림에 직접 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 0을 지정 하는 경우는 `offset` 매개 변수 및-1로는 `length` 매개 변수는 전체 파일이 전송 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="offset" /> 매개 변수가 0보다 작습니다.  
  
또는 
<paramref name="length" /> 매개 변수가 -1보다 작습니다.  
  
또는 
<paramref name="length" /> 매개 변수가 파일의 바이트 수에서 오프셋을 뺀 값보다 큰 바이트 수를 지정한 경우</exception>
        <exception cref="T:System.PlatformNotSupportedException">Out of Process 작업자 요청이 지원되지 않습니다.  
  
또는 
응답에서 <see cref="T:System.Web.HttpWriter" /> 개체를 사용하지 않는 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> 매개 변수가 0보다 작거나 파일 크기보다 큽니다.  
  
또는 
<paramref name="length" /> 매개 변수가 -1보다 작거나 <paramref name="offset" /> 매개 변수에 파일 크기를 더한 값보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[iisver](~/includes/iisver-md.md)] 사용자 지정 오류가 비활성화되는지 여부를 지정하는 값을 가져오거나 설정합니다.</summary>
        <value>IIS 사용자 지정 오류가 비활성화되는 경우 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> 속성은 응용 프로그램이 이상 IIS 7.0에서 호스팅되는 경우에 사용 됩니다. 클래식 모드에서 실행 하는 경우는 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> 속성의 기본값은 `true`합니다. 통합된 모드에서 실행 하는 경우는 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> 속성의 기본값은 `false`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 응답 출력 스트림에 정보를 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">HTTP 출력 스트림에 쓸 문자입니다.</param>
        <summary>HTTP 응답 출력 스트림에 문자를 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 일련의 Write 메서드를 사용 하 여 ASP.NET 페이지에 기록 되는 상수를 만듭니다. 코드는이 버전의 개별 문자 상수는 페이지를 쓸 쓰기 메서드를 호출 합니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">HTTP 출력 스트림에 쓸 <see cref="T:System.Object" />입니다.</param>
        <summary>HTTP 응답 스트림에 <see cref="T:System.Object" />를 씁니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">HTTP 출력 스트림에 쓸 문자열입니다.</param>
        <summary>HTTP 응답 출력 스트림에 문자열을 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 동적으로 생성 된 HTML 페이지를 클라이언트에서 수신 될 때 또는 클라이언트에 게 다시 전송 되는 경우 웹 클라이언트에서 받은 입력 유효성이 검사 되지 않은 경우 보안 위험이 발생할 수 있습니다. 웹 사이트에 제출 하 고 나중에 다시 쓰여진 클라이언트 입력에 포함 된 악의적인 스크립트는 신뢰할 수 있는 원본에서 시작 된 것 나타날 수 있습니다. 이러한 보안 위험을 교차 사이트 스크립팅 공격 이라고 합니다. 클라이언트 브라우저에 사이트에서 전송 될 때 클라이언트에서 받은 데이터를 항상 확인 해야 합니다.  
  
 또한 HTML로 입력으로 받은 데이터를 작성할 때마다 인코딩해야와 같은 기술을 사용 하 여 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 또는 <xref:System.Web.HttpServerUtility.UrlEncode%2A> 악성 스크립트를 실행 하지 못하도록 합니다. 이 방법은 수신 될 때 확인 되지 않은 데이터에 유용 합니다.  
  
 인코딩하거나 데이터를 필터링 하는 경우에 문자 필터를 식별 하 고 (예: 영숫자가 아닌 문자 시퀀스) 설정 하 고 악의적인 스크립트를 포함할 수 있는 바이트 시퀀스에 속하지 않는 제거 되도록 웹 페이지에 대 한 집합을 지정 해야 해당 합니다.  
  
 사이트 간 스크립팅 공격에 대 한 자세한 내용은 문서 Q252985, "하는 방법에 되지 않도록 사이트 간 스크립팅 보안 문제"를 참조 합니다 [Microsoft 기술 자료](https://go.microsoft.com/fwlink/?LinkID=37115) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제에서는 클라이언트의 이름을 클라이언트의 브라우저를 다시 에코합니다. 합니다 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 모든 악성 스크립트 및에 제출한 잘못 된 문자를 제거 하는 메서드는 `UserName` 입력된 필드입니다.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">쓸 문자 배열입니다.</param>
        <param name="index">쓰기 시작할 문자 배열의 위치입니다.</param>
        <param name="count"><paramref name="index" />에서 시작하여 쓸 문자 수입니다.</param>
        <summary>HTTP 응답 출력 스트림에 문자 배열을 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 일련의 Write 메서드를 사용 하 여 ASP.NET 페이지에 기록 되는 상수를 만듭니다. 코드는이 버전의 개별 문자 상수는 페이지를 쓸 쓰기 메서드를 호출 합니다.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 응답 출력 스트림에 지정된 파일을 직접 씁니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 출력에 쓸 파일의 이름입니다.</param>
        <summary>지정된 파일의 내용을 HTTP 응답 출력 스트림에 파일 블록으로 직접 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큰 파일을 사용 하 여이 메서드를 사용 하면 메서드를 호출 하면 예외가 throw 할 수 있습니다. 이 메서드를 사용 하 여 사용할 수 있는 파일의 크기는 웹 서버의 하드웨어 구성에 따라 달라 집니다. 자세한 내용은 문서 812406, "PRB:: Response.WriteFile 없습니다는 큰 파일 다운로드"를 참조 합니다 [Microsoft 기술 자료](https://go.microsoft.com/fwlink/?linkid=149903) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제에서는 라는 텍스트 파일의 모든 내용을 씁니다 `Login.txt` (리터럴 HTML 텍스트 및 입력 컨트롤이 포함 될 수 있습니다는) 출력 스트림에 직접.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">메모리 블록에 쓸 파일의 이름입니다.</param>
        <param name="readIntoMemory">해당 파일을 메모리 블록에 쓸지를 나타냅니다.</param>
        <summary>지정된 파일의 내용을 HTTP 응답 출력 스트림에 메모리 블록으로 직접 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큰 파일을 사용 하 여이 메서드를 사용 하면 메서드를 호출 하면 예외가 throw 할 수 있습니다. 이 메서드를 사용 하 여 사용할 수 있는 파일의 크기는 웹 서버의 하드웨어 구성에 따라 달라 집니다. 자세한 내용은 문서 812406, "PRB:: Response.WriteFile 없습니다는 큰 파일 다운로드"를 참조 합니다 [Microsoft 기술 자료](https://go.microsoft.com/fwlink/?linkid=149903) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제에서는 메모리에 파일을 씁니다.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">HTTP 출력 스트림에 쓸 파일의 파일 핸들입니다.</param>
        <param name="offset">쓰기가 시작될 파일의 바이트 위치입니다.</param>
        <param name="size">출력 스트림에 쓸 바이트 수입니다.</param>
        <summary>HTTP 응답 출력 스트림에 지정된 파일을 직접 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큰 파일을 사용 하 여이 메서드를 사용 하면 메서드를 호출 하면 예외가 throw 할 수 있습니다. 이 메서드를 사용 하 여 사용할 수 있는 파일의 크기는 웹 서버의 하드웨어 구성에 따라 달라 집니다. 자세한 내용은 문서 812406, "PRB:: Response.WriteFile 없습니다는 큰 파일 다운로드"를 참조 합니다 [Microsoft 기술 자료](https://go.microsoft.com/fwlink/?linkid=149903) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제에서는 라는 텍스트 파일의 모든 내용을 씁니다 `Login.txt` (리터럴 HTML 텍스트 및 입력 컨트롤이 포함 될 수 있습니다는) 출력 스트림에 직접.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileHandler" />가 <see langword="null" />인 경우</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" />가 0보다 작은 경우  
  
또는 
 <paramref name="size" />가 파일 크기에서 <paramref name="offset" />을 뺀 값보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">HTTP 출력 스트림에 쓸 파일의 이름입니다.</param>
        <param name="offset">쓰기가 시작될 파일의 바이트 위치입니다.</param>
        <param name="size">출력 스트림에 쓸 바이트 수입니다.</param>
        <summary>HTTP 응답 출력 스트림에 지정된 파일을 직접 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 큰 파일을 사용 하 여이 메서드를 사용 하면 메서드를 호출 하면 예외가 throw 할 수 있습니다. 이 메서드를 사용 하 여 사용할 수 있는 파일의 크기는 웹 서버의 하드웨어 구성에 따라 달라 집니다. 자세한 내용은 문서 812406, "PRB:: Response.WriteFile 없습니다는 큰 파일 다운로드"를 참조 합니다 [Microsoft 기술 자료](https://go.microsoft.com/fwlink/?linkid=149903) 웹 사이트입니다.  
  
   
  
## Examples  
 다음 예제에서는 라는 텍스트 파일의 모든 내용을 씁니다 `Login.txt` (입력 컨트롤 리터럴 텍스트 및 HTML을 포함할 수 있는) 출력 스트림에 직접.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="offset" />가 0보다 작습니다.  
  
또는 
 <paramref name="size" />가 파일 크기에서 <paramref name="offset" />을 뺀 값보다 큰 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">대체할 메서드, 사용자 정의 컨트롤 또는 개체입니다.</param>
        <summary>응답 대체 블록을 응답에 삽입할 수 있도록 하여 출력 캐시 응답의 지정된 응답 영역을 동적으로 생성할 수 있도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 메서드 출력이 캐시 된 페이지에 캐시 후 대체 합니다. 전달 하 여는 <xref:System.Web.HttpContext> 개체는 지정 된 콜백 메서드에 <xref:System.Web.HttpResponseSubstitutionCallback> 서명을 출력 캐시를 바꿀 수 있습니다 페이지 캐시에서 지정 된 모든 위치에서 콘텐츠. 교체를 시작 하려면 호출을 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 스레드로부터 안전 해야 하며 다음 중 하나일 수 있습니다는 콜백 메서드를 전달 하는 메서드:  
  
-   컨테이너 페이지 또는 사용자 정의 컨트롤에 있는 정적 메서드.  
  
-   정적 또는 인스턴스 메서드를 다른 임의의 개체입니다.  
  
 페이지에 대 한 첫 번째 요청에서의 <xref:System.Web.HttpResponse.WriteSubstitution%2A> 호출을 <xref:System.Web.HttpResponseSubstitutionCallback> 출력을 생성 하는 대리자입니다. 그런 다음 이후 요청에서 호출 하는 대리자를 유지 하는 응답에는 대체 버퍼를 추가 합니다. 마지막으로, 클라이언트 쪽 캐시 가능성을 public에서 서버 전용으로 클라이언트에서 캐시 되지 않습니다 하 여 페이지 다시 호출 이후 요청 대리자를 보장 저하 됩니다.  
  
> [!NOTE]
>  캐시 후 대체 출력 캐싱을 적용 되는 사용자 컨트롤 수준에서 캐시 된 사용자 컨트롤에 대해 지원 되지 않습니다. 이 조각 캐싱을 이라고도 합니다. 자세한 내용은 [ASP.NET 페이지의 부분 캐싱을](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="callback" /> 매개 변수의 대상이 <see cref="T:System.Web.UI.Control" /> 형식인 경우</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">페이지의 캐시 가능성 설정</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">ASP.NET 페이지의 부분 캐싱</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">캐시 된 페이지 부분을 동적으로 업데이트합니다.</related>
      </Docs>
    </Member>
  </Members>
</Type>