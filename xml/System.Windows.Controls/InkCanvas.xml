<Type Name="InkCanvas" FullName="System.Windows.Controls.InkCanvas">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4a95604592c0931b964ce402a4cb4c03758d075f" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59017332" /></Metadata><TypeSignature Language="C#" Value="public class InkCanvas : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi InkCanvas extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.InkCanvas" />
  <TypeSignature Language="VB.NET" Value="Public Class InkCanvas&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class InkCanvas : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type InkCanvas = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Children")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>잉크 스트로크를 받아 표시하는 영역을 정의합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 받고 잉크 입력을 표시 하는 요소입니다. 일반적으로 스타일러스 또는 마우스를 사용 하 여 잉크 스트로크를 생성 하는 디지타이저와 상호 작용 하는 스타일러스를 사용 하 여 수행 됩니다. 생성된 된 스트로크 표현 <xref:System.Windows.Ink.Stroke> 개체 및 수 중 하나를 프로그래밍 방식으로 조작 하거나 사용자 입력을 기반으로 합니다. 합니다 <xref:System.Windows.Controls.InkCanvas> 사용자가 수정 하거나 기존 삭제할 수 있도록 <xref:System.Windows.Ink.Stroke>입니다.  
  
 <xref:System.Windows.Controls.InkCanvas> 데이터 소스에 바인딩될 수 있습니다. 예를 들어, 바인딩할 수 있습니다는 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 속성을: serialize 된 잉크의 데이터 형식 (ISF) 또는 심지어 잉크를 포함 하는 base-64로 인코딩된 문자열을 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 의 다른 속성 <xref:System.Windows.Controls.InkCanvas>합니다. 속성을 같은 바인딩할 수 있습니다 <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> 고 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, 다른 데이터 원본에 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 펜과 동일한 highlighter의 사용을 시뮬레이션 하는 방법에 설명 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 태그 언어 (XAML) 파일의 루트 요소는 가정를 <xref:System.Windows.Controls.DockPanel> 호출 `root`합니다. 수도 있다고 가정를 <xref:System.Windows.Controls.Button> 호출 `switchHighlighter` 하 고 모두를 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 및 <xref:System.Windows.FrameworkElement.Loaded> 이벤트가 예제의 이벤트 처리기에 연결 합니다.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 다음 예제에서는 두 개의 선언 <xref:System.Windows.Controls.InkCanvas> XAML 개체 및 해당 및 기타 데이터 원본 간의 데이터 바인딩을 설정 합니다. 첫 번째 <xref:System.Windows.Controls.InkCanvas>라는 `ic`, 두 데이터 소스에 바인딩됩니다. 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 및 <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> 속성을 `ic` 바인딩되는 <xref:System.Windows.Controls.ListBox> , 차례로에 바인딩되는 XAML에 정의 된 배열 개체입니다. <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A>, 및 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 의 두 번째 속성 <xref:System.Windows.Controls.InkCanvas> 바인딩되는 첫 번째 <xref:System.Windows.Controls.InkCanvas> 다음 코드에서입니다.  
  
 [!code-xaml[InkCanvasBindingSnippet#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window1.xaml#1)]   
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms771466(v=vs.90)">WPF 컨트롤 갤러리 샘플</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InkCanvas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InkCanvas();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>InkCanvas 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode ActiveEditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveEditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode ActiveEditingMode { System::Windows::Controls::InkCanvasEditingMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingMode : System.Windows.Controls.InkCanvasEditingMode" Usage="System.Windows.Controls.InkCanvas.ActiveEditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />의 현재 편집 모드를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />의 현재 편집 모드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 속성은 현재 나타냅니다 <xref:System.Windows.Controls.InkCanvasEditingMode> 의 <xref:System.Windows.Controls.InkCanvas>합니다.  된다고 가정 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> 및 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>합니다.  태블릿 펜을 뒤집어에서 사용 되는 경우 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 의 값이 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>합니다. 그렇지 않으면 해당 값은 <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>합니다.  
  
<a name="dependencyPropertyInfo_ActiveEditingMode"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 변수의 값을 보고 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 이 변경 될 때마다 합니다.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler ActiveEditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler ActiveEditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ActiveEditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ ActiveEditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.ActiveEditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 편집 모드가 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 속성이 변경 될 때마다는 <xref:System.Windows.Controls.InkCanvas> 새 편집 모드로 전환 합니다. 예를 들어 있다고 가정 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> 및 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>합니다. 사용자가 태블릿 펜 끝을 변경할 때의 <xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged> 이벤트가 발생 합니다.  
  
<a name="routedEventInfo_ActiveEditingModeChanged"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 변수의 값을 보고 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 이 변경 될 때마다 합니다.  
  
 [!code-csharp[InkCanvasSamples#36](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#36)]
 [!code-vb[InkCanvasSamples#36](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#36)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ActiveEditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ActiveEditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveEditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActiveEditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActiveEditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActiveEditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActiveEditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActiveEditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.ActiveEditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.ActiveEditingMode" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">이 요소에서 자신과 자식을 정렬하는 데 사용해야 하는 부모 내의 마지막 영역입니다.</param>
        <summary>자식 요소를 배치하고 <see cref="T:System.Windows.Controls.InkCanvas" /> 개체에 대한 크기를 결정합니다.</summary>
        <returns>사용되는 실제 크기입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.InkCanvas.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Media.Brush" />을 가져오거나 설정합니다. 브러시는 <see cref="T:System.Windows.Controls.InkCanvas" /> 주위의 테두리 영역을 채우는 데 사용됩니다.</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> 주위의 테두리 영역을 채우는 데 사용되는 <see cref="T:System.Windows.Controls.InkCanvas" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.BackgroundProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법에 설명 합니다 <xref:System.Windows.Controls.InkCanvas.Background%2A> 속성에는 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#37](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#37)]
 [!code-vb[InkCanvasSamples#37](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Background" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="ILAsm" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Bottom" />
      <MemberSignature Language="VB.NET" Value="see GetBottom, and SetBottom" />
      <MemberSignature Language="F#" Value="see GetBottom, and SetBottom" Usage="see GetBottom, and SetBottom" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요소의 아래쪽과 부모 <see cref="T:System.Windows.Controls.InkCanvas" />의 아래쪽 사이의 거리를 가져오거나 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Bottom"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.BottomProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
<a name="xamlAttributeUsage_Bottom"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object InkCanvas.Bottom="double"/>  
- or -  
<object InkCanvas.Bottom="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Bottom"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 문자열 표현 된 <xref:System.Double> 값입니다. 이것은 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다. 예를 들어 값 `1` 허용 됩니다.  
  
 *qualifiedDouble*  
 A *이중* 단위 선언 문자열 중 하나에서 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
   
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Label> 에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BottomProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BottomProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BottomProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BottomProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BottomProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BottomProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.BottomProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> 연결된 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CanPaste" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste();" />
      <MemberSignature Language="F#" Value="member this.CanPaste : unit -&gt; bool" Usage="inkCanvas.CanPaste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클립보드 내용을 <see cref="T:System.Windows.Controls.InkCanvas" />에 붙여 넣을 수 있는지 여부를 나타냅니다.</summary>
        <returns>클립보드 내용을 붙여 넣을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 클립보드에 요소를 복사 하 고를 붙여를 <xref:System.Windows.Controls.InkCanvas>입니다. 이 예제에서는 라는 요소가 있다고 가정 `rect1`, 및는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 예제의 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">클립보드의 내용을 붙여 넣는 권한은 <see cref="T:System.Windows.Controls.InkCanvas" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.UIElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.UIElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As UIElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::UIElementCollection ^ Children { System::Windows::Controls::UIElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Controls.UIElementCollection" Usage="System.Windows.Controls.InkCanvas.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.UIElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />의 자식 요소를 검색합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />에 있는 자식 요소의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Children"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  OneOrMoreUIElements  
</object>  
```  
  
<a name="xamlValues_Children"></a>   
## <a name="xaml-values"></a>XAML 값  
 *OneOrMoreUIElements*  
 하나 이상의 <xref:System.Windows.UIElement> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 추가 <xref:System.Windows.Controls.TextBlock> 에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#8](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#8)]
 [!code-vb[InkCanvasSamples#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySelection">
      <MemberSignature Language="C#" Value="public void CopySelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopySelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CopySelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopySelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopySelection();" />
      <MemberSignature Language="F#" Value="member this.CopySelection : unit -&gt; unit" Usage="inkCanvas.CopySelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>선택된 스트로크 및/또는 요소를 클립보드로 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다. 스트로크를 클립보드에 둘 다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]입니다.  
  
   
  
## Examples  
 두 요소를 선택 하는 다음 예제는 <xref:System.Windows.Controls.InkCanvas> 을 클립보드에 복사 합니다. 이 예제에서는 있다고 가정를 <xref:System.Windows.Controls.TextBox> 호출 `textbox1` 및 <xref:System.Windows.Controls.Button> 호출 `button1 -` 두 컨트롤의 자식 요소는 및를 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 [!code-csharp[InkCanvasSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkCanvasSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Paste" />
      </Docs>
    </Member>
    <Member MemberName="CutSelection">
      <MemberSignature Language="C#" Value="public void CutSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CutSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.CutSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub CutSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CutSelection();" />
      <MemberSignature Language="F#" Value="member this.CutSelection : unit -&gt; unit" Usage="inkCanvas.CutSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>선택된 스트로크 및 요소를 삭제하고 클립보드로 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다. 스트로크를 클립보드에 둘 다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]입니다.  
  
   
  
## Examples  
 다음 예제에서는 선택 하 고 두 요소에서 자릅니다는 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 있다고 가정를 <xref:System.Windows.Controls.TextBox> 호출 `textbox1` 및 <xref:System.Windows.Controls.Button> 호출 `button1` -두 컨트롤의 자식 요소는 및를 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 [!code-csharp[InkCanvasSamples#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#4)]
 [!code-vb[InkCanvasSamples#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.DrawingAttributes DefaultDrawingAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultDrawingAttributes As DrawingAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::DrawingAttributes ^ DefaultDrawingAttributes { System::Windows::Ink::DrawingAttributes ^ get(); void set(System::Windows::Ink::DrawingAttributes ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributes : System.Windows.Ink.DrawingAttributes with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에 그려진 새 잉크 스트로크에 적용된 그리기 특성을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />의 기본 그리기 특성입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 하면이 속성이 설정 된 후 만들어진 새 스트로크만 영향을 줍니다. 이미 만든에 새 그리기 특성을 적용할 <xref:System.Windows.Ink.Stroke> 개체를 개별적으로 사용 하 여 액세스를 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 속성입니다.  
  
<a name="dependencyPropertyInfo_DefaultDrawingAttributes"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 두 개 사용 하는 방법을 보여 줍니다 <xref:System.Windows.Ink.DrawingAttributes> 펜 및 형광펜을 사용 하 여 동일한 경험을 시뮬레이션할 개체 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 태그 언어 (XAML) 파일의 루트 요소는 가정를 <xref:System.Windows.Controls.DockPanel> 호출 `root`합니다. 또한 있다고 가정를 <xref:System.Windows.Controls.Button> 호출 `switchHighlighter` 하 고는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 이벤트를 이벤트 처리기를 연결할 합니다.  
  
 [!code-csharp[DrawingAttributes#3](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#3)]
 [!code-vb[DrawingAttributes#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#3)]  
  
 다음 예제에서는 바인딩하는 방법을 보여는 <xref:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes%2A> 속성을 데이터 소스입니다.  
  
 [!code-xaml[InkCanvasBindingSnippet#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#3)]  
 [!code-xaml[InkCanvasBindingSnippet#4](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#4)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.Strokes" />
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DefaultDrawingAttributesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DefaultDrawingAttributesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DefaultDrawingAttributesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultDrawingAttributesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.DefaultDrawingAttributesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Ink.DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event DefaultDrawingAttributesReplaced As DrawingAttributesReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Ink::DrawingAttributesReplacedEventHandler ^ DefaultDrawingAttributesReplaced;" />
      <MemberSignature Language="F#" Value="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " Usage="member this.DefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.DrawingAttributesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.DefaultDrawingAttributes" /> 속성이 바뀔 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 값을 확인 합니다 <xref:System.Windows.Ink.DrawingAttributes.IsHighlighter%2A> 새 속성 <xref:System.Windows.Ink.DrawingAttributes> 개체입니다.  
  
 [!code-csharp[DrawingAttributes#17](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#17)]
 [!code-vb[DrawingAttributes#17](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStylusPointDescription">
      <MemberSignature Language="C#" Value="public System.Windows.Input.StylusPointDescription DefaultStylusPointDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPointDescription DefaultStylusPointDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultStylusPointDescription As StylusPointDescription" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::StylusPointDescription ^ DefaultStylusPointDescription { System::Windows::Input::StylusPointDescription ^ get(); void set(System::Windows::Input::StylusPointDescription ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStylusPointDescription : System.Windows.Input.StylusPointDescription with get, set" Usage="System.Windows.Controls.InkCanvas.DefaultStylusPointDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPointDescription</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />의 스타일러스 포인트 설정을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />의 스타일러스 포인트 설명입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.Windows.Controls.InkCanvas> 만 저장 합니다 <xref:System.Windows.Input.StylusPointProperties.X>를 <xref:System.Windows.Input.StylusPointProperties.Y>, 및 <xref:System.Windows.Input.StylusPointProperties.NormalPressure> 각각에 대 한 속성 <xref:System.Windows.Input.StylusPoint> 스트로크에 속하는 합니다. 지점에서 스트로크를 구성 하는 방법에 대 한 추가 정보를 저장할 DefaultStylusPointDescription 속성을 사용할 수는 <xref:System.Windows.Controls.InkCanvas>합니다. 이 속성을 설정 하면 새로 스트로크 속성이 설정 된 후에 적용 됩니다.  
  
<a name="xamlTextUsage_DefaultStylusPointDescription"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 속성을 사용할 수 없습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> 있도록 스타일러스 지점에 있는 스트로크의 합니다 <xref:System.Windows.Controls.InkCanvas> 포함를 <xref:System.Windows.Input.StylusPointProperties.X>, <xref:System.Windows.Input.StylusPointProperties.Y>, <xref:System.Windows.Input.StylusPointProperties.NormalPressure>, 및 <xref:System.Windows.Input.StylusPointProperties.TipButton> 속성.  
  
> [!NOTE]
>  에 추가 된 스트로크를 합니다 <xref:System.Windows.Controls.InkCanvas> 후의 <xref:System.Windows.Controls.InkCanvas.DefaultStylusPointDescription%2A> 추가 속성이로 설정 됩니다.  
  
 [!code-csharp[InkCanvasSamples#9](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#9)]
 [!code-vb[InkCanvasSamples#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPointProperties" />
        <altmember cref="T:System.Windows.Input.StylusPointProperty" />
        <altmember cref="T:System.Windows.Input.StylusPointPropertyInfo" />
      </Docs>
    </Member>
    <Member MemberName="DynamicRenderer">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.DynamicRenderer DynamicRenderer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberSignature Language="VB.NET" Value="Protected Property DynamicRenderer As DynamicRenderer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::DynamicRenderer ^ DynamicRenderer { System::Windows::Input::StylusPlugIns::DynamicRenderer ^ get(); void set(System::Windows::Input::StylusPlugIns::DynamicRenderer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicRenderer : System.Windows.Input.StylusPlugIns.DynamicRenderer with get, set" Usage="System.Windows.Controls.InkCanvas.DynamicRenderer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.DynamicRenderer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에 동적으로 잉크를 그리는 렌더러를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />에 동적으로 잉크를 그리는 렌더러입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정할 수 있습니다 합니다 <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A> 속성을 사용자 지정 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 잉크를 사용자 지정 하려는 경우.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A> 멤버인는 <xref:System.Windows.UIElement.StylusPlugIns%2A> 컬렉션입니다. 설정 하는 경우는 <xref:System.Windows.Controls.InkCanvas.DynamicRenderer%2A>, <xref:System.Windows.Controls.InkCanvas> 이전 제거 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 에서 합니다 <xref:System.Windows.Input.StylusPlugIns.StylusPlugInCollection> 새 추가 <xref:System.Windows.Input.StylusPlugIns.DynamicRenderer> 컬렉션의 끝에 합니다. 동작을 변경할 수 있습니다이 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingMode As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingMode { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingMode : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>활성 포인팅 장치에 사용되는 사용자 편집 모드를 가져오거나 설정합니다.</summary>
        <value>태블릿 펜이나 마우스 등의 포인팅 장치가 활성 상태일 때 사용되는 편집 모드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>는 <xref:System.Windows.Controls.InkCanvasEditingMode.Ink>입니다. 변경 된 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 기존 선택 내용을 지웁니다.  
  
 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 와 상호 작용 하는 포인팅 장치가 모드를 지정 합니다 <xref:System.Windows.Controls.InkCanvas>합니다. <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 스타일러스 "지우개 end" 디지타이저를 연결 하는 경우 일부 디지타이저에서 사용 됩니다.  
  
<a name="dependencyPropertyInfo_EditingMode"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.EditingModeProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 다양 한 유형의에서 편집 모드를 사용 하는 응용 프로그램을 만듭니다는 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[ICEditingModeSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ICEditingModeSample/CSharp/Window1.xaml.cs#1)]
 [!code-vb[ICEditingModeSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ICEditingModeSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      </Docs>
    </Member>
    <Member MemberName="EditingModeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.EditingMode" /> 개체의 <see cref="T:System.Windows.Controls.InkCanvas" /> 속성이 변경되었을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 발생 후 편집 모드가 변경 되었습니다. 에 변경 내용이 반영 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas>.  
  
<a name="routedEventInfo_EditingModeChanged"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.EditingModeChangedEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 검사 하는지 여부를 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 속성이 <xref:System.Windows.Controls.InkCanvasEditingMode.Ink> 또는 <xref:System.Windows.Controls.InkCanvasEditingMode.Select>합니다.  
  
 [!code-csharp[InkCanvasSamples#21](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#21)]
 [!code-vb[InkCanvasSamples#21](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInverted">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasEditingMode EditingModeInverted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.InkCanvasEditingMode EditingModeInverted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberSignature Language="VB.NET" Value="Public Property EditingModeInverted As InkCanvasEditingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::InkCanvasEditingMode EditingModeInverted { System::Windows::Controls::InkCanvasEditingMode get(); void set(System::Windows::Controls::InkCanvasEditingMode value); };" />
      <MemberSignature Language="F#" Value="member this.EditingModeInverted : System.Windows.Controls.InkCanvasEditingMode with get, set" Usage="System.Windows.Controls.InkCanvas.EditingModeInverted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasEditingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />와 상호 작용할 때 스타일러스가 반전된 경우 사용자 편집 모드를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />의 반전 편집 모드입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 스타일러스가 반전 하는 경우 수행 되는 작업을 제어 합니다.  
  
 마찬가지로,는 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 스타일러스가 디지타이저에 대 한 표준, 끝 위치에 있는 경우 수행 되는 작업을 제어 하는 속성  
  
<a name="dependencyPropertyInfo_EditingModeInverted"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 사용자가 부분적으로 스타일러스 반전된 팁을 사용 하 여 스트로크를 지울 수를 허용 하는 방법을 보여 줍니다. 타원형 커서가에 표시 되는 <xref:System.Windows.Controls.InkCanvas> 사용자 잉크를 삭제 하는 경우.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler EditingModeInvertedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler EditingModeInvertedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EditingModeInvertedChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ EditingModeInvertedChanged;" />
      <MemberSignature Language="F#" Value="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " Usage="member this.EditingModeInvertedChanged : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" /> 개체의 <see cref="T:System.Windows.Controls.InkCanvas" /> 속성이 변경되었을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트의 반전된 편집 모드 변경 된 후 발생 합니다. 이러한 변경 내용이 반영 합니다 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
<a name="routedEventInfo_EditingModeInvertedChanged"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 검사 하는지 여부를 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 속성이 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> 또는 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>합니다.  
  
 [!code-csharp[InkCanvasSamples#20](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#20)]
 [!code-vb[InkCanvasSamples#20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent EditingModeInvertedChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ EditingModeInvertedChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeInvertedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeInvertedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeInvertedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeInvertedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeInvertedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeInvertedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeInvertedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.EditingModeInverted" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EditingModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EditingModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EditingModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditingModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EditingModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditingModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.EditingModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.EditingMode" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EraserShape">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StylusShape EraserShape { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StylusShape EraserShape" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberSignature Language="VB.NET" Value="Public Property EraserShape As StylusShape" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StylusShape ^ EraserShape { System::Windows::Ink::StylusShape ^ get(); void set(System::Windows::Ink::StylusShape ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EraserShape : System.Windows.Ink.StylusShape with get, set" Usage="System.Windows.Controls.InkCanvas.EraserShape" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StylusShape</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Ink.StylusShape" />에서 잉크를 지우는 데 사용되는 <see cref="T:System.Windows.Controls.InkCanvas" />를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />에 연결된 지우개 도형입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 잉크를 지우는 데 사용할이 셰이프를 <xref:System.Windows.Controls.InkCanvas> 때 현재 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>합니다.  
  
 개별 속성을 <xref:System.Windows.Ink.StylusShape> 셰이프 만들어지면 수정할 수 없습니다.  
  
 변경 하는 경우는 <xref:System.Windows.Controls.InkCanvas.EraserShape%2A>에서 렌더링 되는 커서가 합니다 <xref:System.Windows.Controls.InkCanvas> 까지 업데이트 되지 않습니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 변경 합니다.  
  
<a name="xamlTextUsage_EraserShape"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 속성은 일반적으로 사용 하지 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자가 부분적으로 스타일러스 반전된 팁을 사용 하 여 스트로크를 지울 수를 허용 하는 방법을 보여 줍니다. 타원형 커서가에 표시 되는 <xref:System.Windows.Controls.InkCanvas> 사용자 잉크를 삭제 하는 경우.  
  
 [!code-csharp[InkCanvasSamples#6](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#6)]
 [!code-vb[InkCanvasSamples#6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StylusShape" />
      </Docs>
    </Member>
    <Member MemberName="Gesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasGestureEventHandler Gesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasGestureEventHandler Gesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.Gesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Gesture As InkCanvasGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasGestureEventHandler ^ Gesture;" />
      <MemberSignature Language="F#" Value="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " Usage="member this.Gesture : System.Windows.Controls.InkCanvasGestureEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에서 제스처가 감지될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Gesture"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.GestureEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.InkCanvasGestureEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.InkCanvas> 응용 프로그램 제스처를 인식 하도록 합니다.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.GestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.Gesture" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBottom">
      <MemberSignature Language="C#" Value="public static double GetBottom (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBottom(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetBottom(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBottom (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBottom(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetBottom : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetBottom element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Bottom 속성을 가져올 요소입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> 속성 값을 가져옵니다.</summary>
        <returns>종속성 개체의 아래쪽 좌표입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 가져옵니다 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#34](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#34)]
 [!code-vb[InkCanvasSamples#34](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnabledGestures">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; GetEnabledGestures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetEnabledGestures" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnabledGestures () As ReadOnlyCollection(Of ApplicationGesture)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Ink::ApplicationGesture&gt; ^ GetEnabledGestures();" />
      <MemberSignature Language="F#" Value="member this.GetEnabledGestures : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;" Usage="inkCanvas.GetEnabledGestures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Ink.ApplicationGesture&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에서 인식되는 응용 프로그램 제스처의 컬렉션을 반환합니다.</summary>
        <returns><see cref="T:System.Windows.Controls.InkCanvas" />에서 인식되는 제스처의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서 설정 된 응용 프로그램 제스처를 가져오기 하는 방법에 설명 합니다 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#24](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#24)]
 [!code-vb[InkCanvasSamples#24](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" /> 속성이 <see langword="false" />일 경우(이 속성은</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLeft">
      <MemberSignature Language="C#" Value="public static double GetLeft (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLeft(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetLeft(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLeft (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLeft(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLeft : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetLeft element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Left 속성을 가져올 요소입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Left" /> 속성 값을 가져옵니다.</summary>
        <returns>종속성 개체의 왼쪽 좌표입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 가져옵니다 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#31](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#31)]
 [!code-vb[InkCanvasSamples#31](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRight">
      <MemberSignature Language="C#" Value="public static double GetRight (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetRight(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetRight(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRight (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetRight(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetRight : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetRight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Right 속성을 가져올 요소입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Right" /> 속성 값을 가져옵니다.</summary>
        <returns>종속성 개체의 오른쪽 좌표입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 가져옵니다 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#32](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#32)]
 [!code-vb[InkCanvasSamples#32](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelectedElements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt; GetSelectedElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.UIElement&gt; GetSelectedElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedElements () As ReadOnlyCollection(Of UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::UIElement ^&gt; ^ GetSelectedElements();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedElements : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;" Usage="inkCanvas.GetSelectedElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.UIElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkElement" />에서 선택된 <see cref="T:System.Windows.Controls.InkCanvas" /> 개체를 검색합니다.</summary>
        <returns><see cref="T:System.Windows.FrameworkElement" /> 개체의 배열입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는만 반환 <xref:System.Windows.FrameworkElement> 개체가 아닌 <xref:System.Windows.Ink.Stroke> 개체입니다.  
  
 검색할 선택한 <xref:System.Windows.Ink.Stroke> 개체를 호출 합니다 <xref:System.Windows.Controls.InkCanvas.GetSelectedStrokes%2A> 메서드.  
  
 경우는 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 의 <xref:System.Windows.Controls.InkCanvas> 로 설정 된 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, 사용자가 선택할 수 있습니다 <xref:System.Windows.Ink.Stroke> 개체 및 <xref:System.Windows.FrameworkElement> 개체입니다. 코드를 사용 하 여 두 유형의 개체 수 선택 또는: 호출 된 <xref:System.Windows.Controls.InkCanvas.Select%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 선택한 각 요소의 너비와 높이 두 배로 증가에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#12](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#12)]
 [!code-vb[InkCanvasSamples#12](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectedStrokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection GetSelectedStrokes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Ink.StrokeCollection GetSelectedStrokes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectedStrokes () As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Ink::StrokeCollection ^ GetSelectedStrokes();" />
      <MemberSignature Language="F#" Value="member this.GetSelectedStrokes : unit -&gt; System.Windows.Ink.StrokeCollection" Usage="inkCanvas.GetSelectedStrokes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Ink.StrokeCollection" />에서 선택된 <see cref="T:System.Windows.Ink.Stroke" /> 개체를 나타내는 <see cref="T:System.Windows.Controls.InkCanvas" />을 검색합니다.</summary>
        <returns>선택된 스트로크의 컬렉션입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 반환 <xref:System.Windows.Ink.Stroke> 개체만 해당 합니다. 검색할 선택한 <xref:System.Windows.FrameworkElement> 개체를 호출 합니다 <xref:System.Windows.Controls.InkCanvas.GetSelectedElements%2A> 메서드.  
  
 경우는 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 의 <xref:System.Windows.Controls.InkCanvas> 로 설정 된 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>, 사용자가 선택할 수 있습니다 <xref:System.Windows.Ink.Stroke> 개체 및 <xref:System.Windows.FrameworkElement> 개체입니다. 코드를 사용 하 여 두 유형의 개체 수 선택 또는: 호출 된 <xref:System.Windows.Controls.InkCanvas.Select%2A> 메서드.  
  
   
  
## Examples  
 선택한 각 선의 색을 변경 하는 다음 예제는 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#11](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#11)]
 [!code-vb[InkCanvasSamples#11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Controls.InkCanvas.Select" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="GetSelectionBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetSelectionBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetSelectionBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetSelectionBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelectionBounds () As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetSelectionBounds();" />
      <MemberSignature Language="F#" Value="member this.GetSelectionBounds : unit -&gt; System.Windows.Rect" Usage="inkCanvas.GetSelectionBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에서 선택된 스트로크 및 요소의 경계를 가져옵니다.</summary>
        <returns>선택된 모든 스트로크 및 요소를 둘러싸는 가장 작은 사각형입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 원래 크기 보다 작게 선택 하지 못하도록 사용자를 방지 합니다.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTop">
      <MemberSignature Language="C#" Value="public static double GetTop (System.Windows.UIElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetTop(class System.Windows.UIElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetTop(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTop (element As UIElement) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetTop(System::Windows::UIElement ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTop : System.Windows.UIElement -&gt; double" Usage="System.Windows.Controls.InkCanvas.GetTop element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.AttachedPropertyBrowsableForChildren</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="element">Top 속성을 가져올 요소입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Top" /> 속성 값을 가져옵니다.</summary>
        <returns>종속성 개체의 위쪽 좌표입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 가져옵니다 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#33](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#33)]
 [!code-vb[InkCanvasSamples#33](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="inkCanvas.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">컬렉션에서 요청된 자식 요소의 인덱스(0부터 시작)입니다.</param>
        <summary><see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />를 재정의하며, 자식 요소 컬렉션에서 지정된 인덱스의 자식을 반환합니다.</summary>
        <returns>요청된 자식 요소입니다. <see langword="null" />을 반환하면 안 됩니다. 지정된 인덱스가 범위를 벗어난 경우 예외가 발생합니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParams);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParams As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParams);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="inkCanvas.HitTestCore hitTestParams" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParams" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParams">적중 테스트를 수행할 대상 <see cref="T:System.Windows.Point" />를 지정하는 개체입니다.</param>
        <summary>지정된 지점이 <see cref="T:System.Windows.Controls.InkCanvas" />의 렌더링 경계 내에 있는지 확인합니다.</summary>
        <returns>적중 테스트에서 반환되는 <see cref="T:System.Windows.Media.Visual" />을 나타내는 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestSelection">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Controls.InkCanvasSelectionHitResult HitTestSelection(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.HitTestSelection(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Controls::InkCanvasSelectionHitResult HitTestSelection(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.HitTestSelection : System.Windows.Point -&gt; System.Windows.Controls.InkCanvasSelectionHitResult" Usage="inkCanvas.HitTestSelection point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionHitResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">적중 테스트를 수행할 점입니다.</param>
        <summary>선택 표시기에서 지정된 지점과 교차하거나 이 점을 둘러싸는 부분을 나타내는 값을 반환합니다.</summary>
        <returns>선택 표시기에서 지정된 지점과 교차하거나 이 점을 둘러싸는 부분을 나타내는 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A> 지점 스트로크 선택의 범위 내 또는 8 개의 핸들 중 하나 인지 확인 하는 방법입니다.  끌어서 놓기 작업을 수행 하는 경우에 유용 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 <xref:System.Windows.Controls.InkCanvas.HitTestSelection%2A> 만들지 여부를 결정 하는 <xref:System.Windows.DataObject> 시작 끌어서 놓습니다.  끌어서를 구현 하 여 두 놓을 <xref:System.Windows.Controls.InkCanvas> 개체를 참조 하세요. [방법: 잉크 끌어서 놓기](~/docs/framework/wpf/advanced/how-to-drag-and-drop-ink.md)합니다.  
  
 [!code-csharp[InkDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Wpf/InkDragDrop/CSharp/Window1.xaml.cs#3)]
 [!code-vb[InkDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkDragDrop/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InkPresenter">
      <MemberSignature Language="C#" Value="protected System.Windows.Controls.InkPresenter InkPresenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.InkPresenter InkPresenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property InkPresenter As InkPresenter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Controls::InkPresenter ^ InkPresenter { System::Windows::Controls::InkPresenter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InkPresenter : System.Windows.Controls.InkPresenter" Usage="System.Windows.Controls.InkCanvas.InkPresenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkPresenter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에 잉크를 표시하는 잉크 프리젠터를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />에 잉크를 표시하는 잉크 프리젠터입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGestureRecognizerAvailable">
      <MemberSignature Language="C#" Value="public bool IsGestureRecognizerAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGestureRecognizerAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGestureRecognizerAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGestureRecognizerAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGestureRecognizerAvailable : bool" Usage="System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자의 시스템에서 제스처 인식 구성 요소를 사용할 수 있는지 확인합니다.</summary>
        <value>인식 구성 요소를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 구성 하는 방법에 설명 된 <xref:System.Windows.Controls.InkCanvas> 응용 프로그램 제스처를 인식 하도록 합니다.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="ILAsm" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Left" />
      <MemberSignature Language="VB.NET" Value="see GetLeft, and SetLeft" />
      <MemberSignature Language="F#" Value="see GetLeft, and SetLeft" Usage="see GetLeft, and SetLeft" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요소의 왼쪽과 부모 <see cref="T:System.Windows.Controls.InkCanvas" />의 왼쪽 사이의 거리를 가져오거나 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Left"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.LeftProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
<a name="xamlAttributeUsage_Left"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object InkCanvas.Left="double"/>  
- or -  
<object InkCanvas.Left="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Left"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 문자열 표현 된 <xref:System.Double> 값입니다. 이것은 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다. 예를 들어 값 `1` 허용 됩니다.  
  
 *qualifiedDouble*  
 A *이중* 단위 선언 문자열 중 하나에서 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
   
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Label> 에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Left" /> 연결된 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.InkCanvas.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>논리적 자식에 대한 열거자를 반환합니다.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="inkCanvas.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">이 요소가 자식 요소에 제공할 수 있는 사용 가능한 크기입니다. 값으로 무한대를 지정하면 사용할 수 있는 콘텐츠에 따라 요소 크기가 지정됩니다.</param>
        <summary>자식 요소에 필요한 레이아웃의 크기를 측정하고 <see cref="System.Windows.Controls.InkCanvas" /> 개체의 크기를 결정합니다.</summary>
        <returns>이 요소에서 자식 요소 크기 계산에 따라 레이아웃 중에 필요하다고 결정하는 크기입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="MoveEnabled">
      <MemberSignature Language="C#" Value="public bool MoveEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MoveEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property MoveEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MoveEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MoveEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.MoveEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Windows.Controls.InkCanvas" />에서 선택한 잉크 스트로크 및/또는 요소를 이동할 수 있는지 여부를 나타내는 부울 값을 가져오거나 설정합니다.</summary>
        <value>사용자가 <see cref="T:System.Windows.Controls.InkCanvas" />의 스트로크 및/또는 요소를 이동할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 표시기 테두리가 그려진 잉크 스트로크 및/또는 요소 선택 하면 됩니다. 이 border 사용 하면 선택한 개체를 이동할 수 있습니다. 하는 경우 <xref:System.Windows.Controls.InkCanvas.ResizeEnabled%2A> 는 `true`, 표시기 스트로크 및/또는 요소 및 크기를 조정할 수 있습니다.  
  
 이 속성 설정 된 경우 `false` 선택한 개체에서 표시기 테두리를 자동으로 제거할는 하나 이상의 잉크 스트로크 및/또는 요소를 선택 하는 동안.  
  
   
  
## Examples  
 다음 예에서는 이동 및 요소 크기 조정에서 사용자를 차단 및 스트로크를 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActiveEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnActiveEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActiveEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnActiveEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActiveEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActiveEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnActiveEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnActiveEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.ActiveEditingModeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="inkCanvas.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 인프라의 일부로 이 컨트롤에 대한 적절한 <see cref="T:System.Windows.Automation.Peers.InkCanvasAutomationPeer" /> 구현을 제공합니다.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDefaultDrawingAttributesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnDefaultDrawingAttributesReplaced (System.Windows.Ink.DrawingAttributesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDefaultDrawingAttributesReplaced(class System.Windows.Ink.DrawingAttributesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnDefaultDrawingAttributesReplaced(System.Windows.Ink.DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDefaultDrawingAttributesReplaced (e As DrawingAttributesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDefaultDrawingAttributesReplaced(System::Windows::Ink::DrawingAttributesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit&#xA;override this.OnDefaultDrawingAttributesReplaced : System.Windows.Ink.DrawingAttributesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnDefaultDrawingAttributesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Ink.DrawingAttributesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.DefaultDrawingAttributesReplaced" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.EditingModeChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 발생 후 편집 모드가 변경 되었습니다. 에 변경 내용이 반영 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEditingModeInvertedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEditingModeInvertedChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEditingModeInvertedChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnEditingModeInvertedChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEditingModeInvertedChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEditingModeInvertedChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnEditingModeInvertedChanged : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnEditingModeInvertedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.EditingModeInvertedChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트의 반전된 편집 모드에 변경 된 후 발생 합니다. 에 반영 된 변경 내용을 합니다 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnGesture (System.Windows.Controls.InkCanvasGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGesture(class System.Windows.Controls.InkCanvasGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnGesture(System.Windows.Controls.InkCanvasGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGesture (e As InkCanvasGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGesture(System::Windows::Controls::InkCanvasGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit&#xA;override this.OnGesture : System.Windows.Controls.InkCanvasGestureEventArgs -&gt; unit" Usage="inkCanvas.OnGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.Gesture" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="inkCanvas.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">기존 값과 새 값 그리고 변경된 속성을 설명하는 이벤트 데이터입니다.</param>
        <summary>이 <see cref="T:System.Windows.FrameworkElement" />에서 종속성 속성의 유효 값이 업데이트될 때마다 호출됩니다. 변경된 특정 종속성 속성이 인수 매개 변수에서 보고됩니다. <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />를 재정의합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.SelectionChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자가 잉크 스트로크 및/또는 요소 집합을 선택한 후 선택 항목 변경이 적용 된 후 호출 됩니다. 변경 내용이 적용 되기 전에 <xref:System.Windows.Controls.InkCanvas.OnSelectionChanging%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanging (System.Windows.Controls.InkCanvasSelectionChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanging(class System.Windows.Controls.InkCanvasSelectionChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionChanging(System.Windows.Controls.InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanging (e As InkCanvasSelectionChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanging(System::Windows::Controls::InkCanvasSelectionChangingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit&#xA;override this.OnSelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 변경 내용이 적용 되기 전에 하지만 사용자가 스트로크 및/또는 요소를 새 선택 만들어질 때 호출 됩니다. 변경 내용을 적용 된 후의 <xref:System.Windows.Controls.InkCanvas.OnSelectionChanged%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoved (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoved(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoved (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoved(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoved : EventArgs -&gt; unit&#xA;override this.OnSelectionMoved : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">사용되지 않습니다.</param>
        <summary>사용자가 스트로크 및/또는 요소를 선택하고 선택 영역을 이동했음을 알리는 이벤트입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자가 스트로크 및/또는 요소 선택 영역 이동 되었습니다 및 변경 내용이 적용 된 후 호출 됩니다. 변경 내용이 적용 되기 전에 <xref:System.Windows.Controls.InkCanvas.OnSelectionMoving%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionMoving (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionMoving(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionMoving(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionMoving (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionMoving(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자의 스트로크 및/또는 요소 선택 영역 이동 하도록 요청한 후 변경 내용이 적용 되기 전에 호출 됩니다. 변경 내용을 적용 된 후의 <xref:System.Windows.Controls.InkCanvas.OnSelectionMoved%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionMoved(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResized">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResized : EventArgs -&gt; unit&#xA;override this.OnSelectionResized : EventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.SelectionResized" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자가 스트로크 및/또는 요소 선택의 크기가 조정 및 변경 내용이 적용 된 후 호출 됩니다. 변경 내용이 적용 되기 전에 <xref:System.Windows.Controls.InkCanvas.OnSelectionResizing%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionResizing">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionResizing (System.Windows.Controls.InkCanvasSelectionEditingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionResizing(class System.Windows.Controls.InkCanvasSelectionEditingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnSelectionResizing(System.Windows.Controls.InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionResizing (e As InkCanvasSelectionEditingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionResizing(System::Windows::Controls::InkCanvasSelectionEditingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit&#xA;override this.OnSelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventArgs -&gt; unit" Usage="inkCanvas.OnSelectionResizing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasSelectionEditingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 사용자가 스트로크 및/또는 요소 선택 영역 크기를 조정할 수 요청 후 변경 내용이 적용 되기 전에 호출 됩니다. 변경 내용을 적용 된 후의 <xref:System.Windows.Controls.InkCanvas.OnSelectionResized%2A> 메서드가 호출 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvas.OnSelectionResized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStrokeCollected">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeCollected (System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeCollected(class System.Windows.Controls.InkCanvasStrokeCollectedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeCollected(System.Windows.Controls.InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeCollected (e As InkCanvasStrokeCollectedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeCollected(System::Windows::Controls::InkCanvasStrokeCollectedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit&#xA;override this.OnStrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeCollected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeCollectedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A> 사용자 실제로 완료가 스트로크를 예를 들어, 스타일러스를 태블릿을 움직인 후 시켜 때 호출 됩니다.  
  
 스트로크를 프로그래밍 방식으로 추가 합니다 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 컬렉션을 호출 하지 것입니다는 <xref:System.Windows.Controls.InkCanvas.OnStrokeCollected%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErased">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErased (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErased(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErased(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErased (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErased(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnStrokeErased : System.Windows.RoutedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErased e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokeErasing">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokeErasing (System.Windows.Controls.InkCanvasStrokeErasingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokeErasing(class System.Windows.Controls.InkCanvasStrokeErasingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokeErasing(System.Windows.Controls.InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokeErasing (e As InkCanvasStrokeErasingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokeErasing(System::Windows::Controls::InkCanvasStrokeErasingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit&#xA;override this.OnStrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventArgs -&gt; unit" Usage="inkCanvas.OnStrokeErasing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokeErasingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokeErasing" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStrokesReplaced">
      <MemberSignature Language="C#" Value="protected virtual void OnStrokesReplaced (System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStrokesReplaced(class System.Windows.Controls.InkCanvasStrokesReplacedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.OnStrokesReplaced(System.Windows.Controls.InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStrokesReplaced (e As InkCanvasStrokesReplacedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStrokesReplaced(System::Windows::Controls::InkCanvasStrokesReplacedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit&#xA;override this.OnStrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventArgs -&gt; unit" Usage="inkCanvas.OnStrokesReplaced e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.InkCanvasStrokesReplacedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokesReplaced" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Paste">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>클립보드의 내용을 <see cref="T:System.Windows.Controls.InkCanvas" />에 붙여 넣습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberSignature Language="F#" Value="member this.Paste : unit -&gt; unit" Usage="inkCanvas.Paste " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클립보드의 내용을 <see cref="T:System.Windows.Controls.InkCanvas" />의 왼쪽 위 모퉁이에 붙여 넣습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 클립보드에 요소를 복사 하 고를 붙여를 <xref:System.Windows.Controls.InkCanvas>입니다. 이 예제에서는 라는 요소가 있다고 가정 `rect1`, 및는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 예제의 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">클립보드의 내용을 <see cref="T:System.Windows.Controls.InkCanvas" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Paste(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.Paste : System.Windows.Point -&gt; unit" Usage="inkCanvas.Paste point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">스트로크를 붙여 넣을 지점입니다.</param>
        <summary>클립보드의 내용을 <see cref="T:System.Windows.Controls.InkCanvas" />의 지정된 지점에 붙여 넣습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Controls.InkCanvas> 클립보드 데이터를 지원할 수 있습니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]을 및 텍스트 형식입니다.  
  
   
  
## Examples  
 다음 예제에서는 클립보드에 요소를 복사 하 고를 붙여를 <xref:System.Windows.Controls.InkCanvas>입니다. 이 예제에서는 라는 요소가 있다고 가정 `rect1`, 및는 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 예제의 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-csharp[InkCanvasSamples#1](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#1)]
 [!code-vb[InkCanvasSamples#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">클립보드의 내용을 붙여 넣는 권한은 <see cref="T:System.Windows.Controls.InkCanvas" />합니다. 연관된 열거형: <see cref="F:System.Security.Permissions.UIPermissionClipboard.AllClipboard" /></permission>
        <altmember cref="M:System.Windows.Controls.InkCanvas.CopySelection" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.CanPaste" />
      </Docs>
    </Member>
    <Member MemberName="PreferredPasteFormats">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Controls.InkCanvasClipboardFormat&gt; PreferredPasteFormats" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberSignature Language="VB.NET" Value="Public Property PreferredPasteFormats As IEnumerable(Of InkCanvasClipboardFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ PreferredPasteFormats { System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ get(); void set(System::Collections::Generic::IEnumerable&lt;System::Windows::Controls::InkCanvasClipboardFormat&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PreferredPasteFormats : seq&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt; with get, set" Usage="System.Windows.Controls.InkCanvas.PreferredPasteFormats" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Controls.InkCanvasClipboardFormat&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에 붙여 넣을 수 있는 서식을 가져오거나 설정합니다.</summary>
        <value>열거형 값의 컬렉션입니다. 기본값은 <see cref="F:System.Windows.Controls.InkCanvasClipboardFormat.InkSerializedFormat" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_PreferredPasteFormats"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.PreferredPasteFormats>  
    InkCanvasClipboardFormats  
  </object.PreferredPasteFormats>  
</object>  
```  
  
<a name="xamlValues_PreferredPasteFormats"></a>   
## <a name="xaml-values"></a>XAML 값  
 *InkCanvasClipboardFormats*  
 배열을 <xref:System.Windows.Controls.InkCanvasClipboardFormat> 열거형 값입니다. XAML에서 배열을 지정 하려면 `x:Array` 사용 합니다. 배열 멤버를 선언 하는 요소로 열거형 값을 지정 하려면 `x:Static` 사용 합니다. 자세한 내용은 [X:array 태그 확장](~/docs/framework/xaml-services/x-array-markup-extension.md) 하 고 [X:static 태그 확장](~/docs/framework/xaml-services/x-static-markup-extension.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Windows.Controls.InkCanvas.PreferredPasteFormats%2A> 있도록를 <xref:System.Windows.Controls.InkCanvas> 수락 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 형식으로 [!INCLUDE[TLA#tla_isf](~/includes/tlasharptla-isf-md.md)]입니다.  
  
 [!code-csharp[InkCanvasSamples#26](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#26)]
 [!code-vb[InkCanvasSamples#26](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#26)]  
  
 다음 예제에서 동일한 결과 얻을 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]합니다.  
  
 [!code-xaml[InkCanvasSamples#38](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window2.xaml#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeEnabled">
      <MemberSignature Language="C#" Value="public bool ResizeEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResizeEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeEnabled : bool with get, set" Usage="System.Windows.Controls.InkCanvas.ResizeEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Windows.Controls.InkCanvas" />에서 선택한 잉크 스트로크 및/또는 요소의 크기를 조정할 수 있는지 여부를 나타내는 부울 값을 가져오거나 설정합니다.</summary>
        <value>사용자가 <see cref="T:System.Windows.Controls.InkCanvas" />의 스트로크 및/또는 요소의 크기를 조정할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 표시기 테두리가 그려진 잉크 스트로크 및/또는 요소 선택 하면 됩니다. 이 테두리를 선택한 개체의 크기를 조정 하려면을 사용 합니다. 하는 경우 <xref:System.Windows.Controls.InkCanvas.MoveEnabled%2A> 는 `true`, 표시기를 사용 하는 스트로크 및/또는 요소 및 이동할 수 있습니다.  
  
 이 속성 설정 된 경우 `false` 표시기 테두리 하나 이상의 잉크 스트로크 및/또는 요소를 선택 하는 동안 선택한 개체에서 자동으로 제거 됩니다.  
  
   
  
## Examples  
 다음 예에서는 이동 및 요소 크기 조정에서 사용자를 차단 및 스트로크를 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#7](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#7)]
 [!code-vb[InkCanvasSamples#7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="see GetRight, and SetRight" />
      <MemberSignature Language="ILAsm" Value="see GetRight, and SetRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Right" />
      <MemberSignature Language="VB.NET" Value="see GetRight, and SetRight" />
      <MemberSignature Language="F#" Value="see GetRight, and SetRight" Usage="see GetRight, and SetRight" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요소의 오른쪽과 부모 <see cref="T:System.Windows.Controls.InkCanvas" />의 오른쪽 사이의 거리를 가져오거나 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Right"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.RightProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
<a name="xamlAttributeUsage_Right"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object InkCanvas.Right="double"/>  
- or -  
<object InkCanvas.Right="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Right"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 문자열 표현 된 <xref:System.Double> 값입니다. 이것은 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다. 예를 들어 값 `1` 허용 됩니다.  
  
 *qualifiedDouble*  
 A *이중* 단위 선언 문자열 중 하나에서 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
   
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Label> 에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.RightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Right" /> 연결된 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>잉크 <see cref="T:System.Windows.Ink.Stroke" /> 개체 및/또는 <see cref="T:System.Windows.FrameworkElement" /> 개체의 집합을 선택합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 포함할 수 있습니다 <xref:System.Windows.Ink.Stroke> 사용자 스타일러스 입력에 대 한 응답으로 만들어지는 개체 및 <xref:System.Windows.FrameworkElement> 개체와 같은 <xref:System.Windows.Controls.Image> 및 <xref:System.Windows.Controls.Button> 개체입니다.  
  
 선택된 된 스트로크 인식 및 조작의 편의 위해 이들을 표시기를 사용 하 여 표시 됩니다. <xref:System.Windows.FrameworkElement> 개체 선택 하는 경우에 다르게 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select selectedElements" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedElements">선택할 <see cref="T:System.Windows.UIElement" /> 개체의 컬렉션입니다.</param>
        <summary><see cref="T:System.Windows.UIElement" /> 개체 집합을 선택합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 포함할 수 있습니다 <xref:System.Windows.Ink.Stroke> 사용자 스타일러스 입력에 대 한 응답에 생성 된 개체와 <xref:System.Windows.UIElement> 같은 개체 <xref:System.Windows.Controls.Image> 및 <xref:System.Windows.Controls.Button> 개체입니다.  
  
 선택된 된 스트로크 인식 및 조작의 편의 위해 이들을 표시기를 사용 하 여 표시 됩니다. <xref:System.Windows.UIElement> 개체 선택 하는 경우에 다르게 표시 되지 않습니다. 경우는 <xref:System.Windows.UIElement> 에 `selectedElements` 자식 컬렉션에 없는 <xref:System.Windows.Controls.InkCanvas.Select%2A> 무시는 <xref:System.Windows.UIElement>합니다.  
  
   
  
## Examples  
 다음 예에서는 select 모든 스트로크 및의 두 요소는 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 있다고 가정를 <xref:System.Windows.Controls.TextBox> 호출 `textbox1` 및 <xref:System.Windows.Controls.Button> 호출 `button1` -두 컨트롤의 자식 요소는 및를 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection -&gt; unit" Usage="inkCanvas.Select selectedStrokes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">선택할 <see cref="T:System.Windows.Ink.Stroke" /> 개체의 컬렉션입니다.</param>
        <summary>잉크 <see cref="T:System.Windows.Ink.Stroke" /> 개체 집합을 선택합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 포함할 수 있습니다 <xref:System.Windows.Ink.Stroke> 사용자 스타일러스 입력에 대 한 응답으로 만들어지는 개체 및 <xref:System.Windows.FrameworkElement> 개체와 같은 <xref:System.Windows.Controls.Image> 및 <xref:System.Windows.Controls.Button> 개체입니다.  
  
 선택된 된 스트로크 인식 및 조작의 편의 위해 이들을 표시기를 사용 하 여 표시 됩니다. <xref:System.Windows.FrameworkElement> 개체 선택 하는 경우에 다르게 표시 되지 않습니다.  
  
   
  
## Examples  
 다음 예에서는 select 모든 스트로크 및의 두 요소는 <xref:System.Windows.Controls.InkCanvas>합니다.  이 예제에서는 있다고 가정를 <xref:System.Windows.Controls.TextBox> 호출 `textbox1` 및 <xref:System.Windows.Controls.Button> 호출 `button1` -두 컨트롤의 자식 요소는 및를 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selectedStrokes" />의 스트로크 중 하나 이상이 <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> 속성에 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (System.Windows.Ink.StrokeCollection selectedStrokes, System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt; selectedElements);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(class System.Windows.Ink.StrokeCollection selectedStrokes, class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.UIElement&gt; selectedElements) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.Select(System.Windows.Ink.StrokeCollection,System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (selectedStrokes As StrokeCollection, selectedElements As IEnumerable(Of UIElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(System::Windows::Ink::StrokeCollection ^ selectedStrokes, System::Collections::Generic::IEnumerable&lt;System::Windows::UIElement ^&gt; ^ selectedElements);" />
      <MemberSignature Language="F#" Value="member this.Select : System.Windows.Ink.StrokeCollection * seq&lt;System.Windows.UIElement&gt; -&gt; unit" Usage="inkCanvas.Select (selectedStrokes, selectedElements)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectedStrokes" Type="System.Windows.Ink.StrokeCollection" />
        <Parameter Name="selectedElements" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.UIElement&gt;" />
      </Parameters>
      <Docs>
        <param name="selectedStrokes">선택할 <see cref="T:System.Windows.Ink.Stroke" /> 개체의 컬렉션입니다.</param>
        <param name="selectedElements">선택할 <see cref="T:System.Windows.UIElement" /> 개체의 컬렉션입니다.</param>
        <summary><see cref="T:System.Windows.Ink.Stroke" />와 <see cref="T:System.Windows.UIElement" /> 개체를 조합하여 선택합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 포함할 수 있습니다 <xref:System.Windows.Ink.Stroke> 사용자 스타일러스 입력에 대 한 응답에 생성 된 개체와 <xref:System.Windows.UIElement> 같은 개체 <xref:System.Windows.Controls.Image> 및 <xref:System.Windows.Controls.Button> 개체입니다.  
  
 선택된 된 스트로크 인식 및 조작의 편의 위해 이들을 표시기를 사용 하 여 표시 됩니다. <xref:System.Windows.UIElement> 개체 선택 하는 경우에 다르게 표시 되지 않습니다. 경우는 <xref:System.Windows.UIElement> 에 `selectedElements` 자식 컬렉션에 없는 <xref:System.Windows.Controls.InkCanvas.Select%2A> 무시는 <xref:System.Windows.UIElement>합니다.  
  
   
  
## Examples  
 다음 예에서는 select 모든 스트로크 및의 두 요소는 <xref:System.Windows.Controls.InkCanvas>합니다.  이 예제에서는 있다고 가정를 <xref:System.Windows.Controls.TextBox> 호출 `textbox1` 및 <xref:System.Windows.Controls.Button> 호출 `button1` -두 컨트롤의 자식 요소는 및를 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 [!code-csharp[InkCanvasSamples#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#2)]
 [!code-vb[InkCanvasSamples#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="selectedStrokes" />의 스트로크 중 하나 이상이 <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> 속성에 포함되어 있지 않은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />의 선택 영역이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 잉크 스트로크 및/또는 요소 집합이 선택 되 고 사용자가 적용 된 후에 발생 합니다.  
  
 대신 선택을 적용 되기 전에 잉크 스트로크 및/또는 요소 집합을 선택 하는 요청을 처리 해야, 하는 경우 이벤트 처리기를 추가 합니다 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> 이벤트입니다.  
  
   
  
## Examples  
 다음 예제에서는 원래 크기 보다 작게 선택 하지 못하도록 사용자를 방지 합니다.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionChangingEventHandler SelectionChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionChanging" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionChanging As InkCanvasSelectionChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionChangingEventHandler ^ SelectionChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " Usage="member this.SelectionChanging : System.Windows.Controls.InkCanvasSelectionChangingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>새 잉크 스트로크 및/또는 요소 집합이 선택될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> 변경 내용이 적용 되기 전에 하지만 사용자가 스트로크 및/또는 요소를 선택 하면 이벤트가 발생 합니다.  
  
 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> 이벤트가 처리 될 때 합니다 <xref:System.Windows.Controls.InkCanvasSelectionChangingEventHandler> 수신는 <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs> 개체입니다. <xref:System.Windows.Controls.InkCanvasSelectionChangingEventArgs> 에 액세스 하기 위한 메서드를 제공 <xref:System.Windows.FrameworkElement> 고 <xref:System.Windows.Ink.StrokeCollection> 사용자가 선택 된 개체입니다.  
  
 변경 내용을 적용 된 후의 <xref:System.Windows.Controls.InkCanvas.SelectionChanged> 이벤트가 발생 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Controls.InkCanvas.SelectionChanging> 때 또는 선택된 된 스트로크를 삭제할 때 이벤트가 발생 하지 않습니다는 <xref:System.Windows.Controls.InkCanvas.ActiveEditingMode%2A> 속성 변경 합니다.  
  
   
  
## Examples  
 다음 예에서는 선택된 된 스트로크 royal 파란색입니다.  
  
 [!code-csharp[InkCanvasSamples#14](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#14)]
 [!code-vb[InkCanvasSamples#14](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedElements" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedElements(System.Collections.Generic.IEnumerable{System.Windows.UIElement})" />
        <altmember cref="M:System.Windows.Controls.InkCanvasSelectionChangingEventArgs.SetSelectedStrokes(System.Windows.Ink.StrokeCollection)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoved">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionMoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoved As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionMoved;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoved : EventHandler " Usage="member this.SelectionMoved : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 스트로크 및/또는 요소 선택 영역을 이동한 후 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 스트로크 및/또는 요소 선택 영역 이동 하면서 새로운 위치를 기록 하는 스트로크 또는 요소의 하기 전에 데이터가 업데이트 되 면 발생 합니다. 이벤트 처리기를 추가 합니다 <xref:System.Windows.Controls.InkCanvas.SelectionMoving> 이벤트입니다.  
  
   
  
## Examples  
 다음 예제에서 항목을 선택 취소는 <xref:System.Windows.Controls.InkCanvas> 사용자 이동 후 합니다.  
  
 [!code-csharp[InkCanvasSamples#19](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#19)]
 [!code-vb[InkCanvasSamples#19](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionMoving">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionMoving" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionMoving" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionMoving As InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionMoving;" />
      <MemberSignature Language="F#" Value="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionMoving : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택된 스트로크 및 요소가 이동하기 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 사용자가 스트로크 및/또는 요소 선택, 이동 하도록 요청한 후 변경 내용이 적용 되기 전에 발생 합니다.  
  
 이벤트 처리기 형식의 인수를 받는 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs> 두 개의 속성이 있는: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> 및 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>합니다. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> 이동 하기 전에 선택 영역의 경계를 정의 하 고 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> 이동한 후 선택 항목의 경계를 정의 합니다.  
  
 변경 내용을 적용 된 후의 <xref:System.Windows.Controls.InkCanvas.SelectionMoved> 이벤트가 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자가 선택한 항목에 세로로 이동 수 없습니다는 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#13](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#13)]
 [!code-vb[InkCanvasSamples#13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionMoved" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResized">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResized" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionResized;" />
      <MemberSignature Language="F#" Value="member this.SelectionResized : EventHandler " Usage="member this.SelectionResized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 스트로크 및/또는 요소 선택 영역의 크기를 조정했을 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 다양 한 스트로크 및/또는 요소 크기를 조정 후 발생 합니다.  
  
 대신, 스트로크 및/또는 요소 크기가 조정 되기 전에 선택 영역 크기를 조정 하려면 요청을 처리 해야, 하는 경우 이벤트 처리기를 추가 합니다 <xref:System.Windows.Controls.InkCanvas.SelectionResizing> 이벤트입니다.  
  
   
  
## Examples  
 다음 예제에서 모든 항목을 선택 취소는 <xref:System.Windows.Controls.InkCanvas> 후 사용자는 선택 영역의 크기입니다.  
  
 [!code-csharp[InkCanvasSamples#23](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#23)]
 [!code-vb[InkCanvasSamples#23](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#23)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SelectionResizing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasSelectionEditingEventHandler SelectionResizing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.SelectionResizing" />
      <MemberSignature Language="VB.NET" Value="Public Event SelectionResizing As InkCanvasSelectionEditingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasSelectionEditingEventHandler ^ SelectionResizing;" />
      <MemberSignature Language="F#" Value="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " Usage="member this.SelectionResizing : System.Windows.Controls.InkCanvasSelectionEditingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasSelectionEditingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택된 스트로크 및 요소의 크기가 조정되기 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 사용자는 다양 한 스트로크 및/또는 요소 크기를 조정할 수를 요청한 후 변경 내용이 적용 되기 전에 발생 합니다.  
  
 이벤트 처리기 형식의 인수를 받는 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs> 두 속성을 포함 하는: <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> 고 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A>입니다. <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.OldRectangle%2A> 크기 조정 작업 전에 선택 영역의 경계를 정의 하 고 <xref:System.Windows.Controls.InkCanvasSelectionEditingEventArgs.NewRectangle%2A> 크기 조정 작업 후 선택 항목의 경계를 정의 합니다.  
  
 스트로크 및/또는 요소를 새 크기로 업데이트 한 후의 <xref:System.Windows.Controls.InkCanvas.SelectionResized> 이벤트가 발생 합니다.  
  
   
  
## Examples  
 다음 예제에서는 원래 크기 보다 작게 선택 하지 못하도록 사용자를 방지 합니다.  
  
 [!code-csharp[InkCanvasSamples#16](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#16)]
 [!code-vb[InkCanvasSamples#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Controls.InkCanvas.SelectionResized" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedStrokes" />
        <altmember cref="M:System.Windows.Controls.InkCanvas.GetSelectedElements" />
      </Docs>
    </Member>
    <Member MemberName="SetBottom">
      <MemberSignature Language="C#" Value="public static void SetBottom (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBottom(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetBottom(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBottom (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBottom(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetBottom : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetBottom (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Bottom 속성을 설정할 요소입니다.</param>
        <param name="length"><paramref name="element" />의 아래쪽 좌표입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Bottom" /> 속성 값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#28](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#28)]
 [!code-vb[InkCanvasSamples#28](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEnabledGestures">
      <MemberSignature Language="C#" Value="public void SetEnabledGestures (System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt; applicationGestures);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEnabledGestures(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Windows.Ink.ApplicationGesture&gt; applicationGestures) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetEnabledGestures(System.Collections.Generic.IEnumerable{System.Windows.Ink.ApplicationGesture})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEnabledGestures (applicationGestures As IEnumerable(Of ApplicationGesture))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEnabledGestures(System::Collections::Generic::IEnumerable&lt;System::Windows::Ink::ApplicationGesture&gt; ^ applicationGestures);" />
      <MemberSignature Language="F#" Value="member this.SetEnabledGestures : seq&lt;System.Windows.Ink.ApplicationGesture&gt; -&gt; unit" Usage="inkCanvas.SetEnabledGestures applicationGestures" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="applicationGestures" Type="System.Collections.Generic.IEnumerable&lt;System.Windows.Ink.ApplicationGesture&gt;" />
      </Parameters>
      <Docs>
        <param name="applicationGestures"><see cref="T:System.Windows.Controls.InkCanvas" />에서 인식되는 응용 프로그램 제스처의 컬렉션을 반환합니다.</param>
        <summary><see cref="T:System.Windows.Controls.InkCanvas" />에서 인식되는 응용 프로그램 제스처를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 예제에서는 설정 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.InkCanvas> 응용 프로그램 제스처를 인식 하도록 합니다.  
  
 [!code-csharp[GestureSample#3](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#3)]
 [!code-vb[GestureSample#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#3)]  
[!code-csharp[GestureSample#1](~/samples/snippets/csharp/VS_Snippets_Wpf/GestureSample/CSharp/Window1.xaml.cs#1)]
[!code-vb[GestureSample#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GestureSample/VisualBasic/Window1.xaml.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.InkCanvas.IsGestureRecognizerAvailable" /> 속성이 <see langword="false" />일 경우(이 속성은</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLeft">
      <MemberSignature Language="C#" Value="public static void SetLeft (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLeft(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetLeft(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLeft (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLeft(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetLeft : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetLeft (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Left 속성을 설정할 요소입니다.</param>
        <param name="length"><paramref name="element" />의 왼쪽 좌표입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Left" /> 속성 값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#29](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#29)]
 [!code-vb[InkCanvasSamples#29](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetRight">
      <MemberSignature Language="C#" Value="public static void SetRight (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetRight(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetRight(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetRight (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetRight(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetRight : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetRight (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Right 속성을 설정할 요소입니다.</param>
        <param name="length"><paramref name="element" />의 오른쪽 좌표입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Right" /> 속성 값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#30](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#30)]
 [!code-vb[InkCanvasSamples#30](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTop">
      <MemberSignature Language="C#" Value="public static void SetTop (System.Windows.UIElement element, double length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTop(class System.Windows.UIElement element, float64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.SetTop(System.Windows.UIElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTop (element As UIElement, length As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTop(System::Windows::UIElement ^ element, double length);" />
      <MemberSignature Language="F#" Value="static member SetTop : System.Windows.UIElement * double -&gt; unit" Usage="System.Windows.Controls.InkCanvas.SetTop (element, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.UIElement" />
        <Parameter Name="length" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Top 속성을 설정할 요소입니다.</param>
        <param name="length"><paramref name="element" />의 위쪽 좌표입니다.</param>
        <summary>지정된 종속성 개체에 연결된 <see cref="P:System.Windows.Controls.InkCanvas.Top" /> 속성 값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Button>합니다.  
  
 [!code-csharp[InkCanvasSamples#27](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#27)]
 [!code-vb[InkCanvasSamples#27](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeCollected">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeCollectedEventHandler StrokeCollected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeCollected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeCollected As InkCanvasStrokeCollectedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeCollectedEventHandler ^ StrokeCollected;" />
      <MemberSignature Language="F#" Value="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " Usage="member this.StrokeCollected : System.Windows.Controls.InkCanvasStrokeCollectedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeCollectedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 그린 스트로크가 <see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> 속성에 추가될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 사용자가 스트로크를 포인팅 장치를 사용 하 여 완료 되 면 발생 합니다. 예를 들어 사용자 발생할 디지타이저에서 스타일러스를 움직인 후 여 스트로크를 완료 합니다.  
  
 이벤트 처리기 형식의 인수를 받는 <xref:System.Windows.Controls.InkCanvasStrokeCollectedEventArgs>, 완료 된 스트로크를 참조 하는 합니다. 스트로크에도 추가 됩니다는 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas>입니다.  
  
 프로그래밍 방식으로 추가 <xref:System.Windows.Ink.Stroke> 개체는 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 컬렉션에이 이벤트가 발생 하지 않습니다.  
  
<a name="routedEventInfo_StrokeCollected"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.StrokeCollectedEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.InkCanvasStrokeCollectedEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 사용자가 스트로크를 추가 하는 경우 사용자 지정 속성으로 시간을 저장 합니다 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#22](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#22)]
 [!code-vb[InkCanvasSamples#22](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Ink.Stroke.AddPropertyData(System.Guid,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="StrokeCollectedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeCollectedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeCollectedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeCollectedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeCollectedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeCollectedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeCollectedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokeCollected" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErased">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler StrokeErased;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler StrokeErased" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErased" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StrokeErased As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ StrokeErased;" />
      <MemberSignature Language="F#" Value="member this.StrokeErased : System.Windows.RoutedEventHandler " Usage="member this.StrokeErased : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 스트로크를 지울 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 잉크를 여부를 지울 때이 이벤트가 발생 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 속성이 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> 또는 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke>합니다.  
  
<a name="routedEventInfo_StrokeErasing"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.StrokeErasedEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 에 있는 획 수를 보고 하는 다음 예제는 <xref:System.Windows.Controls.InkCanvas> 경우는 <xref:System.Windows.Controls.InkCanvas.StrokeErased> 이벤트가 발생 합니다. 하는 경우 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 로 설정 된 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint> 사용자의 스트로크를 획 수의 중간을 지우는 <xref:System.Windows.Controls.InkCanvas> 증가 합니다. 즉, 이전 스트로크 두 새 스트로크로 대체 되었습니다.  
  
 [!code-csharp[InkCanvasSamples#18](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#18)]
 [!code-vb[InkCanvasSamples#18](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StrokeErasedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StrokeErasedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokeErasedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StrokeErasedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokeErasedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.InkCanvas.StrokeErasedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.Controls.InkCanvas.StrokeErased" /> 라우트된 이벤트를 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokeErasing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokeErasingEventHandler StrokeErasing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokeErasing" />
      <MemberSignature Language="VB.NET" Value="Public Event StrokeErasing As InkCanvasStrokeErasingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokeErasingEventHandler ^ StrokeErasing;" />
      <MemberSignature Language="F#" Value="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " Usage="member this.StrokeErasing : System.Windows.Controls.InkCanvasStrokeErasingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokeErasingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 스트로크를 지우기 직전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 스트로크를 지워야 하는지 여부를 확인 하려는 경우이 이벤트를 처리 합니다. 설정 된 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성을 `true` 스트로크를 방지 하려는 경우. 이 기술을 사용할 수 있습니다 때 합니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 또는 <xref:System.Windows.Controls.InkCanvas.EditingModeInverted%2A> 속성이 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByStroke> 또는 <xref:System.Windows.Controls.InkCanvasEditingMode.EraseByPoint>합니다.  
  
   
  
## Examples  
 다음 예제를 형광펜으로 렌더링 된 모든 스트로크를 방지 합니다. 가정은 <xref:System.Windows.Controls.InkCanvas> 이벤트 처리기에 연결 됩니다.  
  
 [!code-csharp[DrawingAttributes#16](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingAttributes/CSharp/Window1.xaml.cs#16)]
 [!code-vb[DrawingAttributes#16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingAttributes/VisualBasic/Window1.xaml.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Strokes">
      <MemberSignature Language="C#" Value="public System.Windows.Ink.StrokeCollection Strokes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Ink.StrokeCollection Strokes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Strokes" />
      <MemberSignature Language="VB.NET" Value="Public Property Strokes As StrokeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Ink::StrokeCollection ^ Strokes { System::Windows::Ink::StrokeCollection ^ get(); void set(System::Windows::Ink::StrokeCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Strokes : System.Windows.Ink.StrokeCollection with get, set" Usage="System.Windows.Controls.InkCanvas.Strokes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Ink.StrokeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Ink.Stroke" />에서 수집한 잉크 <see cref="T:System.Windows.Controls.InkCanvas" /> 개체의 컬렉션을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Ink.Stroke" /> 내에 포함된 <see cref="T:System.Windows.Controls.InkCanvas" /> 개체의 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Strokes"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.StrokesProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 두 개 사용 하는 방법을 보여 줍니다 <xref:System.Windows.Ink.StrokeCollection> 동일한 개체 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 플레이어 1과 2는 각 플레이어 사용 하 여 개별 "잉크 화면" 동일한 공유 하는 경우에 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 클릭 이벤트를 이벤트 처리기에 연결 되어 있다고 가정 `switchPlayersButton_Click`합니다.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 다음 예제에서는 바인딩하는 방법을 보여는 <xref:System.Windows.Controls.InkCanvas.Strokes%2A> 의 속성을 <xref:System.Windows.Controls.InkCanvas> 다른 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-xaml[InkCanvasBindingSnippet#2](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasBindingSnippet/CS/Window2.xaml#2)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Ink.StrokeCollection" />
      </Docs>
    </Member>
    <Member MemberName="StrokesProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StrokesProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StrokesProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StrokesProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StrokesProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StrokesProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.StrokesProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StrokesReplaced">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.InkCanvasStrokesReplacedEventHandler StrokesReplaced" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.InkCanvas.StrokesReplaced" />
      <MemberSignature Language="VB.NET" Value="Public Event StrokesReplaced As InkCanvasStrokesReplacedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::InkCanvasStrokesReplacedEventHandler ^ StrokesReplaced;" />
      <MemberSignature Language="F#" Value="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " Usage="member this.StrokesReplaced : System.Windows.Controls.InkCanvasStrokesReplacedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.InkCanvasStrokesReplacedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Strokes" /> 속성이 바뀔 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 두 개 사용 하는 방법을 보여 줍니다 <xref:System.Windows.Ink.StrokeCollection> 동일한 배치 되는 개체 <xref:System.Windows.Controls.InkCanvas>합니다. 이 예제에서는 플레이어 1과 2는 각 플레이어 사용 하 여 개별 "잉크 화면" 동일한 공유 하는 경우에 <xref:System.Windows.Controls.InkCanvas>합니다. 이 가정은 `switchPlayersButton_Click` 이벤트를 이벤트 처리기를 연결할 합니다.  
  
 [!code-csharp[InkCanvasSamples#15](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#15)]
 [!code-vb[InkCanvasSamples#15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">추가할 자식 개체입니다.</param>
        <summary>지정된 개체를 <see cref="T:System.Windows.Controls.InkCanvas" />에 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.InkCanvas.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (textData As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ textData) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">사용되지 않습니다.</param>
        <summary>태그 안에 있는 텍스트를 추가합니다. 항상 <see cref="T:System.ArgumentException" />을 throw합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="see GetTop, and SetTop" />
      <MemberSignature Language="ILAsm" Value="see GetTop, and SetTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.Top" />
      <MemberSignature Language="VB.NET" Value="see GetTop, and SetTop" />
      <MemberSignature Language="F#" Value="see GetTop, and SetTop" Usage="see GetTop, and SetTop" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>요소의 위쪽과 부모 <see cref="T:System.Windows.Controls.InkCanvas" />의 위쪽 사이의 거리를 가져오거나 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Top"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.InkCanvas.TopProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
<a name="xamlAttributeUsage_Top"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object InkCanvas.Top="double"/>  
- or -  
<object InkCanvas.Top="qualifiedDouble"/>  
```  
  
<a name="xamlValues_Top"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 문자열 표현 된 <xref:System.Double> 값입니다. 이것은 [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] 측정 합니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다. 예를 들어 값 `1` 허용 됩니다.  
  
 *qualifiedDouble*  
 A *이중* 단위 선언 문자열 중 하나에서 다음 위에서 설명한 대로 값: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
   
  
## Examples  
 다음 예제에서는 위치를 설정 하는 방법에 설명 된 <xref:System.Windows.Controls.Label> 에 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-xml[InkCanvasSamples#35](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.InkCanvas.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.InkCanvas.Top" /> 연결된 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCustomCursor">
      <MemberSignature Language="C#" Value="public bool UseCustomCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCustomCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCustomCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCustomCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCustomCursor : bool with get, set" Usage="System.Windows.Controls.InkCanvas.UseCustomCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>표준 <see cref="T:System.Windows.Controls.InkCanvas" /> 커서 기능을 재정의하여 사용자 지정 커서를 지원할지 여부를 나타내는 부울 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.InkCanvas" />에서 사용자 지정 커서를 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.InkCanvas> 커서 스타일 현재 반영 하도록 변경 됩니다 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A> 범위 내에서 커서를 놓은 상태는 <xref:System.Windows.Controls.InkCanvas>합니다. 이 동작은 사용 하지 않으려는 예를 들어 경우 경우는 <xref:System.Windows.Controls.InkCanvas> 에서는 사용자 지정이이 속성을 설정 하는 커서 `true`, 커서를 사용 하 여 변경 되지 것입니다는 <xref:System.Windows.Controls.InkCanvas.EditingMode%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서 제공한 것과 다른 커서를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Controls.InkCanvas>합니다.  
  
 [!code-csharp[InkCanvasSamples#5](~/samples/snippets/csharp/VS_Snippets_Wpf/InkCanvasSamples/CSharp/Window1.xaml.cs#5)]
 [!code-vb[InkCanvasSamples#5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InkCanvasSamples/VisualBasic/Window1.xaml.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Controls.InkCanvas.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소 내 시각적 자식 요소의 수를 가져옵니다.</summary>
        <value>이 요소에 대한 시각적 자식 요소의 수입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      </Docs>
    </Member>
  </Members>
</Type>