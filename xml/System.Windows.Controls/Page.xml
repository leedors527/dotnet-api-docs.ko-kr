<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cd2891cbd86ebc1b55b87903c3857df573d8f1a6" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52612073" /></Metadata><TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows Internet Explorer, <see cref="T:System.Windows.Navigation.NavigationWindow" /> 및 <see cref="T:System.Windows.Controls.Frame" />에서 탐색 및 호스팅할 수 있는 콘텐츠 페이지를 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> 탐색 및 키 멤버는 콘텐츠 페이지를 캡슐화 합니다.  
  
-   **수명 관리**: <xref:System.Windows.Controls.Page.KeepAlive%2A>합니다.  
  
-   **탐색**: <xref:System.Windows.Controls.Page.NavigationService%2A>합니다.  
  
-   **모양을**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>를 <xref:System.Windows.Controls.Page.FontSize%2A>를 <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>를 <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>합니다.  
  
-   **호스트 창 모양**: <xref:System.Windows.Controls.Page.WindowHeight%2A>하십시오 <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>합니다.  
  
 태그, 태그 및 코드 숨김 또는 코드를 사용 하 여 페이지를 정의할 수 있습니다. 페이지는 다음과 같은 이유로 콘텐츠 탐색을 위한 기본 방법:  
  
-   정의 재사용 및 관리 하는 것이 쉽습니다.  
  
-   액세스 하 고 사용 된 <xref:System.Windows.Navigation.NavigationService> 탐색 하는 합니다.  
  
-   제목, 너비, 높이 및 탐색 바뀔 수 있습니다 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 해당 호스트 창의 (<xref:System.Windows.Controls.Page.WindowTitle%2A>를 <xref:System.Windows.Controls.Page.WindowWidth%2A>합니다 <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   에 디자이너 지원을 [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]합니다.  
  
 페이지를 호스팅할 수 있습니다 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, 또는 브라우저에서 합니다. 페이지는를 호스트할 수 있습니다.  
  
-   직계 자식이 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, 또는 <xref:System.Windows.Controls.Frame> 요소에 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]입니다.  
  
-   인스턴스화되고의 값으로 설정 합니다 `Content` 속성을 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, 및 <xref:System.Windows.Controls.Frame>합니다.  
  
-   로 설정 합니다 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 원인을 `Source` 속성에 대 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
-   로 설정 된 <xref:System.Windows.Application.StartupUri%2A> 독립 실행형 응용 프로그램에서.  
  
-   로 설정 합니다 <xref:System.Windows.Application.StartupUri%2A> 에 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]합니다.  
  
 응용 프로그램에는 일반적으로 다음과 같은 메커니즘을 사용 하 여 탐색할 수 있습니다 하는 두 개 이상의 페이지에 있습니다.  
  
-   사용 하 여 선언적으로 <xref:System.Windows.Documents.Hyperlink>입니다.  
  
-   사용 하 여 프로그래밍 방식으로 <xref:System.Windows.Navigation.NavigationService>입니다.  
  
-   탐색을 사용 하 여 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 포함 하 여 호스트의 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]를 <xref:System.Windows.Navigation.NavigationWindow>, 및 <xref:System.Windows.Controls.Frame>합니다.  
  
 페이지 함수를 사용 하 여 구조적된 탐색에 대 한 (<xref:System.Windows.Navigation.PageFunction%601>)를 참조 하세요 [구조적 탐색 개요](~/docs/framework/wpf/app-development/structured-navigation-overview.md) 하 고 [탐색 토폴로지 개요](~/docs/framework/wpf/app-development/navigation-topologies-overview.md)합니다.  
  
 이 컨트롤에 대 한 종속성 속성은 컨트롤의 기본 스타일으로 설정할 수 있습니다.  속성이 설정 된 기본 스타일을 컨트롤 응용 프로그램에 표시 되 면 속성 값이 기본값에서 변경 될 수 있습니다. 기본 스타일은 응용 프로그램 실행 중일 때 사용 되는 바탕 화면 테마에서 결정 됩니다.  자세한 내용은 [기본 WPF 테마](https://go.microsoft.com/fwlink/?LinkID=158252)합니다.  
  
   
  
## Examples  
 다음 예제에서는 표준 페이지 성은 태그를 사용 하 여 정의 합니다.  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 다음 예제에서는 표준 페이지를 사용 하 여 정의 하는 방법을 코드:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 다음 예제에서는 표준 페이지 성은 태그 및 코드 숨김의 조합을 사용 하 여 정의 합니다.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Controls.Page> 활성 상태로 유지 되지 않는 (참조 <xref:System.Windows.Controls.Page.KeepAlive%2A>)를 허용 하려면 기본 생성자를 구현 해야 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 에서 탐색할 때의 새 인스턴스를 만들거나 전방 탐색 기록 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">자식 요소를 정렬하는 데 사용할 크기입니다.</param>
        <summary><see cref="T:System.Windows.Controls.Page" />의 내용(자식 요소)을 정렬합니다.</summary>
        <returns>페이지의 정렬된 크기를 나타내는 <see cref="T:System.Windows.Size" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 배경을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Media.Brush" />에서 배경을 칠하는 데 사용하는 <see cref="T:System.Windows.Controls.Page" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Background" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 내용을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" />의 내용이 들어 있는 개체입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> 단일 자식 요소만 있을 수 있습니다. 다른 모든 요소는 <xref:System.Windows.Controls.Page> 해당 요소의 하위 항목 이어야 합니다. 일반적으로의 콘텐츠를 <xref:System.Windows.Controls.Page> 레이아웃 요소를 호스팅합니다-와 같은 <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, 및 <xref:System.Windows.Controls.DockPanel>-의 콘텐츠를 호스팅하는 <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.ContentProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Content" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>지정된 글꼴 패밀리의 이름을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Media.FontFamily" />의 내용에 대한 글꼴 패밀리인 <see cref="T:System.Windows.Controls.Page" />입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.FontFamily" /> 종속성 속성을 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontFamily%2A> 종속성 속성의 식별자입니다.  
  
   
  
## Examples  
 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글꼴 크기를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> 내용의 글꼴 크기입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontSize" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 글꼴 크기와 범위에는 양수 여야 합니다.는 <xref:System.Windows.SystemFonts.MessageFontSize%2A>합니다.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.FontSize" /> 종속성 속성을 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontSize%2A> 종속성 속성의 식별자입니다.  
  
   
  
## Examples  
 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 전경을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Media.Brush" />에서 전경을 칠하는 데 사용하는 <see cref="T:System.Windows.Controls.Page" />입니다. 기본값은 <see cref="P:System.Windows.Media.Brushes.Black" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Foreground" /> 종속성 속성을 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Foreground%2A> 종속성 속성의 식별자입니다.  
  
   
  
## Examples  
 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" /> 인스턴스가 탐색 기록에 유지되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> 인스턴스가 탐색 기록에 유지되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 페이지는 먼저 탐색 하는 경우,의 새 인스턴스를 <xref:System.Windows.Controls.Page> 클래스가 만들어집니다. (뒤로 또는 앞으로)에서 페이지를 탐색, 페이지에 대 한 항목 탐색 기록에 추가 됩니다. 기본적으로 항목에는 페이지 개체를 참조 하지 않습니다. 대신, 항목 페이지에 대 한 팩 uniform resource identifier (URI)를 포함합니다. 페이지에 대 한 항목을 탐색 기록을 사용 하 여 탐색 하면 경우 pack URI는 페이지의 새 인스턴스를 만드는 사용 됩니다. 이 동작은 과도 한 메모리 사용을 방지 하려면 기본값: 중요 한 양의 콘텐츠를 사용 하 여 특히 메모리를 신속 하 게 이용 페이지 인스턴스를 유지 합니다. 이 문제는 뒤에 저장할 수 있는 항목의 수를 앞으로 탐색 기록 스택을 제한이 팩트에서 보강 됩니다. 반면, 페이지에 대 한 pack Uri를 저장 하기에 거의 영향을 주지 않습니다 메모리 소비  
  
 주요 영향을 주는 페이지의 새 인스턴스를 만드는 다른 페이지 상태 페이지의 한 인스턴스에서 기억 하지 않은 경우 이러한 경우 Windows Presentation Foundation은 상태를 기억 하기 위해 다양 한 기술을 제공 합니다.  
  
 설정 페이지를 유지 하는 <xref:System.Windows.Controls.Page.KeepAlive%2A> 속성을 `true` (기본값은 `false`).  
  
> [!NOTE]
>  페이지를 인스턴스화하고 코드만 사용 하 여 탐색 하는 (예를 들어 호출 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>)를 자동으로 유지 됩니다.  
  
 설정 하지 말아야 <xref:System.Windows.Controls.Page.KeepAlive%2A> 에 `true` 필요가 없으면:  
  
-   페이지에 콘텐츠가 많은 경우 인스턴스화하는 데 시간이 오래 걸릴 수 있습니다. 페이지는 활성 상태로 유지 합니다. 페이지를 자주 탐색 하 고 비용을 지속적으로 페이지를 인스턴스화하고 사용자 경험에 저하가 될 수 있습니다. 그러나 성능 측면에서 기본 설정을 사용 하 고 해야 응용 프로그램의 성능을 프로 파일링 테스트 페이지 로드 시간과 응용 프로그램에 필요한 범위를 벗어나는 것을 식별 하는 경우 페이지를 활성 상태로 유지 하도록 구성 문제를 해결 하는 한 가지 방법은 수 있습니다.  
  
> [!NOTE]
>  활성 상태로 유지 되는 페이지에 대 한 항목의 탐색 기록에서 유지 되지 않습니다는 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 사용자에서 다른 위치로 이동 하는 경우, 다시로 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]합니다. 활성 상태로 유지 되는 페이지의 저널 항목만 탐색 기록에 유지 됩니다.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
> [!NOTE]
>  이 종속성 속성의 메타 데이터 유형이 <xref:System.Windows.PropertyMetadata>이 아니라 <xref:System.Windows.FrameworkPropertyMetadata>합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 의 인스턴스를 보유 하는 <xref:System.Windows.Controls.Page> 여러 탐색 간에 클래스입니다.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeepAliveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.KeepAlive" /> 종속성 속성을 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.KeepAlive%2A> 종속성 속성의 식별자입니다.  
  
   
  
## Examples  
 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 논리적 자식 요소에 대한 열거자를 반환합니다.</summary>
        <value><see cref="T:System.Collections.IEnumerator" />의 논리적 자식 요소에 대한 <see cref="T:System.Windows.Controls.Page" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">창에서 자식 요소에 할당할 수 있는 여유 공간입니다.</param>
        <summary><see cref="T:System.Windows.Controls.Page" />의 자식 요소를 측정합니다.</summary>
        <returns>창의 실제 크기인 <see cref="T:System.Windows.Size" />입니다. 실제 크기보다 큰 값이 반환될 수 있으며, 이러한 경우 부모에서 스크롤 막대를 추가해야 합니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NavigationService : System.Windows.Navigation.NavigationService" Usage="System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지의 호스트가 탐색을 관리하는 데 사용하는 탐색 서비스를 가져옵니다.</summary>
        <value>페이지의 호스트가 탐색을 관리하는 데 사용하는 <see cref="T:System.Windows.Navigation.NavigationService" /> 개체이거나, 호스트가 탐색을 지원하지 않으면 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 유형의 호스트를 포함 하 여 페이지를 호스팅할 수 있습니다 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, 브라우저 및 합니다.  
  
 페이지에서 페이지 탐색 지원을 제공 하기 위해 해당 호스트의 탐색을 사용 하 여 통합 해야 합니다. 그러나 페이지 런타임에 될 하는 호스트를 모를 수 때문에 이렇게 하려면 해당 호스트의 탐색 멤버와 직접 통합할 수 없습니다.  
  
 대신, 브라우저 스타일 탐색을 지 원하는 캡슐화 하는 서비스는 탐색 서비스를 사용 하도록 시도할 수 있습니다는 <xref:System.Windows.Navigation.NavigationService> 클래스입니다. 직접 만들 수 없습니다 <xref:System.Windows.Navigation.NavigationService> 인스턴스를 통해. 대신 형식을 같은 호스트 <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>를 만들거나 브라우저 자체 <xref:System.Windows.Navigation.NavigationService> 에서 액세스할 수 있는 인스턴스는 <xref:System.Windows.Controls.Page.NavigationService%2A> 속성.  
  
 반환 되는 탐색 서비스를 <xref:System.Windows.Controls.Page.NavigationService%2A> 속성은의 인스턴스는 <xref:System.Windows.Navigation.NavigationService> 시각적 트리를 구성 하는 첫 번째 탐색기가 관리 되는 클래스입니다. 하나는 없는 경우 `null` 페이지의 호스트가 탐색을 지원 하지 않음을 나타내는 반환 됩니다.  
  
> [!NOTE]
>  <xref:System.Windows.Window> 클래스 탐색을 지원 하지 않으며 탐색 서비스를 제공 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 방법을 보여 줍니다 페이지 수는 탐색 서비스를 사용할 수 있는지 확인, 따라서를 사용 하 여 이전 페이지로 돌아갑니다.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit&#xA;override this.OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit" Usage="page.OnTemplateChanged (oldTemplate, newTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">이전 템플릿입니다.</param>
        <param name="newTemplate">새 템플릿입니다.</param>
        <summary><see cref="T:System.Windows.Controls.Page" />의 템플릿이 변경될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="page.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">이전 부모입니다. <see cref="T:System.Windows.DependencyObject" />에 이전 부모가 없는 경우 <see langword="null" />로 설정됩니다.</param>
        <summary><see cref="T:System.Windows.Controls.Page" />의 부모가 변경될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">새 부모가 <see cref="T:System.Windows.Window" /> 또는 <see cref="T:System.Windows.Controls.Frame" />이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeShowsNavigationUI : unit -&gt; bool" Usage="page.ShouldSerializeShowsNavigationUI " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> 속성의 serialization 동작을 결정할 수 있습니다.</summary>
        <returns>콘텐츠를 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTitle : unit -&gt; bool" Usage="page.ShouldSerializeTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 <see cref="P:System.Windows.Controls.Page.Title" /> 속성의 serialization 동작을 결정할 수 있습니다.</summary>
        <returns>콘텐츠를 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowHeight : unit -&gt; bool" Usage="page.ShouldSerializeWindowHeight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 <see cref="P:System.Windows.Controls.Page.WindowHeight" /> 속성의 serialization 동작을 결정할 수 있습니다.</summary>
        <returns>콘텐츠를 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowTitle : unit -&gt; bool" Usage="page.ShouldSerializeWindowTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 <see cref="P:System.Windows.Controls.Page.WindowTitle" /> 속성의 serialization 동작을 결정할 수 있습니다.</summary>
        <returns>콘텐츠를 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowWidth : unit -&gt; bool" Usage="page.ShouldSerializeWindowWidth " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 <see cref="P:System.Windows.Controls.Page.WindowWidth" /> 속성의 serialization 동작을 결정할 수 있습니다.</summary>
        <returns>콘텐츠를 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowsNavigationUI : bool with get, set" Usage="System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)]에서 <see cref="T:System.Windows.Navigation.NavigationWindow" />의 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]가 표시되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>호스트 <see cref="T:System.Windows.Navigation.NavigationWindow" />의 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]가 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> 탐색 표시 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 가능 하도록 기본적으로 브라우저 스타일 앞으로 및 뒤로 탐색 합니다. 페이지도 설정 된 경우는 <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> 자동으로 열립니다는 <xref:System.Windows.Navigation.NavigationWindow> 에서 페이지를 호스팅합니다. 페이지에 기본값을 사용 하지 않을 경우 <xref:System.Windows.Navigation.NavigationWindow> 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]를 설정할 수 있습니다 <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> 하려면 `false`합니다.  
  
> [!NOTE]
>  때문에 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 탐색을 통합 하지 않습니다 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 에 대 한 [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], 자체적으로 탐색을 쉽게 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]를 표시 하거나 설정 하 여 숨길 수 있는 <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>합니다. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 에 통합 합니다 [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]따라서 설정 <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> 페이지에서 [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] 영향을 주지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 탐색을 숨기려면 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 의 한 <xref:System.Windows.Navigation.NavigationWindow>합니다.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />, <see cref="T:System.Windows.Controls.Page" /> 또는 브라우저에서 호스팅하지 않는 <see cref="T:System.Windows.Window" /> 인스턴스의 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 속성을 검사한 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">추가할 자식 개체입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Controls.Page> 인스턴스가 <xref:System.Windows.Markup.IAddChild> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">개체에 추가할 텍스트입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />를 참조하세요.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Controls.Page> 인스턴스가 <xref:System.Windows.Markup.IAddChild> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Template : System.Windows.Controls.ControlTemplate with get, set" Usage="System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 컨트롤 템플릿을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.ControlTemplate" />의 <see cref="T:System.Windows.Controls.Page" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>XAML 값  
 *resourceExtension*  
 템플릿 리소스를 하거나 참조 하는 방법을 식별 하는 태그 확장 `StaticResource` 또는 `DynamicResource`합니다. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *styleResourceKey*  
 요청된 된 템플릿 선택기를 식별 하는 키입니다. 키의 기존 리소스에 참조를 <xref:System.Windows.ResourceDictionary>입니다.  
  
> [!NOTE]
>  속성 요소 구문은 기술적으로 가능 하지만 권장 하지는 않습니다. 자세한 내용은 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Template" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Page" />의 제목을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" />의 제목입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Windows.Controls.Page.Title%2A> 속성으로 표시 되지 않습니다 <xref:System.Windows.Controls.Page>를 호스팅하는 창의 제목 표시줄에서 표시 되 지도 않습니다를 <xref:System.Windows.Controls.Page>입니다. 설정 하는 대신 <xref:System.Windows.Controls.Page.WindowTitle%2A> 호스트 창 제목을 변경 하려면.  
  
 <xref:System.Windows.Controls.Page.Title%2A> 탐색할된 콘텐츠 조각에 대 한 탐색 기록 항목의 이름을 생성 하도 사용할 수 있습니다. 다음 데이터 조각은 자동으로 우선 순위에 따라에서 탐색 기록 항목 이름, 생성 하는 데 사용 됩니다.  
  
-   연결 된 <xref:System.Windows.Navigation.JournalEntry.Name%2A> 특성입니다.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> 속성  
  
-   합니다 <xref:System.Windows.Controls.Page.WindowTitle%2A> 속성 및 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 현재 페이지  
  
-   현재 페이지에 대한 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.  
  
 연결한 경우는 <xref:System.Windows.Navigation.CustomContentState> 개체 탐색 기록의 콘텐츠에 부분을 지정할 수 있습니다 표시 되는 이름을 탐색 기록 항목에 재정의 하 여 <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>입니다.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Controls.Page.TitleProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Controls.Page.Title" /> 종속성 속성을 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Title%2A> 종속성 속성의 식별자입니다.  
  
   
  
## Examples  
 [종속성 속성 개요](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : double with get, set" Usage="System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" />의 호스트 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 또는 <see cref="T:System.Windows.Controls.Page" />의 높이를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" />를 직접 호스팅하는 창의 높이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> 때만 적용 되는 <xref:System.Windows.Controls.Page> 포함 하는 창에서 직접 호스트:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 경우는 <xref:System.Windows.Controls.Page> 에서 호스트 되는 <xref:System.Windows.Controls.Frame>설정 <xref:System.Windows.Controls.Page.WindowHeight%2A> 아무 효과가 있지만의 값을 여전히 가져올 수 있습니다 <xref:System.Windows.Controls.Page.WindowHeight%2A>합니다.  
  
 A <xref:System.Windows.Controls.Page> 에 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 형식만 사용할 수 있습니다 <xref:System.Windows.Controls.Page.WindowHeight%2A> 의 높이 변경 하려면 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; 높이 설정 하 여 변경할 수 없습니다 <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, 또는 <xref:System.Windows.FrameworkElement.MaxHeight%2A>합니다.  
  
 최소 높이 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] 기간은 150 픽셀입니다. 브라우저에 호스팅된 페이지, 즉 값 <xref:System.Windows.Controls.Page.WindowHeight%2A> 의 전체 높이 않을 경우 적용 될 수 있습니다는 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] 창이 미만인 150 픽셀입니다.  
  
   
  
## Examples  
 다음 예제에서는 페이지에서 창 높이 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTitle : string with get, set" Usage="System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" />의 호스트 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 또는 <see cref="T:System.Windows.Controls.Page" />의 제목을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" />를 직접 호스팅하는 창의 제목입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 페이지를 호스팅하는 창의 제목 포함 <xref:System.Windows.Navigation.NavigationWindow> 및 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], 현재 호스팅되는 파일의 이름입니다 (페이지가 느슨한 이면.xaml 확장명이 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], 또는 페이지를 일부인경우.xbap확장명[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 페이지를 설정 하 여 기본값을 변경할 수는 <xref:System.Windows.Controls.Page.WindowTitle%2A> 속성입니다.  
  
 창의 제목이 다른 페이지 설정 될 때까지 변경 되지 않습니다 이런에서 창의 제목을 설정 하는 페이지, <xref:System.Windows.Controls.Page.WindowTitle%2A> 다른 값으로.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Page> 맨 위에 있는 부분에 대 한 창에서 콘텐츠 여야 합니다 <xref:System.Windows.Controls.Page.WindowTitle%2A> 경우에 의미를 <xref:System.Windows.Controls.Page> 내에서 호스팅됩니다를 <xref:System.Windows.Controls.Frame>, 예를 들어 설정 <xref:System.Windows.Controls.Page.WindowTitle%2A> 호스트 창 제목을 변경 하지 않습니다.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> 탐색할된 콘텐츠 조각에 대 한 탐색 기록 항목의 이름을 생성 하도 사용할 수 있습니다. 다음 데이터 조각은 자동으로 우선 순위에 따라에서 탐색 기록 항목 이름, 생성 하는 데 사용 됩니다.  
  
-   연결 된 <xref:System.Windows.Navigation.JournalEntry.Name%2A> 특성입니다.  
  
-   <xref:System.Windows.Controls.Page.Title%2A> 속성  
  
-   합니다 <xref:System.Windows.Controls.Page.WindowTitle%2A> 속성 및 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 현재 페이지  
  
-   현재 페이지에 대한 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]입니다.  
  
 연결한 경우는 <xref:System.Windows.Navigation.CustomContentState> 개체를 탐색 기록의 콘텐츠에 부분을 사용 하 여 재정의 하 여 탐색 기록 요소의 이름 값을 지정할 수 있습니다 <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 페이지에서 창 제목 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : double with get, set" Usage="System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" />의 호스트 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 또는 <see cref="T:System.Windows.Controls.Page" />의 너비를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Page" />를 직접 호스팅하는 창의 너비입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> 때만 적용 되는 <xref:System.Windows.Controls.Page> 포함 하는 창에서 직접 호스트:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 경우는 <xref:System.Windows.Controls.Page> 에서 호스트 되는 <xref:System.Windows.Controls.Frame>설정 <xref:System.Windows.Controls.Page.WindowWidth%2A> 아무 효과가 있지만의 값을 여전히 가져올 수 있습니다 <xref:System.Windows.Controls.Page.WindowWidth%2A>합니다.  
  
 A <xref:System.Windows.Controls.Page> 에 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] 형식만 사용할 수 있습니다 <xref:System.Windows.Controls.Page.WindowWidth%2A> 의 너비를 변경 하려면 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; 너비를 설정 하 여 변경할 수 없습니다 <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, 또는 <xref:System.Windows.FrameworkElement.MaxWidth%2A>합니다.  
  
 최소 너비는 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] 기간은 250 픽셀입니다. 브라우저에 호스팅된 페이지, 즉 값 <xref:System.Windows.Controls.Page.WindowWidth%2A> 의 전체 너비 않을 경우 적용 될 수 있습니다는 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] 창 250 명 미만인 픽셀 이어야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 페이지에서 창 너비를 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>