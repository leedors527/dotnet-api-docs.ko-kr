<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30b353139e00ffa86a542c259a68250718297ece" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30631397" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>편집 관련 명령의 표준 집합을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 표에서 편집 명령 및 연결 된 기본 키 제스처 (키 이름으로는 <xref:System.Windows.Input.Key> 및 <xref:System.Windows.Input.ModifierKeys> 열거형)입니다.  
  
|편집 명령|기본 키 제스처|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|기본 키 제스처 없음|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|기본 키 제스처 없음|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 캐럿 이동 명령 및 선택 영역 확장 명령을 기본 키 제스처는 공통 집합이 추가 되 고 일반 차이 공유는 <xref:System.Windows.Input.ModifierKeys.Shift> 키 선택 명령 캐럿 이동 명령을 구분 합니다.  예를 들어는 <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> 명령에는 기본 키 제스처는 <xref:System.Windows.Input.Key.Left>, 해당 <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> 명령에는 기본 키 제스처는 <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>합니다.  
  
 명령 정의에서 제공 하는 일반적으로 <xref:System.Windows.Documents.EditingCommands> 클래스를 만들지 마십시오 명령 매개 변수 사용 (의 `parameter` 에서 예상 되는 매개 변수는 <xref:System.Windows.Input.ICommand.Execute%2A> 메서드).  
  
 명령 및 명령 실행에 대 한 자세한 내용은 참조 하십시오. [입력 개요](~/docs/framework/wpf/advanced/input-overview.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 단락이나 단락의 선택 영역이 가운데 놓이도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="E" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 효과 선택 영역에 참여 하는 각 단락의 전체 내용을에 적용 됩니다.  
  
 다음 그림에는 가운데 맞춤 된 콘텐츠의 예가 나와 있습니다.  
  
 ![스크린 샷: Center의 TextAlign 속성 값](~/add/media/flowdoc-textalign-center.png "스크린 샷: Center의 TextAlign 속성 값")  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 단락이나 단락의 선택 영역이 양쪽 맞춤되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="J" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 선택 영역의 모든 단락에는 효과가 적용 됩니다.  
  
 콘텐츠를 맞출는 정렬 된 줄은 동일 하거나 거의 같도록 너비의 되도록 각 내용 줄 내에서 가로 간격 조정 됩니다.  콘텐츠는 일반적으로 부드러운 가장자리 콘텐츠의 양쪽에서 만들려는 양쪽 맞춤 됩니다.  
  
 나머지 보다 짧은 종종 이기 때문에이 명령이 호출 된 후 단락의 마지막 줄에서는 양쪽 맞춤 되지 않고 남아 있을 수 있습니다.  
  
 다음 그림에서는 양쪽 맞춤 되지 않은 (왼쪽 맞춤) 콘텐츠를 보여 줍니다.  
  
 ![스크린 샷: 콘텐츠를 정렬 된](~/add/media/content-unjustified.png "스크린 샷: 콘텐츠 맞춤으로 정렬 됩니다.")  
  
 다음 그림에서는 양쪽 맞춤 된 후 동일한 콘텐츠를 보여 줍니다.  
  
 ![콘텐츠의 스크린 샷 텍스트 맞춤](~/add/media/content-justified.png "콘텐츠의 스크린 샷 텍스트 맞춤")  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠의 선택 영역을 왼쪽에 맞추도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="L" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 효과 선택 영역에 참여 하는 각 단락의 전체 내용을에 적용 됩니다.  
  
 다음 그림에는 왼쪽 맞춤 콘텐츠의 예가 나와 있습니다.  
  
 ![스크린 샷: Left의 TextAlign 속성 값](~/add/media/flowdoc-textalign-left.png "스크린 샷: Left의 TextAlign 속성 값")  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠의 선택 영역을 오른쪽에 맞추도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="R" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 효과 선택 영역에 참여 하는 각 단락의 전체 내용을에 적용 됩니다.  
  
 다음 그림의 오른쪽에 맞추어져 콘텐츠 예를 보여 줍니다.  
  
 ![스크린 샷: Right의 TextAlign 값](~/add/media/flowdoc-textalign-right.png "스크린 샷: Right의 TextAlign 값")  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치나 현재 선택 영역에 백스페이스가 입력되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Backspace" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 선택 영역에 호출 되 면이 명령은 캐럿 바로 앞의 문자 또는 단락 구분 기호를 삭제 합니다. 비어 있지 않은 선택에 호출 되 면 선택 항목을 삭제이 합니다.  
  
 이 명령은 즉시이 명령이 호출 된 후 동일한 위치에 삽입 된 내용에 대 한 삭제 된 선택의 서식을 유지 합니다.  와 대비는 <xref:System.Windows.Documents.EditingCommands.Delete%2A> 이전 서식 유지 되지 않는 명령입니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치에서 철자가 잘못된 단어를 수정하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에는 기본 키 제스처가 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역의 글꼴 크기가 1포인트씩 감소하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 단어 안에 캐럿이 있는 빈 선택 영역에서 호출 되 면 선택 영역 전체 단어에 명령을 적용 하도록 자동으로 확장 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 단락의 들여쓰기가 탭 정지 하나만큼씩 감소하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
> [!IMPORTANT]
>  이 명령은 하지 않는 한 텍스트 요소에 영향을 주지는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> 텍스트 요소의 속성이로 설정 되어 `true`합니다.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역을 삭제하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Delete" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 삭제 된 선택 영역 서식을 삭제 합니다.  와 대비는 <xref:System.Windows.Documents.EditingCommands.Backspace%2A> 명령을 즉시이 명령이 호출 된 후 동일한 위치에 삽입 된 콘텐츠에 대 한 삭제 선택 영역의 서식을 유지 하 합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치를 기준으로 다음 단어를 삭제하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Delete" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단어 안에 포함 된 경우 현재 위치와 단어의 끝 사이의 단어의 나머지 부분에서는 삭제 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치를 기준으로 이전 단어를 삭제하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Backspace" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단어 안에 포함 된 경우 현재 위치와 해당 단어의 시작 부분 사이의 단어의 나머지 부분에서는 삭제 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치나 현재 선택 영역 위에 줄 바꿈을 삽입하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Enter" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 같은 유동 콘텐츠를 지 원하는 편집기에 대 한 <xref:System.Windows.Controls.RichTextBox>,이 명령을 실행 하면 한 <xref:System.Windows.Documents.LineBreak> 현재 위치에 삽입할 요소입니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치나 현재 선택 영역 위에 단락 나누기를 삽입하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Enter" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 ENTER 키를 사용자에 게는 것과 같습니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox> (때는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> 속성은 `true`).  
  
> [!IMPORTANT]
>  이 명령은 하지 않는 한 텍스트 요소에 영향을 주지는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> 텍스트 요소의 속성이로 설정 되어 `true`합니다.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 위치나 현재 선택 영역에 있는 철자가 잘못된 단어의 인스턴스가 무시되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에는 기본 키 제스처가 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역의 글꼴 크기가 1포인트씩 증가하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단어 안에 캐럿이 있는 빈 선택 영역에서이 명령을 호출 하는 경우에 전체 단어에 명령을 적용 하도록 선택 영역 확장 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 단락의 들여쓰기가 탭 정지 하나만큼씩 증가하도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="T" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
> [!IMPORTANT]
>  이 명령은 하지 않는 한 텍스트 요소에 영향을 주지는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> 텍스트 요소의 속성이로 설정 되어 `true`합니다.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 줄씩 아래로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Down" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 페이지씩 아래로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="PageDown" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 단락씩 아래로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Down" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 다음 단락 시작 부분에 캐럿을 배치합니다.  
  
 이 명령은 처럼 동작 <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> 에서 호출 될 때는 <xref:System.Windows.Controls.TextBox>합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 문자씩 왼쪽으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Left" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 단어씩 왼쪽으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Left" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단어 안에 포함 된 경우이 명령은 해당 단어의 시작 부분에 캐럿을 이동 합니다.  그렇지 않으면이 명령은 이전 단어의 시작 부분에 캐럿을 이동합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 문자씩 오른쪽으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Right" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 단어씩 오른쪽으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Right" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단어 안에 포함 된 경우이 명령은 해당 단어의 끝에 캐럿을 이동 합니다.  그렇지 않으면이 명령은 다음 단어의 시작 부분에 캐럿을 이동합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 콘텐츠의 맨 끝 부분으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="End" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *텍스트 컨테이너* 중인 콘텐츠에 대 한 궁극적인 테두리를 구성 하는 요소가 있습니다.  <xref:System.Windows.Controls.TextBlock> 및 <xref:System.Windows.Documents.FlowDocument> 은 텍스트 컨테이너의 예입니다.  텍스트 컨테이너 내에서 전체적으로 포함 된 내용은 라고는 *문서*합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 콘텐츠의 맨 처음 부분으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Home" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *텍스트 컨테이너* 중인 콘텐츠에 대 한 궁극적인 테두리를 구성 하는 요소가 있습니다.  <xref:System.Windows.Controls.TextBlock> 및 <xref:System.Windows.Documents.FlowDocument> 은 텍스트 컨테이너의 예입니다.  텍스트 컨테이너 내에서 전체적으로 포함 된 내용은 라고는 *문서*합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 현재 줄의 맨 끝 부분으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="End" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 현재 줄의 맨 처음 부분으로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Home" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 줄씩 위로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Up" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 페이지씩 위로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="PageUp" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>캐럿이 한 단락씩 위로 이동되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Up" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 다음 단락 시작 부분에 캐럿을 배치합니다.  
  
 이 명령은 처럼 동작 <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> 에서 호출 될 때는 <xref:System.Windows.Controls.TextBox>합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox>합니다.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 줄씩 아래로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Down" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 페이지씩 아래로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="PageDown" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 단락씩 아래로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은 다음 단락 시작 부분으로 선택 영역을 확장 합니다.  그렇지 않으면이 명령은 현재 단락의 끝에 선택 영역을 확장 합니다.  확장된 선택 영역 단락의 끝을 표시 하는 단락 나누기를 포함 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 문자씩 왼쪽으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Left" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 단어씩 왼쪽으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단어 내에 있으면이 명령은 해당 단어의 시작 부분에는 선택 영역을 확장 합니다.  그렇지 않으면이 명령은 이전 단어의 시작 부분에는 선택 영역을 확장 합니다.  
  
 확장된 선택 영역에는 단어 구분 기호가 포함 되지 않습니다.  와 대비 <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, 하는 확장된 된 선택 영역에서 단어 구분 기호 포함 합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 문자씩 오른쪽으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Right" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 단어씩 오른쪽으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가 단어 안에서 캐럿이 있는 경우이 명령은 해당 단어의 끝에 선택 영역을 확장 합니다.  그렇지 않으면이 명령은 다음 단어의 끝에 선택 영역을 확장 합니다.  
  
 확장된 선택 영역 단어 구분 기호를 포함 합니다.  와 대비 <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> 확장된 선택 영역에 단어 구분 기호를 포함 하지 않는 합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 콘텐츠의 맨 끝으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *텍스트 컨테이너* 중인 콘텐츠에 대 한 궁극적인 테두리를 구성 하는 요소가 있습니다.  <xref:System.Windows.Controls.TextBlock> 및 <xref:System.Windows.Documents.FlowDocument> 은 텍스트 컨테이너의 예입니다.  텍스트 컨테이너 내에서 전체적으로 포함 된 내용은 라고는 *문서*합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 콘텐츠의 맨 처음으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *텍스트 컨테이너* 중인 콘텐츠에 대 한 궁극적인 테두리를 구성 하는 요소가 있습니다.  <xref:System.Windows.Controls.TextBlock> 및 <xref:System.Windows.Documents.FlowDocument> 은 텍스트 컨테이너의 예입니다.  텍스트 컨테이너 내에서 전체적으로 포함 된 내용은 라고는 *문서*합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 현재 줄의 끝 부분으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="End" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 현재 줄의 시작 부분으로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Home" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 줄씩 위로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Up" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 페이지씩 위로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="PageUp" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역이 한 단락씩 위로 확장되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 캐럿 단락 시작 부분에 있는 경우이 명령은 이전 단락의 시작 부분에는 선택 영역을 확장 합니다.  그렇지 않으면이 명령은 현재 단락의 시작 부분에는 선택 영역을 확장 합니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Shift" /> + <see langword="Tab" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령에 대 한 동작은 현재 선택한 내용에 따라 달라 집니다. 선택 영역이 비어 있지 않은 경우이 명령은 같습니다 <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>합니다. 캐럿 표 셀에 있으면 (나타내는 <xref:System.Windows.Documents.TableCell> 요소),이 명령은 캐럿을 이전 셀으로 이동 합니다. 그렇지 않으면 현재 위치에 탭 문자가 삽입 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox> (때는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> 속성은 `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Tab" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령에 대 한 동작은 현재 선택한 내용에 따라 달라 집니다. 선택 내용이 비어 있지 않은, 아니면 선택 내용이 비어 있는 단락 시작 부분에는 현재 캐럿 위치 하는 경우이 명령은 같습니다 <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>합니다. 캐럿 표 셀에 있으면 (나타내는 <xref:System.Windows.Documents.TableCell> 요소),이 명령은 캐럿을 다음 셀으로 이동 합니다. 캐럿이 테이블의 마지막 셀에 있으면,이 명령을 사용 하면 새 행을 새 행의 첫 번째 셀에 배치 된 테이블에 추가 합니다.  그렇지 않으면 현재 위치에 탭 문자가 삽입 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox> 및 <xref:System.Windows.Controls.TextBox> (때는 <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> 속성은 `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> 서식이 전환되도록 요청하는 <see cref="T:System.Windows.Documents.Bold" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="B" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.FontWeight> 까지의 범위에 현재 선택 영역에 대 한 <xref:System.Windows.FontWeights.Thin%2A> 를 <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> 현재 선택 영역에 적용 됩니다.  그렇지 않으면 <xref:System.Windows.FontWeights.Normal%2A> 적용 됩니다.  비교 목록은 <xref:System.Windows.FontWeight> 값, 참조 <xref:System.Windows.FontWeights>합니다.  
  
 선택 내용이 비어 있는 경우 단어 안에 캐럿이 여 선택 영역 전체 단어를 포함 하도록 확장 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 글머리 기호 목록이라고도 하는 순서가 지정되지 않은 목록의 서식이 전환되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 효과 선택 영역에 참여 하는 각 단락의 전체 내용을에 적용 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>삽입 모드와 겹쳐쓰기 모드 사이에서 입력 모드를 전환하는 <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령의 기본 키 제스처는 <see langword="Insert" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, 및 <xref:System.Windows.Controls.PasswordBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> 서식이 전환되도록 요청하는 <see cref="T:System.Windows.Documents.Italic" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="I" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.FontStyle> 현재 선택 영역에 대 한 <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> 현재 선택 영역에 적용 됩니다.  그렇지 않으면 <xref:System.Windows.FontStyles.Normal%2A> 적용 됩니다.  
  
 선택 내용이 비어 있는 경우 단어 안에 캐럿이 여 선택 영역 전체 단어를 포함 하도록 확장 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 번호가 있는 목록이라고도 하는 순서가 지정된 목록의 서식이 전환되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 명령은에서 작동는 <xref:System.Windows.Documents.Paragraph> 수준입니다.  이 명령은 부분적으로 선택의 콘텐츠 (단락 내에서 캐럿이 있는 빈 선택 영역을 포함 합니다.) 단락 내에서 호출 되 면 요청 된 효과가 단락 전체에 적용 됩니다.  이 명령은 여러 단락에 걸친 선택에 호출 되 면 효과 선택 영역에 참여 하는 각 단락의 전체 내용을에 적용 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 아래 첨자의 서식이 전환되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="OemPlus" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 위 첨자의 서식이 전환되도록 요청하는 <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역에서 <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> 서식이 전환되도록 요청하는 <see cref="T:System.Windows.Documents.Underline" /> 명령을 나타냅니다.</summary>
        <value>요청된 명령입니다.  이 명령에 대 한 기본 키 제스처는 <see langword="Ctrl" /> + <see langword="U" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선택 내용이 비어 있는 경우 단어 안에 캐럿이 여 선택 영역 전체 단어를 포함 하도록 확장 됩니다.  
  
 반드시 있는 것은 아닙니다; 지정된 된 개체에서이 명령에 응답 하는 실제 구현을 대부분의 경우에서에 명령에 응답 하는 구현을 응용 프로그램 개발자의 책임입니다.  
  
 이 명령은에서 기본적으로 지원 <xref:System.Windows.Controls.RichTextBox>합니다.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 다음 예제에서는 명령을 지 원하는 개체에 명령을 편집 명령을 호출 하는 방법을 보여 줍니다.  
  
 이 예는 <xref:System.Windows.Controls.RichTextBox> 명령 대상으로 사용 합니다.  <xref:System.Windows.Controls.RichTextBox> 구현 하는 <xref:System.Windows.IInputElement> 인터페이스 (에서 상속 되며, <xref:System.Windows.FrameworkElement>), 많은 편집 명령에 대 한 기본 지원을 포함 합니다.  
  
 에 대 한 첫 번째 인수는 <xref:System.Windows.Input.RoutedCommand.Execute%2A> 메서드는 명령 매개 변수입니다.  대부분의 편집 명령은; 명령 매개 변수를 무시합니다. 일반적으로이 매개 변수는 같아야 `null` 편집 명령에 대 한 합니다.  
  
 명령 라우팅 개체를 지정 하는 두 번째 인수입니다.  이 개체를 구현 해야는 <xref:System.Windows.IInputElement> , 인터페이스 및 지정된 된 명령에 대 한 처리기를 포함 해야 합니다.  일반적으로 한 명령은 명령을 처리 하지 않는 개체에서 호출 될 때 무시 됩니다.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>