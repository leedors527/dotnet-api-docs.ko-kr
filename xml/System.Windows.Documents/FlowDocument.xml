<Type Name="FlowDocument" FullName="System.Windows.Documents.FlowDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9b356b05704047343bf2c2283b6b6908fea0cb0d" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934221" /></Metadata><TypeSignature Language="C#" Value="public class FlowDocument : System.Windows.FrameworkContentElement, IServiceProvider, System.Windows.Documents.IDocumentPaginatorSource, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FlowDocument extends System.Windows.FrameworkContentElement implements class System.IServiceProvider, class System.Windows.Documents.IDocumentPaginatorSource, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.FlowDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class FlowDocument&#xA;Inherits FrameworkContentElement&#xA;Implements IAddChild, IDocumentPaginatorSource, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlowDocument : System::Windows::FrameworkContentElement, IServiceProvider, System::Windows::Documents::IDocumentPaginatorSource, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type FlowDocument = class&#xA;    inherit FrameworkContentElement&#xA;    interface IDocumentPaginatorSource&#xA;    interface IServiceProvider&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Documents.IDocumentPaginatorSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Inherit, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Blocks")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>페이지 매김 및 열과 같은 고급 문서 기능을 사용하여 흐름 콘텐츠를 호스팅하고 흐름 콘텐츠 서식을 지정합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> 자식 콘텐츠에 대 한 강력한 콘텐츠 모델을 적용합니다.  에 포함 된 최상위 자식 요소를 <xref:System.Windows.Documents.FlowDocument> 에서 파생 되어야 합니다 <xref:System.Windows.Documents.Block>합니다.  유효한 최상위 자식 요소는 다음과 같습니다.  
  
-   <xref:System.Windows.Documents.BlockUIContainer>  
  
-   <xref:System.Windows.Documents.List>  
  
-   <xref:System.Windows.Documents.Paragraph>  
  
-   <xref:System.Windows.Documents.Section>  
  
-   <xref:System.Windows.Documents.Table>  
  
 기본값 <xref:System.Windows.DataTemplate> 에 대 한 <xref:System.Windows.Documents.FlowDocument> 포함 된 <xref:System.Windows.Controls.FlowDocumentReader> 사용 하는 경우 문서를 표시 하는 데 사용 되는 <xref:System.Windows.Documents.FlowDocument> XAML 파일의 루트 요소로. 경우 <xref:System.Windows.Documents.FlowDocument> 루트 요소가 없는 문서에 표시 될 수는 <xref:System.Windows.Controls.FlowDocumentScrollViewer>, <xref:System.Windows.Controls.FlowDocumentPageViewer>, 또는 <xref:System.Windows.Controls.FlowDocumentReader> 제어 합니다. 편집할 수도 있습니다는 <xref:System.Windows.Documents.FlowDocument> 에 <xref:System.Windows.Controls.RichTextBox> 제어 합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlowDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlowDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" /> 클래스의 비어 있는 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlowDocument (System.Windows.Documents.Block block);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Block block) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.#ctor(System.Windows.Documents.Block)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlowDocument(System::Windows::Documents::Block ^ block);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.FlowDocument : System.Windows.Documents.Block -&gt; System.Windows.Documents.FlowDocument" Usage="new System.Windows.Documents.FlowDocument block" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="block" Type="System.Windows.Documents.Block" />
      </Parameters>
      <Docs>
        <param name="block">추상 <see cref="T:System.Windows.Documents.Block" /> 클래스에서 파생되며 초기 콘텐츠로 추가할 개체입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Documents.FlowDocument" /> 요소를 초기 콘텐츠로 추가하여 <see cref="T:System.Windows.Documents.Block" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 대 한 유효한 입력 형식 `block` 포함 <xref:System.Windows.Documents.BlockUIContainer>를 <xref:System.Windows.Documents.List>, <xref:System.Windows.Documents.Paragraph>를 <xref:System.Windows.Documents.Section>, 및 <xref:System.Windows.Documents.Table>합니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자를 사용 하는 방법을 보여 줍니다.  이 경우에 <xref:System.Windows.Documents.FlowDocument> 텍스트 단락에 중첩 된 실행을 구성 된 흐름 요소 블록 구조를 포함 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentConstructorSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentconstructorsimple)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentConstructorSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentconstructorsimple)]  
  
 다음 예제에서는 프로그래밍 방식으로 간단한 2 x 2 테이블을 생성 하 고 사용 하 여를 <xref:System.Windows.Documents.FlowDocument> 새 생성자 <xref:System.Windows.Documents.FlowDocument> 는 테이블을 포함 합니다.  다소 복잡 한 흐름 요소 블록 구조가 사용 되지만, 생성자를 사용 하는 앞의 예제에서와 동일 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentConstructorTable](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentconstructortable)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentConstructorTable](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentconstructortable)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="block" />가 <see langword="null" />입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.FlowDocument.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 영역의 배경을 채우는 데 사용되는 <see cref="T:System.Windows.Media.Brush" />를 가져오거나 설정합니다.</summary>
        <value>콘텐츠 영역의 배경을 채우는 데 사용되는 브러시입니다. 배경 브러시를 사용하지 않는 경우 <see langword="null" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 견본 사용할 수 있는 미리 정의 된 브러시 색이 있는 테이블을 참조 하세요. <xref:System.Windows.Media.Brushes>합니다.  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.BackgroundProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.Background%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentBackgroundXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentbackgroundxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.Background%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentBackground](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentbackground)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentBackground](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentbackground)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.Background" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Blocks">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.BlockCollection Blocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.BlockCollection Blocks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.Blocks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Blocks As BlockCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::BlockCollection ^ Blocks { System::Windows::Documents::BlockCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Blocks : System.Windows.Documents.BlockCollection" Usage="System.Windows.Documents.FlowDocument.Blocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.BlockCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" /> 콘텐츠의 최상위 <see cref="T:System.Windows.Documents.Block" /> 요소를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" /> 콘텐츠를 구성하는 <see cref="T:System.Windows.Documents.Block" /> 요소를 포함하는 <see cref="T:System.Windows.Documents.BlockCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Documents.BlockCollection> 열거 하거나의 콘텐츠를 조작 하려면이 속성에서 반환 되는 <xref:System.Windows.Documents.FlowDocument>합니다.  
  
 에 포함 된 최상위 자식 요소를 <xref:System.Windows.Documents.FlowDocument> 에서 파생 되어야 합니다 <xref:System.Windows.Documents.Block>합니다.  유효한 최상위 자식 요소는 다음과 같습니다.  
  
-   <xref:System.Windows.Documents.BlockUIContainer>  
  
-   <xref:System.Windows.Documents.List>  
  
-   <xref:System.Windows.Documents.Paragraph>  
  
-   <xref:System.Windows.Documents.Section>  
  
-   <xref:System.Windows.Documents.Table>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnGap">
      <MemberSignature Language="C#" Value="public double ColumnGap { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ColumnGap" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ColumnGap" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnGap As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ColumnGap { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnGap : double with get, set" Usage="System.Windows.Documents.FlowDocument.ColumnGap" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 열 사이 간격을 나타내는 열 간격 값을 가져오거나 설정합니다.</summary>
        <value>열 간격(장치 독립적 픽셀)입니다.  값이 <see cref="F:System.Double.NaN" /> (의 특성 값에 해당 하는 "<c>자동</c>")은 열 간격이 같음 임을 나타냅니다는 <see cref="P:System.Windows.Documents.FlowDocument.LineHeight" /> 속성. 기본값은 <see cref="F:System.Double.NaN" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 가져오면 현재 열 간격을 반환 합니다.  이 값을 설정 현재 유효 열 간격을 변경 하 고 콘텐츠 흐름이 발생할 수 있습니다.  
  
 열 간격이 현재를 초과할 수 없습니다 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 뺀 값 <xref:System.Windows.Documents.FlowDocument.PagePadding%2A>합니다.  경우 값은 <xref:System.Windows.Documents.FlowDocument.ColumnGap%2A> 속성에는이 제한을 초과 하면,이 제한을 준수 유효 열 간격이 줄어듭니다.  
  
 경우에이 속성이 적용 되지 않습니다 <xref:System.Windows.Documents.FlowDocument.ColumnWidth%2A> 는 `null`합니다.  
  
<a name="xamlAttributeUsage_ColumnGap"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object ColumnGap="double"/>  
- or -  
<object ColumnGap="qualifiedDouble"/>  
- or -  
<object ColumnGap="Auto"/>  
```  
  
<a name="xamlValues_ColumnGap"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 위에서 설명한 것 처럼 값 (레터 `Auto`) 뒤에 다음과 같은 단위 지정자 중 하나를: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
 자동  
 현재 값으로 설정할 열 간격 유효 하면는 <xref:System.Windows.Documents.FlowDocument.LineHeight%2A> 속성입니다.  속성 값에 해당 <xref:System.Double.NaN>합니다.  
  
<a name="dependencyPropertyInfo_ColumnGap"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.ColumnGapProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.ColumnGap%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentColumnGap](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcolumngap)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentColumnGap](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcolumngap)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnRuleBrush" />
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnRuleWidth" />
      </Docs>
    </Member>
    <Member MemberName="ColumnGapProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ColumnGapProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ColumnGapProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.ColumnGapProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ColumnGapProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ColumnGapProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ColumnGapProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.ColumnGapProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.ColumnGap" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnRuleBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush ColumnRuleBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush ColumnRuleBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ColumnRuleBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnRuleBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ ColumnRuleBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnRuleBrush : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.FlowDocument.ColumnRuleBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>열 간의 규칙을 그리는 데 사용할 <see cref="T:System.Windows.Media.Brush" />를 가져오거나 설정합니다.</summary>
        <value>열 간의 규칙 선을 그리는 데 사용할 <see cref="T:System.Windows.Media.Brush" /> 또는 배경 브러시를 사용하지 않는 경우 <see langword="null" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열 규칙은 열 간의 그려지고 열의 콘텐츠를 시각적으로 구분 되는 줄입니다.  
  
 견본 사용할 수 있는 미리 정의 된 브러시 색이 있는 테이블을 참조 하세요. <xref:System.Windows.Media.Brushes>합니다.  
  
 경우에이 속성이 적용 되지 않습니다 합니다 <xref:System.Windows.Documents.FlowDocument.ColumnRuleWidth%2A> 속성이 0 또는 `null`합니다.  
  
 열 규칙 두 개 이상의 열이 있는 경우에 표시 됩니다.  
  
<a name="dependencyPropertyInfo_ColumnRuleBrush"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.ColumnRuleBrushProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.ColumnRuleBrush%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentColumnRule](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcolumnrule)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentColumnRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcolumnrule)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnGap" />
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnRuleWidth" />
      </Docs>
    </Member>
    <Member MemberName="ColumnRuleBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ColumnRuleBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ColumnRuleBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.ColumnRuleBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ColumnRuleBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ColumnRuleBrushProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ColumnRuleBrushProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.ColumnRuleBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.ColumnRuleBrush" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnRuleWidth">
      <MemberSignature Language="C#" Value="public double ColumnRuleWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ColumnRuleWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ColumnRuleWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnRuleWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ColumnRuleWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnRuleWidth : double with get, set" Usage="System.Windows.Documents.FlowDocument.ColumnRuleWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>열 규칙 너비를 가져오거나 설정합니다.</summary>
        <value>열 규칙 너비(디바이스 독립적 픽셀)입니다. 기본값은 0.0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 열 규칙은 열 간의 그려지고 열의 콘텐츠를 시각적으로 구분 되는 줄입니다.  
  
 경우에이 속성이 적용 되지 않습니다 합니다 <xref:System.Windows.Documents.FlowDocument.ColumnRuleBrush%2A> 속성은 `null`합니다.  
  
 열 규칙 두 개 이상의 열이 있는 경우에 표시 됩니다.  열 규칙 너비 보다 작거나 같음으로 제한 되는 <xref:System.Windows.Documents.FlowDocument.ColumnGap%2A>합니다.  
  
<a name="xamlAttributeUsage_ColumnRuleWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object ColumnRuleWidth="double"/>  
- or -  
<object ColumnRuleWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_ColumnRuleWidth"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_ColumnRuleWidth"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.ColumnRuleWidthProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.ColumnRuleWidth%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentColumnRule](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcolumnrule)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentColumnRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcolumnrule)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnGap" />
        <altmember cref="P:System.Windows.Documents.FlowDocument.ColumnRuleBrush" />
      </Docs>
    </Member>
    <Member MemberName="ColumnRuleWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ColumnRuleWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ColumnRuleWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.ColumnRuleWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ColumnRuleWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ColumnRuleWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ColumnRuleWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.ColumnRuleWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.ColumnRuleWidth" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnWidth">
      <MemberSignature Language="C#" Value="public double ColumnWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ColumnWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ColumnWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ColumnWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnWidth : double with get, set" Usage="System.Windows.Documents.FlowDocument.ColumnWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />에 원하는 최소 열 너비를 가져오거나 설정합니다.</summary>
        <value>원하는 최소 열 너비(디바이스 독립적 픽셀)입니다. <see cref="F:System.Double.NaN" /> 값은 페이지 너비와 관계없이 하나의 열만 표시합니다.  기본값은 <see cref="F:System.Double.NaN" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument> 사용 가능한 표시 공간 내에서 콘텐츠 표시를 최대화 하기 위해 해당 콘텐츠를 동적으로 조정 합니다.  이 속성에 지정 된 최소 열 너비를 지정 된 사용 가능한 표시 공간에 들어갈 수 있는 열 수로 표시 된 열 수가 결정 됩니다.  실제 열 너비는이 속성에 지정 된 값 보다 클 수 있습니다.  
  
 어느 방향으로든에서 창의 크기를 변경 합니다. 공간을 최대한 활용 하도록 동적으로 다시 생성 하는 열에 발생 합니다. 이러한 방식으로 콘텐츠를 동적으로 사용자의 환경에 조정 됩니다.  
  
<a name="xamlAttributeUsage_ColumnWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object ColumnWidth="double"/>  
- or -  
<object ColumnWidth="qualifiedDouble"/>  
- or -  
<object ColumnWidth="Auto"/>  
```  
  
<a name="xamlValues_ColumnWidth"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 위에서 설명한 대로 값 (레터 `Auto`) 단위 지정자 중 하나: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
 자동  
 열 너비가 자동으로 20 배 현재 계산 <xref:System.Windows.Documents.FlowDocument.FontSize%2A>합니다.  
  
<a name="dependencyPropertyInfo_ColumnWidth"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.ColumnWidthProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.ColumnWidth%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentColumnWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentcolumnwidthxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.ColumnWidth%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentColumnWidth](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcolumnwidth)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentColumnWidth](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcolumnwidth)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ColumnWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ColumnWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.ColumnWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ColumnWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ColumnWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ColumnWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.ColumnWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.ColumnWidth" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ContentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.FlowDocument.ContentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.TextPointer" />에 있는 콘텐츠의 끝을 나타내는 <see cref="T:System.Windows.Documents.FlowDocument" />를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" />에 있는 콘텐츠의 끝을 나타내는 <see cref="T:System.Windows.Documents.FlowDocument" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A> 속성은 콘텐츠 끝에 추가 하는 데 자주 사용 된 <xref:System.Windows.Documents.FlowDocument>합니다.  
  
 <xref:System.Windows.Documents.TextPointer> 이 속성에서 반환한 항상 해당 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 로 <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A> 콘텐츠를 추가 하는 속성을 <xref:System.Windows.Documents.FlowDocument>입니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentContentEnd](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcontentend)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentContentEnd](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcontentend)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.ContentStart" />
      </Docs>
    </Member>
    <Member MemberName="ContentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.ContentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.FlowDocument.ContentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.TextPointer" />에 있는 콘텐츠의 시작 부분을 나타내는 <see cref="T:System.Windows.Documents.FlowDocument" />를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointerContext" />에 있는 콘텐츠의 시작 부분을 나타내는 <see cref="T:System.Windows.Documents.FlowDocument" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Documents.FlowDocument.ContentStart%2A> 속성의 시작 부분에 콘텐츠를 삽입 하는 대개는 <xref:System.Windows.Documents.FlowDocument>합니다.  
  
 <xref:System.Windows.Documents.TextPointer> 이 속성에서 반환한 항상 해당 <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> 로 <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.Windows.Documents.FlowDocument.ContentStart%2A> 시작 부분에 콘텐츠를 삽입 하는 속성을 <xref:System.Windows.Documents.FlowDocument>입니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentContentStart](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcontentstart)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentContentStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcontentstart)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.ContentEnd" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.Documents.FlowDocument.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />에 있는 콘텐츠의 흐름에 대한 상대적인 방향을 가져오거나 설정합니다.</summary>
        <value>상대적인 흐름 방향을 지정하는 <see cref="T:System.Windows.FlowDirection" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.FlowDirection.LeftToRight" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 가져오면 현재 유효한 흐름 방향이 반환됩니다.  이 속성을 설정 하면 내용의 <xref:System.Windows.Documents.FlowDocument> 흐름이 표시 된 방향에서.  
  
 <xref:System.Windows.Documents.FlowDocument.FlowDirection%2A> 콘텐츠의 일반적으로 고유 흐름 방향을 표시 되는 언어에 해당 합니다.  히브리어 및 아랍어는 기본적으로 오른쪽에서 왼쪽으로 진행 되는 언어의 예입니다.  영어, 독일어 및 러시아어는 자연스럽 게 왼쪽에서 오른쪽으로 흐름 되는 언어의 예입니다.  
  
> [!NOTE]
>  이 속성의 값을 자동으로 운영 체제에서 사용 되는 언어와 일치 하도록 변경 되지 않습니다. 기본값은 다른 값을 사용 해야 할 경우 <xref:System.Windows.FlowDirection.LeftToRight>를 직접 지정 해야 합니다.  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FlowDirectionProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FlowDirection%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFlowDirectionXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentflowdirectionxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FlowDirection%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFlowDirection](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentflowdirection)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFlowDirection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentflowdirection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FlowDirection" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Documents.FlowDocument.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 기본 설정 최상위 글꼴 패밀리를 가져오거나 설정합니다.</summary>
        <value>기본 설정 글꼴 패밀리 또는 하나 이상의 대체(fallback) 글꼴 패밀리가 있는 기본 설정 주 글꼴 패밀리를 지정하는 <see cref="T:System.Windows.Media.FontFamily" /> 개체입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" /> 값에 따라 결정되는 글꼴입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Windows.Documents.FlowDocument.FontFamily%2A> 자식 요소에이 최상위 수준 설정을 재정의 합니다.  
  
 여러 패밀리를 지정 하는 경우 두 번째 및 이후의 글꼴 패밀리 기본 글꼴 패밀리를 적용할 수 없거나 사용할 수 없는 경우에 사용할 대체 (fallback) 제품군 역할도 합니다.  
  
 이 속성에만 기본 설정을 지정합니다.  지정된 된 글꼴 패밀리를 사용할 수 없는 경우는 <xref:System.Windows.Documents.FlowDocument> 의해 결정 된 글꼴을 자동으로 대체 됩니다는 <xref:System.Windows.SystemFonts.MessageFontFamily%2A?displayProperty=nameWithType> 값입니다.  
  
<a name="xamlAttributeUsage_FontFamily"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object FontFamily="fontFamilyName"/>  
- or -  
<object FontFamily="fontFamilyNamesList"/>  
- or -  
<object FontFamily="fontFamilyFolderReference"/>  
- or -  
<object FontFamily="fontFamilyUriReference"/>  
```  
  
<a name="xamlValues_FontFamily"></a>   
## <a name="xaml-values"></a>XAML 값  
 *fontFamilyName*  
 글꼴 패밀리 이름을 지정 하는 문자열입니다.  예를 들어 `"Arial"` 또는 `"Century Gothic"`로 이름을 지정할 수 있습니다.  
  
 *fontFamilyNamesList*  
 여러 글꼴 패밀리 이름을 지정 하는 문자열을 각각 쉼표로 구분 된 (쉼표 뒤에 있는 공백은 무시 됨).  지정 된 첫 번째 글꼴 패밀리 기본 글꼴 패밀리; 역 후속 글꼴 패밀리 기본 글꼴 패밀리를 적용할 수 없거나 사용할 수 없는 경우에 사용할 대체 (fallback) 제품군으로 사용 됩니다.  예를 들어 `"Arial, Century Gothic"` Arial 대체 글꼴 패밀리로 Gothic 세기를 사용 하 여 기본 글꼴 패밀리를 지정 합니다.  
  
 *fontFamilyFolderReference*  
 글꼴, 글꼴 패밀리 이름과 함께 포함 된 폴더를 지정 하는 문자열입니다.  폴더 및 글꼴 패밀리 이름 # 문자로 구분 됩니다.  폴더 참조는 절대적 이거나 상대적일 수 있습니다.  예를 들어, `"Custom Fonts\#My Custom Font"`을 입력합니다.  
  
 *fontFamilyUriReference*  
 지정 하는 문자열을 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 을 글꼴의 글꼴 패밀리 이름과 함께 합니다.  [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] 와 글꼴 패밀리 이름 # 문자로 구분 됩니다.  예를 들어, `"http://MyFontServer/Fonts/#My Custom Font"`을 입력합니다.  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FontFamilyProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FontFamily%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFontStuffXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentfontstuffxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FontFamily%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentfontstuff)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentfontstuff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FontFamily" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Documents.FlowDocument.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최상위 글꼴 크기를 가져오거나 설정합니다.</summary>
        <value>사용할 글꼴 크기(장치 독립적 픽셀)입니다.   기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontSize" /> 값에 따라 결정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Windows.Documents.FlowDocument.FontSize%2A> 자식 요소에 최상위 수준 설정을 재정의 합니다.  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FontSizeProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FontSize%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFontStuffXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentfontstuffxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FontSize%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentfontstuff)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentfontstuff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FontSize" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberSignature Language="F#" Value="member this.FontStretch : System.Windows.FontStretch with get, set" Usage="System.Windows.Documents.FlowDocument.FontStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최상위 글꼴 늘이기 특징을 가져오거나 설정합니다.</summary>
        <value>사용하려는 글꼴 확장 특성을 지정하는 <see cref="T:System.Windows.FontStretch" /> 클래스의 멤버입니다. 기본값은 <see cref="P:System.Windows.FontStretches.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Windows.Documents.FlowDocument.FontStretch%2A> 자식 요소에 최상위 수준 설정을 재정의 합니다.  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FontStretchProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FontStretch%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFontStuffXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentfontstuffxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FontStretch%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentfontstuff)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentfontstuff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStretchProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FontStretchProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FontStretch" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FontStyle : System.Windows.FontStyle with get, set" Usage="System.Windows.Documents.FlowDocument.FontStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최상위 글꼴 스타일을 가져오거나 설정합니다.</summary>
        <value>원하는 글꼴 스타일을 지정하는 <see cref="T:System.Windows.FontStyles" /> 클래스의 멤버입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontStyle" /> 값에 따라 결정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Windows.Documents.FlowDocument.FontStyle%2A> 자식 요소에 최상위 수준 설정을 재정의 합니다.  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FontStyleProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FontStyle%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFontStuffXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentfontstuffxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FontStyle%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentfontstuff)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentfontstuff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FontStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FontStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberSignature Language="F#" Value="member this.FontWeight : System.Windows.FontWeight with get, set" Usage="System.Windows.Documents.FlowDocument.FontWeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />에 대한 최상위 글꼴 두께를 가져오거나 설정합니다.</summary>
        <value>원하는 글꼴 두께를 지정하는 <see cref="T:System.Windows.FontWeights" /> 클래스의 멤버입니다. 기본값은 <see cref="P:System.Windows.SystemFonts.MessageFontWeight" /> 값에 따라 결정됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 <xref:System.Windows.Documents.FlowDocument.FontWeight%2A> 자식 요소에 최상위 수준 설정을 재정의 합니다.  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.FontWeightProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.FontWeight%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentFontStuffXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentfontstuffxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.FontWeight%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentfontstuff)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentFontStuff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentfontstuff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontWeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.FontWeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.FontWeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.FlowDocument.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Media.Brush" />의 텍스트 콘텐츠에 적용할 <see cref="T:System.Windows.Documents.FlowDocument" />를 가져오거나 설정합니다.</summary>
        <value>텍스트 콘텐츠에 적용하는 데 사용되는 브러시입니다. 기본값은 <see cref="P:System.Windows.Media.Brushes.Black" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수 있는 미리 정의 된 브러시 색을 보여 주는 견본 테이블을 참조 하세요. <xref:System.Windows.Media.Brushes>합니다.  
  
 모든 <xref:System.Windows.Documents.FlowDocument.Foreground%2A> 자식 요소에 최상위 수준 설정을 재정의 합니다.  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.ForegroundProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>,<br /><br /> <xref:System.Windows.FrameworkPropertyMetadataOptions.SubPropertiesDoNotAffectRender>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.Foreground%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentBackgroundXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentbackgroundxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.Foreground%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentBackground](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentbackground)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentBackground](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentbackground)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.Foreground" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsColumnWidthFlexible">
      <MemberSignature Language="C#" Value="public bool IsColumnWidthFlexible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsColumnWidthFlexible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.IsColumnWidthFlexible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsColumnWidthFlexible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsColumnWidthFlexible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsColumnWidthFlexible : bool with get, set" Usage="System.Windows.Documents.FlowDocument.IsColumnWidthFlexible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.ColumnWidth" /> 값이 고정 값인지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>열 너비가 유동 값이면 <see langword="true" />이고, 열 너비가 고정 값이면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument.IsColumnWidthFlexible%2A> 속성 모든 여분의 콘텐츠 영역 너비 (즉, 페이지 너비 및 배치 된 후 콘텐츠 간의 차이) 열 간에 분산 되는 방식을 결정 합니다. 설정이 `true` 의미 추가 공간이 배분 됩니다는 동일 하 게 각 열에이 경우, 열에 지정 된 너비 보다 조정 될 수 있습니다는 <xref:System.Windows.Documents.FlowDocument.ColumnWidth%2A> 속성입니다.  설정 `false` 페이지의 오른쪽에서 안쪽 여백 공간을 배분;이 예제의 경우 열 항상 크기를 지정 된 너비를 초과 하는 수단을 <xref:System.Windows.Documents.FlowDocument.ColumnWidth%2A> 속성 (너비 모든 페이지 너비 보다 작은 경우에 < c 4 > <xref:System.Windows.Documents.FlowDocument.PagePadding%2A> ).  
  
 다음 그림 때이 속성은 레이아웃의 차이점을 보여 줍니다 `true` 또는 `false`합니다.  연한 파랑에서 콘텐츠의 열을 나타내는 <xref:System.Windows.Documents.FlowDocument>합니다.  
  
 ![스크린 샷: IsColumnWidthFlexible 값 비교](~/add/media/flowdoc-columnflex.png "스크린 샷: IsColumnWidthFlexible 값 비교")  
  
<a name="dependencyPropertyInfo_IsColumnWidthFlexible"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.IsColumnWidthFlexibleProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.IsColumnWidthFlexible%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentColumnFlexXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentcolumnflexxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.IsColumnWidthFlexible%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentColumnFlex](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentcolumnflex)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentColumnFlex](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentcolumnflex)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsColumnWidthFlexibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsColumnWidthFlexibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsColumnWidthFlexibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.IsColumnWidthFlexibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsColumnWidthFlexibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsColumnWidthFlexibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsColumnWidthFlexibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.IsColumnWidthFlexibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.IsColumnWidthFlexible" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Documents.FlowDocument.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.ContentElement.IsEnabled" />에 대한 <see cref="T:System.Windows.Documents.FlowDocument" /> 속성 값을 가져옵니다.</summary>
        <value><see cref="P:System.Windows.ContentElement.IsEnabled" />에 대한 <see cref="T:System.Windows.Documents.FlowDocument" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHyphenationEnabled : bool with get, set" Usage="System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>단어에 자동 하이픈 넣기가 설정되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>단어에 자동 줄 바꿈 및 하이픈 넣기가 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 단어 단위로 하이픈 넣기 기능은 <xref:System.Windows.Documents.FlowDocument> 를 자동으로 중단 하 고 현재 레이아웃 조건에 따라 단어에 하이픈입니다.  긴 단어를 한 줄에서 시작 하 고이 단계를 계속 있으며 양쪽 맞춤 된 텍스트의 공백은 고르게 분포를 달성 하는 경향이 있습니다.  단어 분리 되며 표준 문법 규칙에 따라 하이픈으로 연결 됩니다.  자동 하이픈 넣기는 최적의 단락 레이아웃을 사용 하 여 사용할 경우 특히 효과적 (나타내는 <xref:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled%2A> 속성).  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.IsHyphenationEnabledProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.IsHyphenationEnabled%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentHyphenateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumenthyphenatexaml)]  
  
 다음 그림에서는 어떻게 이전 <xref:System.Windows.Documents.FlowDocument> 렌더링 합니다.  
  
 ![스크린 샷: 사용 하도록 설정 하는 FlowDocument 하이픈](~/add/media/flowdoc-hyphenenabled.png "스크린 샷: FlowDocument 하이픈을 사용 하도록 설정")  
  
 다음 그림에서는 어떻게 동일 <xref:System.Windows.Documents.FlowDocument> 의 기본 설정을 사용 하 여 렌더링 <xref:System.Windows.Documents.FlowDocument.IsHyphenationEnabled%2A> = `false`합니다.  
  
 ![스크린 샷: 비활성화 된 하이픈을 사용 하 여 FlowDocument](~/add/media/flowdoc-hyphendisabled.png "스크린 샷: 비활성화 된 하이픈을 사용 하 여 FlowDocument")  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.IsHyphenationEnabled%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentHyphenate](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumenthyphenate)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentHyphenate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumenthyphenate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHyphenationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.IsHyphenationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOptimalParagraphEnabled">
      <MemberSignature Language="C#" Value="public bool IsOptimalParagraphEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOptimalParagraphEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOptimalParagraphEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOptimalParagraphEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOptimalParagraphEnabled : bool with get, set" Usage="System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최적의 단락 레이아웃 기능이 설정되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>최적의 단락 레이아웃 기능이 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 최적의 단락 레이아웃은에서 단락을 배치 하는 기능을 <xref:System.Windows.Documents.FlowDocument> 공백 최대한 균등 하 게 분배 되도록 합니다.  이론적으로 텍스트 줄 맞춤 및 다른 레이아웃 루틴을 사용 하 여 발생할 수 있는 산만 공백을 제거 하 여 최적의 표시 환경을 제공 합니다.  최적의 단락 레이아웃에 자동 하이픈 넣기와 결합 하면 특히 효과적입니다 (나타내는 <xref:System.Windows.Documents.FlowDocument.IsHyphenationEnabled%2A> 속성).  
  
<a name="dependencyPropertyInfo_Opt"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabledProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentHyphenateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumenthyphenatexaml)]  
  
 다음 그림에서는 어떻게 이전 <xref:System.Windows.Documents.FlowDocument> 렌더링 합니다.  
  
 ![스크린 샷: 사용 하도록 설정 하는 FlowDocument 하이픈](~/add/media/flowdoc-hyphenenabled.png "스크린 샷: FlowDocument 하이픈을 사용 하도록 설정")  
  
 다음 그림에서는 어떻게 동일 <xref:System.Windows.Documents.FlowDocument> 의 기본 설정을 사용 하 여 렌더링 <xref:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled%2A> = `false`합니다.  
  
 ![스크린 샷: 비활성화 된 하이픈을 사용 하 여 FlowDocument](~/add/media/flowdoc-hyphendisabled.png "스크린 샷: 비활성화 된 하이픈을 사용 하 여 FlowDocument")  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentHyphenate](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumenthyphenate)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentHyphenate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumenthyphenate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOptimalParagraphEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOptimalParagraphEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOptimalParagraphEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOptimalParagraphEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOptimalParagraphEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOptimalParagraphEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.IsOptimalParagraphEnabled" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Documents.FlowDocument.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 각 줄의 높이를 가져오거나 설정합니다.</summary>
        <value>각 줄의 높이는 장치 독립적 픽셀 단위로 0.0034에서 160000 사이의 범위에 있습니다. 값이 <see cref="F:System.Double.NaN" /> (의 특성 값에 해당 하는 "<c>자동</c>") 이면 줄 높이가 현재 글꼴 특성에서 자동으로 결정 됩니다. 기본값은 <see cref="F:System.Double.NaN" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 값을 변경 해도 연결된 된 텍스트의 높이 변경 되지 않습니다. 대신, 텍스트를 포함 하는 줄의 높이 변경 합니다. 텍스트의 크기를 변경 하려면 사용 된 <xref:System.Windows.Documents.FlowDocument.FontSize%2A> 속성입니다.  
  
 레이아웃의 줄을이 속성 외에 <xref:System.Windows.Documents.FlowDocument> 영향을 받는 해당 <xref:System.Windows.Documents.FlowDocument.LineStackingStrategy%2A> 속성입니다.  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 값 보다 크거나 `0.0034` 와 같거나 작아야 합니다 `160000`합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 위에서 설명한 대로 값 (레터 `Auto`) 단위 지정자 중 하나: `px`, `in`, `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
 자동  
 이면 줄 높이가 현재 글꼴 특성에서 자동으로 결정 됩니다.  속성 값에 해당 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.LineHeightProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.LineHeight%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentLineHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentlineheightxaml)]  
  
 다음 그림에서는 어떻게 이전 <xref:System.Windows.Documents.FlowDocument> 렌더링 합니다.  
  
 ![스크린 샷: FlowDocument LineHeight](~/add/media/flowdocument-lineheight.png "스크린 샷: FlowDocument LineHeight")  
  
 다음 그림에서는 어떻게 동일 <xref:System.Windows.Documents.FlowDocument> 의 기본 설정을 사용 하 여 렌더링 <xref:System.Windows.Documents.FlowDocument.LineHeight%2A> = <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
 ![스크린 샷: FlowDocument LineHeight 기본값](~/add/media/flowdocument-lineheightdefault.png "스크린 샷: FlowDocument LineHeight 기본값")  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.LineHeight%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentLineHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentlineheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentLineHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentlineheight)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Controls.TextBlock.LineHeight" />가 양수가 아닌 값으로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.LineHeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Documents.FlowDocument.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" /> 내의 각 텍스트 줄에 대한 줄 상자가 결정되는 메커니즘을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.LineStackingStrategy" /> 내의 각 텍스트 줄에 대해 줄 상자가 결정되는 메커니즘을 지정하는 <see cref="T:System.Windows.Documents.FlowDocument" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.LineStackingStrategyProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> 속성의 텍스트 줄의 줄 상자가 만들어지는 방법을 확인 하는 <xref:System.Windows.Controls.TextBlock>합니다. 첫 번째 <xref:System.Windows.Controls.TextBlock> 에 <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> 의 값 <xref:System.Windows.LineStackingStrategy.MaxHeight> 고 두 번째 <xref:System.Windows.Controls.TextBlock> 값 <xref:System.Windows.LineStackingStrategy.BlockLineHeight>합니다.  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 다음 그림에서는 앞의 코드의 결과 보여 줍니다.  
  
 ![스크린 샷: LineStackingStrategy 값 비교](~/add/media/flow-linestackingstrategy.gif "스크린 샷: LineStackingStrategy 값 비교")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.LineStackingStrategy" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Documents.FlowDocument.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 논리적 자식을 반복할 수 있는 열거자를 가져옵니다.</summary>
        <value>논리적 자식의 열거자입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPageHeight">
      <MemberSignature Language="C#" Value="public double MaxPageHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxPageHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.MaxPageHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxPageHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageHeight : double with get, set" Usage="System.Windows.Documents.FlowDocument.MaxPageHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최대 페이지 높이를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />의 페이지 최고 높이(장치 독립적 픽셀)입니다. 기본값은 <see cref="F:System.Double.PositiveInfinity" />(최대 페이지 높이 없음)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageHeight%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageHeight%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
 이 속성이 없는 경우 적용 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 로 설정 된 <xref:System.Double.NaN?displayProperty=nameWithType> (자동).  
  
<a name="xamlAttributeUsage_MaxPageHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object MaxPageHeight="double"/>  
- or -  
<object MaxPageHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxPageHeight"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxPageHeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.MaxPageHeightProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageHeight%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.MaxPageHeight%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPageHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxPageHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxPageHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.MaxPageHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxPageHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxPageHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxPageHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.MaxPageHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.MaxPageHeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPageWidth">
      <MemberSignature Language="C#" Value="public double MaxPageWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxPageWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.MaxPageWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxPageWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageWidth : double with get, set" Usage="System.Windows.Documents.FlowDocument.MaxPageWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최대 페이지 너비를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />에서 페이지의 최대 너비(장치 독립적 픽셀)입니다. 기본값은 <see cref="F:System.Double.PositiveInfinity" />(최대 페이지 너비 없음)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageWidth%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageWidth%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
 이 속성이 없는 경우 적용 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 로 설정 된 <xref:System.Double.NaN?displayProperty=nameWithType> (자동).  
  
<a name="xamlAttributeUsage_MaxPageWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object MaxPageWidth="double"/>  
- or -  
<object MaxPageWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxPageWidth"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxPageWidth"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.MaxPageWidthProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageWidth%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.MaxPageWidth%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxPageWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxPageWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxPageWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.MaxPageWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxPageWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxPageWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxPageWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.MaxPageWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.MaxPageWidth" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinPageHeight">
      <MemberSignature Language="C#" Value="public double MinPageHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinPageHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.MinPageHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinPageHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinPageHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinPageHeight : double with get, set" Usage="System.Windows.Documents.FlowDocument.MinPageHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최소 페이지 높이를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />에서 페이지의 최소 높이(장치 독립적 픽셀)입니다. 기본값은 0.0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageHeight%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageHeight%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
 이 속성이 없는 경우 적용 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 로 설정 된 <xref:System.Double.NaN?displayProperty=nameWithType> (자동).  
  
<a name="xamlAttributeUsage_MinPageHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object MinPageHeight="double"/>  
- or -  
<object MinPageHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinPageHeight"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinPageHeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.MinPageHeightProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.MinPageHeight%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.MinPageHeight%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinPageHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinPageHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinPageHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.MinPageHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinPageHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinPageHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinPageHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.MinPageHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.MinPageHeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinPageWidth">
      <MemberSignature Language="C#" Value="public double MinPageWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinPageWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.MinPageWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinPageWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinPageWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinPageWidth : double with get, set" Usage="System.Windows.Documents.FlowDocument.MinPageWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 최소 페이지 너비를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />에서 페이지의 최소 너비(장치 독립적 픽셀)입니다. 기본값은 0.0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageWidth%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageWidth%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
 이 속성이 없는 경우 적용 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 로 설정 된 <xref:System.Double.NaN?displayProperty=nameWithType> (자동).  
  
<a name="xamlAttributeUsage_MinPageWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object MinPageWidth="double"/>  
- or -  
<object MinPageWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinPageWidth"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinPageWidth"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.MinPageWidthProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.MinPageWidth%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.MinPageWidth%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinPageWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinPageWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinPageWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.MinPageWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinPageWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinPageWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinPageWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.MinPageWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.MinPageWidth" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="flowDocument.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>파생 클래스에서 재정의되는 경우 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 인프라에 대한 특정 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 구현을 제공합니다.</summary>
        <returns>형식별 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 구현입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드의 구현은 특정 생성자를 호출 하는 일반적으로 <xref:System.Windows.Automation.Peers.AutomationPeer> 구현 및 결과 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="flowDocument.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">연결된 이벤트에 대한 인수입니다.</param>
        <summary>요소에 있는 종속성 속성 중 하나 이상의 유효 값이 변경된 경우에 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Windows.FrameworkContentElement.OnPropertyChanged%2A?displayProperty=nameWithType>를 재정의합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PageHeight">
      <MemberSignature Language="C#" Value="public double PageHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PageHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.PageHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property PageHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PageHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PageHeight : double with get, set" Usage="System.Windows.Documents.FlowDocument.PageHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 기본 설정 페이지 높이를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />의 페이지 기본 높이(장치 독립적 픽셀)입니다. 값이 <see cref="F:System.Double.NaN" /> (의 특성 값에 해당 하는 "<c>자동</c>") 이면 페이지 높이가 자동으로 결정 됩니다. 기본값은 <see cref="F:System.Double.NaN" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageHeight%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageHeight%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
<a name="xamlAttributeUsage_PageHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object PageHeight="double"/>  
- or -  
<object PageHeight="qualifiedDouble"/>  
- or -  
<object PageHeight="Auto"/>  
```  
  
<a name="xamlValues_PageHeight"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
 *자동*  
 이면 페이지 높이가 자동으로 결정 됩니다.  속성 값에 해당 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
<a name="dependencyPropertyInfo_PageHeight"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.PageHeightProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.PageHeight%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PageHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PageHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.PageHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PageHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.PageHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.PageHeight" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PagePadding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness PagePadding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness PagePadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.PagePadding" />
      <MemberSignature Language="VB.NET" Value="Public Property PagePadding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness PagePadding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.PagePadding : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.FlowDocument.PagePadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>페이지 및 페이지 콘텐츠 경계선 사이의 안쪽 여백 두께를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>적용할 안쪽 여백의 양을 장치 독립적 픽셀 단위로 지정하는 <see cref="T:System.Windows.Thickness" /> 구조체입니다. 기본값은 0의 균일 두께(0.0)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.FlowDocument.PagePadding%2A> 균일 하 게 모든 방향으로 설명할 수 있습니다 (`PagePadding="10"`), 네 개의 왼쪽 나타내는 값을 위쪽, 오른쪽으로 및 독립적으로 안쪽 여백 아래쪽 또는 (`PagePadding="5,0,10,20"`).  
  
 지정 된 안쪽 여백 두께 해당 페이지 크기를 초과 하는 경우 (예를 들어, 왼쪽 및 오른쪽 안쪽 여백 너비의 합계는 페이지 너비를 초과)의 안쪽 여백 두께 비례적으로 줄어듭니다 관련 페이지 크기 보다 작을 수 .  
  
<a name="xamlAttributeUsage_PagePadding"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object PagePadding="uniformThickness"/>  
- or -  
<object PagePadding="independentThickness"/>  
- or -  
<object PagePadding="qualifiedUniformThickness"/>  
- or -  
<object PagePadding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_PagePadding"></a>   
## <a name="xaml-values"></a>XAML 값  
 *uniformThickness*  
 단일의 문자열 표현 <xref:System.Double> 네 가지 두께 균일 하 게 적용할 값입니다.  예를 들어, 값 `"10"` 의 값과 동일 `"10,10,10,10"`합니다.  값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *independentThickness*  
 순서가 지정 된 4의 문자열 표현 <xref:System.Double> 왼쪽, 위쪽에 대 한 독립적인 두께에 해당 하는 값 오른쪽이 순서 대로 아래쪽 합니다.  4 개 값; 쉼표로 구분 해야 합니다. 공백은 허용 되지 않습니다.  예를 들어, "5,10,15,20" 결과 여백 5 픽셀에서 왼쪽의 콘텐츠, 콘텐츠 위쪽 여백 10 픽셀, 콘텐츠, 오른쪽의 안쪽 여백 (픽셀)를 15 및 콘텐츠 아래쪽 여백 20 픽셀입니다.  
  
 *qualifiedUniformThickness*  
 에 설명 된 값 *uniformThickness* 단위 지정자 중 하나가 오는: `px`, `in`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 예를 들어 `"1in"` 모든 방향으로 1 인치의 uniform 안쪽 여백을 제공 합니다.  
  
 *qualifiedIndependentThickness*  
 에 설명 된 값 *independentThickness*, 각 독립 값 뒤에 다음과 같은 단위 지정자 중 하나를 사용 하 여: `px`, `in`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 예를 들어, `"1.5in,0.8in,1.5in,0.8in"`을 입력합니다.  단위 지정자 혼합 또는 하나 이상의 값에서 생략 되었을 수 있습니다.  
  
<a name="dependencyPropertyInfo_PagePadding"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.PagePaddingProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 다양 한 방법 표시 합니다 <xref:System.Windows.Documents.FlowDocument.PagePadding%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpaddingxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.PagePadding%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpadding)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PagePaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PagePaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PagePaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.PagePaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PagePaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PagePaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PagePaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.PagePaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.PagePadding" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageWidth">
      <MemberSignature Language="C#" Value="public double PageWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 PageWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.PageWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property PageWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double PageWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.PageWidth : double with get, set" Usage="System.Windows.Documents.FlowDocument.PageWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 기본 설정 페이지 너비를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Documents.FlowDocument" />에서 페이지의 기본 너비(장치 독립적 픽셀)입니다. 값이 <see cref="F:System.Double.NaN" /> (의 특성 값에 해당 하는 "<c>자동</c>") 이면 페이지 너비가 자동으로 결정 됩니다. 기본값은 <see cref="F:System.Double.NaN" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 연속선상에서 표시 하는 경우는 <xref:System.Windows.Documents.FlowDocument.MinPageWidth%2A> 속성 보다 우선 합니다 <xref:System.Windows.Documents.FlowDocument.MaxPageWidth%2A> 차례로 보다 우선적으로 사용 하는 속성은 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 속성. 에 지정된 된 페이지의 모든 세 가지 속성을 설정 하는 경우 이것이 속성을 확인 하는 순서입니다.  
  
<a name="xamlAttributeUsage_PageWidth"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object PageWidth="double"/>  
- or -  
<object PageWidth="qualifiedDouble"/>  
- or -  
<object PageWidth="Auto"/>  
```  
  
<a name="xamlValues_PageWidth"></a>   
## <a name="xaml-values"></a>XAML 값  
 *double*  
 <xref:System.Double>  
  
 문자열 표현 된 <xref:System.Double> 보다는 작습니다 0.0 보다 크거나 같은 값 <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>합니다. 값을 정규화 되지 않은 장치 독립적 픽셀 단위로 측정 됩니다. 문자열 소수점이 하를 명시적으로 포함 되지 해야 합니다.  
  
 *qualifiedDouble*  
 *이중* 값, 위에서 설명한 대로 뒤에 다음과 같은 단위 지정자 중 하나: `px`, `in`를 `cm`, `pt`합니다.  
  
 `px` (기본값) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` 인치; 1에서 96px = =  
  
 `cm` 센티미터; 1cm==(96/2.54) px  
  
 `pt` 포인트; 1pt==(96/72) px  
  
 *자동*  
 이면 페이지 너비가 자동으로 결정 됩니다.  속성 값에 해당 <xref:System.Double.NaN?displayProperty=nameWithType>합니다.  
  
<a name="dependencyPropertyInfo_PageWidth"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.PageWidthProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentPageWidthHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumentpagewidthheightxaml)]  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.PageWidth%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumentpagewidthheight)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentPageWidthHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumentpagewidthheight)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PageWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PageWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.PageWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PageWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.PageWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.PageWidth" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDpi">
      <MemberSignature Language="C#" Value="public void SetDpi (System.Windows.DpiScale dpiInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDpi(valuetype System.Windows.DpiScale dpiInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.SetDpi(System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDpi (dpiInfo As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDpi(System::Windows::DpiScale dpiInfo);" />
      <MemberSignature Language="F#" Value="member this.SetDpi : System.Windows.DpiScale -&gt; unit" Usage="flowDocument.SetDpi dpiInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dpiInfo" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dpiInfo"><see cref="T:System.Windows.Media.Visual" />또는 <see cref="T:System.Windows.UIElement" />가 렌더링되는 DPI 설정입니다.</param>
        <summary>FlowDocument에 대한 DPI를 설정하여 다시 측정되고 다시 렌더링되도록 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모니터 당 DPI 시나리오에서 사용 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">가져올 서비스 개체의 형식을 지정하는 개체입니다.</param>
        <summary>지정된 형식의 서비스 개체를 가져옵니다.</summary>
        <returns><paramref name="serviceType." /> 형식의 서비스 개체입니다.  
  
또는 
 <paramref name="serviceType" /> 형식의 서비스 개체가 없는 경우 <see langword="null" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator">
      <MemberSignature Language="C#" Value="System.Windows.Documents.DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.System#Windows#Documents#IDocumentPaginatorSource#DocumentPaginator" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DocumentPaginator As DocumentPaginator Implements IDocumentPaginatorSource.DocumentPaginator" />
      <MemberSignature Language="C++ CLI" Value="property System::Windows::Documents::DocumentPaginator ^ System::Windows::Documents::IDocumentPaginatorSource::DocumentPaginator { System::Windows::Documents::DocumentPaginator ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.DocumentPaginator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>실제 콘텐츠 페이지 매기기를 수행하는 소스 개체를 정의합니다.</summary>
        <value>실제 콘텐츠 페이지 매기기를 수행하는 개체입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">추가할 자식 개체입니다.</param>
        <summary>자식 개체를 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.FlowDocument.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">개체에 추가할 텍스트입니다.</param>
        <summary>노드의 텍스트 콘텐츠를 개체에 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Documents.FlowDocument.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>텍스트 콘텐츠의 가로 맞춤을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>원하는 맞춤을 지정하는 <see cref="T:System.Windows.TextAlignment" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.TextAlignment.Left" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.TextAlignmentProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.TextAlignment%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentTextAlignmentXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumenttextalignmentxaml)]  
  
 다음 그림에서는 어떻게 앞 <xref:System.Windows.Documents.FlowDocument> 와 함께 렌더링 <xref:System.Windows.TextAlignment.Left> 텍스트 맞춤 (기본값).  
  
 ![스크린 샷: Left의 TextAlign 속성 값](~/add/media/flowdoc-textalign-left.png "스크린 샷: Left의 TextAlign 속성 값")  
  
 다음 그림에서는 어떻게 동일 <xref:System.Windows.Documents.FlowDocument> 와 함께 렌더링 <xref:System.Windows.TextAlignment.Right> 텍스트 맞춤입니다.  
  
 ![스크린 샷: Right의 TextAlign 값](~/add/media/flowdoc-textalign-right.png "스크린 샷: Right의 TextAlign 값")  
  
 다음 그림에서는 어떻게 동일 <xref:System.Windows.Documents.FlowDocument> 와 함께 렌더링 <xref:System.Windows.TextAlignment.Center> 텍스트 맞춤입니다.  
  
 ![스크린 샷: Center의 TextAlign 속성 값](~/add/media/flowdoc-textalign-center.png "스크린 샷: Center의 TextAlign 속성 값")  
  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.TextAlignment%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentTextAlignment](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumenttextalignment)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentTextAlignment](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumenttextalignment)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.TextAlignment" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextEffects : System.Windows.Media.TextEffectCollection with get, set" Usage="System.Windows.Documents.FlowDocument.TextEffects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 텍스트에 적용할 효과를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Media.TextEffectCollection" />의 텍스트에 적용되는 효과를 정의하는 하나 이상의 <see cref="T:System.Windows.Media.TextEffect" /> 개체가 들어 있는 <see cref="T:System.Windows.Documents.FlowDocument" />입니다. 기본값은 <see langword="null" />(효과가 적용되지 않음)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Documents.FlowDocument.TextEffectsProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.FlowDocument.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextEffectsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.FlowDocument.TextEffectsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.FlowDocument.TextEffects" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.FlowDocument.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Typography : System.Windows.Documents.Typography" Usage="System.Windows.Documents.FlowDocument.Typography" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Documents.FlowDocument" />의 텍스트 콘텐츠에 대해 현재 유효한 입력 체계 변형을 가져옵니다.</summary>
        <value>현재 유효한 입력 체계 변형을 지정하는 <see cref="T:System.Windows.Documents.Typography" /> 개체입니다. 기본 입력 체계 값 목록은 <see cref="T:System.Windows.Documents.Typography" />를 참조하십시오.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Documents.FlowDocument.Typography%2A> 속성에만 적용 됩니다. [!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)] 글꼴입니다. 입력 체계 변형을 variant를 지원 하지 않는 글꼴에서 효과가 없습니다.  이 항목에 대 한 자세한 내용은 참조 하세요. [WPF의 입력 체계](~/docs/framework/wpf/advanced/typography-in-wpf.md)합니다.  
  
   
  
## Examples  
 다음 예제에서는 다양 한 입력 체계 변형을 사용 하 여 설정 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Documents.FlowDocument.Typography%2A> 특성을 <xref:System.Windows.Documents.FlowDocument> 요소입니다.  
  
 [!code-xaml[FlowDocumentSnippets#_FlowDocumentTypographyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_flowdocumenttypographyxaml)]  
  
 다음 예제에서는 다양 한 측면을 설정 하는 방법의 <xref:System.Windows.Documents.FlowDocument.Typography%2A> 속성 프로그래밍 방식으로 합니다.  
  
 [!code-csharp[FlowDocumentSnippets#_FlowDocumentTypography](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_flowdocumenttypography)]
 [!code-vb[FlowDocumentSnippets#_FlowDocumentTypography](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_flowdocumenttypography)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>