<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb5a42730ceec2161b81c946cda56d790062bd5d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37516311" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> 클래스에는 메서드가 시작 응용 프로그램 및 스레드를 중지 하 고 다음과 같이 Windows 메시지를 처리 합니다.  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 현재 스레드에서 응용 프로그램 메시지 루프를 시작 하 고 필요에 따라 표시 되도록 폼을 만듭니다.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 또는 <xref:System.Windows.Forms.Application.ExitThread%2A> 메시지 루프를 중지 합니다.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 루프에서 프로그램은 메시지를 처리 합니다.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Windows 메시지를 모니터링 하는 응용 프로그램 메시지 펌프에 메시지 필터를 추가 합니다.  
  
-   <xref:System.Windows.Forms.IMessageFilter> 이벤트 발생을 중지 하거나 이벤트 처리기를 호출 하기 전에 특별 한 작업을 수행할 수 있습니다.  
  
 이 클래스에 <xref:System.Windows.Forms.Application.CurrentCulture%2A> 고 <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> 문화권 현재 스레드에 대 한 정보를 속성을 가져오거나 설정 합니다.  
  
 이 클래스의 인스턴스를 만들 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작 하려면 `listBox1` 고 `button1`입니다. 클릭할 때 `button1`서 `button1_Click` 메서드 표시는 <xref:System.Windows.Forms.MessageBox>합니다. 클릭 하면 `No` 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 번호를 추가 합니다. 사용자가 클릭 하면 `Yes`, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
> [!NOTE]
>  에 대 한 호출 <xref:System.Windows.Forms.Application.Exit%2A> 부분 신뢰에서 실패 합니다.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</param>
        <summary>Adds a message filter to monitor Windows messages as they are routed to their destinations.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 필터를 사용 하 여 특정 이벤트가 발생 하지 않도록 하려면 하거나 이벤트 처리기에 전달 되기 전에 이벤트에 대 한 특별 한 작업을 수행 합니다. 메시지 필터는 특정 스레드에 고유 합니다.  
  
 메시지에 디스패치되 지 않게 방지 하기 위해 합니다 `value` 이 메서드에 전달 하는 매개 변수 인스턴스를 재정의 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> 메시지를 처리 하는 코드를 사용 하 여 메서드. 이 메서드는 `false`를 반환해야 합니다.  
  
> [!CAUTION]
>  응용 프로그램에 대 한 메시지 펌프에 메시지 필터를 추가 하면 성능이 저하 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 메시지 필터를 만듭니다 `TestMessageFilter`합니다. 이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다. 메시지 필터를 사용 하려면 먼저에 대 한 구현을 제공 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the caller can quit this application.</summary>
        <value>호출자가 해당 응용 프로그램을 끝낼 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 `false` 에서 호출 되 면을 <xref:System.Windows.Forms.Control> 웹 브라우저 내에서 호스팅되고 있습니다. 따라서 합니다 <xref:System.Windows.Forms.Control> 종료할 수 없습니다는 <xref:System.Windows.Forms.Application>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 처리기를 연결 해야 합니다는 <xref:System.Windows.Forms.Application.Exit%2A> 응용 프로그램 실행이 중지 되기 전에 이벤트 처리 되지 않은, 하는 데 필요한 작업입니다. 이 응용 프로그램 또는 가비지 수집 회수 되지 않은 개체를 삭제 하 여 열려 있는 파일을 닫을 수 있습니다.  
  
 이 이벤트에 연결 된 모든 이벤트 처리기를 분리 해야 합니다는 정적 이벤트 이기 때문에 <xref:System.Windows.Forms.Application.ApplicationExit> 자체 이벤트 처리기입니다. 이러한 처리기를 분리 하지 않는 경우 이러한 이벤트에 연결 된 상태로 유지 되며 계속 메모리를 사용 하 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에서는 합니다 <xref:System.Windows.Forms.Application.ApplicationExit> 시점과 폼 위치 파일에 유지 해야 하는 시점을 알아야 하는 이벤트를 `FileStream` 을 닫아야 합니다.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 한 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 경우를 추적 하 고 있습니다. 닫을 때 각 폼의 위치를 기억 하는 클래스입니다. 경우는 <xref:System.Windows.Forms.Application.ApplicationExit> 이벤트가 발생 하면 클래스는 사용자에 대 한 각각의 위치를 파일에 씁니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data that is shared among all users.</summary>
        <value>모든 사용자가 공유하는 응용 프로그램 데이터의 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에이 있는지 확인할 수 있는지 확인 합니다 `AssemblyInformationalVersion` 특성입니다. 이 특성이 존재 하는 경우 둘 다에 대해 사용 됩니다 <xref:System.Windows.Forms.Application.ProductVersion%2A> 고 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>입니다. 이 특성이 없으면 속성을 모두 실행 파일의 버전을 대신 사용 합니다.  
  
 경로 사용 하 여 Windows Forms 응용 프로그램은 배포 여부에 따라 달라 지므로 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 됩니다\\*username* 디렉터리입니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data that is shared among all users.</summary>
        <value>모든 사용자가 공유하는 응용 프로그램 데이터의 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가 없으면 다음 형식으로 만들어집니다.  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the company name associated with the application.</summary>
        <value>회사 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture information for the current thread.</summary>
        <value>현재 스레드에 대한 문화권 정보를 나타내는 <see cref="T:System.Globalization.CultureInfo" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하는 모든 창입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current input language for the current thread.</summary>
        <value>현재 스레드의 현재 입력 언어를 나타내는 <see cref="T:System.Windows.Forms.InputLanguage" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Processes all Windows messages currently in the message queue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 폼을 실행 하면 다음 이벤트 처리를 대기 하는 새 폼을 만듭니다. 폼에 이벤트를 처리할 때마다 해당 이벤트와 연결 된 모든 코드를 처리 합니다. 다른 모든 이벤트는 큐에서 대기 합니다. 코드에서 이벤트를 처리 하는 동안 응용 프로그램이 응답 하지 않습니다. 예를 들어, 다른 창 맨 위에 끌 경우 창 그려지지 않습니다.  
  
 호출 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 응용 프로그램 코드에서 다른 이벤트를 처리할 수 있습니다. 예를 들어, 데이터를 추가 하는 폼이 있어야 하는 경우는 <xref:System.Windows.Forms.ListBox> 추가한 <xref:System.Windows.Forms.Application.DoEvents%2A> 코드에 폼이 다시 그려집니다 다른 창 위로 끌 때. 제거 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 코드에서 폼이 그려집니다 단추의 click 이벤트 처리기가 완료 될 때까지 실행 합니다. 메시징에 대 한 자세한 내용은 참조 하세요. [Windows Forms에 사용자 입력](~/docs/framework/winforms/user-input-in-windows-forms.md)합니다.  
  
 Visual Basic 6.0과 달리 합니다 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 호출 하지 않습니다는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드.  
  
 일반적으로 메시지를 처리 하는 루프에서이 메서드를 사용 합니다.  
  
> [!CAUTION]
>  이 메서드를 호출 하면 현재 스레드가 모든 대기 창 메시지를 처리 하는 동안 일시 중단 합니다. 트리거되지 이벤트가 발생 하는 메시지를 응용 프로그램 코드의 다른 영역 실행할 수 있습니다. 이 인해 응용 프로그램의 디버그 하기 어려운 예기치 않은 동작이 발생할 수 있습니다. 작업이 나 시간이 오래 걸리는 계산을 수행 하는 경우 새 스레드에서 이러한 작업을 수행 하는 것이 좋습니다. 비동기 프로그래밍에 대 한 자세한 내용은 참조 하세요. [비동기 프로그래밍 모델 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드. 예제를 실행 하는 경우 선택할 수 있는 그래픽 파일을 <xref:System.Windows.Forms.OpenFileDialog>입니다. 선택한 파일 형태로 표시 됩니다. <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 사용 하면 그래픽 파일을 열어 각 폼을 다시 그리도록 합니다. 이 예제를 실행 하려면 다음 코드를 포함 하는 폼에 붙여를 <xref:System.Windows.Forms.PictureBox> 라는 `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> 라는 `OpenFileDialog1`, 이라는 단추가 `fileButton`합니다. 호출 된 `InitializePictureBox` 하 고 `InitializeOpenFileDialog` 폼의 생성자에서 메서드 또는 `Load` 메서드.  
  
> [!NOTE]
>  Visual Studio를 추가 하는 경우에 <xref:System.Windows.Forms.OpenFileDialog> 끌기 작업을 사용 하 여 폼에 다음을 수정 해야 `InitializeOpenFileDialog` 의 새 인스턴스를 만드는 줄을 제거 하 여 메서드 <xref:System.Windows.Forms.OpenFileDialog>합니다.  
  
 예제에는 항목을 필요는 <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> 의 이벤트를 <xref:System.Windows.Forms.Button> 컨트롤 및 <xref:System.Windows.Forms.FileDialog.FileOk> 의 이벤트는 <xref:System.Windows.Forms.OpenFileDialog> 예제에 정의 된 이벤트 처리기에 연결 된. 예제를 실행할 때 단추를 클릭 하 여 대화 상자를 표시 합니다.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enables visual styles for the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 응용 프로그램에 대 한 비주얼 스타일을 사용 합니다. 비주얼 스타일 색, 글꼴 및 운영 체제 테마를 구성 하는 기타 시각적 요소 이며 컨트롤 및 운영 체제에서 지 원하는 경우 비주얼 스타일으로 컨트롤을 그립니다. 스타일이 적용 되려면 <xref:System.Windows.Forms.Application.EnableVisualStyles> 응용 프로그램에서 컨트롤을 만들기 전에 호출 해야 합니다 일반적으로 <xref:System.Windows.Forms.Application.EnableVisualStyles> 첫 번째 줄은는 `Main` 함수입니다. 별도 매니페스트를 호출 하는 경우 비주얼 스타일을 사용 하지 않아도 됩니다 <xref:System.Windows.Forms.Application.EnableVisualStyles>합니다.  
  
> [!NOTE]
>  .NET Framework 2.0 이전 합니다 `FlatStyle` 에서 파생 되는 컨트롤과 같은 일부 컨트롤의 속성 <xref:System.Windows.Forms.ButtonBase>로 설정 해야 <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> 비주얼 스타일을 사용 하 여 그릴 컨트롤에 대 한 순서 대로 합니다. .NET Framework 2.0을 사용 하 여 작성 된 응용 프로그램에서 이것이 더 이상 필요 합니다.  
  
> [!NOTE]
>  이 메서드는 Internet Explorer에서 호스팅되는 컨트롤에 대 한 영향을 주지 않습니다 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> 에 `Main` 함수 응용 프로그램에 대 한 비주얼 스타일을 사용 하도록 설정 합니다.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to enter a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 있으므로  클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 있으므로 <xref:System.Windows.Forms.Application.EnterThreadModal> 클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.EnterThreadModal> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">필요한 <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> 이벤트를 대기할 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, including the executable name.</summary>
        <value>응용 프로그램을 시작한 실행 파일의 경로 및 파일 이름입니다.  이 경로 사용 하 여 Windows Forms 응용 프로그램은 배포 여부에 따라 달라 지므로 [! INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]입니다. [! INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 된\\* 사용자 이름 디렉터리입니다. 자세한 내용은 [로컬 및 원격 데이터 액세스 ClickOnce 응용 프로그램에서]를 참조 하세요. (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 경로 가져오는 중입니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 모든 스레드에서 실행 되는 모든 메시지 루프를 중지 하 고 응용 프로그램의 모든 창을 닫습니다. 이 메서드는 응용 프로그램을 종료를 반드시 강제로 되지 않습니다. 합니다 <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 일반적으로 메시지 루프를 강제로 내에서 호출 됩니다 <xref:System.Windows.Forms.Application.Run%2A> 돌아갑니다. 현재 스레드에 대 한 메시지 루프를 종료 하려면 호출 <xref:System.Windows.Forms.Application.ExitThread%2A>합니다.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 다음 이벤트를 발생 하 고 연결된 된 조건부 작업을 수행 합니다.  
  
-   A <xref:System.Windows.Forms.Form.FormClosing> 나타내는 각 폼에 대 한 이벤트가 발생 합니다 <xref:System.Windows.Forms.Application.OpenForms%2A> 속성입니다. 설정 하 여이 이벤트는 취소할 수는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성을 해당 <xref:System.Windows.Forms.FormClosingEventArgs> 매개 변수를 `true`입니다.  
  
-   그런 다음 처리기 중 하나에서 이벤트를 취소 하는 경우 <xref:System.Windows.Forms.Application.Exit%2A> 추가 작업 없이 반환 합니다. 이 고, 그렇지는 <xref:System.Windows.Forms.Form.FormClosed> 열려 있는 모든 폼에 대 한 이벤트는 다음 실행 중인 모든 메시지 루프와 forms 닫힙니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 발생 하지 않습니다는 <xref:System.Windows.Forms.Form.Closed> 및 <xref:System.Windows.Forms.Form.Closing> 의 일부로 사용 되지 않는 이벤트 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 합니다 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작할 `listBox1`, 및 `button1`합니다. 클릭할 때 `button1`는 `button1_Click` 목록 상자에 1 ~ 3 숫자를 추가 하 고 표시 하는 메서드를 <xref:System.Windows.Forms.MessageBox>입니다. 클릭 하면 **No** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다. 사용자가 클릭 하면 **예**, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A>, 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
 이 예제에서는 `listBox1` 및 `button1` 인스턴스화되고 폼에 배치 합니다.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</param>
        <summary>Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">실행을 종료 하는 권한에 대 한 응용 프로그램 스레드입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the message loop on the current thread and closes all windows on the thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 현재 스레드의 메시지 루프를 종료 합니다. 이 메서드를 호출 하면 <xref:System.Windows.Forms.Application.Run%2A> 현재 스레드를 반환 합니다. 전체 응용 프로그램을 종료 하려면 호출 <xref:System.Windows.Forms.Application.Exit%2A>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">The Windows event message to filter.</param>
        <summary>Runs any filters against a window message, and returns a copy of the modified message.</summary>
        <returns>
          <see langword="True" /> if the filters were processed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application finishes processing and is about to enter the idle state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업 수행 해야 하는 경우 스레드가 유휴 상태인 전에이 이벤트에 연결 합니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 있으므로  클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 있으므로 <xref:System.Windows.Forms.Application.Idle> 클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows 폼에 붙여 넣습니다 및 이벤트 처리기와 연결 되었는지 확인 합니다 <xref:System.Windows.Forms.Application.Idle> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the application is about to leave a modal state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 있으므로  클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 있으므로 <xref:System.Windows.Forms.Application.LeaveThreadModal> 클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.LeaveThreadModal> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a local, non-roaming user.</summary>
        <value>로밍 사용자가 아닌 로컬 사용자의 응용 프로그램 데이터 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 사용자는 사용자 프로필이 사용자가 로그온는 시스템에 저장 됩니다. 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 일반적인 기본 경로 C:\Documents and Settings\\*username*settings\application 데이터입니다. 이 경로 다를 수 있지만 Windows Forms 응용 프로그램은 사용 하 여 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 하지만이 예제에서는 합니다 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 사용자에 대 한 응용 프로그램 데이터를 저장 하는 속성을 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> 대신 사용할 수 있습니다.  
  
 합니다 `MyApplicationContext` 클래스에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 간 결함을 위해 일부 코드가 표시 되지 않습니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether a message loop exists on this thread.</summary>
        <value>메시지 루프가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅하는 경우이 속성은 항상 반환 `false`합니다. 사용 하 여 <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> 호스팅 환경에 아직 활성 메시지 루프를 하는 경우 Windows Forms 하도록 지시 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes OLE on the current thread.</summary>
        <returns>One of the <see cref="T:System.Threading.ApartmentState" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 `Microsoft.Win32` OLE를 필요로 하는 메서드. <xref:System.Windows.Forms.Application.OleRequired%2A> 먼저 현재 스레드의 OLE를 초기화 하는 경우를 확인 합니다. 그러지 않으면 OLE에 대 한 스레드를 초기화 합니다.  
  
> [!NOTE]
>  스레드 OLE 메서드를 직접 호출 하지 않으면이 메서드를 호출할 필요가 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Windows.Forms.Application.OnThreadException%2A> 에 응용 프로그램의 처리를 중단 하는 예외가 발생 합니다.  
  
 합니다 <xref:System.Windows.Forms.Application> 클래스에는 <xref:System.Windows.Forms.Application.ThreadException> 이벤트입니다. 처리 되지 않은 예외에 대 한 필요한 사용자 지정 처리를 수행 하기 위해이 이벤트는 이벤트 처리기를 연결할 수 있습니다. 이벤트 처리기를 연결 하지 않는 경우 <xref:System.Windows.Forms.Application.OnThreadException%2A> 오류가 되었음을 사용자에 게 알릴 수 있는 대화 상자를 표시 하는 기본 동작을 실행 합니다.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> Windows Forms를 소유 하는 스레드에서 발생 하는 처리 되지 않은 예외에 대 한 기본 예외 동작을 구현 합니다. 다른 스레드에서 처리 되지 않은 예외를 처리 합니다 <xref:System.AppDomain.UnhandledException> 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of open forms owned by the application.</summary>
        <value>이 응용 프로그램에서 소유하는 현재 열려 있는 폼을 모두 포함하는 <see cref="T:System.Windows.Forms.FormCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> 속성 응용 프로그램에서 소유 하는 폼의 읽기 전용 컬렉션을 나타냅니다. 이 컬렉션 인덱스 위치 또는 검색할 수는 <xref:System.Windows.Forms.Control.Name%2A> 의 <xref:System.Windows.Forms.Form>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">호출자에 게 정의 된 대로 모든 창에 액세스할 수 있는 권한이 있어야 합니다 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> 값을 <see cref="T:System.Security.Permissions.UIPermissionWindow" /> 열거형입니다.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product name associated with this application.</summary>
        <value>제품 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 현재 응용 프로그램의 기본 폼을 포함 하는 어셈블리의 메타 데이터에서 가져옵니다. 설정 하 여 설정할 수 있습니다 <xref:System.Reflection.AssemblyProductAttribute> 어셈블리 매니페스트 내에서. 자세한 내용은 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the product version associated with this application.</summary>
        <value>제품 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 버전 번호를 표시 하는 일반적으로 *수 주*.* 부 번호*.* 빌드 번호*.* 전용 부분 번호*합니다. 어셈블리 매니페스트 내에서 어셈블리 버전을 설정 하 여 명시적으로 설정할 수 있습니다. 자세한 내용은 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)합니다.  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에이 있는지 확인할 수 있는지 확인 합니다 `AssemblyInformationalVersion` 특성입니다. 이 특성이 존재 하는 경우 둘 다에 대해 사용 됩니다 <xref:System.Windows.Forms.Application.ProductVersion%2A> 고 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>입니다. 이 특성이 없으면 속성을 모두 실행 파일의 버전을 대신 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</param>
        <summary>Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅할 때 사용 됩니다. 호출 해야 <xref:System.Windows.Forms.Application.RaiseIdle%2A> 호스팅 응용 프로그램을 유휴 상태로 전환 하는 경우. 이 통해 몇 가지 Windows Forms 컨트롤 및 구성 요소는 사용자가 응용 프로그램 상호 작용 하지 하는 동안 중요 한 백그라운드 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</param>
        <summary>Registers a callback for checking whether the message loop is running in hosted environments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅할 때 사용 됩니다. 호스트 된 환경에서 <xref:System.Windows.Forms.Application.MessageLoop%2A> 속성은 항상 Windows Forms 메시지를 처리 하지 않은 경우 false를 반환 합니다. 이 콜백을 사용 하 여 호스팅 환경에서 아직 메시지를 처리 하는 경우 Windows Forms에 지시 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</param>
        <summary>Removes a message filter from the message pump of the application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 더 이상 Windows 메시지를 디스패치 되기 전에 캡처 하려고 할 때 메시지 필터를 제거할 수 없습니다.  
  
   
  
## Examples  
 메시지 필터를 사용 하려면 먼저에 대 한 구현을 제공 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다. 다음 클래스 호출 메시지 필터를 만들고 `TestMessageFilter`합니다. 이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value specifying whether the current application is drawing controls with visual styles.</summary>
        <value>응용 프로그램 창의 클라이언트 영역에서 컨트롤에 비주얼 스타일이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 컨트롤을 그리는 경우이 속성을 사용 하 여 모양을 응용 프로그램에서 다른 컨트롤과 일관 되도록 비주얼 스타일로 컨트롤을 그릴 것인지를 결정 합니다.  
  
 다음 표에서 대 한 있어야 하는 네 가지 조건이 <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> 반환할 `true`합니다.  
  
|조건|설명|  
|---------------|-----------------|  
|운영 체제에서 비주얼 스타일을 지원합니다.|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.|  
|사용자가 운영 체제에서 비주얼 스타일이 활성화|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.|  
|응용 프로그램에서 비주얼 스타일 사용|<xref:System.Windows.Forms.Application.EnableVisualStyles> 메서드를 호출하여 또는 컨트롤 그리기에 ComCtl32.dll 버전 6 이상을 사용하도록 지정하는 응용 프로그램 매니페스트를 사용하여 응용 프로그램에서 비주얼 스타일을 사용하도록 설정할 수 있습니다.|  
|비주얼 스타일은 응용 프로그램 창의 클라이언트 영역을 그리는 데 사용 되 고|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.Application> 클래스의 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성을 사용하고 값이 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 또는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>인지 확인하세요.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Shuts down the application and starts a new instance immediately.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출에 대 한 가장 일반적인 이유 `Restart` 를 통해 다운로드 한 응용 프로그램의 새 버전을 시작 하는 것 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 사용 하는 `Update` 또는 `UpdateAsync` 메서드.  
  
 응용 프로그램은 처음 실행 된 컨텍스트에서 다시 시작 됩니다. 응용 프로그램의 주 실행 파일을 직접 가리키는 URL을 사용 하 여 응용 프로그램 시작 된 경우 동일한 URL을 사용 하 여 시작할 수 있습니다. 응용 프로그램을 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램을 사용 하 여 다시 시작할 수 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]입니다.  
  
 응용 프로그램이 처음 실행 하는 경우 명령줄 옵션이 제공된 된 경우 <xref:System.Windows.Forms.Application.Restart%2A> 동일한 옵션을 사용 하 여 다시 응용 프로그램을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Your code is not a Windows Forms application. You cannot call this method in this context.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">호출 된 <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> 메서드 두 번 이상 지정된 된 컨트롤에 대 한 지정 하지 컨트롤에 대해 표시할 도구 설명 텍스트를 여러 않지만 대신 현재 컨트롤에 대 한 도구 설명 텍스트를 변경 합니다.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins running a standard application message loop on the current thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins running a standard application message loop on the current thread, without a form.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Win32 기반 또는 Windows Forms 응용 프로그램 메시지 루프는 마우스 클릭과 키보드 입력과 같은 사용자 이벤트를 처리 하는 코드에서 루틴입니다. 모든 실행 중인 Windows 기반 응용 프로그램에는 주 메시지 루프를 호출 하는 활성 메시지 루프에 필요 합니다. 주 메시지 루프가 종료 되 면 응용 프로그램이 종료 됩니다. Windows Forms에서이 루프를 닫을 때 합니다 <xref:System.Windows.Forms.Application.Exit%2A> 메서드를 호출 되거나는 <xref:System.Windows.Forms.Application.ExitThread%2A> 주 메시지 루프를 실행 하는 스레드에서 호출 됩니다.  
  
 대부분의 Windows Forms 개발자는이 버전의 메서드를 사용할 필요가 없습니다. 기능을 사용할지는 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> 오버 로드를 기본 폼이 닫힐 때 응용 프로그램이 종료 되도록 기본 폼을 사용 하 여 응용 프로그램을 시작 합니다. 기타 모든 상황에 대 한 사용 합니다 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> 오버 로드를 제공 하는 것이 지는 <xref:System.Windows.Forms.ApplicationContext> 보다 효과적으로 제어할 응용 프로그램의 수명에 대 한 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</param>
        <summary>Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 루프 실행 될 때까지 <xref:System.Windows.Forms.Application.Exit%2A> 나 <xref:System.Windows.Forms.Application.ExitThread%2A> 라고 또는 <xref:System.Windows.Forms.Application.ThreadExit> 컨텍스트 개체에서 이벤트가 발생 합니다.  
  
   
  
## Examples  
 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.ApplicationContext>, 함께 `Application.Run(context)` 응용 프로그램을 시작 하는 경우 여러 개의 폼을 표시할 메서드.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 에 대 한 코드를 `AppForm1` 고 `AppForm2` 폼 간 결함을 위해 표시 되지 않습니다. 참조 된 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록은 클래스 개요입니다.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on this thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</param>
        <summary>Begins running a standard application message loop on the current thread, and makes the specified form visible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 응용 프로그램의 main 함수는이 메서드를 호출 하 고 응용 프로그램의 주 창에 전달 합니다.  
  
 이 메서드는 이벤트 처리기를 추가 합니다 `mainForm` 에 대 한 매개 변수는 <xref:System.Windows.Forms.Form.Closed> 이벤트입니다. 이벤트 처리기 호출을 <xref:System.Windows.Forms.Application.ExitThread%2A> 응용 프로그램을 정리 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.Control.Dispose%2A> 메서드는 <xref:System.Windows.Forms.Form> 이 메서드를 반환 하기 전에 호출 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 합니다 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작할 `listBox1`, 및 `button1`합니다. 클릭할 때 `button1`는 `button1_Click` 목록 상자에 1 ~ 3 숫자를 추가 하 고 표시 하는 메서드를 <xref:System.Windows.Forms.MessageBox>입니다. 클릭 하면 **No** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다. 사용자가 클릭 하면 **예**, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
 이 예제에서는 `listBox1` 및 `button1` 만들고 폼에 배치 합니다.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A main message loop is already running on the current thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</summary>
        <value>최상위 창 캡션에 적용될 서식 문자열입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하는 모든 창입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">The default value to use for new controls. If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</param>
        <summary>Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특정 Windows Forms 컨트롤 중 하나를 사용 하 여 해당 텍스트를 렌더링할 수는 <xref:System.Windows.Forms.TextRenderer> 기반으로 하는 클래스를 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 그래픽 라이브러리 또는 <xref:System.Drawing.Graphics> 클래스를 기반으로 하는 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 그래픽 라이브러리. 이 변경은 합니다 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 성능과 지역화 문제로 인해 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다. 사용 하 여 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 의 기본값을 설정 하는 `UseCompatibleTextRendering` 지 원하는 컨트롤에 대 한 속성입니다.  
  
 `UseCompatibleTextRendering` 속성을 사용 하 여 렌더링 텍스트는 Windows Forms 컨트롤 간에 시각적 호환성을 제공 합니다 <xref:System.Windows.Forms.TextRenderer> 클래스 및 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 고 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] 를사용하여사용자지정텍스트렌더링을수행하는응용프로그램<xref:System.Drawing.Graphics>클래스입니다. 대부분의 경우 응용 프로그램에서 업그레이드 중이 아님 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 또는 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]를 그대로 두는 것이 좋습니다 `UseCompatibleTextRendering` 기본값인으로 `false`합니다.  
  
 합니다 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 기반 <xref:System.Windows.Forms.TextRenderer> 클래스에 도입 된는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 성능 향상을 위해 텍스트를 좋게 및 국가별 글꼴에 대 한 지원이 향상을 확인 합니다. 이전 버전의 합니다 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]는 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 기반 <xref:System.Drawing.Graphics> 클래스는 모든 텍스트 렌더링을 수행 하는 데 사용 되었습니다. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 문자 간격 및 줄 바꿈 다르게에서 계산 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다. 사용 하는 Windows Forms 응용 프로그램을 <xref:System.Drawing.Graphics> 텍스트를 렌더링 하는 클래스를 사용 하는 컨트롤의 텍스트 발생할 수 있습니다 <xref:System.Windows.Forms.TextRenderer> 응용 프로그램의 다른 텍스트와에서 다르게 표시 합니다. 이러한 호환성 문제를 해결 하려면 설정 합니다 `UseCompatibleTextRendering` 속성을 `true`입니다. 설정 하려면 `UseCompatibleTextRendering` 에 `true` 응용 프로그램에서 모든 지원 되는 컨트롤에 대 한 호출을 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 매개 변수를 사용 하 여 메서드 `true`합니다.  
  
 Windows Forms 코드는 Internet Explorer와 같은 다른 응용 프로그램에서 호스팅되는 경우이 메서드는 호출 하지 말아야 합니다. 만 독립 실행형 Windows Forms 응용 프로그램에서이 메서드를 호출 합니다.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  에 대 한 기본값을 설정 하려면 `UseCompatibleTextRendering` 에 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] 이상 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>합니다.  
  
 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 이상에 대 한 호출 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Program.cs 파일에서 자동으로 생성 됩니다. 텍스트 렌더링 기본값을 변경 하려면 생성된 된 코드를 수정 합니다.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You can only call this method before the first window is created by your Windows Forms application.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</param>
        <param name="force">
          <see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</param>
        <summary>Suspends or hibernates the system, or requests that the system be suspended or hibernated.</summary>
        <returns>
          <see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 20 시간 (초) 내에서 응용 프로그램 일시 중단 요청에 응답 하지 않으면, Windows는 응답이 없는 상태 이므로 응용 프로그램 수 중지 하거나 종료를 결정 합니다. 응용 프로그램을 일시 중단 요청에 응답 한 후 리소스를 정리 하 고 활성 프로세스를 종료 하는 데 필요한 만큼의 시간 걸릴 수 있지만.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <summary>Instructs the application how to respond to unhandled exceptions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 Windows Forms에서 throw 된 예외를 catch 할 수는 없는 경우가 많습니다. 이 메서드를 사용 하 여 Windows Forms 구성 요소에 의해 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부를 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.  
  
 호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.  
  
 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</param>
        <param name="threadScope">
          <see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</param>
        <summary>Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 Windows Forms에서 throw 된 예외를 catch 할 수는 없는 경우가 많습니다. 이 메서드를 사용 하 여 Windows Forms 구성 요소에 의해 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부를 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.  
  
 호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.  
  
 때 `threadScope` 는 `true`, 스레드 예외 모드를 설정 됩니다. 스레드 예외 모드를 사용 하는 경우 응용 프로그램 예외 모드를 재정의 `mode` 로 설정 되지 않은 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>합니다.  
  
 때 `threadScope` 는 `false`, 응용 프로그램 예외 모드가 설정 됩니다. 응용 프로그램 예외 모드는 포함 된 모든 스레드는 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> 모드입니다. 응용 프로그램 예외 모드를 설정 하는 경우에 현재 스레드의 설정은 적용 되지 않습니다.  
  
 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You cannot set the exception mode after the application has created its first window.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the executable file that started the application, not including the executable name.</summary>
        <value>응용 프로그램을 시작한 실행 파일의 경로입니다.  이 경로 사용 하 여 Windows Forms 응용 프로그램은 배포 여부에 따라 달라 지므로 [! INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]입니다. [! INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 된\\* 사용자 이름 디렉터리입니다. 자세한 내용은 [로컬 및 원격 데이터 액세스 ClickOnce 응용 프로그램에서]를 참조 하세요. (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 경로 가져오는 중입니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when an untrapped thread exception is thrown.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 Windows Forms 스레드에서 발생 하는 핸들 그렇지 않으면 처리 되지 않은 예외를 Windows Forms 응용을 프로그램 수 있습니다. 이벤트 처리기를 연결 합니다 <xref:System.Windows.Forms.Application.ThreadException> 알 수 없는 상태에서 응용 프로그램 그대로 두고 이러한 예외를 처리 하는 이벤트입니다. 가능한 경우 예외를 구조적된 예외 처리 블록에서 처리 되어야 합니다.  
  
 이 콜백을 설정 하 여 처리 되지 않은 Windows Forms 스레드 예외에 대 한 사용 되는지 여부를 변경할 수 있습니다 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>합니다. 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
> [!NOTE]
>  이 이벤트가 없는 활성화 누락 됩니다을 보장 하기 위해 연결 해야 호출 하기 전에 처리기 <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>합니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 이벤트 처리기를 추가 하는 경우 관리 되지 않는 코드를 호출 하려면 호출자가 즉시입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread is about to shut down. When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 처리기를 연결 해야 합니다는 <xref:System.Windows.Forms.Application.ThreadExit> 하나를 수행 하는 이벤트 처리 되지 않은, 스레드가 실행을 중지 하기 전에 필수 작업입니다. 이 스레드 또는 가비지 수집기 회수 되지 않은 개체를 삭제 하 여 열려 있는 파일을 닫습니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 있으므로  클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 있으므로 <xref:System.Windows.Forms.Application.ThreadExit> 클래스에서 상속 , 경우에이 속성을 사용할 수 있습니다는  형식과 연결 됩니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.ThreadExit> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the path for the application data of a user.</summary>
        <value>사용자의 응용 프로그램 데이터 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 이 경로에 저장 된 데이터에는 로밍에 사용 되는 사용자 프로필의 일부입니다. 로밍 사용자 네트워크에 둘 이상의 컴퓨터에서 작동합니다. 사용자 프로필 로밍 사용자에 대 한 서버 네트워크에서 유지 되 고 사용자가 로그온 하면 시스템으로 로드 됩니다. 로밍에 대 한 것으로 간주 하는 사용자 프로필에 대 한 운영 체제는 로밍 프로필을 지원 해야 하 고 사용 하도록 설정 해야 합니다.  
  
 일반적인 기본 경로 C:\Documents and Settings\\*username*\Application Data. 이 경로 다를 수 있지만 Windows Forms 응용 프로그램은 사용 하 여 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에서는 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 속성을 사용자에 대 한 응용 프로그램 데이터를 저장 합니다.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 간 결함을 위해 일부 코드가 표시 되지 않습니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the registry key for the application data of a user.</summary>
        <value>사용자의 응용 프로그램 데이터에 대한 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가 없으면 다음 형식으로 만들어집니다.  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 이 키에 저장 된 데이터에는 로밍에 사용 되는 사용자 프로필의 일부입니다. 로밍 사용자 네트워크에 둘 이상의 컴퓨터에서 작동합니다. 사용자 프로필 로밍 사용자에 대 한 서버 네트워크에서 유지 되 고 사용자가 로그온 하면 시스템으로 로드 됩니다. 로밍에 대 한 것으로 간주 하는 사용자 프로필에 대 한 운영 체제는 로밍 프로필을 지원 해야 하 고 사용 하도록 설정 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets whether the wait cursor is used for all open forms of the application.</summary>
        <value>대기 커서가 열려 있는 모든 폼에 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`서 <xref:System.Windows.Forms.Control.UseWaitCursor%2A> 응용 프로그램에서 열려 있는 모든 폼의 속성에 설정할 `true`. 모든 폼이 설정 될 때까지이 호출이 반환 되지 않습니다. 장기 실행 작업을 있고 작업이 여전히 진행 되는 모든 응용 프로그램 폼에 표시 하려는 경우이 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that specifies how visual styles are applied to application windows.</summary>
        <value>
          <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 클라이언트 영역 또는 응용 프로그램 창의 비클라이언트 영역에서 비주얼 스타일 사용 되는지 여부를 결정 합니다. 일반적으로이 속성은 기본 폼의 생성자 내에서 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 중 하나에 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 내에서 값을 <xref:System.Windows.Forms.Control.Click> 에 대 한 이벤트 처리기를 <xref:System.Windows.Forms.Button> 컨트롤. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 열거형입니다.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>