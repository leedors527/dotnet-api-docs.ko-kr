<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="23cf5709c7b9981a55cf02267bf0f36cec7fa6ac" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="7c571-101">응용 프로그램을 시작 및 중지하기 위한 메서드, Windows 메시지를 처리하기 위한 메서드, 응용 프로그램에 대한 정보를 가져오기 위한 속성 등과 같이 응용 프로그램을 관리하기 위한 <see langword="static" /> 메서드 및 속성을 제공합니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7c571-101">Provides <see langword="static" /> methods and properties to manage an application, such as methods to start and stop an application, to process Windows messages, and properties to get information about an application.</span>
      </span>
      <span data-ttu-id="7c571-102">이 클래스는 상속될 수 없습니다.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7c571-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-103"><xref:System.Windows.Forms.Application> 클래스에는 메서드가 시작 하 고 응용 프로그램 및 스레드를 중지 하 고 다음과 같이 Windows 메시지를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-103">The <xref:System.Windows.Forms.Application> class has methods to start and stop applications and threads, and to process Windows messages, as follows:</span></span>  
  
-   <span data-ttu-id="7c571-104"><xref:System.Windows.Forms.Application.Run%2A> 현재 스레드에서 응용 프로그램 메시지 루프를 시작 하 고 필요에 따라으로 폼을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-104"><xref:System.Windows.Forms.Application.Run%2A> starts an application message loop on the current thread and, optionally, makes a form visible.</span></span>  
  
-   <span data-ttu-id="7c571-105"><xref:System.Windows.Forms.Application.Exit%2A> 또는 <xref:System.Windows.Forms.Application.ExitThread%2A> 메시지 루프를 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-105"><xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> stops a message loop.</span></span>  
  
-   <span data-ttu-id="7c571-106"><xref:System.Windows.Forms.Application.DoEvents%2A> 루프에서 프로그램이 동안 메시지를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-106"><xref:System.Windows.Forms.Application.DoEvents%2A> processes messages while your program is in a loop.</span></span>  
  
-   <span data-ttu-id="7c571-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> Windows 메시지를 모니터링 하는 응용 프로그램 메시지 펌프에 메시지 필터를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-107"><xref:System.Windows.Forms.Application.AddMessageFilter%2A> adds a message filter to the application message pump to monitor Windows messages.</span></span>  
  
-   <span data-ttu-id="7c571-108"><xref:System.Windows.Forms.IMessageFilter> 이벤트 발생을 중지 하거나 이벤트 처리기를 호출 하기 전에 특별 한 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-108"><xref:System.Windows.Forms.IMessageFilter> lets you stop an event from being raised or perform special operations before invoking an event handler.</span></span>  
  
 <span data-ttu-id="7c571-109">이 클래스에 <xref:System.Windows.Forms.Application.CurrentCulture%2A> 및 <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> 문화권 현재 스레드에 대 한 정보를 속성을 가져오거나 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-109">This class has <xref:System.Windows.Forms.Application.CurrentCulture%2A> and <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> properties to get or set culture information for the current thread.</span></span>  
  
 <span data-ttu-id="7c571-110">이 클래스의 인스턴스를 만들 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-110">You cannot create an instance of this class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-111">다음 코드 예제에서는 폼의 목록 상자에 숫자를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-111">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="7c571-112">클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-112">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="7c571-113">`Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 생성 하는 응용 프로그램을 시작 하려면 `listBox1` 및 `button1`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-113">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1` and `button1`.</span></span> <span data-ttu-id="7c571-114">사용자가 클릭할 때 `button1`, `button1_Click` 메서드 표시는 <xref:System.Windows.Forms.MessageBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-114">When the user clicks `button1`, the `button1_Click` method displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="7c571-115">사용자가 클릭할 경우 `No` 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-115">If the user clicks `No` on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds a number to the list.</span></span> <span data-ttu-id="7c571-116">사용자가 클릭할 경우 `Yes`, 응용 프로그램 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-116">If the user clicks `Yes`, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-117">에 대 한 호출 <xref:System.Windows.Forms.Application.Exit%2A> 부분 신뢰 환경에서 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-117">The call to <xref:System.Windows.Forms.Application.Exit%2A> will fail in partial trust.</span></span>  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7c571-118">설치하려는<see cref="T:System.Windows.Forms.IMessageFilter" /> 인터페이스를 구현한 것입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-118">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> interface you want to install.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-119">Windows 메시지가 대상 위치로 라우팅될 때 해당 메시지를 모니터링하기 위해 메시지 필터를 추가합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-119">Adds a message filter to monitor Windows messages as they are routed to their destinations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-120">특정 이벤트가 발생 하지 않도록 설정 하려면 또는 이벤트 처리기에 전달 되기 전에 이벤트에 대 한 특별 한 작업을 수행 하는 메시지 필터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-120">Use a message filter to prevent specific events from being raised or to perform special operations for an event before it is passed to an event handler.</span></span> <span data-ttu-id="7c571-121">메시지 필터는 특정 스레드에 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-121">Message filters are unique to a specific thread.</span></span>  
  
 <span data-ttu-id="7c571-122">메시지가 디스패치되 되지 않게 하려면는 `value` 이 메서드에 전달 하는 매개 변수 인스턴스를 재정의 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> 메시지를 처리 하는 코드를 사용 하 여 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-122">To prevent a message from being dispatched, the `value` parameter instance that you pass to this method must override the <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> method with the code to handle the message.</span></span> <span data-ttu-id="7c571-123">이 메서드는 `false`를 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-123">The method must return `false`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-124">응용 프로그램에 대 한 메시지 펌프에 메시지 필터를 추가 하면 성능이 저하 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-124">Adding message filters to the message pump for an application can degrade performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-125">다음 코드 예제에서는 라는 메시지 필터를 만들고 `TestMessageFilter`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-125">The following code example creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="7c571-126">이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-126">This filter blocks all messages relating to the left mouse button.</span></span> <span data-ttu-id="7c571-127">에 대 한 구현을 제공 해야 메시지 필터를 사용 하려면 먼저는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-127">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-128">비관리 코드를 호출할 직접 실행 호출자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-128">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="7c571-129">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-129">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-130">호출자가 해당 응용 프로그램을 끝낼 수 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-130">Gets a value indicating whether the caller can quit this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-131">호출자가 해당 응용 프로그램을 끝낼 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-131">
              <see langword="true" /> if the caller can quit this application; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-132">이 속성은 반환 `false` 에서 호출 되 면는 <xref:System.Windows.Forms.Control> 웹 브라우저 내에서 호스트 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-132">This property returns `false` if it is called from a <xref:System.Windows.Forms.Control> being hosted within a Web browser.</span></span> <span data-ttu-id="7c571-133">따라서는 <xref:System.Windows.Forms.Control> 종료할 수 없습니다는 <xref:System.Windows.Forms.Application>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-133">Thus, the <xref:System.Windows.Forms.Control> cannot quit the <xref:System.Windows.Forms.Application>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-134">응용 프로그램이 종료되려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-134">Occurs when the application is about to shut down.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-135">이벤트 처리기를 연결 해야는 <xref:System.Windows.Forms.Application.Exit%2A> 처리 되지 않은, 수행 하도록 이벤트를 응용 프로그램의 실행이 중지 되기 전에 작업 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-135">You must attach the event handlers to the <xref:System.Windows.Forms.Application.Exit%2A> event to perform unhandled, required tasks before the application stops running.</span></span> <span data-ttu-id="7c571-136">이 응용 프로그램 또는 개체를 가비지 수집이 회수 하지 않은 처리에서 연 파일을 닫을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-136">You can close files opened by this application, or dispose of objects that garbage collection did not reclaim.</span></span>  
  
 <span data-ttu-id="7c571-137">이 이벤트에 연결 된 모든 이벤트 처리기를 분리 해야 정적 이벤트 이기 때문에 <xref:System.Windows.Forms.Application.ApplicationExit> 자체 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-137">Because this is a static event, you must detach any event handlers attached to this event in the <xref:System.Windows.Forms.Application.ApplicationExit> event handler itself.</span></span> <span data-ttu-id="7c571-138">이러한 처리기를 분리 하면 경우 이벤트에 연결 된 상태로 유지는 및 메모리 사용을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-138">If you do not detach these handlers, they will remain attached to the event and continue to consume memory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-139">다음 코드 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-139">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="7c571-140">응용 프로그램 시작 하 고 종료 하는 경우 각 폼의 위치가 기억 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-140">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="7c571-141">사용 하 여 보여 주는이 예제는 <xref:System.Windows.Forms.Application.ApplicationExit> 시점과 폼 위치는 파일에 유지 해야 하는 시점에 대해 알아야 하는 이벤트는 `FileStream` 을 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-141">This example demonstrates using the <xref:System.Windows.Forms.Application.ApplicationExit> event to know when the form positions should be persisted to the file, and when the `FileStream` should be closed.</span></span>  
  
 <span data-ttu-id="7c571-142">클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 한 각 폼 닫혀 있고 모두 있을 때에 현재 스레드를 종료 하는 경우를 추적 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-142">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track of when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="7c571-143">클래스를 닫을 때 각 폼의 위치를 기억 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-143">The class remembers the position of each form when it is closed.</span></span> <span data-ttu-id="7c571-144">경우는 <xref:System.Windows.Forms.Application.ApplicationExit> 이벤트가 발생 하면 클래스 각각에 대 한 사용자의 위치는 파일에 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-144">When the <xref:System.Windows.Forms.Application.ApplicationExit> event occurs, the class writes the positions of each for the user to the file.</span></span> <span data-ttu-id="7c571-145">폼 위치 데이터 파일에 저장 됩니다 `appdata.txt` 의해 결정 된 위치에 만들어진 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-145">The form position data is stored in a file titled `appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-146">`Main` 메서드 호출 `Application.Run(context)` 제공 된 응용 프로그램을 시작 하는 <xref:System.Windows.Forms.ApplicationContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-146">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="7c571-147">이 코드에 표시 된 예의 일부는는 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-147">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="7c571-148">참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-148">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-149">모든 사용자가 공유하는 응용 프로그램 데이터의 경로를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-149">Gets the path for the application data that is shared among all users.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-150">모든 사용자가 공유하는 응용 프로그램 데이터의 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-150">The path for the application data that is shared among all users.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-151">경로가 존재 하지 않을 경우 다음과 같은 형식에는 하나이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-151">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="7c571-152">*기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="7c571-152">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="7c571-153"><xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에 있는지 확인할 수 있는지 확인은 `AssemblyInformationalVersion` 특성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-153"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="7c571-154">둘 다에 대해 사용 되는이 특성이 존재 하면 <xref:System.Windows.Forms.Application.ProductVersion%2A> 및 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-154">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-155">이 특성이 없는 경우 두 속성 대신 실행 파일의 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-155">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
 <span data-ttu-id="7c571-156">경로 사용 하 여 Windows Forms 응용 프로그램은 배포 여부에 따라 달라 집니다 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-156">The path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="7c571-157"> 응용 프로그램 C:\Documents and Settings에 사용자별으로 응용 프로그램 캐시에 저장 된\\*username* 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-157"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span> <span data-ttu-id="7c571-158">자세한 내용은 참조 [로컬 액세스 및 ClickOnce 응용 프로그램의 원격 데이터](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-158">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-159">모든 사용자가 공유하는 응용 프로그램 데이터의 레지스트리 키를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-159">Gets the registry key for the application data that is shared among all users.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-160">모든 사용자가 공유하는 응용 프로그램 데이터의 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-160">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key of the application data that is shared among all users.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-161">키가 없는 경우 다음 형식으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-161">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="7c571-162">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="7c571-162">LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-163">응용 프로그램과 관련된 회사 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-163">Gets the company name associated with the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-164">회사 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-164">The company name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7c571-165">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-165">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-166">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-166">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-167">현재 스레드에 대한 문화권 정보를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-167">Gets or sets the culture information for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-168">현재 스레드에 대한 문화권 정보를 나타내는 <see cref="T:System.Globalization.CultureInfo" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-168">A <see cref="T:System.Globalization.CultureInfo" /> representing the culture information for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7c571-169">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-169">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-170">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-170">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="7c571-171">이 속성을 설정 하는 모든 창입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-171">for all windows to set this property.</span>
          </span>
          <span data-ttu-id="7c571-172">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-172">Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-173">현재 스레드의 현재 입력 언어를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-173">Gets or sets the current input language for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-174">현재 스레드의 현재 입력 언어를 나타내는 <see cref="T:System.Windows.Forms.InputLanguage" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-174">An <see cref="T:System.Windows.Forms.InputLanguage" /> representing the current input language for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7c571-175">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-175">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-176">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-176">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-177">비관리 코드를 호출할 직접 실행 호출자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-177">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="7c571-178">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-178">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-179">현재 메시지 큐에 있는 모든 Windows 메시지를 처리합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-179">Processes all Windows messages currently in the message queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-180">Windows Form을 실행 하면 다음 이벤트를 처리할 때까지 대기 하는 새 양식을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-180">When you run a Windows Form, it creates the new form, which then waits for events to handle.</span></span> <span data-ttu-id="7c571-181">폼에 이벤트를 처리할 때마다 해당 이벤트와 연결 된 모든 코드를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-181">Each time the form handles an event, it processes all the code associated with that event.</span></span> <span data-ttu-id="7c571-182">다른 모든 이벤트는 큐에서 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-182">All other events wait in the queue.</span></span> <span data-ttu-id="7c571-183">코드에서 이벤트를 처리 하는 동안 응용 프로그램 응답 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-183">While your code handles the event, your application does not respond.</span></span> <span data-ttu-id="7c571-184">예를 들어 다른 창 맨 위로 끌면 경우 창이 그려지지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-184">For example, the window does not repaint if another window is dragged on top.</span></span>  
  
 <span data-ttu-id="7c571-185">호출 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 응용 프로그램 코드에서 다른 이벤트를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-185">If you call <xref:System.Windows.Forms.Application.DoEvents%2A> in your code, your application can handle the other events.</span></span> <span data-ttu-id="7c571-186">예를 들어, 데이터를 추가 하는 폼을 사용 하는 경우는 <xref:System.Windows.Forms.ListBox> 추가 <xref:System.Windows.Forms.Application.DoEvents%2A> 코드에 폼이 다시 그려집니다 다른 창 위로 끌 때.</span><span class="sxs-lookup"><span data-stu-id="7c571-186">For example, if you have a form that adds data to a <xref:System.Windows.Forms.ListBox> and add <xref:System.Windows.Forms.Application.DoEvents%2A> to your code, your form repaints when another window is dragged over it.</span></span> <span data-ttu-id="7c571-187">제거 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 사용자 코드에서 폼이 그려집니다 단추의 click 이벤트 처리기가 완료 될 때까지 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-187">If you remove <xref:System.Windows.Forms.Application.DoEvents%2A> from your code, your form will not repaint until the click event handler of the button is finished executing.</span></span> <span data-ttu-id="7c571-188">메시징에 대 한 자세한 내용은 참조 하십시오. [Windows Forms에 사용자 입력](~/docs/framework/winforms/user-input-in-windows-forms.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-188">For more information on messaging, see [User Input in Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).</span></span>  
  
 <span data-ttu-id="7c571-189">Visual Basic 6.0과 달리는 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 호출 하지 않습니다는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-189">Unlike Visual Basic 6.0, the <xref:System.Windows.Forms.Application.DoEvents%2A> method does not call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7c571-190">일반적으로 메시지를 처리 하는 루프에서이 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-190">Typically, you use this method in a loop to process messages.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-191">이 메서드를 호출 하면 현재 스레드가 모든 대기 중인 창 메시지를 처리 하는 동안 일시 중단 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-191">Calling this method causes the current thread to be suspended while all waiting window messages are processed.</span></span> <span data-ttu-id="7c571-192">메시지로 인해 시작 옵션으로 이벤트를 응용 프로그램 코드의 다른 영역 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-192">If a message causes an event to be triggered, then other areas of your application code may execute.</span></span> <span data-ttu-id="7c571-193">이 인해 응용 프로그램을 디버그 하기 어려운 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-193">This can cause your application to exhibit unexpected behaviors that are difficult to debug.</span></span> <span data-ttu-id="7c571-194">연산 또는 시간이 오래 걸리는 계산을 수행 하면 것이 새 스레드에 대해 작업을 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-194">If you perform operations or computations that take a long time, it is often preferable to perform those operations on a new thread.</span></span> <span data-ttu-id="7c571-195">비동기 프로그래밍에 대 한 자세한 내용은 참조 [비동기 프로그래밍 모델 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-195">For more information about asynchronous programming, see [Asynchronous Programming Model (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-196">다음 코드 예제는 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-196">The following code example demonstrates using the <xref:System.Windows.Forms.Application.DoEvents%2A> method.</span></span> <span data-ttu-id="7c571-197">예제를 실행 하는 경우 선택할 수 있는 그래픽 파일에서는 <xref:System.Windows.Forms.OpenFileDialog>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-197">When the example runs, a user can select graphics files from an <xref:System.Windows.Forms.OpenFileDialog>.</span></span> <span data-ttu-id="7c571-198">선택한 파일은 폼에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-198">The selected files are displayed in the form.</span></span> <span data-ttu-id="7c571-199"><xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 사용 하면 열려 있는 각 그래픽 파일에 대 한 폼의 다시 그리기 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-199">The <xref:System.Windows.Forms.Application.DoEvents%2A> method forces a repaint of the form for each graphics file opened.</span></span> <span data-ttu-id="7c571-200">이 예제를 실행 하려면 포함 된 폼에 다음 코드를 붙여넣습니다는 <xref:System.Windows.Forms.PictureBox> 라는 `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> 라는 `OpenFileDialog1`, 이라는 버튼 `fileButton`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-200">To run this example, paste the following code in a form containing a <xref:System.Windows.Forms.PictureBox> named `PictureBox1`, an <xref:System.Windows.Forms.OpenFileDialog> named `OpenFileDialog1`, and a button named `fileButton`.</span></span> <span data-ttu-id="7c571-201">호출 된 `InitializePictureBox` 및 `InitializeOpenFileDialog` 폼의 생성자에서 메서드 또는 `Load` 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-201">Call the `InitializePictureBox` and `InitializeOpenFileDialog` methods from the form's constructor or `Load` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-202">[!INCLUDE[vsprvs](~/includes/vsprvs-md.md)]추가 하는 경우, 한 <xref:System.Windows.Forms.OpenFileDialog> 끌기 작업을 사용 하 여 폼에 다음을 수정 해야 합니다 `InitializeOpenFileDialog` 의 새 인스턴스를 만드는 줄을 제거 하 여 메서드 <xref:System.Windows.Forms.OpenFileDialog>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-202">In [!INCLUDE[vsprvs](~/includes/vsprvs-md.md)], if you add an <xref:System.Windows.Forms.OpenFileDialog> to your form by using a drag operation, you will have to modify the following `InitializeOpenFileDialog` method by removing the line that creates a new instance of <xref:System.Windows.Forms.OpenFileDialog>.</span></span>  
  
 <span data-ttu-id="7c571-203">이 예제에서는 필요는 <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> 의 이벤트는 <xref:System.Windows.Forms.Button> 제어 및 <xref:System.Windows.Forms.FileDialog.FileOk> 의 이벤트는 <xref:System.Windows.Forms.OpenFileDialog> 예제에 정의 된 이벤트 처리기에 연결 되어 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-203">The example also requires that the <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> event of the <xref:System.Windows.Forms.Button> control and the <xref:System.Windows.Forms.FileDialog.FileOk> event of the <xref:System.Windows.Forms.OpenFileDialog> are connected to the event handlers defined in the example.</span></span> <span data-ttu-id="7c571-204">이 예제를 실행할 때 단추를 클릭 하 여 대화 상자를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-204">When the example is running, display the dialog box by clicking the button.</span></span>  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-205">응용 프로그램에 비주얼 스타일을 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-205">Enables visual styles for the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-206">이 메서드는 응용 프로그램에 대 한 비주얼 스타일을 활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-206">This method enables visual styles for the application.</span></span> <span data-ttu-id="7c571-207">비주얼 스타일 색, 글꼴 및 운영 체제 테마를 구성 하는 기타 시각적 요소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-207">Visual styles are the colors, fonts, and other visual elements that form an operating system theme.</span></span> <span data-ttu-id="7c571-208">컨트롤 및 운영 체제에서 지 원하는 경우 비주얼 스타일으로 컨트롤을 그립니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-208">Controls will draw with visual styles if the control and the operating system support it.</span></span> <span data-ttu-id="7c571-209">스타일이 적용 되려면 <xref:System.Windows.Forms.Application.EnableVisualStyles> 응용 프로그램에 컨트롤을 만들기 전에 호출 해야 일반적으로 <xref:System.Windows.Forms.Application.EnableVisualStyles> 의 첫 번째 줄은는 `Main` 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-209">To have an effect, <xref:System.Windows.Forms.Application.EnableVisualStyles> must be called before creating any controls in the application; typically, <xref:System.Windows.Forms.Application.EnableVisualStyles> is the first line in the `Main` function.</span></span> <span data-ttu-id="7c571-210">별도 매니페스트를 호출할 때 비주얼 스타일을 사용 하지 않아도 됩니다 <xref:System.Windows.Forms.Application.EnableVisualStyles>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-210">A separate manifest is not required to enable visual styles when calling <xref:System.Windows.Forms.Application.EnableVisualStyles>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-211">.NET Framework 2.0 이전 버전의 `FlatStyle` 에서 파생 되는 컨트롤과 같은 일부 컨트롤의 속성 <xref:System.Windows.Forms.ButtonBase>로 설정 해야 할 <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> 컨트롤을 비주얼 스타일으로 그리기 위해.</span><span class="sxs-lookup"><span data-stu-id="7c571-211">Prior to the .NET Framework 2.0, the `FlatStyle` property of some controls, such as controls that derive from <xref:System.Windows.Forms.ButtonBase>, had to be set to <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> in order for the controls to be drawn with visual styles.</span></span> <span data-ttu-id="7c571-212">.NET Framework 2.0으로 작성 된 응용 프로그램에서는 이것이 더 이상 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-212">In applications written with the .NET Framework 2.0, this is no longer necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-213">이 메서드는 Internet Explorer에서 호스팅되는 컨트롤에 대 한 영향을 주지 않습니다 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-213">This method will have no effect for controls hosted in Internet Explorer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-214">다음 코드 예제에서는 호출 <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> 에 `Main` 함수를 응용 프로그램에 대 한 비주얼 스타일을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-214">The following code example demonstrates calling <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> in the `Main` function to enable visual styles for the application.</span></span>  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-215">응용 프로그램이 모달 상태로 전환되려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-215">Occurs when the application is about to enter a modal state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-216">정적 이벤트 이기 때문에 메모리 누수가 발생 하거나 응용 프로그램이 삭제 될 때 이벤트 처리기를 분리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-216">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-217">다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-217">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="7c571-218">예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Application.EnterThreadModal> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-218">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span> <span data-ttu-id="7c571-219">이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-219">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="7c571-220">자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-220">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="7c571-221">예제 코드를 실행 하려면 Windows Forms에 붙여 넣고 이벤트 처리기가 연결 확인는 <xref:System.Windows.Forms.Application.EnterThreadModal> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-221">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.EnterThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-222">필요한 <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> 이벤트를 수신할 수 있는 권한이 있습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-222">Requires <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> permission to listen to the event.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-223">응용 프로그램을 시작한 실행 파일의 경로(실행 파일 이름 포함)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-223">Gets the path for the executable file that started the application, including the executable name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-224">응용 프로그램을 시작한 실행 파일의 경로 및 파일 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-224">The path and executable name for the executable file that started the application.</span>
          </span>
          <span data-ttu-id="7c571-225">이 경로는 Windows Forms 응용 프로그램이 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]를 사용하여 배포되는지 여부에 따라 달라집니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-225">This path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span>
          </span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="7c571-226"> 응용 프로그램 C:\Documents and Settings에 사용자별으로 응용 프로그램 캐시에 저장 된\\*username* 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-226"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span><span data-ttu-id="7c571-227">자세한 내용은 참조 [로컬 액세스 및 ClickOnce 응용 프로그램의 원격 데이터](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-227">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="7c571-228">에 경로 가져오는 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-228">for getting the path.</span>
          </span>
          <span data-ttu-id="7c571-229">연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-229">Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-230">모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-230">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-231">모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-231">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-232"><xref:System.Windows.Forms.Application.Exit%2A> 메서드는 모든 스레드에서 실행 중인 모든 메시지 루프를 중지 하 고 응용 프로그램의 모든 창을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-232">The <xref:System.Windows.Forms.Application.Exit%2A> method stops all running message loops on all threads and closes all windows of the application.</span></span> <span data-ttu-id="7c571-233">이 메서드는 응용 프로그램 종료를 반드시 강제로 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-233">This method does not necessarily force the application to exit.</span></span> <span data-ttu-id="7c571-234"><xref:System.Windows.Forms.Application.Exit%2A> 메시지 루프 및 힘 내에서 메서드는 일반적으로 호출 <xref:System.Windows.Forms.Application.Run%2A> 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-234">The <xref:System.Windows.Forms.Application.Exit%2A> method is typically called from within a message loop, and forces <xref:System.Windows.Forms.Application.Run%2A> to return.</span></span> <span data-ttu-id="7c571-235">현재 스레드에 대 한 메시지 루프를 종료 하려면 호출 <xref:System.Windows.Forms.Application.ExitThread%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-235">To exit a message loop for the current thread only, call <xref:System.Windows.Forms.Application.ExitThread%2A>.</span></span>  
  
 <span data-ttu-id="7c571-236"><xref:System.Windows.Forms.Application.Exit%2A> 다음 이벤트를 발생 시키고 연결된 된 조건부 작업을 수행:</span><span class="sxs-lookup"><span data-stu-id="7c571-236"><xref:System.Windows.Forms.Application.Exit%2A> raises the following events and performs the associated conditional actions:</span></span>  
  
-   <span data-ttu-id="7c571-237">A <xref:System.Windows.Forms.Form.FormClosing> 나타내는 각 폼에 대 한 이벤트는 <xref:System.Windows.Forms.Application.OpenForms%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-237">A <xref:System.Windows.Forms.Form.FormClosing> event is raised for every form represented by the <xref:System.Windows.Forms.Application.OpenForms%2A> property.</span></span> <span data-ttu-id="7c571-238">설정 하 여이 이벤트는 취소할 수는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성의 해당 <xref:System.Windows.Forms.FormClosingEventArgs> 매개 변수를 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-238">This event can be canceled by setting the <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> property of their <xref:System.Windows.Forms.FormClosingEventArgs> parameter to `true`.</span></span>  
  
-   <span data-ttu-id="7c571-239">다음 중 하나 이상의 처리기에서 이벤트를 취소 하는 경우 <xref:System.Windows.Forms.Application.Exit%2A> 추가 작업 없이 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-239">If one of more of the handlers cancels the event, then <xref:System.Windows.Forms.Application.Exit%2A> returns without further action.</span></span> <span data-ttu-id="7c571-240">그렇지 않은 경우는 <xref:System.Windows.Forms.Form.FormClosed> 열린 모든 폼에 대 한 이벤트는 다음 실행 중인 모든 메시지 루프와 forms 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-240">Otherwise, a <xref:System.Windows.Forms.Form.FormClosed> event is raised for every open form, then all running message loops and forms are closed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-241"><xref:System.Windows.Forms.Application.Exit%2A> 메서드 발생 하지 않습니다는 <xref:System.Windows.Forms.Form.Closed> 및 <xref:System.Windows.Forms.Form.Closing> 이벤트는의 일부로 사용 되지 않으므로 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-241">The <xref:System.Windows.Forms.Application.Exit%2A> method does not raise the <xref:System.Windows.Forms.Form.Closed> and <xref:System.Windows.Forms.Form.Closing> events, which are obsolete as of [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-242">다음 코드 예제에서는 폼의 목록 상자에 숫자를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-242">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="7c571-243">클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-243">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="7c571-244">`Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 생성 하는 응용 프로그램을 시작 하려면 `listBox1`, 및 `button1`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-244">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="7c571-245">사용자가 클릭할 때 `button1`, `button1_Click` 숫자 목록 상자에 1 ~ 3을 추가 하 고 표시 하는 메서드는 <xref:System.Windows.Forms.MessageBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-245">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="7c571-246">사용자가 클릭할 경우 **아니요** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-246">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="7c571-247">사용자가 클릭할 경우 **예**, 응용 프로그램 호출 <xref:System.Windows.Forms.Application.Exit%2A>, 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-247">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A>, to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="7c571-248">예제를 실행 하려면 `listBox1` 및 `button1` 인스턴스화되고 폼에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-248">The example requires that `listBox1` and `button1` have been instantiated and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-249">비관리 코드를 호출할 직접 실행 호출자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-249">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="7c571-250">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-250">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="7c571-251">응용 프로그램 내의 <see cref="T:System.Windows.Forms.Form" />이 종료를 취소했는지 여부를 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-251">Returns whether any <see cref="T:System.Windows.Forms.Form" /> within the application cancelled the exit.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-252">모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-252">Informs all message pumps that they must terminate, and then closes all application windows after the messages have been processed.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">
          <span data-ttu-id="7c571-253">실행을 종료 하는 권한에 대 한 응용 프로그램 스레드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-253">For permission to terminate a running application thread.</span>
          </span>
          <span data-ttu-id="7c571-254">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-254">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-255">현재 스레드의 메시지 루프를 종료하고 스레드의 모든 창을 닫습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-255">Exits the message loop on the current thread and closes all windows on the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-256">이 메서드를 사용 하 여 현재 스레드의 메시지 루프를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-256">Use this method to exit the message loop of the current thread.</span></span> <span data-ttu-id="7c571-257">이 메서드를 호출을 사용 하면 <xref:System.Windows.Forms.Application.Run%2A> 현재 스레드를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-257">This method causes the call to <xref:System.Windows.Forms.Application.Run%2A> for the current thread to return.</span></span> <span data-ttu-id="7c571-258">전체 응용 프로그램을 종료 하려면 호출 <xref:System.Windows.Forms.Application.Exit%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-258">To exit the entire application, call <xref:System.Windows.Forms.Application.Exit%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-259">비관리 코드를 호출할 직접 실행 호출자입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-259">for the immediate caller to call unmanaged code.</span>
          </span>
          <span data-ttu-id="7c571-260">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">
          <span data-ttu-id="7c571-261">필터링할 Windows 이벤트 메시지입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-261">The Windows event message to filter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-262">창 메시지에 대한 필터를 실행하고 수정된 메시지의 복사본을 반환합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-262">Runs any filters against a window message, and returns a copy of the modified message.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7c571-263">필터가 처리되었으면 <see langword="True" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-263">
              <see langword="True" /> if the filters were processed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-264">응용 프로그램이 처리를 끝내고 유휴 상태가 되려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-264">Occurs when the application finishes processing and is about to enter the idle state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-265">수행 해야 하는 작업이 있는 경우 스레드가 유휴 상태가, 전에이 이벤트에 첨부 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-265">If you have tasks that you must perform before the thread becomes idle, attach them to this event.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-266">정적 이벤트 이기 때문에 메모리 누수가 발생 하거나 응용 프로그램이 삭제 될 때 이벤트 처리기를 분리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-266">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-267">다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-267">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="7c571-268">예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Application.Idle> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-268">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.Idle> event.</span></span> <span data-ttu-id="7c571-269">이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-269">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="7c571-270">자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-270">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="7c571-271">예제 코드를 실행 하려면 Windows Form에 붙여 넣고 이벤트 처리기와 연결 되어 있는지 확인은 <xref:System.Windows.Forms.Application.Idle> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-271">To run the example code, paste it into a Windows Form and make sure that the event handler is associated with the <xref:System.Windows.Forms.Application.Idle> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-272">응용 프로그램이 모달 상태에서 벗어나려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-272">Occurs when the application is about to leave a modal state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-273">정적 이벤트 이기 때문에 메모리 누수가 발생 하거나 응용 프로그램이 삭제 될 때 이벤트 처리기를 분리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-273">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-274">다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-274">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="7c571-275">예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Application.LeaveThreadModal> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-275">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span> <span data-ttu-id="7c571-276">이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-276">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="7c571-277">자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-277">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="7c571-278">예제 코드를 실행 하려면 Windows Forms에 붙여 넣고 이벤트 처리기가 연결 확인는 <xref:System.Windows.Forms.Application.LeaveThreadModal> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-278">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.LeaveThreadModal> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-279">로밍 사용자가 아닌 로컬 사용자의 응용 프로그램 데이터 경로를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-279">Gets the path for the application data of a local, non-roaming user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-280">로밍 사용자가 아닌 로컬 사용자의 응용 프로그램 데이터 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-280">The path for the application data of a local, non-roaming user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-281">로컬 사용자가 하나 사용자 프로필이 사용자가 로그온에 시스템에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-281">A local user is one whose user profile is stored on the system on which the user logged on.</span></span> <span data-ttu-id="7c571-282">경로가 존재 하지 않을 경우 다음과 같은 형식에는 하나이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-282">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="7c571-283">*기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="7c571-283">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="7c571-284">일반적인 기본 경로 C:\Documents and 설정을\\*username*\local 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-284">A typical base path is C:\Documents and Settings\\*username*\Local Settings\Application Data.</span></span> <span data-ttu-id="7c571-285">그러나이 경로 다를 수,를 사용 하 여 Windows Forms 응용 프로그램 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-285">This path will be different, however, if the Windows Forms application is deployed by using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="7c571-286"> 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-286"> creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="7c571-287">자세한 내용은 참조 [로컬 액세스 및 ClickOnce 응용 프로그램의 원격 데이터](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-287">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-288">다음 코드 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-288">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="7c571-289">응용 프로그램 시작 하 고 종료 하는 경우 각 폼의 위치가 기억 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-289">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="7c571-290">하지만이 예제를 사용 하 여 보여 줍니다.는 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 사용자에 대 한 응용 프로그램 데이터를 저장 하는 속성의 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-290">Although this example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user, the <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> can be used instead.</span></span>  
  
 <span data-ttu-id="7c571-291">`MyApplicationContext` 클래스에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 모두 있을 때에 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-291">The `MyApplicationContext` class inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="7c571-292">이 클래스는 사용자에 대 한 각 폼의 위치를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-292">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="7c571-293">폼 위치 데이터 파일에 저장 됩니다 `Appdata.txt` 의해 결정 된 위치에 만들어진 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-293">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-294">`Main` 메서드 호출 `Application.Run(context)` 제공 된 응용 프로그램을 시작 하는 <xref:System.Windows.Forms.ApplicationContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-294">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="7c571-295">이 코드에 표시 된 예의 일부는는 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-295">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="7c571-296">일부 코드는 간단 하 게 나타내기 위해 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-296">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="7c571-297">참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-297">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-298">이 스레드에 메시지 루프가 있는지 여부를 나타내는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-298">Gets a value indicating whether a message loop exists on this thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-299">메시지 루프가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-299">
              <see langword="true" /> if a message loop exists; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-300">관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅하는 경우이 속성은 항상 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-300">When hosting Windows Forms in other environments, such as unmanaged applications, this property will always return `false`.</span></span> <span data-ttu-id="7c571-301">사용 하 여 <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> 에 대 한 호스팅 환경에 아직 활성 메시지 경우 Windows Forms 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-301">Use <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> to instruct Windows Forms if the hosting environment still has an active message loop.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-302">현재 스레드의 OLE를 초기화합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-302">Initializes OLE on the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7c571-303">
            <see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-303">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-304">이 메서드를 호출 하기 전에 호출 `Microsoft.Win32` OLE를 필요로 하는 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-304">Call this method before calling any `Microsoft.Win32` method that requires OLE.</span></span> <span data-ttu-id="7c571-305"><xref:System.Windows.Forms.Application.OleRequired%2A> 먼저 현재 스레드의 OLE를 초기화 하는 경우를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-305"><xref:System.Windows.Forms.Application.OleRequired%2A> first checks to see if OLE has been initialized on the current thread.</span></span> <span data-ttu-id="7c571-306">파일이 없으면 OLE에 대 한 스레드를 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-306">If not, it initializes the thread for OLE.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-307">스레드가 OLE 메서드를 직접 호출 하지 않으면이 메서드를 호출할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-307">Unless a thread calls OLE methods directly, you do not need to call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">
          <span data-ttu-id="7c571-308">throw된 예외를 나타내는 <see cref="T:System.Exception" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-308">An <see cref="T:System.Exception" /> that represents the exception that was thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-309">
            <see cref="E:System.Windows.Forms.Application.ThreadException" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-309">Raises the <see cref="E:System.Windows.Forms.Application.ThreadException" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-310">호출 <xref:System.Windows.Forms.Application.OnThreadException%2A> 를 응용 프로그램의 처리를 중단 하는 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-310">Call <xref:System.Windows.Forms.Application.OnThreadException%2A> to raise an exception that will halt processing of the application.</span></span>  
  
 <span data-ttu-id="7c571-311"><xref:System.Windows.Forms.Application> 클래스에는 <xref:System.Windows.Forms.Application.ThreadException> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-311">The <xref:System.Windows.Forms.Application> class has a <xref:System.Windows.Forms.Application.ThreadException> event.</span></span> <span data-ttu-id="7c571-312">처리 되지 않은 예외에 대 한 필요한 사용자 지정 처리를 수행 하기 위해이 이벤트는 이벤트 처리기를 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-312">You can attach an event handler to this event to do whatever custom processing you need for unhandled exceptions.</span></span> <span data-ttu-id="7c571-313">이벤트 처리기를 연결 하지 않는 경우 <xref:System.Windows.Forms.Application.OnThreadException%2A> 오류가 발생 했음을 사용자에 게 알리기 위해 대화 상자를 표시 하는 기본 동작을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-313">If you do not attach an event handler, <xref:System.Windows.Forms.Application.OnThreadException%2A> will execute the default behavior, which involves displaying a dialog box to inform the user that there has been an error.</span></span>  
  
 <span data-ttu-id="7c571-314"><xref:System.Windows.Forms.Application.OnThreadException%2A> Windows Forms에서 소유 하는 스레드에서 발생 하는 처리 되지 않은 예외에 대 한 기본 예외 동작을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-314"><xref:System.Windows.Forms.Application.OnThreadException%2A> only implements default exception behavior for unhandled exceptions that occur on threads owned by Windows Forms.</span></span> <span data-ttu-id="7c571-315">다른 스레드에서 처리 되지 않은 예외를 처리는 <xref:System.AppDomain.UnhandledException> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-315">Unhandled exceptions on other threads are handled by the <xref:System.AppDomain.UnhandledException> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-316">응용 프로그램에서 소유한 열려 있는 폼의 컬렉션을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-316">Gets a collection of open forms owned by the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-317">이 응용 프로그램에서 소유하는 현재 열려 있는 폼을 모두 포함하는 <see cref="T:System.Windows.Forms.FormCollection" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-317">A <see cref="T:System.Windows.Forms.FormCollection" /> containing all the currently open forms owned by this application.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-318"><xref:System.Windows.Forms.Application.OpenForms%2A> 속성 응용 프로그램에서 소유 하는 폼의 읽기 전용 컬렉션을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-318">The <xref:System.Windows.Forms.Application.OpenForms%2A> property represents a read-only collection of forms owned by the application.</span></span> <span data-ttu-id="7c571-319">이 컬렉션을 검색 하는 인덱스 위치 또는 <xref:System.Windows.Forms.Control.Name%2A> 의 <xref:System.Windows.Forms.Form>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-319">This collection can be searched by index position or by the <xref:System.Windows.Forms.Control.Name%2A> of the <xref:System.Windows.Forms.Form>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="7c571-320">호출자에 게에 정의 된 대로 모든 창에 액세스할 수 있는 권한이 있어야는 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> 의 값은 <see cref="T:System.Security.Permissions.UIPermissionWindow" /> 열거형입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-320">Caller must have permission to access all windows, as defined by the <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> value of the <see cref="T:System.Security.Permissions.UIPermissionWindow" /> enumeration.</span>
          </span>
        </permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-321">이 응용 프로그램과 관련된 제품 이름을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-321">Gets the product name associated with this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-322">제품 이름입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-322">The product name.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-323">`ProductName` 현재 응용 프로그램의 기본 폼을 포함 하는 어셈블리의 메타 데이터에서 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-323">`ProductName` is taken from the metadata of the assembly containing the main form of the current application.</span></span> <span data-ttu-id="7c571-324">설정 하 여 설정할 수 있습니다 <xref:System.Reflection.AssemblyProductAttribute> 어셈블리 매니페스트 내에서.</span><span class="sxs-lookup"><span data-stu-id="7c571-324">You can set it by setting <xref:System.Reflection.AssemblyProductAttribute> inside of your assembly manifest.</span></span> <span data-ttu-id="7c571-325">자세한 내용은 참조 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-325">For more information, see [Assembly Manifest](~/docs/framework/app-domains/assembly-manifest.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-326">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-326">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-327">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-327">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-328">이 응용 프로그램과 관련된 제품 버전을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-328">Gets the product version associated with this application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-329">제품 버전입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-329">The product version.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-330">으로 버전 번호를 표시 하는 일반적으로 *수 주*.* 부 번호*.* 빌드 번호*.* 전용 부분 번호*합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-330">Typically, a version number displays as *major number*.*minor number*.*build number*.*private part number*.</span></span> <span data-ttu-id="7c571-331">어셈블리 매니페스트 내에서 어셈블리 버전을 설정 하 여 명시적으로 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-331">You can set it explicitly by setting the assembly version within your assembly manifest.</span></span> <span data-ttu-id="7c571-332">자세한 내용은 참조 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-332">For more information, see [Assembly Manifest](~/docs/framework/app-domains/assembly-manifest.md).</span></span>  
  
 <span data-ttu-id="7c571-333"><xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에 있는지 확인할 수 있는지 확인은 `AssemblyInformationalVersion` 특성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-333"><xref:System.Windows.Forms.Application.ProductVersion%2A> first looks to see if the assembly containing the main executable has the `AssemblyInformationalVersion` attribute on it.</span></span> <span data-ttu-id="7c571-334">둘 다에 대해 사용 되는이 특성이 존재 하면 <xref:System.Windows.Forms.Application.ProductVersion%2A> 및 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-334">If this attribute exists, it is used for both <xref:System.Windows.Forms.Application.ProductVersion%2A> and <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-335">이 특성이 없는 경우 두 속성 대신 실행 파일의 버전을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-335">If this attribute does not exist, both properties use the version of the executable file instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-336">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-336">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-337">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-337">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="7c571-338">
            <see cref="T:System.EventArgs" /> 이벤트에 전달할 <see cref="E:System.Windows.Forms.Application.Idle" /> 개체입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-338">The <see cref="T:System.EventArgs" /> objects to pass to the <see cref="E:System.Windows.Forms.Application.Idle" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-339">호스팅된 시나리오에서 <see cref="E:System.Windows.Forms.Application.Idle" /> 이벤트를 발생시킵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-339">Raises the <see cref="E:System.Windows.Forms.Application.Idle" /> event in hosted scenarios.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-340">이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅하는 경우에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-340">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="7c571-341">호출 해야 <xref:System.Windows.Forms.Application.RaiseIdle%2A> 호스팅 응용 프로그램 유휴 상태로 전환 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="7c571-341">You should call <xref:System.Windows.Forms.Application.RaiseIdle%2A> when the hosting application enters an idle state.</span></span> <span data-ttu-id="7c571-342">따라서 일부 Windows Forms 컨트롤 및 구성 요소는 사용자가 응용 프로그램 상호 작용 하지 하는 동안 중요 한 배경 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-342">This enables some Windows Forms controls and components to do important background work while the user is not interacting with the application.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="7c571-343">Windows Forms이 호스팅된 환경에서 아직 메시지를 보내고 있는지 여부를 확인해야 할 경우 호출할 메서드입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-343">The method to call when Windows Forms needs to check if the hosting environment is still sending messages.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-344">호스팅된 환경에서 메시지 루프가 실행 중인지 여부를 확인하기 위한 콜백을 등록합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-344">Registers a callback for checking whether the message loop is running in hosted environments.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-345">이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅하는 경우에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-345">This method is used when hosting Windows Forms in another environment, such as an unmanaged application.</span></span> <span data-ttu-id="7c571-346">호스팅된 환경에서의 <xref:System.Windows.Forms.Application.MessageLoop%2A> 속성은 항상 Windows Forms 메시지를 처리 하지 않은 경우 false를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-346">In hosted environments, the <xref:System.Windows.Forms.Application.MessageLoop%2A> property will always return false if Windows Forms is not processing messages.</span></span> <span data-ttu-id="7c571-347">사용 하 여이 콜백을 Windows Forms 호스팅 환경에서 아직 메시지를 처리 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="7c571-347">Use this callback to tell Windows Forms if the hosting environment is still processing messages.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7c571-348">응용 프로그램에서 제거할 <see cref="T:System.Windows.Forms.IMessageFilter" />를 구현한 것입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-348">The implementation of the <see cref="T:System.Windows.Forms.IMessageFilter" /> to remove from the application.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-349">응용 프로그램의 메시지 펌프에서 메시지 필터를 제거합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-349">Removes a message filter from the message pump of the application.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-350">더 이상 디스패치 되기 전에 Windows 메시지를 캡처하려고 할 때 메시지 필터를 제거할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-350">You can remove a message filter when you no longer want to capture Windows messages before they are dispatched.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-351">에 대 한 구현을 제공 해야 메시지 필터를 사용 하려면 먼저는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-351">Before you can use a message filter, you must provide an implementation for the <xref:System.Windows.Forms.IMessageFilter> interface.</span></span> <span data-ttu-id="7c571-352">다음 클래스는 라는 메시지 필터를 만듭니다 `TestMessageFilter`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-352">The following class creates a message filter called `TestMessageFilter`.</span></span> <span data-ttu-id="7c571-353">이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-353">This filter blocks all messages relating to the left mouse button.</span></span>  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-354">현재 응용 프로그램에서 비주얼 스타일로 컨트롤을 그리고 있는지 여부를 지정하는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-354">Gets a value specifying whether the current application is drawing controls with visual styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-355">응용 프로그램 창의 클라이언트 영역에서 컨트롤에 비주얼 스타일이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-355">
              <see langword="true" /> if visual styles are enabled for controls in the client area of application windows; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-356">사용자 지정 컨트롤을 그리는 경우이 속성을 사용 하 여 모양을 응용 프로그램의 다른 컨트롤과 일치 되도록 비주얼 스타일로 컨트롤을 그릴 것인지를 결정 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-356">If you are drawing a custom control, use this property to decide whether to draw the control with or without visual styles, so that its appearance is consistent with other controls in the application.</span></span>  
  
 <span data-ttu-id="7c571-357">다음 표에서 존재 해야 하는 4 개의 상태를 보여 줍니다. <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> 반환할 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-357">The following table shows the four conditions that must exist for <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> to return `true`.</span></span>  
  
|<span data-ttu-id="7c571-358">조건</span><span class="sxs-lookup"><span data-stu-id="7c571-358">Condition</span></span>|<span data-ttu-id="7c571-359">설명</span><span class="sxs-lookup"><span data-stu-id="7c571-359">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="7c571-360">운영 체제에서 지원 비주얼 스타일</span><span class="sxs-lookup"><span data-stu-id="7c571-360">The operating system supports visual styles</span></span>|<span data-ttu-id="7c571-361">이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="7c571-361">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="7c571-362">사용자가 운영 체제에서 비주얼 스타일 활성화</span><span class="sxs-lookup"><span data-stu-id="7c571-362">The user has enabled visual styles in the operating system</span></span>|<span data-ttu-id="7c571-363">이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="7c571-363">To verify this condition separately, use the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> property of the <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> class.</span></span>|  
|<span data-ttu-id="7c571-364">응용 프로그램에서 비주얼 스타일을 사용 하는</span><span class="sxs-lookup"><span data-stu-id="7c571-364">Visual styles are enabled in the application</span></span>|<span data-ttu-id="7c571-365"><xref:System.Windows.Forms.Application.EnableVisualStyles> 메서드를 호출하여 또는 컨트롤 그리기에 ComCtl32.dll 버전 6 이상을 사용하도록 지정하는 응용 프로그램 매니페스트를 사용하여 응용 프로그램에서 비주얼 스타일을 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-365">Visual styles can be enabled in an application by calling the <xref:System.Windows.Forms.Application.EnableVisualStyles> method or by using an application manifest that specifies that ComCtl32.dll version 6 or later will be used to draw controls.</span></span>|  
|<span data-ttu-id="7c571-366">비주얼 스타일은 응용 프로그램 창의 클라이언트 영역을 그리는 데 사용 되 고</span><span class="sxs-lookup"><span data-stu-id="7c571-366">Visual styles are being used to draw the client area of application windows</span></span>|<span data-ttu-id="7c571-367">이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.Application> 클래스의 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성을 사용하고 값이 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 또는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>인지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="7c571-367">To verify this condition separately, use the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property of the <xref:System.Windows.Forms.Application> class and verify that it has the value <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> or <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-368">응용 프로그램을 종료하고 즉시 새 인스턴스를 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-368">Shuts down the application and starts a new instance immediately.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-369">호출에 대 한 가장 일반적인 이유 `Restart` 통해 다운로드 한 응용 프로그램의 새 버전을 시작 하는 것 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 를 사용 하는 `Update` 또는 `UpdateAsync` 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-369">The most common reason for calling `Restart` is to start a new version of the application that you have downloaded through [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] using the `Update` or `UpdateAsync` method.</span></span>  
  
 <span data-ttu-id="7c571-370">처음 실행 하는 것 컨텍스트에서 응용 프로그램 다시 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-370">Applications are restarted in the context in which they were initially run.</span></span> <span data-ttu-id="7c571-371">응용 프로그램에서 직접 응용 프로그램의 주 실행 파일을 가리키는 URL을 사용 하 여 시작 된 경우 동일한 URL을 사용 하 여 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-371">If your application was started using a URL pointing directly to the application's main executable file, it will be restarted using the same URL.</span></span> <span data-ttu-id="7c571-372">응용 프로그램이 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램을 사용 하 여 시작할 수 있습니다 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-372">If your application is a [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application, it will be restarted using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span>  
  
 <span data-ttu-id="7c571-373">응용 프로그램 먼저 실행 하는 경우 명령줄 옵션이 제공된 되었으면 <xref:System.Windows.Forms.Application.Restart%2A> 동일한 옵션을 사용 하 여 다시 응용 프로그램을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-373">If your application was originally supplied command-line options when it first executed, <xref:System.Windows.Forms.Application.Restart%2A> will launch the application again with the same options.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7c571-374">사용자 코드가 Windows Forms 응용 프로그램이 아닌 경우.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-374">Your code is not a Windows Forms application.</span>
          </span>
          <span data-ttu-id="7c571-375">이 컨텍스트에서 이 메서드를 호출할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-375">You cannot call this method in this context.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-376">필요한 <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> 권한.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-376">Requires <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> permission.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-377">현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-377">Begins running a standard application message loop on the current thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-378">폼을 사용하지 않고 현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-378">Begins running a standard application message loop on the current thread, without a form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-379">Win32 기반 또는 Windows Forms 응용 프로그램 메시지 루프는 마우스 클릭과 키보드 입력과 같은 사용자 이벤트를 처리 하는 코드에는 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-379">In a Win32-based or Windows Forms application, a message loop is a routine in code that processes user events, such as mouse clicks and keyboard strokes.</span></span> <span data-ttu-id="7c571-380">실행 중인 모든 Windows 기반 응용 프로그램에는 기본 메시지 루프를 호출 하면 현재 메시지 루프가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-380">Every running Windows-based application requires an active message loop, called the main message loop.</span></span> <span data-ttu-id="7c571-381">기본 메시지 루프를 닫을 때 응용 프로그램이 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-381">When the main message loop is closed, the application exits.</span></span> <span data-ttu-id="7c571-382">Windows Forms에서이 루프는 닫힙니다는 <xref:System.Windows.Forms.Application.Exit%2A> 메서드를 호출할 경우 또는 <xref:System.Windows.Forms.Application.ExitThread%2A> 기본 메시지 루프를 실행 하는 스레드에서 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-382">In Windows Forms, this loop is closed when the <xref:System.Windows.Forms.Application.Exit%2A> method is called, or when the <xref:System.Windows.Forms.Application.ExitThread%2A> method is called on the thread that is running the main message loop.</span></span>  
  
 <span data-ttu-id="7c571-383">대부분 Windows Forms 개발자가이 버전의 메서드를 사용 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-383">Most Windows Forms developers will not need to use this version of the method.</span></span> <span data-ttu-id="7c571-384">사용 해야는 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> 오버 로드를 응용 프로그램 기본 폼이 닫힐 때 종료 되도록 응용 프로그램 기본 폼을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-384">You should use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> overload to start an application with a main form, so that the application terminates when the main form is closed.</span></span> <span data-ttu-id="7c571-385">사용 하 여 다른 모든 상황에서 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> 오버 로드를 지 원하는 제공는 <xref:System.Windows.Forms.ApplicationContext> 효율적으로 제어할 응용 프로그램의 수명에 대 한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-385">For all other situations, use the <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> overload, which supports supplying an <xref:System.Windows.Forms.ApplicationContext> object for better control over the lifetime of the application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-386">주 메시지 루프가 이미 이 스레드에서 실행되고 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-386">A main message loop is already running on this thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <span data-ttu-id="7c571-387">응용 프로그램이 실행되는 <see cref="T:System.Windows.Forms.ApplicationContext" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-387">An <see cref="T:System.Windows.Forms.ApplicationContext" /> in which the application is run.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-388">
            <see cref="T:System.Windows.Forms.ApplicationContext" />를 사용하여 현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-388">Begins running a standard application message loop on the current thread, with an <see cref="T:System.Windows.Forms.ApplicationContext" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-389">메시지 루프 실행 될 때까지 <xref:System.Windows.Forms.Application.Exit%2A> 또는 <xref:System.Windows.Forms.Application.ExitThread%2A> 라고 또는 <xref:System.Windows.Forms.Application.ThreadExit> 컨텍스트 개체에서 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-389">The message loop runs until <xref:System.Windows.Forms.Application.Exit%2A> or <xref:System.Windows.Forms.Application.ExitThread%2A> is called or the <xref:System.Windows.Forms.Application.ThreadExit> event is raised on the context object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-390">이 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-390">The example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="7c571-391">응용 프로그램 시작 하 고 종료 하는 경우 각 폼의 위치가 기억 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-391">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="7c571-392">사용 하는 방법을 보여 주는이 예제는 <xref:System.Windows.Forms.ApplicationContext>와 함께 `Application.Run(context)` 방법에서 응용 프로그램이 시작 될 때 여러 폼을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-392">This example demonstrates how to use an <xref:System.Windows.Forms.ApplicationContext>, along with the `Application.Run(context)` method, to display multiple forms when the application starts.</span></span>  
  
 <span data-ttu-id="7c571-393">클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 모두 있을 때에 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-393">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="7c571-394">이 클래스는 사용자에 대 한 각 폼의 위치를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-394">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="7c571-395">폼 위치 데이터 파일에 저장 됩니다 `Appdata.txt` 의해 결정 된 위치에 만들어진 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-395">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-396">`Main` 메서드 호출 `Application.Run(context)` 제공 된 응용 프로그램을 시작 하는 <xref:System.Windows.Forms.ApplicationContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-396">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="7c571-397">에 대 한 코드는 `AppForm1` 및 `AppForm2` forms 간단 하 게 나타내기 위해 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-397">The code for the `AppForm1` and `AppForm2` forms is not shown for the purpose of brevity.</span></span> <span data-ttu-id="7c571-398">참조는 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록에 대 한 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-398">See the <xref:System.Windows.Forms.ApplicationContext> class overview for the whole code listing.</span></span>  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-399">주 메시지 루프가 이미 이 스레드에서 실행되고 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-399">A main message loop is already running on this thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">
          <span data-ttu-id="7c571-400">표시하려는 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-400">A <see cref="T:System.Windows.Forms.Form" /> that represents the form to make visible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-401">현재 스레드에서 표준 응용 프로그램 메시지 루프의 실행을 시작하고 지정된 폼을 표시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-401">Begins running a standard application message loop on the current thread, and makes the specified form visible.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-402">일반적으로 응용 프로그램의 main 함수는이 메서드를 호출 하 고 응용 프로그램의 주 창에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-402">Typically, the main function of an application calls this method and passes to it the main window of the application.</span></span>  
  
 <span data-ttu-id="7c571-403">이벤트 처리기를 추가 하는이 메서드는 `mainForm` 에 대 한 매개 변수는 <xref:System.Windows.Forms.Form.Closed> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-403">This method adds an event handler to the `mainForm` parameter for the <xref:System.Windows.Forms.Form.Closed> event.</span></span> <span data-ttu-id="7c571-404">이벤트 처리기 호출 <xref:System.Windows.Forms.Application.ExitThread%2A> 응용 프로그램을 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-404">The event handler calls <xref:System.Windows.Forms.Application.ExitThread%2A> to clean up the application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-405"><xref:System.Windows.Forms.Control.Dispose%2A> 의 메서드는 <xref:System.Windows.Forms.Form> 이 메서드의 반환 하기 전에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-405">The <xref:System.Windows.Forms.Control.Dispose%2A> method of the <xref:System.Windows.Forms.Form> class will be called prior to the return of this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-406">다음 코드 예제에서는 폼의 목록 상자에 숫자를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-406">The following code example lists numbers in a list box on a form.</span></span> <span data-ttu-id="7c571-407">클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-407">Each time you click `button1`, the application adds another number to the list.</span></span>  
  
 <span data-ttu-id="7c571-408">`Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 생성 하는 응용 프로그램을 시작 하려면 `listBox1`, 및 `button1`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-408">The `Main` method calls <xref:System.Windows.Forms.Application.Run%2A> to start the application, which creates the form, `listBox1`, and `button1`.</span></span> <span data-ttu-id="7c571-409">사용자가 클릭할 때 `button1`, `button1_Click` 숫자 목록 상자에 1 ~ 3을 추가 하 고 표시 하는 메서드는 <xref:System.Windows.Forms.MessageBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-409">When the user clicks `button1`, the `button1_Click` method adds numbers one to three to the list box, and displays a <xref:System.Windows.Forms.MessageBox>.</span></span> <span data-ttu-id="7c571-410">사용자가 클릭할 경우 **아니요** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-410">If the user clicks **No** on the <xref:System.Windows.Forms.MessageBox>, the `button1_Click` method adds another number to the list.</span></span> <span data-ttu-id="7c571-411">사용자가 클릭할 경우 **예**, 응용 프로그램 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-411">If the user clicks **Yes**, the application calls <xref:System.Windows.Forms.Application.Exit%2A> to process all remaining messages in the queue and then to quit.</span></span>  
  
 <span data-ttu-id="7c571-412">예제를 실행 하려면 `listBox1` 및 `button1` 만들고 폼에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-412">The example requires that `listBox1` and `button1` have been created and placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-413">주 메시지 루프가 이미 현재 스레드에서 실행되고 있는 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-413">A main message loop is already running on the current thread.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-414">경고 배너와 함께 최상위 창 캡션이 표시될 때 이 캡션에 적용될 서식 문자열을 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-414">Gets or sets the format string to apply to top-level window captions when they are displayed with a warning banner.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-415">최상위 창 캡션에 적용될 서식 문자열입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-415">The format string to apply to top-level window captions.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">
          <span data-ttu-id="7c571-416">이 속성을 설정 하는 모든 창입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-416">for all windows to set this property.</span>
          </span>
          <span data-ttu-id="7c571-417">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-417">Associated enumeration: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">
          <span data-ttu-id="7c571-418">새 컨트롤에 사용할 기본값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-418">The default value to use for new controls.</span>
          </span>
          <span data-ttu-id="7c571-419">
            <see langword="true" />이면 <c>UseCompatibleTextRendering</c>을 지원하는 새 컨트롤이 텍스트 렌더링에 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 기반의 <see cref="T:System.Drawing.Graphics" /> 클래스를 사용하고, <see langword="false" />이면 새 컨트롤이 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 기반의 <see cref="T:System.Windows.Forms.TextRenderer" /> 클래스를 사용합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-419">If <see langword="true" />, new controls that support <c>UseCompatibleTextRendering</c> use the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <see cref="T:System.Drawing.Graphics" /> class for text rendering; if <see langword="false" />, new controls use the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <see cref="T:System.Windows.Forms.TextRenderer" /> class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-420">특정 컨트롤에 정의된 <c>UseCompatibleTextRendering</c> 속성에 대한 응용 프로그램 수준의 기본값을 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-420">Sets the application-wide default for the <c>UseCompatibleTextRendering</c> property defined on certain controls.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-421">특정 Windows Forms 컨트롤 중 하나를 사용 하 여 해당 텍스트를 렌더링할 수는 <xref:System.Windows.Forms.TextRenderer> 클래스를 기반으로 하는 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 그래픽 라이브러리 또는 <xref:System.Drawing.Graphics> 클래스를 기반으로 하는 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 그래픽 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-421">Certain Windows Forms controls can render their text using either the <xref:System.Windows.Forms.TextRenderer> class, which is based on the [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] graphics library, or the <xref:System.Drawing.Graphics> class, which is based on the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] graphics library.</span></span> <span data-ttu-id="7c571-422">이 변경 되었는지는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 와 성능 및 지역화 문제로 인해 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-422">This change was made in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] because of performance and localization issues with [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)].</span></span> <span data-ttu-id="7c571-423">사용 하 여 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 의 기본값을 설정 하는 `UseCompatibleTextRendering` 지 원하는 컨트롤에 대 한 속성.</span><span class="sxs-lookup"><span data-stu-id="7c571-423">Use <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> to set the default value of the `UseCompatibleTextRendering` property for controls that support it.</span></span>  
  
 <span data-ttu-id="7c571-424">`UseCompatibleTextRendering` 속성은 해당 렌더링 텍스트를 사용 하 여 Windows Forms 컨트롤 간의 시각적 호환성을 제공 하기 위한는 <xref:System.Windows.Forms.TextRenderer> 클래스 및 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 및 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] 는 를사용하여사용자지정텍스트렌더링을수행하는응용프로그램<xref:System.Drawing.Graphics>클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-424">The `UseCompatibleTextRendering` property is intended to provide visual compatibility between Windows Forms controls that render text using the <xref:System.Windows.Forms.TextRenderer> class and [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] and [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] applications that perform custom text rendering using the <xref:System.Drawing.Graphics> class.</span></span> <span data-ttu-id="7c571-425">대부분의 경우에서 응용 프로그램을 업그레이드 하는 경우 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 또는 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]를 그대로 사용 하는 것이 좋습니다. `UseCompatibleTextRendering` 의 기본값으로 설정 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-425">In most cases, if your application is not being upgraded from [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] or [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], it is recommended that you leave `UseCompatibleTextRendering` set to the default value of `false`.</span></span>  
  
 <span data-ttu-id="7c571-426">[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 기반 <xref:System.Windows.Forms.TextRenderer> 클래스에 도입 된는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 성능 향상을 위해 텍스트를 더 보기 좋게 및 국가별 글꼴에 대 한 지원 향상을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-426">The [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] based <xref:System.Windows.Forms.TextRenderer> class was introduced in the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] to improve performance, make text look better, and improve support for international fonts.</span></span> <span data-ttu-id="7c571-427">이전 버전의 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 기반 <xref:System.Drawing.Graphics> 클래스는 모든 텍스트 렌더링을 수행 하는 데 사용 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-427">In earlier versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], the [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] based <xref:System.Drawing.Graphics> class was used to perform all text rendering.</span></span> [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]<span data-ttu-id="7c571-428"> 문자 간격 및 줄 바꿈 다르게에서 계산 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-428"> calculates character spacing and word wrapping differently from [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)].</span></span> <span data-ttu-id="7c571-429">사용 하는 Windows Forms 응용 프로그램에는 <xref:System.Drawing.Graphics> 텍스트를 렌더링 하는 클래스를 사용 하는 컨트롤에 대 한 텍스트 될 수 <xref:System.Windows.Forms.TextRenderer> 다른 응용 프로그램에 다른 텍스트를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-429">In a Windows Forms application that uses the <xref:System.Drawing.Graphics> class to render text, this could cause the text for controls that use <xref:System.Windows.Forms.TextRenderer> to appear different from the other text in the application.</span></span> <span data-ttu-id="7c571-430">이러한 호환성 문제를 해결 하려면 설정할 수 있습니다는 `UseCompatibleTextRendering` 속성을 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-430">To resolve this incompatibility, you can set the `UseCompatibleTextRendering` property to `true`.</span></span> <span data-ttu-id="7c571-431">설정 하려면 `UseCompatibleTextRendering` 를 `true` 응용 프로그램에서 지원 되는 모든 컨트롤에 대 한 호출의 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 의 매개 변수를 사용 하 여 메서드 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-431">To set `UseCompatibleTextRendering` to `true` for all supported controls in the application, call the <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> method with a parameter of `true`.</span></span>  
  
 <span data-ttu-id="7c571-432">Windows Forms 코드 Internet Explorer와 같은 다른 응용 프로그램에서 호스팅되는 경우이 메서드는 호출 하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-432">You should never call this method if your Windows Forms code is hosted in another application, such as Internet Explorer.</span></span> <span data-ttu-id="7c571-433">만 독립 실행형 Windows Forms 응용 프로그램에서이 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-433">Only call this method in stand-alone Windows Forms applications.</span></span>  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  <span data-ttu-id="7c571-434">에 대 한 기본값을 설정 하려면 `UseCompatibleTextRendering` 에 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] 이상 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-434">To set the default value for `UseCompatibleTextRendering` in [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] or later, see <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7c571-435">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 이후 버전에 대 한 호출 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Program.cs 파일에서 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-435">In [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] or later, a call to <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> is automatically generated in the Program.cs file.</span></span> <span data-ttu-id="7c571-436">텍스트 렌더링 기본값을 변경 하려면 생성 된 코드를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-436">To change the text rendering default, modify the generated code.</span></span>  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-437">Windows Forms 응용 프로그램에서 첫 번째 창이 만들어진 후에 이 메서드를 호출한 경우</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-437">You can only call this method before the first window is created by your Windows Forms application.</span>
          </span>
        </exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="7c571-438">전환할 전원 모드를 나타내는 <see cref="T:System.Windows.Forms.PowerState" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-438">A <see cref="T:System.Windows.Forms.PowerState" /> indicating the power activity mode to which to transition.</span>
          </span>
        </param>
        <param name="force">
          <span data-ttu-id="7c571-439">일시 중단 모드를 즉시 적용하려면 <see langword="true" />이고, Windows에서 각 응용 프로그램에 일시 중단 요청을 보내게 하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-439">
              <see langword="true" /> to force the suspended mode immediately; <see langword="false" /> to cause Windows to send a suspend request to every application.</span>
          </span>
        </param>
        <param name="disableWakeEvent">
          <span data-ttu-id="7c571-440">깨우기 이벤트가 발생할 때 시스템의 전원 상태를 활성 상태로 복원하지 않으려면 <see langword="true" />이고, 깨우기 이벤트가 발생할 때 시스템의 전원 상태를 활성 상태로 복원하려면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-440">
              <see langword="true" /> to disable restoring the system's power status to active on a wake event, <see langword="false" /> to enable restoring the system's power status to active on a wake event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-441">시스템을 일시 중단하거나 최대 절전 모드로 전환하거나, 시스템을 일시 중단하거나 최대 절전 모드로 전환하도록 요구합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-441">Suspends or hibernates the system, or requests that the system be suspended or hibernated.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7c571-442">시스템이 일시 중단되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-442">
              <see langword="true" /> if the system is being suspended, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-443">20 초 내 응용 프로그램 일시 중단 요청에 응답 하지 않으면, 응답 하지 않는 상태 인지 하 고 있는지 응용 프로그램 수 중지 하거나 종료 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-443">If an application does not respond to a suspend request within 20 seconds, Windows determines that it is in a non-responsive state, and that the application can either be put to sleep or terminated.</span></span> <span data-ttu-id="7c571-444">하지만 응용 프로그램 일시 중단 요청에 응답, 리소스를 정리 하 고 활성 프로세스를 종료 하는 데 필요한 만큼의 시간 걸릴 수 있습니다 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-444">Once an application responds to a suspend request, however, it can take whatever time it needs to clean up resources and shut down active processes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-445">처리되지 않은 예외에 응답하는 방법을 응용 프로그램에 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-445">Instructs the application how to respond to unhandled exceptions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7c571-446">다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-446">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="7c571-447">설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-447">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="7c571-448">사용 하 여는 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드가 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> UI가 아닌 스레드 예외를 처리 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-448">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="7c571-449">이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 방지할 수의 종료,이 예제에서는 오류를 기록 하기만 종료 전에 응용 프로그램 이벤트 로그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-449">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="7c571-450">이 예에서는 두 개를 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 및 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-450">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">
          <span data-ttu-id="7c571-451">예외가 catch되지 않고 throw되는 경우 응용 프로그램의 동작을 설명하는 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-451">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-452">처리되지 않은 예외에 응답하는 방법을 응용 프로그램에 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-452">Instructs the application how to respond to unhandled exceptions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-453">모든 Windows Forms에서 throw 된 예외를 catch 하는 수는 종종 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-453">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="7c571-454">이 메서드를 사용 하 여 Windows Forms 구성 요소에서 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부는 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-454">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="7c571-455">호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-455">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="7c571-456">스레드가 생성 되지 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms에서 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-456">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-457">다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-457">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="7c571-458">설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-458">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="7c571-459">사용 하 여는 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드가 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> UI가 아닌 스레드 예외를 처리 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-459">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="7c571-460">이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 방지할 수의 종료,이 예제에서는 오류를 기록 하기만 종료 전에 응용 프로그램 이벤트 로그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-460">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="7c571-461">이 예에서는 두 개를 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 및 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-461">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-462">응용 프로그램에서 창을 처음 만든 후에는 예외 모드를 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-462">You cannot set the exception mode after the application has created its first window.</span>
          </span>
        </exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">
          <span data-ttu-id="7c571-463">예외가 catch되지 않고 throw되는 경우 응용 프로그램의 동작을 설명하는 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 값입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-463">An <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> value describing how the application should behave if an exception is thrown without being caught.</span>
          </span>
        </param>
        <param name="threadScope">
          <span data-ttu-id="7c571-464">스레드 예외 모드를 설정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-464">
              <see langword="true" /> to set the thread exception mode; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7c571-465">처리되지 않은 예외에 응답하고 필요에 따라 스레드 관련 동작을 적용하는 방법을 응용 프로그램에 지시합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-465">Instructs the application how to respond to unhandled exceptions, optionally applying thread-specific behavior.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-466">모든 Windows Forms에서 throw 된 예외를 catch 하는 수는 종종 없습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-466">It is often not feasible to catch all of the exceptions thrown by Windows Forms.</span></span> <span data-ttu-id="7c571-467">이 메서드를 사용 하 여 Windows Forms 구성 요소에서 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부는 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-467">Using this method, you can instruct your application whether it should catch all unhandled exceptions thrown by Windows Forms components and continue operating, or whether it should expose them to the user and halt execution.</span></span>  
  
 <span data-ttu-id="7c571-468">호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="7c571-468">Call <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> before you instantiate the main form of your application using the <xref:System.Windows.Forms.Application.Run%2A> method.</span></span>  
  
 <span data-ttu-id="7c571-469">때 `threadScope` 은 `true`, 스레드 예외 모드를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-469">When `threadScope` is `true`, the thread exception mode is set.</span></span> <span data-ttu-id="7c571-470">스레드 예외 모드를 사용 하는 경우 응용 프로그램 예외 모드를 재정의 `mode` 로 설정 되지 않은 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-470">The thread exception mode overrides the application exception mode if `mode` is not set to <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.</span></span>  
  
 <span data-ttu-id="7c571-471">때 `threadScope` 은 `false`, 응용 프로그램 예외 모드를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-471">When `threadScope` is `false`, the application exception mode is set.</span></span> <span data-ttu-id="7c571-472">응용 프로그램 예외 모드 포함 된 모든 스레드에 사용 되는 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-472">The application exception mode is used for all threads that have the <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> mode.</span></span> <span data-ttu-id="7c571-473">응용 프로그램 예외 모드를 설정 하는 경우에 현재 스레드의 설정을 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-473">Setting the application exception mode does not affect the setting of the current thread.</span></span>  
  
 <span data-ttu-id="7c571-474">스레드가 생성 되지 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms에서 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-474">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-475">다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-475">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="7c571-476">설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-476">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="7c571-477">사용 하 여는 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드가 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> UI가 아닌 스레드 예외를 처리 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-477">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="7c571-478">이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 방지할 수의 종료,이 예제에서는 오류를 기록 하기만 종료 전에 응용 프로그램 이벤트 로그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-478">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="7c571-479">이 예에서는 두 개를 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 및 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-479">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7c571-480">응용 프로그램에서 창을 처음 만든 후에는 예외 모드를 설정할 수 없습니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-480">You cannot set the exception mode after the application has created its first window.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-481">응용 프로그램을 시작한 실행 파일의 경로(실행 파일 이름 제외)를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-481">Gets the path for the executable file that started the application, not including the executable name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-482">응용 프로그램을 시작한 실행 파일의 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-482">The path for the executable file that started the application.</span>
          </span>
          <span data-ttu-id="7c571-483">이 경로는 Windows Forms 응용 프로그램이 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]를 사용하여 배포되는지 여부에 따라 달라집니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-483">This path will be different depending on whether the Windows Forms application is deployed using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span>
          </span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="7c571-484"> 응용 프로그램 C:\Documents and Settings에 사용자별으로 응용 프로그램 캐시에 저장 된\\*username* 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-484"> applications are stored in a per-user application cache in the C:\Documents and Settings\\*username* directory.</span></span><span data-ttu-id="7c571-485">자세한 내용은 참조 [로컬 액세스 및 ClickOnce 응용 프로그램의 원격 데이터](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-485">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7c571-486">다음 코드 예제에서는이 속성을 가져오고 텍스트 상자에 해당 값을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-486">The following code example gets this property and displays its value in a text box.</span></span> <span data-ttu-id="7c571-487">예제를 실행 하려면 `textBox1` 폼에 배치 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-487">The example requires that `textBox1` has been placed on a form.</span></span>  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="7c571-488">에 경로 가져오는 중입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-488">for getting the path.</span>
          </span>
          <span data-ttu-id="7c571-489">연결 된 열거형의 경우: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-489">Associated enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-490">포착되지 않은 스레드 예외가 throw될 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-490">Occurs when an untrapped thread exception is thrown.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-491">이 이벤트는 Windows Forms 응용을 프로그램에서 Windows Forms 스레드에서 발생 하는 예외를 처리할 그렇지 않으면 처리 되지 않은을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-491">This event allows your Windows Forms application to handle otherwise unhandled exceptions that occur in Windows Forms threads.</span></span> <span data-ttu-id="7c571-492">이벤트 처리기에 <xref:System.Windows.Forms.Application.ThreadException> 알 수 없는 상태에 응용 프로그램을 유지 하 되 이러한 예외를 처리 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-492">Attach your event handlers to the <xref:System.Windows.Forms.Application.ThreadException> event to deal with these exceptions, which will leave your application in an unknown state.</span></span> <span data-ttu-id="7c571-493">가능한 경우 구조적된 예외 처리 블록에서 예외를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-493">Where possible, exceptions should be handled by a structured exception handling block.</span></span>  
  
 <span data-ttu-id="7c571-494">이 콜백을 설정 하 여 처리 되지 않은 Windows Forms 스레드 예외에 대 한 사용 되는지 여부를 변경할 수 있습니다 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-494">You can change whether this callback is used for unhandled Windows Forms thread exceptions by setting <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>.</span></span> <span data-ttu-id="7c571-495">스레드가 생성 되지 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms에서 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-495">To catch exceptions that occur in threads not created and owned by Windows Forms, use the <xref:System.AppDomain.UnhandledException> event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7c571-496">이 이벤트의 활성화 되지 누락을 보장 하기 위해 연결 해야를 호출 하기 전에 처리기 <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-496">To guarantee that no activations of this event are missed, you must attach a handler before you call <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-497">정적 이벤트 이기 때문에 메모리 누수가 발생 하거나 응용 프로그램이 삭제 될 때 이벤트 처리기를 분리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-497">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-498">다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-498">The following code example sets event handlers for exceptions that occur on Windows Forms threads and exceptions that occur on other threads.</span></span> <span data-ttu-id="7c571-499">설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-499">It sets <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> so that all exceptions are handled by the application, regardless of the settings in the application's user configuration file.</span></span> <span data-ttu-id="7c571-500">사용 하 여는 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드가 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> UI가 아닌 스레드 예외를 처리 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-500">It uses the <xref:System.Windows.Forms.Application.ThreadException> event to handle UI thread exceptions, and the <xref:System.AppDomain.UnhandledException> event to handle non-UI thread exceptions.</span></span> <span data-ttu-id="7c571-501">이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 방지할 수의 종료,이 예제에서는 오류를 기록 하기만 종료 전에 응용 프로그램 이벤트 로그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-501">Since <xref:System.AppDomain.UnhandledException> cannot prevent an application from terminating, the example simply logs the error in the application event log before termination.</span></span>  
  
 <span data-ttu-id="7c571-502">이 예에서는 두 개를 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 및 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-502">This example assumes that you have defined two <xref:System.Windows.Forms.Button> controls, `button1` and `button2`, on your <xref:System.Windows.Forms.Form> class.</span></span>  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="7c571-503">이 이벤트 처리기를 추가할 때 관리 되지 않는 코드를 호출 하는 직접 실행 호출자의 합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-503">for the immediate caller to call unmanaged code when adding a handler to this event.</span>
          </span>
          <span data-ttu-id="7c571-504">연결 된 열거형의 경우: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-504">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-505">스레드가 종료되려고 할 때 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-505">Occurs when a thread is about to shut down.</span>
          </span>
          <span data-ttu-id="7c571-506">응용 프로그램의 주 스레드가 종료되려고 할 때 이 이벤트가 발생한 다음 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 이벤트가 발생합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-506">When the main thread for an application is about to be shut down, this event is raised first, followed by an <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-507">이벤트 처리기를 연결 해야는 <xref:System.Windows.Forms.Application.ThreadExit> 필요한 작업을 수행 하는 이벤트 처리 되지 않은, 스레드가 실행을 중지 하기 전에 필요한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-507">You must attach the event handlers to the <xref:System.Windows.Forms.Application.ThreadExit> event to perform any unhandled, required tasks before the thread stops running.</span></span> <span data-ttu-id="7c571-508">이 스레드를 배치 하거나 가비지 수집기가 회수 하는 개체에 의해 열린 파일을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-508">Close files opened by this thread, or dispose of objects that the garbage collector did not reclaim.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7c571-509">정적 이벤트 이기 때문에 메모리 누수가 발생 하거나 응용 프로그램이 삭제 될 때 이벤트 처리기를 분리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-509">Because this is a static event, you must detach your event handlers when your application is disposed, or memory leaks will result.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-510">다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-510">The following code example demonstrates the use of this member.</span></span> <span data-ttu-id="7c571-511">예제에서는 이벤트 처리기에서 보고 된 <xref:System.Windows.Forms.Application.ThreadExit> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-511">In the example, an event handler reports on the occurrence of the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span> <span data-ttu-id="7c571-512">이 보고서를 통해 이벤트 발생 하 고 디버깅 하는 데 도움이 수 때 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-512">This report helps you to learn when the event occurs and can assist you in debugging.</span></span> <span data-ttu-id="7c571-513">자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 와 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 여러 줄에 메시지를 추가 하거나 <xref:System.Windows.Forms.TextBox>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-513">To report on multiple events or on events that occur frequently, consider replacing <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> with <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or appending the message to a multiline <xref:System.Windows.Forms.TextBox>.</span></span>  
  
 <span data-ttu-id="7c571-514">예제 코드를 실행 하려면 Windows Forms에 붙여 넣고 이벤트 처리기가 연결 확인는 <xref:System.Windows.Forms.Application.ThreadExit> 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-514">To run the example code, paste it into a Windows Forms and ensure that the event handler is associated with the <xref:System.Windows.Forms.Application.ThreadExit> event.</span></span>  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7c571-515">
            <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />를 사용하여 등록한 메시지 루프 콜백의 등록을 취소합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-515">Unregisters the message loop callback made with <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-516">사용자의 응용 프로그램 데이터 경로를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-516">Gets the path for the application data of a user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-517">사용자의 응용 프로그램 데이터 경로입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-517">The path for the application data of a user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-518">경로가 존재 하지 않을 경우 다음과 같은 형식에는 하나이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-518">If a path does not exist, one is created in the following format:</span></span>  
  
 <span data-ttu-id="7c571-519">*기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="7c571-519">*Base Path*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>  
  
 <span data-ttu-id="7c571-520">이 경로에 저장 된 데이터에는 로밍를 사용 하는 사용자 프로필의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-520">Data stored in this path is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="7c571-521">로밍 사용자는 네트워크에 둘 이상의 컴퓨터에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-521">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="7c571-522">로밍 사용자에 대 한 사용자 프로필은 네트워크의 서버에 유지 되 고 사용자가 로그온 할 때 시스템에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-522">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="7c571-523">로밍에 대 한 것으로 간주 되려면 사용자 프로필에 대 한 운영 체제 로밍 프로필 지원 하 고 사용 하도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-523">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 <span data-ttu-id="7c571-524">일반적인 기본 경로 C:\Documents and 설정을\\*username*\Application 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-524">A typical base path is C:\Documents and Settings\\*username*\Application Data.</span></span> <span data-ttu-id="7c571-525">그러나이 경로 다를 수,를 사용 하 여 Windows Forms 응용 프로그램 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-525">This path will be different, however, if the Windows Forms application is deployed by using [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</span></span> [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]<span data-ttu-id="7c571-526"> 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-526"> creates its own application data directory that is isolated from all other applications.</span></span> <span data-ttu-id="7c571-527">자세한 내용은 참조 [로컬 액세스 및 ClickOnce 응용 프로그램의 원격 데이터](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-527">For more information, see [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-528">다음 코드 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-528">The following code example displays two forms and exits the application when both forms are closed.</span></span> <span data-ttu-id="7c571-529">응용 프로그램 시작 하 고 종료 하는 경우 각 폼의 위치가 기억 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-529">When the application starts and exits, the position of each form is remembered.</span></span> <span data-ttu-id="7c571-530">사용 하 여 보여 주는이 예제는 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 속성을 사용자에 대 한 응용 프로그램 데이터를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-530">This example demonstrates using the <xref:System.Windows.Forms.Application.UserAppDataPath%2A> property to store application data for the user.</span></span>  
  
 <span data-ttu-id="7c571-531">클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 모두 있을 때에 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-531">The class `MyApplicationContext` inherits from <xref:System.Windows.Forms.ApplicationContext> and keeps track when each form is closed, and exits the current thread when they both are.</span></span> <span data-ttu-id="7c571-532">이 클래스는 사용자에 대 한 각 폼의 위치를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-532">The class stores the positions of each form for the user.</span></span> <span data-ttu-id="7c571-533">폼 위치 데이터 파일에 저장 됩니다 `Appdata.txt` 의해 결정 된 위치에 만들어진 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-533">The form position data is stored in a file titled `Appdata.txt` that is created in the location determined by <xref:System.Windows.Forms.Application.UserAppDataPath%2A>.</span></span> <span data-ttu-id="7c571-534">`Main` 메서드 호출 `Application.Run(context)` 제공 된 응용 프로그램을 시작 하는 <xref:System.Windows.Forms.ApplicationContext>합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-534">The `Main` method calls `Application.Run(context)` to start the application given the <xref:System.Windows.Forms.ApplicationContext>.</span></span>  
  
 <span data-ttu-id="7c571-535">이 코드에 표시 된 예의 일부는는 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-535">This code is an excerpt from the example shown in the <xref:System.Windows.Forms.ApplicationContext> class overview.</span></span> <span data-ttu-id="7c571-536">일부 코드는 간단 하 게 나타내기 위해 표시 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-536">Some code is not shown for the purpose of brevity.</span></span> <span data-ttu-id="7c571-537">참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-537">See <xref:System.Windows.Forms.ApplicationContext> for the whole code listing.</span></span>  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-538">사용자의 응용 프로그램 데이터에 대한 레지스트리 키를 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-538">Gets the registry key for the application data of a user.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-539">사용자의 응용 프로그램 데이터에 대한 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-539">A <see cref="T:Microsoft.Win32.RegistryKey" /> representing the registry key for the application data specific to the user.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-540">키가 없는 경우 다음 형식으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-540">If the key does not exist, it is created in the following format:</span></span>  
  
 <span data-ttu-id="7c571-541">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span><span class="sxs-lookup"><span data-stu-id="7c571-541">CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A></span></span>   
  
 <span data-ttu-id="7c571-542">이 키에 저장 된 데이터에는 로밍를 사용 하는 사용자 프로필의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-542">Data stored in this key is part of user profile that is enabled for roaming.</span></span> <span data-ttu-id="7c571-543">로밍 사용자는 네트워크에 둘 이상의 컴퓨터에서 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-543">A roaming user works on more than one computer in a network.</span></span> <span data-ttu-id="7c571-544">로밍 사용자에 대 한 사용자 프로필은 네트워크의 서버에 유지 되 고 사용자가 로그온 할 때 시스템에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-544">The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on.</span></span> <span data-ttu-id="7c571-545">로밍에 대 한 것으로 간주 되려면 사용자 프로필에 대 한 운영 체제 로밍 프로필 지원 하 고 사용 하도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-545">For a user profile to be considered for roaming, the operating system must support roaming profiles and it must be enabled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-546">대기 커서가 응용 프로그램의 열려 있는 모든 폼에 사용되는지 여부를 가져오거나 설정합니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-546">Gets or sets whether the wait cursor is used for all open forms of the application.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-547">대기 커서가 열려 있는 모든 폼에 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-547">
              <see langword="true" /> is the wait cursor is used for all open forms; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-548">이 속성이로 설정 된 경우 `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> 응용 프로그램에서 열려 있는 모든 폼의 속성으로 설정 됩니다 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-548">When this property is set to `true`, the <xref:System.Windows.Forms.Control.UseWaitCursor%2A> property of all open forms in the application will be set to `true`.</span></span> <span data-ttu-id="7c571-549">모든 양식에서이 속성이 설정 되어 될 때까지이 호출이 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-549">This call will not return until this property has been set on all forms.</span></span> <span data-ttu-id="7c571-550">장기 실행 작업을 포함할 때 작업 아직 처리 중인 모든 응용 프로그램 폼에 상태를 표시 하려면이 속성을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-550">Use this property when you have a long-running operation, and want to indicate in all application forms that the operation is still processing.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7c571-551">비주얼 스타일이 응용 프로그램 창에 적용되는 방법을 지정하는 값을 가져옵니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-551">Gets a value that specifies how visual styles are applied to application windows.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7c571-552">
            <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 값의 비트 조합입니다.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7c571-552">A bitwise combination of the <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7c571-553">이 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 클라이언트 영역 또는 응용 프로그램 창의 비클라이언트 영역에서 비주얼 스타일을 사용 하는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-553">This <xref:System.Windows.Forms.Application.VisualStyleState%2A> property determines whether visual styles are enabled in client areas or nonclient areas of application windows.</span></span> <span data-ttu-id="7c571-554">일반적으로이 속성은 기본 폼의 생성자 내에서 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-554">Generally, this property should be set within the main form's constructor or <xref:System.Windows.Forms.Form.Load> event handler.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7c571-555">다음 코드 예제에서는 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 중 하나에 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 내에서 값의 <xref:System.Windows.Forms.Control.Click> 에 대 한 이벤트 처리기는 <xref:System.Windows.Forms.Button> 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-555">The following code example sets the <xref:System.Windows.Forms.Application.VisualStyleState%2A> property to one of the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> values within the <xref:System.Windows.Forms.Control.Click> event handler for a <xref:System.Windows.Forms.Button> control.</span></span> <span data-ttu-id="7c571-556">이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 열거형입니다.</span><span class="sxs-lookup"><span data-stu-id="7c571-556">This code example is part of a larger example provided for the <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> enumeration.</span></span>  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>