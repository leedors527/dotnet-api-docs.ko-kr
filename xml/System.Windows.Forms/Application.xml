<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28c0e715149bda84de593d0811549daf5e8f8dbe" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58456037" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>애플리케이션을 시작 및 중지하기 위한 메서드, Windows 메시지를 처리하기 위한 메서드, 애플리케이션에 대한 정보를 가져오기 위한 속성 등과 같이 애플리케이션을 관리하기 위한 <see langword="static" /> 메서드 및 속성을 제공합니다. 이 클래스는 상속될 수 없습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> 클래스에는 메서드가 시작 응용 프로그램 및 스레드를 중지 하 고 다음과 같이 Windows 메시지를 처리 합니다.  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 현재 스레드에서 응용 프로그램 메시지 루프를 시작 하 고 필요에 따라 표시 되도록 폼을 만듭니다.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> 또는 <xref:System.Windows.Forms.Application.ExitThread%2A> 메시지 루프를 중지 합니다.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> 루프에서 프로그램은 메시지를 처리 합니다.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Windows 메시지를 모니터링 하는 응용 프로그램 메시지 펌프에 메시지 필터를 추가 합니다.  
  
-   <xref:System.Windows.Forms.IMessageFilter> 이벤트 발생을 중지 하거나 이벤트 처리기를 호출 하기 전에 특별 한 작업을 수행할 수 있습니다.  
  
 이 클래스에 <xref:System.Windows.Forms.Application.CurrentCulture%2A> 고 <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> 문화권 현재 스레드에 대 한 정보를 속성을 가져오거나 설정 합니다.  
  
 이 클래스의 인스턴스를 만들 수 없습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작 하려면 `listBox1` 고 `button1`입니다. 클릭할 때 `button1`서 `button1_Click` 메서드 표시는 <xref:System.Windows.Forms.MessageBox>합니다. 클릭 하면 `No` 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 번호를 추가 합니다. 사용자가 클릭 하면 `Yes`, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
> [!NOTE]
>  에 대 한 호출 <xref:System.Windows.Forms.Application.Exit%2A> 부분 신뢰에서 실패 합니다.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">설치하려는<see cref="T:System.Windows.Forms.IMessageFilter" /> 인터페이스를 구현한 것입니다.</param>
        <summary>Windows 메시지가 대상 위치로 라우팅될 때 해당 메시지를 모니터링하기 위해 메시지 필터를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 필터를 사용 하 여 특정 이벤트가 발생 하지 않도록 하려면 하거나 이벤트 처리기에 전달 되기 전에 이벤트에 대 한 특별 한 작업을 수행 합니다. 메시지 필터는 특정 스레드에 고유 합니다.  
  
 메시지에 디스패치되 지 않게 방지 하기 위해 합니다 `value` 이 메서드에 전달 하는 매개 변수 인스턴스를 재정의 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> 메시지를 처리 하는 코드를 사용 하 여 메서드. 이 메서드는 `false`를 반환해야 합니다.  
  
> [!CAUTION]
>  응용 프로그램에 대 한 메시지 펌프에 메시지 필터를 추가 하면 성능이 저하 될 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 메시지 필터를 만듭니다 `TestMessageFilter`합니다. 이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다. 메시지 필터를 사용 하려면 먼저에 대 한 구현을 제공 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호출자가 해당 애플리케이션을 끝낼 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>호출자가 해당 애플리케이션을 끝낼 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 `false` 에서 호출 되 면을 <xref:System.Windows.Forms.Control> 웹 브라우저 내에서 호스팅되고 있습니다. 따라서 합니다 <xref:System.Windows.Forms.Control> 종료할 수 없습니다는 <xref:System.Windows.Forms.Application>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 종료되려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 처리기를 연결 해야 합니다는 `ApplicationExit` 응용 프로그램 실행이 중지 되기 전에 이벤트 처리 되지 않은, 하는 데 필요한 작업입니다. 이 응용 프로그램 또는 가비지 수집 회수 되지 않은 개체를 삭제 하 여 열려 있는 파일을 닫을 수 있습니다.  
  
 이 이벤트에 연결 된 모든 이벤트 처리기를 분리 해야 합니다는 정적 이벤트 이기 때문에 `ApplicationExit` 자체 이벤트 처리기입니다. 이러한 처리기를 분리 하지 않는 경우 이러한 이벤트에 연결 된 상태로 유지 되며 계속 메모리를 사용 하 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에서는 합니다 `ApplicationExit` 시점과 폼 위치 파일에 유지 해야 하는 시점을 알아야 하는 이벤트를 `FileStream` 을 닫아야 합니다.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 한 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 경우를 추적 하 고 있습니다. 닫을 때 각 폼의 위치를 기억 하는 클래스입니다. 경우는 `ApplicationExit` 이벤트가 발생 하면 클래스는 사용자에 대 한 각각의 위치를 파일에 씁니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 사용자가 공유하는 애플리케이션 데이터의 경로를 가져옵니다.</summary>
        <value>모든 사용자가 공유하는 애플리케이션 데이터의 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에이 있는지 확인할 수 있는지 확인 합니다 `AssemblyInformationalVersion` 특성입니다. 이 특성이 존재 하는 경우 둘 다에 대해 사용 됩니다 <xref:System.Windows.Forms.Application.ProductVersion%2A> 고 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>입니다. 이 특성이 없으면 속성을 모두 실행 파일의 버전을 대신 사용 합니다.  
  
 경로 사용 하 여 Windows Forms 응용 프로그램은 배포 여부에 따라 달라 지므로 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 됩니다\\*username* 디렉터리입니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 사용자가 공유하는 애플리케이션 데이터의 레지스트리 키를 가져옵니다.</summary>
        <value>모든 사용자가 공유하는 애플리케이션 데이터의 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가 없으면 다음 형식으로 만들어집니다.  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션과 관련된 회사 이름을 가져옵니다.</summary>
        <value>회사 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드에 대한 문화권 정보를 가져오거나 설정합니다.</summary>
        <value>현재 스레드에 대한 문화권 정보를 나타내는 <see cref="T:System.Globalization.CultureInfo" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하는 모든 창입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 스레드의 현재 입력 언어를 가져오거나 설정합니다.</summary>
        <value>현재 스레드의 현재 입력 언어를 나타내는 <see cref="T:System.Windows.Forms.InputLanguage" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 메시지 큐에 있는 모든 Windows 메시지를 처리합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 폼을 실행 하면 다음 이벤트 처리를 대기 하는 새 폼을 만듭니다. 폼에 이벤트를 처리할 때마다 해당 이벤트와 연결 된 모든 코드를 처리 합니다. 다른 모든 이벤트는 큐에서 대기 합니다. 코드에서 이벤트를 처리 하는 동안 응용 프로그램이 응답 하지 않습니다. 예를 들어, 다른 창 맨 위에 끌 경우 창 그려지지 않습니다.  
  
 호출 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 응용 프로그램 코드에서 다른 이벤트를 처리할 수 있습니다. 예를 들어, 데이터를 추가 하는 폼이 있어야 하는 경우는 <xref:System.Windows.Forms.ListBox> 추가한 <xref:System.Windows.Forms.Application.DoEvents%2A> 코드에 폼이 다시 그려집니다 다른 창 위로 끌 때. 제거 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A> 코드에서 폼이 그려집니다 단추의 click 이벤트 처리기가 완료 될 때까지 실행 합니다. 메시징에 대 한 자세한 내용은 참조 하세요. [Windows Forms에 사용자 입력](~/docs/framework/winforms/user-input-in-windows-forms.md)합니다.  
  
 Visual Basic 6.0과 달리 합니다 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 호출 하지 않습니다는 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 메서드.  
  
 일반적으로 메시지를 처리 하는 루프에서이 메서드를 사용 합니다.  
  
> [!CAUTION]
>  이 메서드를 호출 하면 현재 스레드가 모든 대기 창 메시지를 처리 하는 동안 일시 중단 합니다. 트리거되지 이벤트가 발생 하는 메시지를 응용 프로그램 코드의 다른 영역 실행할 수 있습니다. 이 인해 응용 프로그램의 디버그 하기 어려운 예기치 않은 동작이 발생할 수 있습니다. 작업이 나 시간이 오래 걸리는 계산을 수행 하는 경우 새 스레드에서 이러한 작업을 수행 하는 것이 좋습니다. 비동기 프로그래밍에 대 한 자세한 내용은 참조 하세요. [비동기 프로그래밍 모델 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드. 예제를 실행 하는 경우 선택할 수 있는 그래픽 파일을 <xref:System.Windows.Forms.OpenFileDialog>입니다. 선택한 파일 형태로 표시 됩니다. <xref:System.Windows.Forms.Application.DoEvents%2A> 메서드를 사용 하면 그래픽 파일을 열어 각 폼을 다시 그리도록 합니다. 이 예제를 실행 하려면 다음 코드를 포함 하는 폼에 붙여를 <xref:System.Windows.Forms.PictureBox> 라는 `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> 라는 `OpenFileDialog1`, 이라는 단추가 `fileButton`합니다. 호출 된 `InitializePictureBox` 하 고 `InitializeOpenFileDialog` 폼의 생성자에서 메서드 또는 `Load` 메서드.  
  
> [!NOTE]
>  Visual Studio를 추가 하는 경우에 <xref:System.Windows.Forms.OpenFileDialog> 끌기 작업을 사용 하 여 폼에 다음을 수정 해야 `InitializeOpenFileDialog` 의 새 인스턴스를 만드는 줄을 제거 하 여 메서드 <xref:System.Windows.Forms.OpenFileDialog>합니다.  
  
 예제에는 항목을 필요는 <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> 의 이벤트를 <xref:System.Windows.Forms.Button> 컨트롤 및 <xref:System.Windows.Forms.FileDialog.FileOk> 의 이벤트는 <xref:System.Windows.Forms.OpenFileDialog> 예제에 정의 된 이벤트 처리기에 연결 된. 예제를 실행할 때 단추를 클릭 하 여 대화 상자를 표시 합니다.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램에 비주얼 스타일을 사용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 응용 프로그램에 대 한 비주얼 스타일을 사용 합니다. 비주얼 스타일 색, 글꼴 및 운영 체제 테마를 구성 하는 기타 시각적 요소 이며 컨트롤 및 운영 체제에서 지 원하는 경우 비주얼 스타일으로 컨트롤을 그립니다. 스타일이 적용 되려면 <xref:System.Windows.Forms.Application.EnableVisualStyles> 응용 프로그램에서 컨트롤을 만들기 전에 호출 해야 합니다 일반적으로 <xref:System.Windows.Forms.Application.EnableVisualStyles> 첫 번째 줄은는 `Main` 함수입니다. 별도 매니페스트를 호출 하는 경우 비주얼 스타일을 사용 하지 않아도 됩니다 <xref:System.Windows.Forms.Application.EnableVisualStyles>합니다.  
  
> [!NOTE]
>  .NET Framework 2.0 이전 합니다 `FlatStyle` 에서 파생 되는 컨트롤과 같은 일부 컨트롤의 속성 <xref:System.Windows.Forms.ButtonBase>로 설정 해야 <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> 비주얼 스타일을 사용 하 여 그릴 컨트롤에 대 한 순서 대로 합니다. .NET Framework 2.0을 사용 하 여 작성 된 응용 프로그램에서 이것이 더 이상 필요 합니다.  
  
> [!NOTE]
>  이 메서드는 Internet Explorer에서 호스팅되는 컨트롤에 대 한 영향을 주지 않습니다 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 호출 <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> 에 `Main` 함수 응용 프로그램에 대 한 비주얼 스타일을 사용 하도록 설정 합니다.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 모달 상태로 전환되려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.Application.EnterThreadModal> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.EnterThreadModal> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">필요한 <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> 이벤트를 대기할 권한입니다.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램을 시작한 실행 파일의 경로(실행 파일 이름 포함)를 가져옵니다.</summary>
        <value>응용 프로그램을 시작한 실행 파일의 경로 및 파일 이름입니다.  
  
이 경로는 Windows Forms 응용 프로그램이 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]를 사용하여 배포되는지 여부에 따라 달라집니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 됩니다\\*username* 디렉터리입니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 경로 가져오는 중입니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 모든 스레드에서 실행 되는 모든 메시지 루프를 중지 하 고 응용 프로그램의 모든 창을 닫습니다. 이 메서드는 응용 프로그램을 종료를 반드시 강제로 되지 않습니다. 합니다 <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 일반적으로 메시지 루프를 강제로 내에서 호출 됩니다 <xref:System.Windows.Forms.Application.Run%2A> 돌아갑니다. 현재 스레드에 대 한 메시지 루프를 종료 하려면 호출 <xref:System.Windows.Forms.Application.ExitThread%2A>합니다.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 다음 이벤트를 발생 하 고 연결된 된 조건부 작업을 수행 합니다.  
  
-   A <xref:System.Windows.Forms.Form.FormClosing> 나타내는 각 폼에 대 한 이벤트가 발생 합니다 <xref:System.Windows.Forms.Application.OpenForms%2A> 속성입니다. 설정 하 여이 이벤트는 취소할 수는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 속성을 해당 <xref:System.Windows.Forms.FormClosingEventArgs> 매개 변수를 `true`입니다.  
  
-   그런 다음 처리기 중 하나에서 이벤트를 취소 하는 경우 <xref:System.Windows.Forms.Application.Exit%2A> 추가 작업 없이 반환 합니다. 이 고, 그렇지는 <xref:System.Windows.Forms.Form.FormClosed> 열려 있는 모든 폼에 대 한 이벤트는 다음 실행 중인 모든 메시지 루프와 forms 닫힙니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> 메서드는 발생 하지 않습니다는 <xref:System.Windows.Forms.Form.Closed> 및 <xref:System.Windows.Forms.Form.Closing> 의 일부로 사용 되지 않는 이벤트 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 합니다 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작할 `listBox1`, 및 `button1`합니다. 클릭할 때 `button1`는 `button1_Click` 목록 상자에 1 ~ 3 숫자를 추가 하 고 표시 하는 메서드를 <xref:System.Windows.Forms.MessageBox>입니다. 클릭 하면 **No** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다. 사용자가 클릭 하면 **예**, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A>, 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
 이 예제에서는 `listBox1` 및 `button1` 인스턴스화되고 폼에 배치 합니다.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">응용 프로그램 내의 <see cref="T:System.Windows.Forms.Form" />이 종료를 취소했는지 여부를 반환합니다.</param>
        <summary>모든 메시지 펌프에 끝나야 함을 알리고 메시지가 처리된 후 모든 응용 프로그램 창을 닫습니다.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">실행을 종료 하는 권한에 대 한 응용 프로그램 스레드입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드의 메시지 루프를 종료하고 스레드의 모든 창을 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 현재 스레드의 메시지 루프를 종료 합니다. 이 메서드를 호출 하면 <xref:System.Windows.Forms.Application.Run%2A> 현재 스레드를 반환 합니다. 전체 응용 프로그램을 종료 하려면 호출 <xref:System.Windows.Forms.Application.Exit%2A>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">필터링할 Windows 이벤트 메시지입니다.</param>
        <summary>창 메시지에 대한 필터를 실행하고 수정된 메시지의 복사본을 반환합니다.</summary>
        <returns>필터가 처리되었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 처리를 끝내고 유휴 상태가 되려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 작업 수행 해야 하는 경우 스레드가 유휴 상태인 전에이 이벤트에 연결 합니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.Application.Idle> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows 폼에 붙여 넣습니다 및 이벤트 처리기와 연결 되었는지 확인 합니다 <xref:System.Windows.Forms.Application.Idle> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램이 모달 상태에서 벗어나려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.Application.LeaveThreadModal> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.LeaveThreadModal> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로밍 사용자가 아닌 로컬 사용자의 응용 프로그램 데이터 경로를 가져옵니다.</summary>
        <value>로밍 사용자가 아닌 로컬 사용자의 응용 프로그램 데이터 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로컬 사용자는 사용자 프로필이 사용자가 로그온는 시스템에 저장 됩니다. 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 일반적인 기본 경로 C:\Documents and Settings\\*username*settings\application 데이터입니다. 이 경로 다를 수 있지만 Windows Forms 응용 프로그램은 사용 하 여 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 하지만이 예제에서는 합니다 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 사용자에 대 한 응용 프로그램 데이터를 저장 하는 속성을 <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> 대신 사용할 수 있습니다.  
  
 합니다 `MyApplicationContext` 클래스에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 간 결함을 위해 일부 코드가 표시 되지 않습니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 스레드에 메시지 루프가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>메시지 루프가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅하는 경우이 속성은 항상 반환 `false`합니다. 사용 하 여 <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> 호스팅 환경에 아직 활성 메시지 루프를 하는 경우 Windows Forms 하도록 지시 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 스레드의 OLE를 초기화합니다.</summary>
        <returns><see cref="T:System.Threading.ApartmentState" /> 값 중 하나입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하기 전에 `Microsoft.Win32` OLE를 필요로 하는 메서드. <xref:System.Windows.Forms.Application.OleRequired%2A> 먼저 현재 스레드의 OLE를 초기화 하는 경우를 확인 합니다. 그러지 않으면 OLE에 대 한 스레드를 초기화 합니다.  
  
> [!NOTE]
>  스레드 OLE 메서드를 직접 호출 하지 않으면이 메서드를 호출할 필요가 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">throw된 예외를 나타내는 <see cref="T:System.Exception" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Application.ThreadException" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 <xref:System.Windows.Forms.Application.OnThreadException%2A> 에 응용 프로그램의 처리를 중단 하는 예외가 발생 합니다.  
  
 합니다 <xref:System.Windows.Forms.Application> 클래스에는 <xref:System.Windows.Forms.Application.ThreadException> 이벤트입니다. 처리 되지 않은 예외에 대 한 필요한 사용자 지정 처리를 수행 하기 위해이 이벤트는 이벤트 처리기를 연결할 수 있습니다. 이벤트 처리기를 연결 하지 않는 경우 <xref:System.Windows.Forms.Application.OnThreadException%2A> 오류가 되었음을 사용자에 게 알릴 수 있는 대화 상자를 표시 하는 기본 동작을 실행 합니다.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> Windows Forms를 소유 하는 스레드에서 발생 하는 처리 되지 않은 예외에 대 한 기본 예외 동작을 구현 합니다. 다른 스레드에서 처리 되지 않은 예외를 처리 합니다 <xref:System.AppDomain.UnhandledException> 이벤트입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램에서 소유한 열려 있는 폼의 컬렉션을 가져옵니다.</summary>
        <value>이 응용 프로그램에서 소유하는 현재 열려 있는 폼을 모두 포함하는 <see cref="T:System.Windows.Forms.FormCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> 속성 응용 프로그램에서 소유 하는 폼의 읽기 전용 컬렉션을 나타냅니다. 이 컬렉션 인덱스 위치 또는 검색할 수는 <xref:System.Windows.Forms.Control.Name%2A> 의 <xref:System.Windows.Forms.Form>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">호출자에 게 정의 된 대로 모든 창에 액세스할 수 있는 권한이 있어야 합니다 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> 값을 <see cref="T:System.Security.Permissions.UIPermissionWindow" /> 열거형입니다.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 응용 프로그램과 관련된 제품 이름을 가져옵니다.</summary>
        <value>제품 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 현재 응용 프로그램의 기본 폼을 포함 하는 어셈블리의 메타 데이터에서 가져옵니다. 설정 하 여 설정할 수 있습니다 <xref:System.Reflection.AssemblyProductAttribute> 어셈블리 매니페스트 내에서. 자세한 내용은 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)를 참조하세요.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 응용 프로그램과 관련된 제품 버전을 가져옵니다.</summary>
        <value>제품 버전입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 으로 버전 번호를 표시 하는 일반적으로 *수 주*. *부 번호*. *빌드 번호*. *전용 부분 번호*합니다. 어셈블리 매니페스트 내에서 어셈블리 버전을 설정 하 여 명시적으로 설정할 수 있습니다. 자세한 내용은 [어셈블리 매니페스트](~/docs/framework/app-domains/assembly-manifest.md)를 참조하세요.  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> 첫 번째은 주 실행 파일을 포함 하는 어셈블리에이 있는지 확인할 수 있는지 확인 합니다 `AssemblyInformationalVersion` 특성입니다. 이 특성이 존재 하는 경우 둘 다에 대해 사용 됩니다 <xref:System.Windows.Forms.Application.ProductVersion%2A> 고 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>입니다. 이 특성이 없으면 속성을 모두 실행 파일의 버전을 대신 사용 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> 이벤트에 전달할 <see cref="E:System.Windows.Forms.Application.Idle" /> 개체입니다.</param>
        <summary>호스팅된 시나리오에서 <see cref="E:System.Windows.Forms.Application.Idle" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅할 때 사용 됩니다. 호출 해야 <xref:System.Windows.Forms.Application.RaiseIdle%2A> 호스팅 응용 프로그램을 유휴 상태로 전환 하는 경우. 이 통해 몇 가지 Windows Forms 컨트롤 및 구성 요소는 사용자가 응용 프로그램 상호 작용 하지 하는 동안 중요 한 백그라운드 작업을 수행할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Windows Forms이 호스팅된 환경에서 아직 메시지를 보내고 있는지 여부를 확인해야 할 경우 호출할 메서드입니다.</param>
        <summary>호스팅된 환경에서 메시지 루프가 실행 중인지 여부를 확인하기 위한 콜백을 등록합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 관리 되지 않는 응용 프로그램과 같은 다른 환경에서 Windows Forms를 호스팅할 때 사용 됩니다. 호스트 된 환경에서 <xref:System.Windows.Forms.Application.MessageLoop%2A> 속성은 항상 Windows Forms 메시지를 처리 하지 않은 경우 false를 반환 합니다. 이 콜백을 사용 하 여 호스팅 환경에서 아직 메시지를 처리 하는 경우 Windows Forms에 지시 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">응용 프로그램에서 제거할 <see cref="T:System.Windows.Forms.IMessageFilter" />를 구현한 것입니다.</param>
        <summary>응용 프로그램의 메시지 펌프에서 메시지 필터를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 더 이상 Windows 메시지를 디스패치 되기 전에 캡처 하려고 할 때 메시지 필터를 제거할 수 없습니다.  
  
   
  
## Examples  
 메시지 필터를 사용 하려면 먼저에 대 한 구현을 제공 해야 합니다는 <xref:System.Windows.Forms.IMessageFilter> 인터페이스입니다. 다음 클래스 호출 메시지 필터를 만들고 `TestMessageFilter`합니다. 이 필터는 마우스 왼쪽된 단추와 관련 된 모든 메시지를 차단 합니다.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 응용 프로그램에서 비주얼 스타일로 컨트롤을 그리고 있는지 여부를 지정하는 값을 가져옵니다.</summary>
        <value>응용 프로그램 창의 클라이언트 영역에서 컨트롤에 비주얼 스타일이 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자 지정 컨트롤을 그리는 경우이 속성을 사용 하 여 모양을 응용 프로그램에서 다른 컨트롤과 일관 되도록 비주얼 스타일로 컨트롤을 그릴 것인지를 결정 합니다.  
  
 다음 표에서 대 한 있어야 하는 네 가지 조건이 <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> 반환할 `true`합니다.  
  
|조건|설명|  
|---------------|-----------------|  
|운영 체제에서 비주얼 스타일을 지원합니다.|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.|  
|사용자가 운영 체제에서 비주얼 스타일이 활성화|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 클래스의 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 속성을 사용하세요.|  
|응용 프로그램에서 비주얼 스타일 사용|<xref:System.Windows.Forms.Application.EnableVisualStyles> 메서드를 호출하여 또는 컨트롤 그리기에 ComCtl32.dll 버전 6 이상을 사용하도록 지정하는 애플리케이션 매니페스트를 사용하여 애플리케이션에서 비주얼 스타일을 사용하도록 설정할 수 있습니다.|  
|비주얼 스타일은 응용 프로그램 창의 클라이언트 영역을 그리는 데 사용 되 고|이 조건을 별도로 확인하려면 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 클래스의 <xref:System.Windows.Forms.Application> 속성을 사용하고 값이 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 또는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>인지 확인하세요.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>응용 프로그램을 종료하고 즉시 새 인스턴스를 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출에 대 한 가장 일반적인 이유 `Restart` 를 통해 다운로드 한 응용 프로그램의 새 버전을 시작 하는 것 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 사용 하는 `Update` 또는 `UpdateAsync` 메서드.  
  
 응용 프로그램은 처음 실행 된 컨텍스트에서 다시 시작 됩니다. 응용 프로그램의 주 실행 파일을 직접 가리키는 URL을 사용 하 여 응용 프로그램 시작 된 경우 동일한 URL을 사용 하 여 시작할 수 있습니다. 응용 프로그램을 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램을 사용 하 여 다시 시작할 수 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]입니다.  
  
 응용 프로그램이 처음 실행 하는 경우 명령줄 옵션이 제공된 된 경우 <xref:System.Windows.Forms.Application.Restart%2A> 동일한 옵션을 사용 하 여 다시 응용 프로그램을 시작 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">사용자 코드가 Windows Forms 응용 프로그램이 아닌 경우. 이 컨텍스트에서 이 메서드를 호출할 수 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">필요한 <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> 권한.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>폼을 사용하지 않고 현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Win32 기반 또는 Windows Forms 응용 프로그램 메시지 루프는 마우스 클릭과 키보드 입력과 같은 사용자 이벤트를 처리 하는 코드에서 루틴입니다. 모든 실행 중인 Windows 기반 응용 프로그램에는 주 메시지 루프를 호출 하는 활성 메시지 루프에 필요 합니다. 주 메시지 루프가 종료 되 면 응용 프로그램이 종료 됩니다. Windows Forms에서이 루프를 닫을 때 합니다 <xref:System.Windows.Forms.Application.Exit%2A> 메서드를 호출 되거나는 <xref:System.Windows.Forms.Application.ExitThread%2A> 주 메시지 루프를 실행 하는 스레드에서 호출 됩니다.  
  
 대부분의 Windows Forms 개발자는이 버전의 메서드를 사용할 필요가 없습니다. 기능을 사용할지는 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> 오버 로드를 기본 폼이 닫힐 때 응용 프로그램이 종료 되도록 기본 폼을 사용 하 여 응용 프로그램을 시작 합니다. 기타 모든 상황에 대 한 사용 합니다 <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> 오버 로드를 제공 하는 것이 지는 <xref:System.Windows.Forms.ApplicationContext> 보다 효과적으로 제어할 응용 프로그램의 수명에 대 한 개체입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">주 메시지 루프가 이미 이 스레드에서 실행되고 있는 경우</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">응용 프로그램이 실행되는 <see cref="T:System.Windows.Forms.ApplicationContext" />입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ApplicationContext" />를 사용하여 현재 스레드에서 표준 응용 프로그램 메시지 루프를 실행하기 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메시지 루프 실행 될 때까지 <xref:System.Windows.Forms.Application.Exit%2A> 나 <xref:System.Windows.Forms.Application.ExitThread%2A> 라고 또는 <xref:System.Windows.Forms.Application.ThreadExit> 컨텍스트 개체에서 이벤트가 발생 합니다.  
  
   
  
## Examples  
 예제에서는 두 개의 폼을 표시 하 고 모두 폼이 닫히면 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.ApplicationContext>, 함께 `Application.Run(context)` 응용 프로그램을 시작 하는 경우 여러 개의 폼을 표시할 메서드.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 에 대 한 코드를 `AppForm1` 고 `AppForm2` 폼 간 결함을 위해 표시 되지 않습니다. 참조 된 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 목록은 클래스 개요입니다.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">주 메시지 루프가 이미 이 스레드에서 실행되고 있는 경우</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">표시하려는 폼을 나타내는 <see cref="T:System.Windows.Forms.Form" />입니다.</param>
        <summary>현재 스레드에서 표준 응용 프로그램 메시지 루프의 실행을 시작하고 지정된 폼을 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 응용 프로그램의 main 함수는이 메서드를 호출 하 고 응용 프로그램의 주 창에 전달 합니다.  
  
 이 메서드는 이벤트 처리기를 추가 합니다 `mainForm` 에 대 한 매개 변수는 <xref:System.Windows.Forms.Form.Closed> 이벤트입니다. 이벤트 처리기 호출을 <xref:System.Windows.Forms.Application.ExitThread%2A> 응용 프로그램을 정리 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.Control.Dispose%2A> 메서드는 <xref:System.Windows.Forms.Form> 이 메서드를 반환 하기 전에 호출 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼에 목록 상자에 숫자를 표시 합니다. 클릭할 때마다 `button1`, 응용 프로그램 목록에 다른 숫자를 추가 합니다.  
  
 합니다 `Main` 메서드 호출 <xref:System.Windows.Forms.Application.Run%2A> 폼을 만드는 응용 프로그램을 시작할 `listBox1`, 및 `button1`합니다. 클릭할 때 `button1`는 `button1_Click` 목록 상자에 1 ~ 3 숫자를 추가 하 고 표시 하는 메서드를 <xref:System.Windows.Forms.MessageBox>입니다. 클릭 하면 **No** 에 <xref:System.Windows.Forms.MessageBox>, `button1_Click` 메서드 목록에 다른 숫자를 추가 합니다. 사용자가 클릭 하면 **예**, 응용 프로그램이 호출 <xref:System.Windows.Forms.Application.Exit%2A> 큐에 남아 있는 모든 메시지를 처리 하 고 종료 됩니다.  
  
 이 예제에서는 `listBox1` 및 `button1` 만들고 폼에 배치 합니다.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">주 메시지 루프가 이미 현재 스레드에서 실행되고 있는 경우</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>경고 배너와 함께 최상위 창 캡션이 표시될 때 이 캡션에 적용될 서식 문자열을 가져오거나 설정합니다.</summary>
        <value>최상위 창 캡션에 적용될 서식 문자열입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하는 모든 창입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">새 컨트롤에 사용할 기본값입니다. <see langword="true" />이면 <c>UseCompatibleTextRendering</c>을 지원하는 새 컨트롤이 텍스트 렌더링에 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 기반의 <see cref="T:System.Drawing.Graphics" /> 클래스를 사용하고, <see langword="false" />이면 새 컨트롤이 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 기반의 <see cref="T:System.Windows.Forms.TextRenderer" /> 클래스를 사용합니다.</param>
        <summary>특정 컨트롤에 정의된 <c>UseCompatibleTextRendering</c> 속성에 대한 애플리케이션 수준의 기본값을 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특정 Windows Forms 컨트롤 중 하나를 사용 하 여 해당 텍스트를 렌더링할 수는 <xref:System.Windows.Forms.TextRenderer> 기반으로 하는 클래스를 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 그래픽 라이브러리 또는 <xref:System.Drawing.Graphics> 클래스를 기반으로 하는 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 그래픽 라이브러리. 이 변경은 합니다 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 성능과 지역화 문제로 인해 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다. 사용 하 여 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 의 기본값을 설정 하는 `UseCompatibleTextRendering` 지 원하는 컨트롤에 대 한 속성입니다.  
  
 `UseCompatibleTextRendering` 속성을 사용 하 여 렌더링 텍스트는 Windows Forms 컨트롤 간에 시각적 호환성을 제공 합니다 <xref:System.Windows.Forms.TextRenderer> 클래스 및 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 고 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] 를사용하여사용자지정텍스트렌더링을수행하는응용프로그램<xref:System.Drawing.Graphics>클래스입니다. 대부분의 경우 응용 프로그램에서 업그레이드 중이 아님 [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 또는 [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]를 그대로 두는 것이 좋습니다 `UseCompatibleTextRendering` 기본값인으로 `false`합니다.  
  
 합니다 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 기반 <xref:System.Windows.Forms.TextRenderer> 클래스에 도입 된는 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] 성능 향상을 위해 텍스트를 좋게 및 국가별 글꼴에 대 한 지원이 향상을 확인 합니다. 이전 버전의 합니다 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]는 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 기반 <xref:System.Drawing.Graphics> 클래스는 모든 텍스트 렌더링을 수행 하는 데 사용 되었습니다. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 문자 간격 및 줄 바꿈 다르게에서 계산 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]합니다. 사용 하는 Windows Forms 응용 프로그램을 <xref:System.Drawing.Graphics> 텍스트를 렌더링 하는 클래스를 사용 하는 컨트롤의 텍스트 발생할 수 있습니다 <xref:System.Windows.Forms.TextRenderer> 응용 프로그램의 다른 텍스트와에서 다르게 표시 합니다. 이러한 호환성 문제를 해결 하려면 설정 합니다 `UseCompatibleTextRendering` 속성을 `true`입니다. 설정 하려면 `UseCompatibleTextRendering` 에 `true` 응용 프로그램에서 모든 지원 되는 컨트롤에 대 한 호출을 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> 매개 변수를 사용 하 여 메서드 `true`합니다.  
  
 Windows Forms 코드는 Internet Explorer와 같은 다른 응용 프로그램에서 호스팅되는 경우이 메서드는 호출 하지 말아야 합니다. 만 독립 실행형 Windows Forms 응용 프로그램에서이 메서드를 호출 합니다.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  에 대 한 기본값을 설정 하려면 `UseCompatibleTextRendering` 에 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] 이상 <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>합니다.  
  
 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 이상에 대 한 호출 <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> Program.cs 파일에서 자동으로 생성 됩니다. 텍스트 렌더링 기본값을 변경 하려면 생성된 된 코드를 수정 합니다.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Windows Forms 응용 프로그램에서 첫 번째 창이 만들어진 후에 이 메서드를 호출한 경우</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">전환할 전원 모드를 나타내는 <see cref="T:System.Windows.Forms.PowerState" />입니다.</param>
        <param name="force">일시 중단 모드를 즉시 적용하려면 <see langword="true" />이고, Windows에서 각 응용 프로그램에 일시 중단 요청을 보내게 하려면 <see langword="false" />입니다.</param>
        <param name="disableWakeEvent">깨우기 이벤트가 발생할 때 시스템의 전원 상태를 활성 상태로 복원하지 않으려면 <see langword="true" />이고, 깨우기 이벤트가 발생할 때 시스템의 전원 상태를 활성 상태로 복원하려면 <see langword="false" />입니다.</param>
        <summary>시스템을 일시 중단하거나 최대 절전 모드로 전환하거나, 시스템을 일시 중단하거나 최대 절전 모드로 전환하도록 요구합니다.</summary>
        <returns>시스템이 일시 중단되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 20 시간 (초) 내에서 응용 프로그램 일시 중단 요청에 응답 하지 않으면, Windows는 응답이 없는 상태 이므로 응용 프로그램 수 중지 하거나 종료를 결정 합니다. 응용 프로그램을 일시 중단 요청에 응답 한 후 리소스를 정리 하 고 활성 프로세스를 종료 하는 데 필요한 만큼의 시간 걸릴 수 있지만.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>처리되지 않은 예외에 응답하는 방법을 응용 프로그램에 지시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">예외가 catch되지 않고 throw되는 경우 응용 프로그램의 동작을 설명하는 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 값입니다.</param>
        <summary>처리되지 않은 예외에 응답하는 방법을 응용 프로그램에 지시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 Windows Forms에서 throw 된 예외를 catch 할 수는 없는 경우가 많습니다. 이 메서드를 사용 하 여 Windows Forms 구성 요소에 의해 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부를 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.  
  
 호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.  
  
 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">응용 프로그램에서 창을 처음 만든 후에는 예외 모드를 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">예외가 catch되지 않고 throw되는 경우 응용 프로그램의 동작을 설명하는 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 값입니다.</param>
        <param name="threadScope">스레드 예외 모드를 설정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>처리되지 않은 예외에 응답하고 필요에 따라 스레드 관련 동작을 적용하는 방법을 응용 프로그램에 지시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 Windows Forms에서 throw 된 예외를 catch 할 수는 없는 경우가 많습니다. 이 메서드를 사용 하 여 Windows Forms 구성 요소에 의해 throw 된 처리 되지 않은 모든 예외를 catch 하 고 작업을 계속할지 여부를 사용자에 게 노출 하 고 실행을 중단할지 응용 프로그램을 지시할 수 있습니다.  
  
 호출 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 사용 하 여 응용 프로그램의 기본 폼을 인스턴스화하기 전에 <xref:System.Windows.Forms.Application.Run%2A> 메서드.  
  
 때 `threadScope` 는 `true`, 스레드 예외 모드를 설정 됩니다. 스레드 예외 모드를 사용 하는 경우 응용 프로그램 예외 모드를 재정의 `mode` 로 설정 되지 않은 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>합니다.  
  
 때 `threadScope` 는 `false`, 응용 프로그램 예외 모드가 설정 됩니다. 응용 프로그램 예외 모드는 포함 된 모든 스레드는 <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> 모드입니다. 응용 프로그램 예외 모드를 설정 하는 경우에 현재 스레드의 설정은 적용 되지 않습니다.  
  
 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">응용 프로그램에서 창을 처음 만든 후에는 예외 모드를 설정할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램을 시작한 실행 파일의 경로(실행 파일 이름 제외)를 가져옵니다.</summary>
        <value>응용 프로그램을 시작한 실행 파일의 경로입니다.  
  
이 경로는 Windows Forms 응용 프로그램이 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]를 사용하여 배포되는지 여부에 따라 달라집니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 응용 프로그램은 C:\Documents and Settings의 사용자별 응용 프로그램 캐시에 저장 됩니다\\*username* 디렉터리입니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는이 속성을 가져옵니다 하 고 텍스트 상자에 해당 값을 표시 합니다. 이 예제에서는 `textBox1` 폼에 배치 되었습니다.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">에 경로 가져오는 중입니다. 연결 된 열거형: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>포착되지 않은 스레드 예외가 throw될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 Windows Forms 스레드에서 발생 하는 핸들 그렇지 않으면 처리 되지 않은 예외를 Windows Forms 응용을 프로그램 수 있습니다. 이벤트 처리기를 연결 합니다 <xref:System.Windows.Forms.Application.ThreadException> 알 수 없는 상태에서 응용 프로그램 그대로 두고 이러한 예외를 처리 하는 이벤트입니다. 가능한 경우 예외를 구조적된 예외 처리 블록에서 처리 되어야 합니다.  
  
 이 콜백을 설정 하 여 처리 되지 않은 Windows Forms 스레드 예외에 대 한 사용 되는지 여부를 변경할 수 있습니다 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>합니다. 만들지 않은 스레드에서 발생 하는 예외를 catch 하 고 사용 하 여 Windows Forms를 소유 하는 <xref:System.AppDomain.UnhandledException> 이벤트 처리기입니다.  
  
> [!NOTE]
>  이 이벤트가 없는 활성화 누락 됩니다을 보장 하기 위해 연결 해야 호출 하기 전에 처리기 <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>합니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 Windows Forms 스레드와 다른 스레드에서 발생 하는 예외 발생 하는 예외에 대 한 이벤트 처리기를 설정 합니다. 설정 <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> 모든 예외는 응용 프로그램의 사용자 구성 파일의 설정에 관계 없이 응용 프로그램에서 처리할 수 있도록 합니다. 사용 합니다 <xref:System.Windows.Forms.Application.ThreadException> UI 스레드 예외를 처리 하는 이벤트 및 <xref:System.AppDomain.UnhandledException> 비 UI 스레드에서 예외를 처리 하는 이벤트입니다. 이후 <xref:System.AppDomain.UnhandledException> 응용 프로그램을 막을 수 없습니다 종료에서 예제 오류를 기록 하기만 종료 하기 전에 응용 프로그램 이벤트 로그에 있습니다.  
  
 이 예에서는 두 개의 정의 했다고 가정 <xref:System.Windows.Forms.Button> 컨트롤 `button1` 하 고 `button2`의 프로그램 <xref:System.Windows.Forms.Form> 클래스입니다.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 이벤트 처리기를 추가 하는 경우 관리 되지 않는 코드를 호출 하려면 호출자가 즉시입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>스레드가 종료되려고 할 때 발생합니다. 응용 프로그램의 주 스레드가 종료되려고 할 때 이 이벤트가 발생한 다음 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 이벤트가 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 처리기를 연결 해야 합니다는 <xref:System.Windows.Forms.Application.ThreadExit> 하나를 수행 하는 이벤트 처리 되지 않은, 스레드가 실행을 중지 하기 전에 필수 작업입니다. 이 스레드 또는 가비지 수집기 회수 되지 않은 개체를 삭제 하 여 열려 있는 파일을 닫습니다.  
  
> [!CAUTION]
>  정적 이벤트 이기 때문에 응용 프로그램 삭제 되거나 메모리 누수가 발생 하는 경우 이벤트 처리기를 분리 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.Application.ThreadExit> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 Windows Forms에 붙여 넣습니다 및 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.Application.ThreadExit> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />를 사용하여 등록한 메시지 루프 콜백의 등록을 취소합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자의 응용 프로그램 데이터 경로를 가져옵니다.</summary>
        <value>사용자의 응용 프로그램 데이터 경로입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경로가 없으면 다음 형식으로 만들어집니다.  
  
 *기본 경로*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 이 경로에 저장 된 데이터에는 로밍에 사용 되는 사용자 프로필의 일부입니다. 로밍 사용자 네트워크에 둘 이상의 컴퓨터에서 작동합니다. 사용자 프로필 로밍 사용자에 대 한 서버 네트워크에서 유지 되 고 사용자가 로그온 하면 시스템으로 로드 됩니다. 로밍에 대 한 것으로 간주 하는 사용자 프로필에 대 한 운영 체제는 로밍 프로필을 지원 해야 하 고 사용 하도록 설정 해야 합니다.  
  
 일반적인 기본 경로 C:\Documents and Settings\\*username*\Application Data. 이 경로 다를 수 있지만 Windows Forms 응용 프로그램은 사용 하 여 배포 하는 경우 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]합니다. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 다른 모든 응용 프로그램에서 격리 된 자체 응용 프로그램 데이터 디렉터리를 만듭니다. 자세한 내용은 [로컬 및 ClickOnce 응용 프로그램의 원격 데이터 액세스](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 폼을 표시 하 고 두 형태 모두 닫을 때 응용 프로그램을 종료 합니다. 응용 프로그램 시작 및 종료, 경우에 각 폼의 위치가 기억 됩니다. 이 예제에서는 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 속성을 사용자에 대 한 응용 프로그램 데이터를 저장 합니다.  
  
 클래스 `MyApplicationContext` 에서 상속 <xref:System.Windows.Forms.ApplicationContext> 각 폼 닫혀 있고 둘 경우 현재 스레드를 종료 하는 시기를 추적 하 고 있습니다. 클래스는 사용자에 대 한 각 폼의 위치를 저장합니다. 폼 위치 데이터 라는 파일에 저장 됩니다 `Appdata.txt` 기준 위치에 만든 <xref:System.Windows.Forms.Application.UserAppDataPath%2A>합니다. 합니다 `Main` 메서드 호출 `Application.Run(context)` 지정 하는 응용 프로그램을 시작 합니다 <xref:System.Windows.Forms.ApplicationContext>합니다.  
  
 이 코드는 예제에 표시 된 발췌 된 <xref:System.Windows.Forms.ApplicationContext> 클래스 개요입니다. 간 결함을 위해 일부 코드가 표시 되지 않습니다. 참조 <xref:System.Windows.Forms.ApplicationContext> 전체 코드 샘플에 대 한 합니다.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자의 응용 프로그램 데이터에 대한 레지스트리 키를 가져옵니다.</summary>
        <value>사용자의 응용 프로그램 데이터에 대한 레지스트리 키를 나타내는 <see cref="T:Microsoft.Win32.RegistryKey" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 키가 없으면 다음 형식으로 만들어집니다.  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 이 키에 저장 된 데이터에는 로밍에 사용 되는 사용자 프로필의 일부입니다. 로밍 사용자 네트워크에 둘 이상의 컴퓨터에서 작동합니다. 사용자 프로필 로밍 사용자에 대 한 서버 네트워크에서 유지 되 고 사용자가 로그온 하면 시스템으로 로드 됩니다. 로밍에 대 한 것으로 간주 하는 사용자 프로필에 대 한 운영 체제는 로밍 프로필을 지원 해야 하 고 사용 하도록 설정 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>대기 커서가 응용 프로그램의 열려 있는 모든 폼에 사용되는지 여부를 가져오거나 설정합니다.</summary>
        <value>대기 커서가 열려 있는 모든 폼에 사용되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`서 <xref:System.Windows.Forms.Control.UseWaitCursor%2A> 응용 프로그램에서 열려 있는 모든 폼의 속성에 설정할 `true`. 모든 폼이 설정 될 때까지이 호출이 반환 되지 않습니다. 장기 실행 작업을 있고 작업이 여전히 진행 되는 모든 응용 프로그램 폼에 표시 하려는 경우이 속성을 사용 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>비주얼 스타일이 응용 프로그램 창에 적용되는 방법을 지정하는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 클라이언트 영역 또는 응용 프로그램 창의 비클라이언트 영역에서 비주얼 스타일 사용 되는지 여부를 결정 합니다. 일반적으로이 속성은 기본 폼의 생성자 내에서 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리기입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 속성 중 하나에 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 내에서 값을 <xref:System.Windows.Forms.Control.Click> 에 대 한 이벤트 처리기를 <xref:System.Windows.Forms.Button> 컨트롤. 이 코드 예제는에 대해 제공 된 큰 예제의 일부는 <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> 열거형입니다.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>