<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a0a753e7dbacac71ae28a64e7bcd5e38da15ad4" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52376881" /></Metadata><TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Cursor = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>마우스 포인터를 그리는 데 사용되는 이미지를 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 커서가 작은 사진을 화면의 위치가 트랙볼, 펜, 마우스 등의 포인팅 디바이스에 의해 제어 됩니다. 포인팅 디바이스를 이동 하면 운영 체제에 따라 커서를 이동 합니다.  
  
 다양 한 커서 모양은 사용자에 게 마우스 해야 하는 작업을 알려주는 데 사용 됩니다. 예를 들어, 편집 또는 텍스트를 선택 하는 경우는 <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> 커서는 일반적으로 표시 합니다. 대기 커서를 현재 실행 중인 프로세스를 사용자에 게에 주로 사용 됩니다. 사용자를 대기 해야 하는 프로세스의 예제 파일을 파일에 저장 하거나와 같은 컨트롤을 채우는 열을 <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> 또는 <xref:System.Windows.Forms.TreeView> 많은 양의 데이터를 사용 하 여 합니다.  
  
 파생 되는 모든 컨트롤을 <xref:System.Windows.Forms.Control> 클래스는 <xref:System.Windows.Forms.Control.Cursor%2A> 속성입니다. 컨트롤의 범위 내에 없을 때 마우스 포인터에 의해 표시 되는 커서를 변경 하려면 할당을 <xref:System.Windows.Forms.Cursor> 에 <xref:System.Windows.Forms.Control.Cursor%2A> 컨트롤의 속성입니다. 할당 하 여 응용 프로그램 수준에서 커서를 표시할 수는 또는 <xref:System.Windows.Forms.Cursor> 에 <xref:System.Windows.Forms.Cursor.Current%2A> 속성입니다. 예를 들어, 응용 프로그램의 용도 텍스트 파일을 편집 하려면 설정할 수 있습니다 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 속성을 <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> 파일을 로드 하거나 처리 중인 모든 마우스 이벤트를 방지 하기 위해 저장 하는 동안 응용 프로그램 위에 대기 커서를 표시 합니다. 프로세스가 완료 되 면 설정 된 <xref:System.Windows.Forms.Cursor.Current%2A> 속성을 <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> 각 컨트롤 형식에 대해 적절 한 커서를 표시 하려면 응용 프로그램에 대 한 합니다.  
  
> [!NOTE]
>  호출 하는 경우 <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> 다시 설정 하기 전에 <xref:System.Windows.Forms.Cursor.Current%2A> 속성을 다시 합니다 <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> 커서 응용 프로그램 마우스 이벤트를 수신 대기 하는 다시 시작 됩니다 하 고 적절 한 표시 하는 다시 시작 됩니다 <xref:System.Windows.Forms.Cursor> 응용 프로그램에서 각 컨트롤에 대 한 합니다.  
  
 기존 핸들 등의 여러 원본에서 커서 개체를 만들 수 있습니다 <xref:System.Windows.Forms.Cursor>, 표준 <xref:System.Windows.Forms.Cursor> 파일, 리소스 또는 데이터 스트림 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Cursor> 애니메이션된 커서 (.ani 파일) 또는 커서 흑백이 아닌 색을 사용 하 여 클래스를 지원 하지 않습니다.  
  
 커서를 사용 하는 이미지의 크기가 너무 작으면를 사용할 수는 <xref:System.Windows.Forms.Cursor.DrawStretched%2A> 커서의 범위에 맞게 이미지를 적용 하는 방법입니다. 호출 하 여 커서를 임시로 숨길 수 있습니다 합니다 <xref:System.Windows.Forms.Cursor.Hide%2A> 메서드를 호출 하 여 복원할 수는 <xref:System.Windows.Forms.Cursor.Show%2A> 메서드.  
  
 .NET Framework 4.5.2부터는 <xref:System.Windows.Forms.Cursor> app.config 파일에 다음 항목이 포함 되어 있으면 시스템 DPI 설정에 따라 조정 됩니다.  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 다음 코드 예제에서는 사용자 지정 커서를 사용 하 여 보여 주는 폼을 표시 합니다. 사용자 지정 <xref:System.Windows.Forms.Cursor> 응용 프로그램의 리소스 파일에 포함 됩니다. 커서 커서 파일에 포함 된 예제를 실행 하려면 `MyCursor.cur`합니다. 명령줄을 사용 하 여이 예제를 컴파일하려면 다음 플래그를 포함 합니다. `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 다음 코드 예제에서 고객 정보를 표시 한 <xref:System.Windows.Forms.TreeView> 제어 합니다. 루트 트리 노드 고객 이름을 표시 하 고 자식 트리 노드를 각 고객에 게 할당 순서 번호를 표시 합니다. 이 예제에서는 1,000 명 고객이 15 주문과 함께 표시 됩니다. 다시 합니다 <xref:System.Windows.Forms.TreeView> 를 사용 하 여 표시 되지 않습니다는 <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> 및 <xref:System.Windows.Forms.TreeView.EndUpdate%2A> 메서드 및 대기 <xref:System.Windows.Forms.Cursor> 표시 됩니다 하는 동안는 <xref:System.Windows.Forms.TreeView> 만들고 그리는 <xref:System.Windows.Forms.TreeNode> 개체. 이 예제에서는 명명 된 커서 파일이 있어야 `MyWait.cur` 응용 프로그램 디렉터리에서입니다. 도 필요는 `Customer` 개체의 컬렉션을 저장할 수 있는 `Order` 개체 및 인스턴스에 만들었다고를 <xref:System.Windows.Forms.TreeView> 대 한 control 권한는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Cursor" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : nativeint -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">만들 커서의 창 핸들을 나타내는 <see cref="T:System.IntPtr" />입니다.</param>
        <summary>지정된 창 핸들에서 <see cref="T:System.Windows.Forms.Cursor" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 사용 하 여 완료 되 면 커서 핸들을 해제 해야 합니다. 리소스를 삭제 하는 방법에 대 한 자세한 내용은 참조 하세요. [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서 커서를 만들고 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 커서의 <xref:System.Windows.Forms.Cursor.Handle%2A>, 해당 위치 및 클리핑 사각형을 변경 합니다. 결과 위쪽과 왼쪽된 50 픽셀 위치에서 코드를 실행할 때 커서가 이동 합니다. 또한 커서의 클리핑 사각형 폼의 경계를 변경 됩니다 (기본적으로는 사용자의 전체 화면). 이 예제를 실행 하려면를 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Button> 를 클릭할 때이 코드를 호출 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" />가 <see cref="F:System.IntPtr.Zero" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : System.IO.Stream -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.Windows.Forms.Cursor" />를 로드할 데이터 스트림입니다.</param>
        <summary>지정된 데이터 스트림에서 <see cref="T:System.Windows.Forms.Cursor" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 데이터 스트림에 `stream` 커서 (.cur) 파일을 포함 해야 합니다.  
  
> [!NOTE]
>  애니메이션된 커서 (.ani 파일)에서 지원 되지 않습니다는 <xref:System.Windows.Forms.Cursor> 클래스입니다.  
  
   
  
## Examples  
 커서를 로드 하는 다음 코드 예제는 <xref:System.IO.Stream> 만든 합니다 <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A> 메서드의 <xref:System.Windows.Forms.OpenFileDialog>. 메서드가 호출 되 면는 <xref:System.Windows.Forms.OpenFileDialog> 사용자에 게 표시 됩니다 및 시기를 합니다. 현재 파일을 선택 하 고 대화 상자가 닫힌 파일 열릴 및 <xref:System.IO.Stream> 반환 만드는 데 사용 되는 <xref:System.Windows.Forms.Cursor>합니다.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">로드할 커서 파일입니다.</param>
        <summary>지정된 파일에서 <see cref="T:System.Windows.Forms.Cursor" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` 매개 변수는 표준 커서 (.cur) 파일을 참조 해야 합니다.  
  
> [!NOTE]
>  애니메이션된 커서 (.ani 파일)에서 지원 되지 않습니다는 <xref:System.Windows.Forms.Cursor> 클래스입니다.  
  
   
  
## Examples  
 다음 코드 예제에서 고객 정보를 표시 한 <xref:System.Windows.Forms.TreeView> 제어 합니다. 루트 트리 노드 고객 이름을 표시 하 고 자식 트리 노드를 각 고객에 게 할당 순서 번호를 표시 합니다. 이 예제에서는 1,000 명 고객이 15 주문과 함께 표시 됩니다. 다시 합니다 <xref:System.Windows.Forms.TreeView> 를 사용 하 여 표시 되지 않습니다는 <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> 및 <xref:System.Windows.Forms.TreeView.EndUpdate%2A> 메서드 및 대기 <xref:System.Windows.Forms.Cursor> 표시 됩니다 하는 동안는 <xref:System.Windows.Forms.TreeView> 만들고 그리는 <xref:System.Windows.Forms.TreeNode> 개체. 이 예제를 실행 하려면를 `Customer` 개체의 컬렉션을 저장할 수 있는 `Order` 개체입니다. 인스턴스를 만든도 필요는 <xref:System.Windows.Forms.TreeView> 컨트롤을 <xref:System.Windows.Forms.Form>입니다.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : Type * string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor (type, resource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">리소스 <see cref="T:System.Type" />입니다.</param>
        <param name="resource">리소스의 이름입니다.</param>
        <summary>지정된 리소스 유형을 사용하여 지정된 리소스에서 <see cref="T:System.Windows.Forms.Cursor" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음은 응용 프로그램 내에 리소스로 커서를 포함 하는 방법의 예입니다. 리소스를 포함 하려면 리소스 이름 뒤에 쉼표, 다음 전체 어셈블리 경로 참조 합니다. 포함된 리소스에서 커서를 로드 하는 방법을 알아보려면 예제 섹션을 참조 합니다.  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  리소스 참조를 컴파일할 때 뿐만 아니라 코드에서 참조 하는 경우는 대/소문자 구분 C# 및 Visual Basic 컴파일러에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 사용자 지정 커서를 사용 하 여 보여 주는 폼을 표시 합니다 <xref:System.Windows.Forms.Cursor.%23ctor%2A> 생성자입니다. 사용자 지정 <xref:System.Windows.Forms.Cursor> 응용 프로그램의 리소스 파일에 포함 됩니다. 이 예제에서는 명명 된 커서 파일에 포함 된 커서가 있어야 `MyCursor.cur`합니다. 명령줄을 사용 하 여이 예제를 컴파일하려면 다음 플래그를 포함 합니다. `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Cursor.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>커서의 클리핑 사각형을 나타내는 범위를 가져오거나 설정합니다.</summary>
        <value>화면 좌표에서 <see cref="T:System.Windows.Forms.Cursor" />에 대한 클리핑 사각형을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 잘린된 커서의 클리핑 사각형 내 에서만 이동할 수 있습니다. 일반적으로 시스템에서는 마우스가 캡처되는지 현재 하는 경우에이. 커서 잘리지 않습니다. 현재 전체 화면 크기를 포함 하는 결과 사각형입니다.  
  
   
  
## Examples  
 다음 코드 예제에서 커서를 만들고 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 커서의 <xref:System.Windows.Forms.Cursor.Handle%2A>, 해당 위치 및 클리핑 사각형을 변경 합니다. 결과 위쪽과 왼쪽된 50 픽셀 위치에서 코드를 실행할 때 커서가 이동 합니다. 또한 커서의 클리핑 사각형 폼의 경계를 변경 됩니다 (기본적으로는 사용자의 전체 화면). 이 예제를 실행 하려면를 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Button> 를 클릭할 때이 코드를 호출 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하는 모든 창입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberSignature Language="F#" Value="member this.CopyHandle : unit -&gt; nativeint" Usage="cursor.CopyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Windows.Forms.Cursor" />의 핸들을 복사합니다.</summary>
        <returns>커서의 핸들을 나타내는 <see cref="T:System.IntPtr" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 삭제 되지 것입니다의 가비지 수집기에 의해 때문에를 사용 하 여 완료 되 면이 메서드를 호출 하 여 만들어진 핸들의 삭제 되어야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Cursor.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 커서를 나타내는 커서 개체를 가져오거나 설정합니다.</summary>
        <value>마우스 커서를 나타내는 <see cref="T:System.Windows.Forms.Cursor" />입니다. 마우스 커서가 표시되지 않으면 기본값이 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 된 <xref:System.Windows.Forms.Cursor.Current%2A> 속성이 현재 표시 되는 커서를 변경 합니다. 응용 프로그램 수도 있습니다 마우스 이벤트를 수신 대기를 계속할 수 없습니다. 장기 실행 작업 중 응용 프로그램 마우스 이벤트에 응답 하지 않도록 신호를 사용 하 여는 <xref:System.Windows.Forms.Application.UseWaitCursor%2A> 속성입니다. 그러나 대부분의 경우에서 것 백그라운드 스레드를 사용 하 여 장기 실행 작업을 관리 하 고 사용자 인터페이스가 사용자에 게 액세스 하는 것이 좋습니다. 백그라운드 작업을 쉽게 구현에 대 한 자세한 내용은 참조 하세요. <xref:System.ComponentModel.BackgroundWorker>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 하려면 안전한 하위 창에서. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cursor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Cursor" />에서 사용하는 모든 리소스를 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Dispose%2A> 사용을 마치면 <xref:System.Windows.Forms.Cursor>를 호출합니다. `Dispose` 메서드를 사용하면 <xref:System.Windows.Forms.Cursor>를 사용할 수 없게 됩니다. 호출한 후 <xref:System.Windows.Forms.Cursor.Dispose%2A>에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Windows.Forms.Cursor> 가비지 수집기에서 메모리를 회수할 수 있도록 하는 <xref:System.Windows.Forms.Cursor> 차지한 합니다. 자세한 내용은 [관리 되지 않는 리소스 정리](~/docs/standard/garbage-collection/unmanaged.md) 하 고 [Dispose 메서드 구현](~/docs/standard/garbage-collection/implementing-dispose.md)합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Cursor.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.Windows.Forms.Cursor>를 호출하십시오. 그렇지 않은 경우 가비지 수집기가 될 때까지 사용 중인 리소스가 해제 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출할 때 메서드에 전달 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.Draw (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Windows.Forms.Cursor" />를 그릴 <see cref="T:System.Drawing.Graphics" /> 표면입니다.</param>
        <param name="targetRect"><see cref="T:System.Windows.Forms.Cursor" />의 범위를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>지정된 범위 내의 지정된 표면에 커서를 그립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그리기 명령으로 표시 된 그래픽 표면에 시작 되는 `g` 매개 변수를 하지만 <xref:System.Drawing.Graphics> 호출을 전달 하도록 지정된 된 이미지를 렌더링 하는 방법에 대 한 정보를 포함 하지는 <xref:System.Windows.Forms.Cursor>합니다. 합니다 <xref:System.Windows.Forms.Cursor.Draw%2A> 메서드는 지정 된 차원에 이미지를 자릅니다 및 지정할 수 있습니다를 <xref:System.Drawing.Rectangle> 그릴는 <xref:System.Windows.Forms.Cursor>합니다. 이 메서드는 그래픽 표면에 커서를 그릴 하려는 경우에 일반적으로 사용 됩니다. 예를 들어 있을 수 있습니다에서 커서를 선택할 수 있는 대화 상자는 <xref:System.Windows.Forms.ListBox> 컨트롤 또는 그룹을 <xref:System.Windows.Forms.RadioButton> 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제를 실행 하려면를 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출 될 때 메서드로 전달할 개체입니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawStretched : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.DrawStretched (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g"><see cref="T:System.Windows.Forms.Cursor" />를 그릴 <see cref="T:System.Drawing.Graphics" /> 표면입니다.</param>
        <param name="targetRect"><see cref="T:System.Windows.Forms.Cursor" />의 범위를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <summary>지정된 범위 내의 지정된 표면에 늘이기 형식으로 커서를 그립니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 그리기 명령으로 표시 된 그래픽 표면에 시작 되는 `g` 매개 변수를 하지만 <xref:System.Drawing.Graphics> 개체에 대 한 호출을 전달 하도록 지정된 된 이미지를 렌더링 하는 방법에 대 한 정보를 포함 하지 않습니다는 <xref:System.Windows.Forms.Cursor> 개체입니다. 합니다 <xref:System.Windows.Forms.Cursor.DrawStretched%2A> 메서드를 채우도록 이미지를 지정 된 확장 <xref:System.Drawing.Rectangle> 커서를 그릴 때.  
  
   
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제를 실행 하려면를 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출 될 때 메서드로 전달할 개체입니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cursor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">비교할 <see cref="T:System.Windows.Forms.Cursor" />입니다.</param>
        <summary>커서가 지정된 <see cref="T:System.Windows.Forms.Cursor" />와 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns>이 커서가 지정된 <see cref="T:System.Windows.Forms.Cursor" />와 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서 커서를 만들고 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 커서의 <xref:System.Windows.Forms.Cursor.Handle%2A>, 해당 위치 및 클리핑 사각형을 변경 합니다. 결과 위쪽과 왼쪽된 50 픽셀 위치에서 코드를 실행할 때 커서가 이동 합니다. 또한 커서의 클리핑 사각형 폼의 경계를 변경 됩니다 (기본적으로는 사용자의 전체 화면). 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Button> 를 클릭할 때이 코드를 호출 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="cursor.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>가비지 컬렉션이 회수하기 전에 개체가 리소스를 해제하고 다른 정리 작업을 수행할 수 있게 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cursor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Forms.Cursor" />에 대한 해시 코드를 검색합니다.</summary>
        <returns>현재 <see cref="T:System.Windows.Forms.Cursor" />에 대한 해시 코드입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Cursor.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>커서의 핸들을 가져옵니다.</summary>
        <value>커서의 핸들을 나타내는 <see cref="T:System.IntPtr" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 핸들의 복사본이 아닙니다. 삭제 하지 마십시오.  
  
   
  
## Examples  
 다음 코드 예제에서 커서를 만들고 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 커서의 <xref:System.Windows.Forms.Cursor.Handle%2A>, 해당 위치 및 클리핑 사각형을 변경 합니다. 결과 위쪽과 왼쪽된 50 픽셀 위치에서 코드를 실행할 때 커서가 이동 합니다. 또한 커서의 클리핑 사각형 폼의 경계를 변경 됩니다 (기본적으로는 사용자의 전체 화면). 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Button> 를 클릭할 때이 코드를 호출 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">핸들 값이 <see cref="F:System.IntPtr.Zero" />인 경우</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberSignature Language="F#" Value="static member Hide : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>커서를 숨깁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.Cursor.Show%2A> 고 <xref:System.Windows.Forms.Cursor.Hide%2A> 메서드 호출을 분산 되어야 합니다. 호출할 때마다 합니다 <xref:System.Windows.Forms.Cursor.Hide%2A> 메서드를 호출 해야 합니다 <xref:System.Windows.Forms.Cursor.Show%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 마우스 포인터가 단추의 클라이언트 영역에 들어갈 때 커서를 숨깁니다. 마찬가지로, 마우스 포인터 단추의 클라이언트 영역을 떠날 때 커서를 다시 표시 됩니다. 이 예제는 <xref:System.Windows.Forms.Form> 사용 하 여는 <xref:System.Windows.Forms.Button> 라는 `myButton`합니다.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창에 대해이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.HotSpot : System.Drawing.Point" Usage="System.Windows.Forms.Cursor.HotSpot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>커서 핫 스폿을 가져옵니다.</summary>
        <value>커서 핫 스폿을 나타내는 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.HotSpot%2A> 되는 <xref:System.Drawing.Point> 화면의 다른 요소와 상호 작용 하는 커서의 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">비교할 <see cref="T:System.Windows.Forms.Cursor" />입니다.</param>
        <param name="right">비교할 <see cref="T:System.Windows.Forms.Cursor" />입니다.</param>
        <summary><see cref="T:System.Windows.Forms.Cursor" /> 클래스의 두 인스턴스가 같은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="T:System.Windows.Forms.Cursor" /> 클래스의 두 인스턴스가 같으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[이 연산자에 대 한 해당 메서드는 <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출 될 때 메서드로 전달할 개체입니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="System.Windows.Forms.Cursor.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">비교할 <see cref="T:System.Windows.Forms.Cursor" />입니다.</param>
        <param name="right">비교할 <see cref="T:System.Windows.Forms.Cursor" />입니다.</param>
        <summary><see cref="T:System.Windows.Forms.Cursor" /> 클래스의 두 인스턴스가 같지 않은지 여부를 나타내는 값을 반환합니다.</summary>
        <returns><see cref="T:System.Windows.Forms.Cursor" /> 클래스의 두 인스턴스가 같지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[이 연산자에 대 한 해당 메서드는 <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출할 때 메서드에 전달 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Cursor.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>커서의 위치를 가져오거나 설정합니다.</summary>
        <value>화면 좌표에서 커서의 위치를 나타내는 <see cref="T:System.Drawing.Point" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.Cursor.Position%2A> 속성이 동일 합니다 <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서 커서를 만들고 합니다 <xref:System.Windows.Forms.Cursor.Current%2A> 커서의 <xref:System.Windows.Forms.Cursor.Handle%2A>, 해당 위치 및 클리핑 사각형을 변경 합니다. 결과 위쪽과 왼쪽된 50 픽셀 위치에서 코드를 실행할 때 커서가 이동 합니다. 또한 커서의 클리핑 사각형 폼의 경계를 변경 됩니다 (기본적으로는 사용자의 전체 화면). 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Button> 를 클릭할 때이 코드를 호출 합니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberSignature Language="F#" Value="static member Show : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>커서를 표시합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.Cursor.Show%2A> 고 <xref:System.Windows.Forms.Cursor.Hide%2A> 메서드 호출을 분산 되어야 합니다. 호출할 때마다 합니다 <xref:System.Windows.Forms.Cursor.Hide%2A> 메서드를 호출 해야 합니다 <xref:System.Windows.Forms.Cursor.Show%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에서는 마우스 포인터가 단추의 클라이언트 영역에 들어갈 때 커서를 숨깁니다. 마찬가지로, 마우스 포인터 단추의 클라이언트 영역을 떠날 때 커서를 다시 표시 됩니다. 이 예제는 <xref:System.Windows.Forms.Form> 사용 하 여는 <xref:System.Windows.Forms.Button> 라는 `myButton`합니다.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Windows.Forms.Cursor.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>커서 개체의 크기를 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Forms.Cursor" />의 너비 및 높이를 나타내는 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에서는 크기의 두 배로 늘어난 모드로 보통 크기로 폼에서 지정된 된 커서를 그립니다. 이 예제는 <xref:System.Windows.Forms.Form> 및 <xref:System.Windows.Forms.Cursor> 호출 될 때 메서드로 전달할 개체입니다.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 클래스입니다.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 클래스입니다.</param>
        <summary>개체를 serialize합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Cursor.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Cursor" />에 대한 데이터가 들어 있는 개체를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.Cursor" />에 대한 데이터가 들어 있는 <see cref="T:System.Object" />입니다. 기본값은 <see langword="null" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cursor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Windows.Forms.Cursor" />를 나타내는 사람이 인식할 수 있는 문자열을 검색합니다.</summary>
        <returns>이 <see cref="T:System.Windows.Forms.Cursor" />를 나타내는 <see cref="T:System.String" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>