<Type Name="ListBox" FullName="System.Windows.Forms.ListBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="283899e479c7eb92fbcc9ae4ba579866c07de559" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57955181" /></Metadata><TypeSignature Language="C#" Value="public class ListBox : System.Windows.Forms.ListControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ListBox extends System.Windows.Forms.ListControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ListBox" />
  <TypeSignature Language="VB.NET" Value="Public Class ListBox&#xA;Inherits ListControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ListBox : System::Windows::Forms::ListControl" />
  <TypeSignature Language="F#" Value="type ListBox = class&#xA;    inherit ListControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ListControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultBindingProperty("SelectedValue")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("SelectedIndexChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>항목 목록을 표시할 Windows 컨트롤을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox> 컨트롤을 사용 하면 사용자가 클릭 하 여 선택할 수 있는 사용자에 게 항목의 목록을 표시할 수 있습니다. A <xref:System.Windows.Forms.ListBox> 컨트롤은 단일 또는 다중 선택을 사용 하 여 제공할 수는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성입니다. <xref:System.Windows.Forms.ListBox> 도 제공 합니다 <xref:System.Windows.Forms.ListBox.MultiColumn%2A> 항목을 세로가 아닌 열에 있는 항목의 표시를 사용 하도록 설정 하려면 속성입니다. 이 사용 하 여 컨트롤이 더 많은 항목을 표시할 수 없습니다 및 사용자가 더 이상 항목으로 스크롤하고 해야 합니다.  
  
 Windows에서 표시할 항목의 그리기 작업을 처리 하는 일반적으로 <xref:System.Windows.Forms.ListBox>합니다. 사용할 수는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성과 핸들 합니다 <xref:System.Windows.Forms.ListBox.MeasureItem> 및 <xref:System.Windows.Forms.ListBox.DrawItem> 이벤트는 자동 해당 Windows 그리기를 재정의할 수 있도록 하며 직접 항목을 그리는 합니다. 소유자가 그린 따르면 <xref:System.Windows.Forms.ListBox> 목록의 가변 높이 항목이, 이미지 또는 다른 색 또는 각 항목의 텍스트 글꼴을 표시 하는 컨트롤입니다. 합니다 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 속성인 <xref:System.Windows.Forms.ListBox.GetItemHeight%2A>, 및 <xref:System.Windows.Forms.ListBox.GetItemRectangle%2A> 사용 하면 사용자 고유의 항목을 그릴 수입니다.  
  
 표시 및 선택 기능 외에도 합니다 <xref:System.Windows.Forms.ListBox> 항목을 효율적으로 추가할 수 있도록 하는 기능도 제공는 <xref:System.Windows.Forms.ListBox> 목록의 항목에서 텍스트를 검색 하 합니다. 합니다 <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> 및 <xref:System.Windows.Forms.ListBox.EndUpdate%2A> 메서드를 사용 하는 많은 수의 항목을 추가 하는 <xref:System.Windows.Forms.ListBox> 컨트롤 될 때마다 다시 표시 하지 않고 항목 목록에 추가 됩니다. 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 고 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 메서드를 사용 하는 특정 검색 문자열을 포함 하는 목록의 항목을 검색할 수 있습니다.  
  
 <xref:System.Windows.Forms.ListBox.Items%2A>, <xref:System.Windows.Forms.ListBox.SelectedItems%2A>, 및 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성에서 사용 되는 세 가지 컬렉션에 대 한 액세스를 제공 합니다 <xref:System.Windows.Forms.ListBox>합니다. 다음 표에서 설명에서 사용 하는 세 개의 컬렉션에는 <xref:System.Windows.Forms.ListBox> 및 컨트롤 내에서 사용 합니다.  
  
|컬렉션 클래스|내에서 사용 합니다 <xref:System.Windows.Forms.ListBox>|  
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Forms.ListBox.ObjectCollection>|에 포함 된 모든 항목을 포함 합니다 <xref:System.Windows.Forms.ListBox> 제어 합니다.|  
|<xref:System.Windows.Forms.ListBox.SelectedObjectCollection>|포함 된 항목의 하위 집합에는 선택한 항목의 컬렉션을 포함에 <xref:System.Windows.Forms.ListBox> 제어 합니다.|  
|<xref:System.Windows.Forms.ListBox.SelectedIndexCollection>|인덱스의 하위 집합 선택된 된 인덱스의 컬렉션을 포함의 <xref:System.Windows.Forms.ListBox.ObjectCollection>합니다. 이러한 인덱스는 선택 된 항목을 지정 합니다.|  
  
 다음 세 가지 예제에 따르면 세 개의 인덱싱된 컬렉션에는 <xref:System.Windows.Forms.ListBox> 클래스는 지원 합니다.  
  
 다음 표에서 방법의 예를 보여 줍니다 <xref:System.Windows.Forms.ListBox.ObjectCollection> 항목을 저장 합니다 <xref:System.Windows.Forms.ListBox> 예제에서의 선택 상태 뿐만 아니라 <xref:System.Windows.Forms.ListBox>합니다.  
  
|인덱스|항목|ListBox 내에서 선택 상태|  
|-----------|----------|----------------------------------------|  
|0|개체 1|선택 취소|  
|1|object2|선택함|  
|2|object3|선택 취소|  
|3|object4|선택함|  
|4|object5|선택함|  
  
 기반으로 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection> 이전 표에 표시 된,이 테이블에 표시 하는 방법을 <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> 표시 됩니다.  
  
|인덱스|항목|  
|-----------|----------|  
|0|object2|  
|1|object4|  
|2|object5|  
  
 기반으로 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection> 이전 표에 표시 된,이 테이블에 표시 하는 방법을 <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> 표시 됩니다.  
  
|인덱스|항목의 인덱스|  
|-----------|-------------------|  
|0|1|  
|1|3|  
|2|4|  
  
 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스를 사용 하면 항목을 추가 하는 <xref:System.Windows.Forms.ListBox>합니다. 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 멤버를 추가할 때 메서드가 개체를 수락할 수는 <xref:System.Windows.Forms.ListBox>합니다. 개체에 추가 되 면 합니다 <xref:System.Windows.Forms.ListBox>, 컨트롤에서 정의 된 텍스트를 사용 합니다 <xref:System.Object.ToString%2A> 개체의 개체 내에서 멤버 이름을 지정 하지 않으면에 방법이 지정 되어를 <xref:System.Windows.Forms.ListControl.DisplayMember%2A> 속성. 사용 하 여 항목을 추가 하는 것 외에도 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스를 추가할 수도 있습니다를 사용 하 여 항목는 <xref:System.Windows.Forms.ListControl.DataSource%2A> 의 속성을 <xref:System.Windows.Forms.ListControl> 클래스.  
  
> [!NOTE]
>  있는 경우는 <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ComboBox>, 또는 <xref:System.Windows.Forms.CheckedListBox> 는 기본 Windows form 및 파생된 Windows 폼에 있는 컨트롤의 문자열 컬렉션을 수정 하려면에서는 기본 Windows 폼에 있는 컨트롤의 문자열 컬렉션은 비워 둘 수 있습니다. 문자열 컬렉션이 비어 있으면 되는 읽기 전용으로 다른 Windows 폼을 파생 시킬 때 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 컨트롤 열에 여러 항목을 표시 하는 컨트롤의 목록에서 선택한 항목이 둘 이상 있을 수 있습니다. 50 개의 항목을 추가 하는 예제 코드를 <xref:System.Windows.Forms.ListBox> 를 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 및 선택 하 여 목록에서 항목 3는 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드. 코드를 다음 값을 표시 합니다 <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> 컬렉션을 통해를 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성 및 <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>을 통해는 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성. 이 예제 코드에서 호출에 하는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ListBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ListBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 컨트롤 열에 여러 항목을 표시 하는 컨트롤의 목록에서 선택한 항목이 둘 이상 있을 수 있습니다. 50 개의 항목을 추가 하는 예제 코드를 <xref:System.Windows.Forms.ListBox> 를 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 및 선택 하 여 목록에서 항목 3는 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드. 코드를 다음 값을 표시 합니다 <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> 컬렉션을 통해를 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성 및 <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>을 통해는 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성. 이 예제 코드에서 호출에 하는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemsCore">
      <MemberSignature Language="C#" Value="protected virtual void AddItemsCore (object[] value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddItemsCore(object[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.AddItemsCore(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddItemsCore (value As Object())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddItemsCore(cli::array &lt;System::Object ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddItemsCore : obj[] -&gt; unit&#xA;override this.AddItemsCore : obj[] -&gt; unit" Usage="listBox.AddItemsCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  There is no replacement.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="value">개체의 배열입니다.</param>
        <summary>이 멤버는 더 이상 사용되지 않으며 대체 멤버도 없습니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowSelection">
      <MemberSignature Language="C#" Value="protected override bool AllowSelection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.AllowSelection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property AllowSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool AllowSelection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowSelection : bool" Usage="System.Windows.Forms.ListBox.AllowSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 목록의 항목을 선택할 수 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Forms.SelectionMode" />가 <see cref="F:System.Windows.Forms.SelectionMode.None" />가 아니면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.ListBox.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 배경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 배경색을 나타내는 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.ListBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>형식의 배경 이미지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이블의 <see cref="P:System.Windows.Forms.ListBox.BackgroundImage" /> 속성이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.ListBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 열거형에 정의된 대로 <see cref="T:System.Windows.Forms.ImageLayout" />의 배경 이미지 레이아웃을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" />의 다음 값 중 하나입니다. 값은 <see langword="Center" />, <see langword="None" />, <see langword="Stretch" />, <see langword="Tile" /> 또는 <see langword="Zoom" />입니다. 기본값은 <see langword="Center" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 열거형 값이 없는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.ListBox.BackgroundImageLayout" /> 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdate">
      <MemberSignature Language="C#" Value="public void BeginUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.BeginUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginUpdate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginUpdate();" />
      <MemberSignature Language="F#" Value="member this.BeginUpdate : unit -&gt; unit" Usage="listBox.BeginUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 메서드가 호출될 때까지 해당 컨트롤이 그려지지 않도록 하여 항목이 한 번에 하나씩 <see cref="M:System.Windows.Forms.ListBox.EndUpdate" />에 추가되는 동안 성능을 유지합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 항목을 추가 하는 기본 방법은 <xref:System.Windows.Forms.ListBox> 사용 하는 것을 <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 (통해를 <xref:System.Windows.Forms.ListBox.Items%2A> 의 속성을 <xref:System.Windows.Forms.ListBox>). 이 단일 작업에서 목록 항목의 배열을 추가할 수 있습니다. 하지만 추가 하려는 경우에 하나의 항목을 사용 하 여 시간을 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스를 사용할 수는 <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> 컨트롤 다시 그리기를 수행 하지 못하도록 메서드는 <xref:System.Windows.Forms.ListBox> 항목 목록에 추가 될 때마다. 목록에 항목을 추가 하는 작업을 완료 한 후 호출을 <xref:System.Windows.Forms.ListBox.EndUpdate%2A> 메서드를는 <xref:System.Windows.Forms.ListBox> 다시 그려야 합니다. 이 방법으로 항목의 그리기 추가 <xref:System.Windows.Forms.ListBox> 많은 수의 항목 목록에 추가 되는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> 하 고 <xref:System.Windows.Forms.ListBox.EndUpdate%2A> 5 천 항목을 추가 하는 동안 메서드를 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`에 추가 되었습니다를 <xref:System.Windows.Forms.Form> 이 메서드는 형식 내에 배치 하 고 여기에서 호출 하 고 있습니다.  
  
 [!code-cpp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.EndUpdate" />
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.ListBox.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에 그려진 테두리의 형식을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.BorderStyle" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.BorderStyle.Fixed3D" />입니다.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">값이 <see cref="T:System.Windows.Forms.BorderStyle" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="ClearSelected">
      <MemberSignature Language="C#" Value="public void ClearSelected ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearSelected() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ClearSelected" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearSelected ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearSelected();" />
      <MemberSignature Language="F#" Value="member this.ClearSelected : unit -&gt; unit" Usage="listBox.ClearSelected " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 모든 항목을 선택 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하는 것은 설정에 해당 하는 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 음수 1 (-1) 속성입니다. 신속 하 게 목록의 모든 항목의 선택을 취소 하려면이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성을를 <xref:System.Windows.Forms.ListBox.TopIndex%2A> 속성의 표시 영역에 있는 항목의 목록 맨 위에 현재 선택된 된 항목을 이동할는 <xref:System.Windows.Forms.ListBox>. 또한 다음 예제에서는 사용 하 여 항목을 제거 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> 클래스 및 사용 하 여 모든 항목 선택 영역을 지우는 방법은 <xref:System.Windows.Forms.ListBox.ClearSelected%2A> 메서드. 코드 현재 선택한 항목을 먼저 이동 된 <xref:System.Windows.Forms.ListBox> 목록의 맨 위로 이동 합니다. 현재 선택한 항목 앞의 모든 항목을 제거 및에서 모든 선택을 취소 한 다음 코드는 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 항목이 포함 된 폼 추가 되 고에서 선택한 항목은 현재는 <xref:System.Windows.Forms.ListBox>합니다.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 컨트롤을 클릭하면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnWidth">
      <MemberSignature Language="C#" Value="public int ColumnWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ColumnWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ColumnWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ColumnWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnWidth : int with get, set" Usage="System.Windows.Forms.ListBox.ColumnWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>여러 열로 구성된 <see cref="T:System.Windows.Forms.ListBox" />의 열 너비를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 있는 각 열의 너비(픽셀)입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값 영 (0)으로 설정 하면 기본 너비는 각 열에 할당 됩니다. 경우는 <xref:System.Windows.Forms.ListBox> 는 여러 열은 <xref:System.Windows.Forms.ListBox>,이 속성 목록에서 각 열의 현재 너비를 반환 합니다. 여러 열에서 각 열을 되도록 하려면이 속성을 사용할 수 있습니다 <xref:System.Windows.Forms.ListBox> 해당 항목을 올바르게 표시할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 간단한 두 개의 열 <xref:System.Windows.Forms.ListBox>합니다.  
  
 [!code-csharp[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성에 할당된 값이 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="listBox.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 컨트롤에서 내게 필요한 옵션 개체를 새로 만듭니다.</summary>
        <returns>이 컨트롤에서 내게 필요한 옵션 개체입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ListBox.ObjectCollection CreateItemCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.ListBox/ObjectCollection CreateItemCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.CreateItemCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateItemCollection () As ListBox.ObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::ListBox::ObjectCollection ^ CreateItemCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateItemCollection : unit -&gt; System.Windows.Forms.ListBox.ObjectCollection&#xA;override this.CreateItemCollection : unit -&gt; System.Windows.Forms.ListBox.ObjectCollection" Usage="listBox.CreateItemCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+ObjectCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>항목 컬렉션의 새 인스턴스를 만듭니다.</summary>
        <returns>새 항목 컬렉션을 나타내는 <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" />입니다.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>이 항목을 저장 하는 다른 컬렉션을 제공 하 여 파생된 클래스에서 재정의할 수 있습니다.</para></block>
        <altmember cref="T:System.Windows.Forms.ListBox.ObjectCollection" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.ListBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 핸들이 만들어지는 경우 필요한 작성 매개 변수를 가져옵니다.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 관리 되지 않는 코드를 사용 하 여 작동 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomTabOffsets">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.IntegerCollection CustomTabOffsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/IntegerCollection CustomTabOffsets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.CustomTabOffsets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CustomTabOffsets As ListBox.IntegerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::IntegerCollection ^ CustomTabOffsets { System::Windows::Forms::ListBox::IntegerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomTabOffsets : System.Windows.Forms.ListBox.IntegerCollection" Usage="System.Windows.Forms.ListBox.CustomTabOffsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+IntegerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에 있는 항목 사이의 탭 너비를 가져옵니다.</summary>
        <value>탭 너비를 나타내는 정수 컬렉션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 정수 배열에는 오름차순 탭 공백이 들어 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItemHeight">
      <MemberSignature Language="C#" Value="public const int DefaultItemHeight = 13;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultItemHeight = (13)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ListBox.DefaultItemHeight" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultItemHeight As Integer  = 13" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultItemHeight = 13;" />
      <MemberSignature Language="F#" Value="val mutable DefaultItemHeight : int" Usage="System.Windows.Forms.ListBox.DefaultItemHeight" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>13</MemberValue>
      <Docs>
        <summary>소유자가 그린 <see cref="T:System.Windows.Forms.ListBox" />의 기본 항목 높이를 나타냅니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.ListBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 크기를 가져옵니다.</summary>
        <value>컨트롤의 기본 <see cref="T:System.Drawing.Size" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>소유자가 그린 <see cref="T:System.Windows.Forms.ListBox" />의 시각적 측면이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 소유자가 그린 사용한 <xref:System.Windows.Forms.ListBox>합니다. 이 이벤트는만 때 발생 합니다 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성 `DrawMode.OwnerDrawFixed` 또는 `DrawMode.OwnerDrawVariable`. 이 이벤트를 사용 하 여 항목을 그리는 데 필요한 작업을 수행 하는 <xref:System.Windows.Forms.ListBox>합니다. 가변 크기의 항목이 있는 경우 (때 합니다 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성이로 설정 되어 `DrawMode.OwnerDrawVariable`), 항목을 그리기 전에 <xref:System.Windows.Forms.ListBox.MeasureItem> 이벤트가 발생 합니다. 에 대 한 이벤트 처리기를 만들 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.MeasureItem> 이벤트에 대 한 이벤트 처리기에서 그릴 하려는 항목에 대 한 크기를 지정 하는 <xref:System.Windows.Forms.ListBox.DrawItem> 이벤트입니다.  
  
 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제에는 소유자가 그린 만드는 방법을 보여 줍니다 <xref:System.Windows.Forms.ListBox> 항목입니다. 코드를 사용 하는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성을 그리는 항목은 고정 된 크기 및 <xref:System.Windows.Forms.ListBox.DrawItem> 에 각 항목의 그리기를 수행 하는 이벤트를 <xref:System.Windows.Forms.ListBox>입니다. 메서드와 속성을 사용 하는 예제 코드는 <xref:System.Windows.Forms.DrawItemEventArgs> 클래스 항목을 그릴 이벤트 처리기에 매개 변수로 전달 합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 이라는 컨트롤 `listBox1` 는 폼에 추가 되었습니다는 <xref:System.Windows.Forms.ListBox.DrawItem> 예제 코드에 정의 된 이벤트 처리기 이벤트를 처리 합니다. 예제에는 항목에 추가 된도 필요 합니다 <xref:System.Windows.Forms.ListBox> 순서로 "Apple", "주황색" 및 "진한 보라" 텍스트를 사용 하 여 합니다.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawMode">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DrawMode DrawMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DrawMode DrawMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.DrawMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DrawMode As DrawMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DrawMode DrawMode { System::Windows::Forms::DrawMode get(); void set(System::Windows::Forms::DrawMode value); };" />
      <MemberSignature Language="F#" Value="member this.DrawMode : System.Windows.Forms.DrawMode with get, set" Usage="System.Windows.Forms.ListBox.DrawMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 그리기 모드를 가져오거나 설정합니다.</summary>
        <value>컨트롤 항목의 그리기 모드를 나타내는 <see cref="T:System.Windows.Forms.DrawMode" /> 값 중 하나입니다. 기본값은 <see langword="DrawMode.Normal" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 소유자가 그린 만드는 방법을 보여 줍니다 <xref:System.Windows.Forms.ListBox> 항목입니다. 코드를 사용 하는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성을 그리는 항목은 고정 된 크기 및 <xref:System.Windows.Forms.ListBox.DrawItem> 에 각 항목의 그리기를 수행 하는 이벤트를 <xref:System.Windows.Forms.ListBox>입니다. 메서드와 속성을 사용 하는 예제 코드는 <xref:System.Windows.Forms.DrawItemEventArgs> 클래스 항목을 그릴 이벤트 처리기에 매개 변수로 전달 합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 이라는 컨트롤 `listBox1` 는 폼에 추가 되었습니다는 <xref:System.Windows.Forms.ListBox.DrawItem> 예제 코드에 정의 된 이벤트 처리기 이벤트를 처리 합니다. 예제에는 항목에 추가 된도 필요 합니다 <xref:System.Windows.Forms.ListBox> 순서로 "Apple", "주황색" 및 "진한 보라" 텍스트를 사용 하 여 합니다.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">속성에 할당된 값이 <see cref="T:System.Windows.Forms.DrawMode" /> 열거형의 멤버가 아닌 경우</exception>
        <exception cref="T:System.ArgumentException">여러 열로 구성된 <see cref="T:System.Windows.Forms.ListBox" />가 가변 높이를 가질 수 없는 경우</exception>
        <altmember cref="T:System.Windows.Forms.DrawMode" />
        <altmember cref="E:System.Windows.Forms.ListBox.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="EndUpdate">
      <MemberSignature Language="C#" Value="public void EndUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.EndUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUpdate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUpdate();" />
      <MemberSignature Language="F#" Value="member this.EndUpdate : unit -&gt; unit" Usage="listBox.EndUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 메서드에 의해 그리기가 일시 중단된 후 <see cref="M:System.Windows.Forms.ListBox.BeginUpdate" /> 컨트롤 그리기를 다시 시작합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목을 추가 하는 기본 방법은 <xref:System.Windows.Forms.ListBox> 사용 하는 것을 <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 (통해를 <xref:System.Windows.Forms.ListBox.Items%2A> 의 속성을 <xref:System.Windows.Forms.ListBox>). 이 항목의 배열을 목록에 한 번에 추가할 수 있습니다. 하지만 추가 하려는 경우에 하나의 항목을 사용 하 여 시간을 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스를 사용할 수는 <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> 컨트롤 다시 그리기를 수행 하지 못하도록 메서드는 <xref:System.Windows.Forms.ListBox> 항목 목록에 추가 될 때마다. 목록에 항목을 추가 하는 작업을 완료 한 후 호출을 <xref:System.Windows.Forms.ListBox.EndUpdate%2A> 메서드를는 <xref:System.Windows.Forms.ListBox> 다시 그려야 합니다. 이 방법으로 항목의 그리기 추가 <xref:System.Windows.Forms.ListBox> 많은 수의 항목 목록에 추가 되는 경우.  
  
   
  
## Examples  
 다음 코드 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> 하 고 <xref:System.Windows.Forms.ListBox.EndUpdate%2A> 5 천 항목을 추가 하는 동안 메서드를 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`에 추가 되었습니다를 <xref:System.Windows.Forms.Form> 이 메서드는 형식 내에 배치 하 고 여기에서 호출 하 고 있습니다.  
  
 [!code-cpp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.BeginUpdate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindString">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 문자열로 시작되는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindString">
      <MemberSignature Language="C#" Value="public int FindString (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindString(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindString (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindString(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.FindString : string -&gt; int" Usage="listBox.FindString s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">검색할 텍스트입니다.</param>
        <summary>지정된 문자열로 시작되는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다.</summary>
        <returns>찾은 첫째 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 수행 검색은 대/소문자 구분 되지 않습니다. 지정 된 검색 문자열 매개 변수를 부분적으로 일치 하는 단어에 대 한 검색이 수행 됩니다 `s`합니다. 지정 된 문자열과 일치 하는 첫 번째 항목을 검색 하려면이 메서드를 사용할 수 있습니다. 사용 하 여 검색 텍스트가 포함 된 항목을 제거 하는 등의 작업을 수행할 수 있습니다는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> 메서드 또는 항목의 텍스트를 변경 합니다. 에 있는 텍스트의 다른 인스턴스를 검색 하려는 경우 지정 된 텍스트를 발견 하면를 <xref:System.Windows.Forms.ListBox>, 버전을 사용할 수는 <xref:System.Windows.Forms.ListBox.FindString%2A> 내의 시작 인덱스를 지정 하는 것에 대 한 매개 변수를 제공 하는 방법은 <xref:System.Windows.Forms.ListBox>합니다. 부분적으로 일치 하는 대신 정확 하 게 일치 하는 항목 검색을 수행 하려는 경우 사용 된 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 문자열의 첫 번째 인스턴스를 검색 하는 방법을 <xref:System.Windows.Forms.ListBox>입니다. 경우 항목이 일치 하는 검색 문자열 <xref:System.Windows.Forms.ListBox.FindString%2A> 는-1을 반환 값 및 표시 하는 예제는 <xref:System.Windows.Forms.MessageBox>합니다. 예제에서는 검색 텍스트와 일치 하는 항목이 없으면 합니다 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 에서 항목을 선택 하는 방법의 <xref:System.Windows.Forms.ListBox>.  
  
 [!code-cpp[ListBox.FindString2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString2/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString2/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="s" /> 매개 변수의 값이 -1보다 작거나 항목 수보다 크거나 같은 경우</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindString">
      <MemberSignature Language="C#" Value="public int FindString (string s, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindString(string s, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindString(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindString (s As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindString(System::String ^ s, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.FindString : string * int -&gt; int" Usage="listBox.FindString (s, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">검색할 텍스트입니다.</param>
        <param name="startIndex">검색될 첫째 항목 앞에 나오는 항목의 0부터 시작하는 인덱스입니다. 컨트롤의 처음부터 검색하려면 -1로 설정합니다.</param>
        <summary>지정된 문자열로 시작되는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다. 검색은 특정 시작 인덱스에서 시작됩니다.</summary>
        <returns>찾은 첫째 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 수행 검색은 대/소문자 구분 되지 않습니다. 지정 된 검색 문자열 매개 변수를 부분적으로 일치 하는 단어에 대 한 검색이 수행 됩니다 `s`합니다. 이 메서드를 사용 하 여 지정된 된 시작 인덱스에 대 한 항목 목록 내에 지정 된 문자열과 일치 하는 첫 번째 항목을 검색 하는 <xref:System.Windows.Forms.ListBox>합니다. 사용 하 여 검색 텍스트가 포함 된 항목을 제거 하는 등의 작업을 수행할 수 있습니다는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> 메서드 또는 항목의 텍스트를 변경 합니다. 이 메서드는 호출을 시작 하는 인덱스를 지정 하지 않습니다는이 메서드의 버전을 사용 하 여 생성 된 후에 일반적으로 사용 됩니다. 초기 항목을 목록에서 찾은,이 메서드는 대개 사용의 인덱스 위치를 지정 하 여 검색 텍스트의 인스턴스를 추가로 찾는 `startIndex` 첫 번째 검색된 인스턴스의 검색 텍스트 후 항목의 매개 변수입니다. 부분적으로 일치 하는 대신 정확 하 게 일치 하는 항목 검색을 수행 하려는 경우 사용 된 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 메서드.  
  
> [!NOTE]
>  검색 맨 아래에 도달한 경우는 <xref:System.Windows.Forms.ListBox>, 맨 위부터 검색이 계속 합니다 <xref:System.Windows.Forms.ListBox> 로 지정한 항목을 다시는 `startIndex` 매개 변수.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 의 항목에서 검색 텍스트의 모든 인스턴스를 검색 하는 방법의 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 버전을 사용 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 에 모든 항목의 지속적인 검색을 시작 검색 인덱스를 지정할 수 있도록 하는 메서드를 <xref:System.Windows.Forms.ListBox>. 이 예제에서는 시기를 결정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox.FindString%2A> 메서드 재귀 검색을 방지 하기 위해 항목 목록의 맨 아래에 도달한 후에 목록 맨 위에서 검색을 시작 합니다. 항목이 발견 되 면를 <xref:System.Windows.Forms.ListBox>를 사용 하 여 선택 합니다 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드.  
  
 [!code-cpp[ListBox.FindString#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 매개 변수가 0보다 작거나 <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> 클래스의 <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> 속성 값보다 크거나 같은 경우</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindStringExact">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 문자열과 정확히 일치하는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindStringExact">
      <MemberSignature Language="C#" Value="public int FindStringExact (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindStringExact(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindStringExact (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindStringExact(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.FindStringExact : string -&gt; int" Usage="listBox.FindStringExact s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">검색할 텍스트입니다.</param>
        <summary>지정된 문자열과 정확히 일치하는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다.</summary>
        <returns>찾은 첫째 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 수행 검색은 대/소문자 구분 되지 않습니다. 검색 문자열 매개 변수에 지정 된 단어는 정확히 일치에 대 한 검색이 수행 됩니다 `s`합니다. 지정 된 문자열과 일치 하는 첫 번째 항목을 검색 하려면이 메서드를 사용할 수 있습니다. 사용 하 여 검색 텍스트가 포함 된 항목을 제거 하는 등의 작업을 수행할 수 있습니다는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> 메서드 또는 항목의 텍스트를 변경 합니다. 에 있는 텍스트의 다른 인스턴스를 검색 하려는 경우 지정 된 텍스트를 발견 하면를 <xref:System.Windows.Forms.ListBox>, 버전을 사용할 수는 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 내의 시작 인덱스를 지정 하는 것에 대 한 매개 변수를 제공 하는 방법은 <xref:System.Windows.Forms.ListBox>합니다. 사용 하 여 완전 하 게 일치 하는 대신 부분 단어 검색을 수행 하려는 경우는 <xref:System.Windows.Forms.ListBox.FindString%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.FindStringExact%2A?displayProperty=nameWithType> 검색 방법은 <xref:System.Windows.Forms.ListBox> 지정 된 문자열과 정확히 일치 하는 항목에 대 한 제어 합니다. 검색 문자열을 일치 하는 항목이 없으면 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 는-1을 반환 값 및 표시 하는 예제는 <xref:System.Windows.Forms.MessageBox>합니다. 예제에서는 검색 텍스트와 일치 하는 항목이 없으면 합니다 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 에서 항목을 선택 하는 방법의 <xref:System.Windows.Forms.ListBox>.  
  
 [!code-cpp[ListBox.FindStringExact#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindStringExact/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindStringExact#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindStringExact/CS/form1.cs#1)]
 [!code-vb[ListBox.FindStringExact#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindStringExact/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.FindString(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindStringExact">
      <MemberSignature Language="C#" Value="public int FindStringExact (string s, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindStringExact(string s, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindStringExact(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindStringExact (s As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindStringExact(System::String ^ s, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.FindStringExact : string * int -&gt; int" Usage="listBox.FindStringExact (s, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">검색할 텍스트입니다.</param>
        <param name="startIndex">검색될 첫째 항목 앞에 나오는 항목의 0부터 시작하는 인덱스입니다. 컨트롤의 처음부터 검색하려면 -1로 설정합니다.</param>
        <summary>지정된 문자열과 정확히 일치하는 <see cref="T:System.Windows.Forms.ListBox" />의 첫째 항목을 찾습니다. 검색은 특정 시작 인덱스에서 시작됩니다.</summary>
        <returns>찾은 첫째 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 의해 수행 검색은 대/소문자 구분 되지 않습니다. 지정 된 검색 문자열 매개 변수를 정확 하 게 일치 하는 단어에 대 한 검색이 수행 됩니다 `s`합니다. 이 메서드를 사용 하 여 지정된 된 시작 인덱스에 대 한 항목 목록 내에 지정 된 문자열과 일치 하는 첫 번째 항목을 검색 하는 <xref:System.Windows.Forms.ListBox>합니다. 사용 하 여 검색 텍스트를 포함 하는 항목을 제거 하는 등 태스크를 수행할 수 있습니다는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> 메서드 또는 항목의 텍스트를 변경 합니다. 이 메서드는 호출을 시작 하는 인덱스를 지정 하지 않습니다는이 메서드의 버전을 사용 하 여 생성 된 후에 일반적으로 사용 됩니다. 초기 항목을 목록에서 찾은,이 메서드는 대개 사용의 인덱스 위치를 지정 하 여 검색 텍스트의 인스턴스를 추가로 찾는 `startIndex` 첫 번째 검색된 인스턴스의 검색 텍스트 후 항목의 매개 변수입니다. 사용 하 여 완전 하 게 일치 하는 대신 부분 단어 검색을 수행 하려는 경우는 <xref:System.Windows.Forms.ListBox.FindString%2A> 메서드.  
  
> [!NOTE]
>  검색 맨 아래에 도달한 경우는 <xref:System.Windows.Forms.ListBox>, 맨 위부터 검색이 계속 합니다 <xref:System.Windows.Forms.ListBox> 로 지정한 항목을 다시는 `startIndex` 매개 변수.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 에서 모든 항목을 검색 하는 방법을 <xref:System.Windows.Forms.ListBox> 정확히 일치 하는 지정된 된 검색 텍스트가 합니다. 이 예제에서는 버전을 사용 합니다 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 에 모든 항목의 지속적인 검색을 시작 검색 인덱스를 지정할 수 있도록 하는 메서드를 <xref:System.Windows.Forms.ListBox>. 이 예제에서는 시기를 결정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox.FindStringExact%2A> 메서드 재귀 검색을 방지 하기 위해 항목을 목록의 아래쪽에 도달한 후에 목록 맨 위에서 검색을 시작 합니다. 항목이 발견 되 면를 <xref:System.Windows.Forms.ListBox>를 사용 하 여 선택 합니다 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드.  
  
 [!code-cpp[ListBox.FindStringExact2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindStringExact2/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindStringExact2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindStringExact2/CS/form1.cs#1)]
 [!code-vb[ListBox.FindStringExact2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindStringExact2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 매개 변수가 0보다 작거나 <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> 클래스의 <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> 속성 값보다 크거나 같은 경우</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindString(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.ListBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 표시되는 텍스트의 글꼴을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시되는 텍스트에 적용되는 <see cref="T:System.Drawing.Font" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.ListBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 전경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 전경 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemHeight">
      <MemberSignature Language="C#" Value="public int GetItemHeight (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetItemHeight(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetItemHeight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemHeight (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetItemHeight(int index);" />
      <MemberSignature Language="F#" Value="member this.GetItemHeight : int -&gt; int" Usage="listBox.GetItemHeight index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">높이를 반환할 항목의 인덱스(0부터 시작)입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목 높이를 반환합니다.</summary>
        <returns>지정된 항목의 높이(픽셀)입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성으로 설정 되지 않은 `DrawMode.OwnerDrawVariable`, 표준의 모든 항목의 인덱스 매개 변수의 값은 무시 됩니다 <xref:System.Windows.Forms.ListBox> 크기는 동일 합니다. 소유자가 그린를 사용 하는 경우이 속성을 사용할 수 있습니다 <xref:System.Windows.Forms.ListBox> 내에서 모든 항목의 크기를 결정 하는 <xref:System.Windows.Forms.ListBox>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 매개 변수에 지정된 값이 0보다 작거나 항목 수보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetItemRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetItemRectangle (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetItemRectangle(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetItemRectangle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemRectangle (index As Integer) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetItemRectangle(int index);" />
      <MemberSignature Language="F#" Value="member this.GetItemRectangle : int -&gt; System.Drawing.Rectangle" Usage="listBox.GetItemRectangle index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">해당 경계 사각형을 반환하려는 항목의 인덱스(0부터 시작)입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목에 대한 경계 사각형을 반환합니다.</summary>
        <returns>지정된 항목의 경계 사각형을 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 항목에 지정 된 경우는 `index` 매개 변수가 표시 이면이 메서드에서 반환 하는 사각형 컨트롤의 표시 부분 외부 됩니다. 목록 내 항목의 위치와 크기를 확인 하려면이 메서드를 사용할 수 있습니다. 항목의 높이 가져오려면 특히 가변 높이 소유자 그려지는 목록 항목을 사용할 수는 <xref:System.Windows.Forms.ListBox.GetItemHeight%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 매개 변수가 0보다 작거나 <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> 클래스의 <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> 속성 값보다 크거나 같은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="listBox.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">디스플레이 범위를 검색할 영역을 지정하는 <see cref="T:System.Drawing.Rectangle" />입니다.</param>
        <param name="factor">컨트롤 범위의 높이 및 너비입니다.</param>
        <param name="specified">크기 및 위치를 정의하는 데 사용할 컨트롤 범위를 지정하는 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 크기가 조정되는 범위를 검색합니다.</summary>
        <returns>컨트롤의 크기가 조정되는 범위를 나타내는 <see cref="T:System.Drawing.Rectangle" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.ListBox> 재정의 클래스를 <xref:System.Windows.Forms.Control.GetScaledBounds%2A?displayProperty=nameWithType> 하 게 요청 된 높이 대신 현재 높이 확장 하는 방법입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelected">
      <MemberSignature Language="C#" Value="public bool GetSelected (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetSelected(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetSelected(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelected (index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetSelected(int index);" />
      <MemberSignature Language="F#" Value="member this.GetSelected : int -&gt; bool" Usage="listBox.GetSelected index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">항목이 선택되어 있는지 여부를 확인하는 항목의 인덱스(0부터 시작)입니다.</param>
        <summary>지정된 항목이 선택되어 있는지를 나타내는 값을 반환합니다.</summary>
        <returns>지정된 항목이 <see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 신속 하 게 지정된 된 항목이 선택 되었는지 여부를 확인 하려면이 메서드를 사용할 수 있습니다. 이 메서드는 특정 작업을 다중 선택의 특정 항목이 수행 해야 하는 경우에 유용한 <xref:System.Windows.Forms.ListBox> 을 선택 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.GetSelected%2A> 에서 항목을 확인 하는 방법을 <xref:System.Windows.Forms.ListBox> 선택 되지 않은 항목을 선택 하 고 선택 된 항목을 선택 취소 하기 위해 선택 됩니다. 예제도 사용 하 여 보여 줍니다는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성을 사용를 <xref:System.Windows.Forms.ListBox> 개를 사용 하 여 항목을 선택 합니다 <xref:System.Windows.Forms.ListBox.Sorted%2A> 속성에서 항목을 정렬 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 자동으로. 이 예제에서는 <xref:System.Windows.Forms.ListBox>명명 된 `listBox1`를 폼에 추가 되었습니다 합니다 `InitializeMyListBox` 에서 예제에 정의 된 메서드를 호출 합니다 <xref:System.Windows.Forms.Form.Load> 폼의 이벤트.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 매개 변수가 0보다 작거나 <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> 클래스의 <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> 속성 값보다 크거나 같은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="HorizontalExtent">
      <MemberSignature Language="C#" Value="public int HorizontalExtent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HorizontalExtent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.HorizontalExtent" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalExtent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HorizontalExtent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalExtent : int with get, set" Usage="System.Windows.Forms.ListBox.HorizontalExtent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 가로 스크롤 막대로 스크롤할 수 있는 너비를 가져오거나 설정합니다.</summary>
        <value>가로 스크롤 막대로 컨트롤을 스크롤할 수 있는 너비(픽셀)입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우이 속성에 유용한 값은만 보고 합니다 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 속성이 `true`합니다. 하는 경우의 너비를 <xref:System.Windows.Forms.ListBox> 가로 스크롤 막대를 가로로 스크롤합니다 항목에서이 속성의 값 보다 작은 <xref:System.Windows.Forms.ListBox>합니다. 하는 경우의 너비는 <xref:System.Windows.Forms.ListBox> 이 값 보다 크거나 같음 가로 스크롤 막대가 숨겨집니다. 이 속성의 값으로 동적으로 업데이트 되지 않습니다는 <xref:System.Windows.Forms.ListBox>합니다. 이 속성은 유용의 항목을 <xref:System.Windows.Forms.ListBox> 소유자가 그린 합니다. 예를 들어 경우의 소유자 그리기 항목이 <xref:System.Windows.Forms.ListBox> 너비가 200 픽셀이 하지만 <xref:System.Windows.Forms.ListBox> 60 픽셀는 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 속성 항목의 오른쪽 가장자리 컨트롤의 표시 영역 스크롤하여 하려면 200으로 설정 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 및 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 에 모든 항목의 텍스트를 보여 주는 가로 스크롤 막대를 표시 하려면 속성을 <xref:System.Windows.Forms.ListBox> 컨트롤. 또한이 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> 속성을 항목의 크기로 인해 부분적으로 표시 되지 않습니다는 <xref:System.Windows.Forms.ListBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollbar">
      <MemberSignature Language="C#" Value="public bool HorizontalScrollbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HorizontalScrollbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalScrollbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HorizontalScrollbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalScrollbar : bool with get, set" Usage="System.Windows.Forms.ListBox.HorizontalScrollbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가로 스크롤 막대가 컨트롤에 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 가로 스크롤 막대를 표시하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 속성에 따라 결정 하는지 여부를 <xref:System.Windows.Forms.ListBox> 가로 스크롤을 표시 해야 경우 표시줄 내 항목의 너비는 <xref:System.Windows.Forms.ListBox> 컨트롤의 오른쪽 가장자리를 넘어 확장 합니다. 이 속성 설정 된 경우 `true`, 스크롤 막대에 있는 항목의 너비를 기준으로 자동으로 표시 됩니다는 <xref:System.Windows.Forms.ListBox>합니다. 경우는 <xref:System.Windows.Forms.ListBox> 는 소유자가 그린 <xref:System.Windows.Forms.ListBox>, 가로 스크롤 막대를 올바르게 표시 하기 위해 설정 해야 합니다는 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 및 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 에 모든 항목의 텍스트를 보여 주는 가로 스크롤 막대를 표시 하려면 속성을 <xref:System.Windows.Forms.ListBox> 컨트롤. 또한이 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> 속성을 항목의 크기로 인해 부분적으로 표시 되지 않습니다는 <xref:System.Windows.Forms.ListBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalExtent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexFromPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 좌표에 있는 항목의 0부터 시작하는 인덱스를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexFromPoint">
      <MemberSignature Language="C#" Value="public int IndexFromPoint (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexFromPoint(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.IndexFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexFromPoint (p As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexFromPoint(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.IndexFromPoint : System.Drawing.Point -&gt; int" Usage="listBox.IndexFromPoint p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">항목 인덱스를 얻는 데 사용되는 좌표를 포함하는 <see cref="T:System.Drawing.Point" /> 개체입니다.</param>
        <summary>지정된 좌표에 있는 항목의 0부터 시작하는 인덱스를 반환합니다.</summary>
        <returns>지정된 좌표에 있는 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤 내에서 특정 위치에 있는 항목을 확인할 수 있습니다. 누를 때 선택한 목록 내의 항목을 확인 하려면이 메서드를 사용할 수는 <xref:System.Windows.Forms.ListBox>합니다. 커서의 위치를 결정 하 고 전달할 수 있습니다는 `p` 의 매개 변수는 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 사용자는 항목을 확인할 메서드를 통해 마우스 마우스 오른쪽 단추로 클릭 합니다. 그런 다음 작업 및 특정 항목을 기반으로 하는 기능을 제공 하려면 사용자에 게 바로 가기 메뉴를 표시할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 끌어서 놓기 작업을 수행 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.ListBox> 놓을 항목이 포함 된 컨트롤을 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 양식 설정의 생성자는 <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> 속성을 `true` 끌어서 놓기 작업이 발생할 수 있도록는 <xref:System.Windows.Forms.RichTextBox>합니다. 예제에서는 합니다 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트를 <xref:System.Windows.Forms.ListBox> 호출 하 여 끌기 작업을 시작 하려면를 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드. 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragEnter> 이벤트 항목을 끄는 경우에 <xref:System.Windows.Forms.RichTextBox> 유효한 데이터 형식입니다. <xref:System.Windows.Forms.Control.DragDrop> 으로 끌어 온된 항목의 실제 삭제를 수행 하는 이벤트를 <xref:System.Windows.Forms.RichTextBox> 컨트롤 내에서 현재 커서 위치는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragDrop> 및 <xref:System.Windows.Forms.Control.DragEnter> 예제에 정의 된 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexFromPoint">
      <MemberSignature Language="C#" Value="public int IndexFromPoint (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexFromPoint(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.IndexFromPoint(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexFromPoint (x As Integer, y As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexFromPoint(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IndexFromPoint : int * int -&gt; int" Usage="listBox.IndexFromPoint (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">검색할 위치의 X 좌표입니다.</param>
        <param name="y">검색할 위치의 Y 좌표입니다.</param>
        <summary>지정된 좌표에 있는 항목의 0부터 시작하는 인덱스를 반환합니다.</summary>
        <returns>지정된 좌표에 있는 항목의 인덱스(0부터 시작)입니다. 일치하는 항목이 없으면 <see langword="ListBox.NoMatches" />를 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤 내의 특정 위치에 있는 항목을 확인할 수 있습니다. 누를 때 선택한 목록 내의 항목을 확인 하려면이 메서드를 사용할 수는 <xref:System.Windows.Forms.ListBox>합니다. 커서의 위치를 결정 하 고 전달할 수 있습니다는 `x` 및 `y` 의 매개 변수는 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 사용자는 항목을 확인할 메서드를 통해 마우스 마우스 오른쪽 단추로 클릭 합니다. 그런 다음 작업 및 특정 항목을 기반으로 하는 기능을 제공 하려면 사용자에 게 바로 가기 메뉴를 표시할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하 여 끌어서 놓기 작업을 수행 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.ListBox> 놓을 항목이 포함 된 컨트롤을 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 양식 설정의 생성자는 <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> 속성을 `true` 끌어서 놓기 작업이 발생할 수 있도록는 <xref:System.Windows.Forms.RichTextBox>합니다. 예제에서는 합니다 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트를 <xref:System.Windows.Forms.ListBox> 호출 하 여 끌기 작업을 시작 하려면를 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드. 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragEnter> 이벤트 항목을 끄는 경우에 <xref:System.Windows.Forms.RichTextBox> 유효한 데이터 형식입니다. <xref:System.Windows.Forms.Control.DragDrop> 으로 끌어 온된 항목의 실제 삭제를 수행 하는 이벤트를 <xref:System.Windows.Forms.RichTextBox> 컨트롤 내에서 현재 커서 위치는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragDrop> 및 <xref:System.Windows.Forms.Control.DragEnter> 예제에 정의 된 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntegralHeight">
      <MemberSignature Language="C#" Value="public bool IntegralHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IntegralHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.IntegralHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property IntegralHeight As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IntegralHeight { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IntegralHeight : bool with get, set" Usage="System.Windows.Forms.ListBox.IntegralHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부분 항목을 표시하지 않도록 컨트롤의 크기를 조정할지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>부분 항목을 표시하지 않도록 컨트롤의 크기를 조정하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 컨트롤 크기가 자동으로 조정 항목 부분적으로 표시 되지 않습니다. 원래 크기를 유지 하려는 경우는 <xref:System.Windows.Forms.ListBox> 폼의 공간 요구 사항에 따라이 속성을 설정 `false`합니다.  
  
 기본적으로 <xref:System.Windows.Forms.ListBox> 하며 <xref:System.Windows.Forms.CheckedListBox> 크기는 전체 항목에 대해서만 표시 되도록 합니다. 원하는 경우는 <xref:System.Windows.Forms.ListBox> 또는 <xref:System.Windows.Forms.CheckedListBox> 을 완전히 채우도록 도킹된 영역을 설정 <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> 에 `false`입니다. 이렇게 하면 컨트롤 하 고 영역을 완전히 채울 수 있지만 마지막 항목이 완전히 표시 되지 않습니다.  
  
 경우는 <xref:System.Windows.Forms.ListBox> 모든 항목이 포함 되지 않은이 속성이 적용 되지 않습니다.  
  
> [!NOTE]
>  높이 기준으로 하는 정수 높이 <xref:System.Windows.Forms.ListBox>를 클라이언트 영역 높이 대신 합니다. 결과적으로, 합니다 <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> 속성이 설정 되어 `true`, 항목이 계속 표시 될 수 있습니다 부분적으로 스크롤 막대가 표시 됩니다.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성이 `DrawMode.OwnerDrawVariable`,이 속성이 적용 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 및 <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 에 모든 항목의 텍스트를 보여 주는 가로 스크롤 막대를 표시 하려면 속성을 <xref:System.Windows.Forms.ListBox> 컨트롤. 또한이 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> 속성을 항목의 크기로 인해 부분적으로 표시 되지 않습니다는 <xref:System.Windows.Forms.ListBox> 제어 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ItemHeight">
      <MemberSignature Language="C#" Value="public virtual int ItemHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ItemHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ItemHeight" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ItemHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ItemHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ItemHeight : int with get, set" Usage="System.Windows.Forms.ListBox.ItemHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(13)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목 높이를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 있는 항목의 높이(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성 `DrawMode.OwnerDrawFixed`, 모든 항목의 높이가 같습니다. 경우는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성이로 설정 되어 `DrawMode.OwnerDrawVariable`, <xref:System.Windows.Forms.ListBox.ItemHeight%2A> 속성에 추가 된 각 항목의 높이 지정 합니다 <xref:System.Windows.Forms.ListBox>. 소유자가 그린 목록에서 각 항목은 다른 높이 가질 수 있으므로 사용할 수는 <xref:System.Windows.Forms.ListBox.GetItemHeight%2A> 에서 특정 항목의 높이 가져오기 위한 메서드를 <xref:System.Windows.Forms.ListBox>입니다. 사용 하는 경우는 <xref:System.Windows.Forms.ListBox.ItemHeight%2A> 속성에는 <xref:System.Windows.Forms.ListBox> 가변 높이의 항목을 사용 하 여이 속성 컨트롤의 첫 번째 항목의 높이 반환 합니다.  
  
 최대 높이 <xref:System.Windows.Forms.ListBox> 항목은 255 픽셀입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Windows.Forms.ListBox.ItemHeight" /> 속성이 0픽셀보다 작거나 255픽셀보다 크게 설정된 경우</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.GetItemHeight(System.Int32)" />
        <altmember cref="P:System.Windows.Forms.ListBox.DrawMode" />
        <altmember cref="E:System.Windows.Forms.ListBox.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.ObjectCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/ObjectCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ListBox.ObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::ObjectCollection ^ Items { System::Windows::Forms::ListBox::ObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Forms.ListBox.ObjectCollection" Usage="System.Windows.Forms.ListBox.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+ObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목을 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox.ObjectCollection" />에 있는 항목을 나타내는 <see cref="T:System.Windows.Forms.ListBox" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 현재 저장 되어 있는 항목의 목록에 대 한 참조를 가져올 수 있습니다는 <xref:System.Windows.Forms.ListBox>합니다. 이 참조를 사용 하 여 항목 추가 항목을 제거 고 컬렉션의 항목 개수를 얻을 수 있습니다. 항목 컬렉션을 사용 하 여 수행할 수 있는 작업에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 참조 항목입니다.  
  
 항목을 조작할 수도 있습니다는 <xref:System.Windows.Forms.ListBox> 를 사용 하 여는 <xref:System.Windows.Forms.ListControl.DataSource%2A> 속성입니다. 사용 하는 경우는 <xref:System.Windows.Forms.ListControl.DataSource%2A> 항목을 추가 하는 속성을 <xref:System.Windows.Forms.ListBox>에서 항목을 볼 수 있습니다는 <xref:System.Windows.Forms.ListBox> 를 사용 하 여를 <xref:System.Windows.Forms.ListBox.Items%2A> 속성이 있지만 더하거나의 메서드를 사용 하 여 목록에서 항목을 제거할 수 없습니다는 <xref:System.Windows.Forms.ListBox.ObjectCollection>.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 컨트롤 열에 여러 항목을 표시 하는 컨트롤의 목록에서 선택한 항목이 둘 이상 있을 수 있습니다. 50 개의 항목을 추가 하는 예제 코드를 <xref:System.Windows.Forms.ListBox> 를 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 및 선택 하 여 목록에서 항목 3는 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드. 코드를 다음 값을 표시 합니다 <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> 컬렉션 (통해를 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성) 및 <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> (통해를 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성). 이 예제 코드에서 호출에 하는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ListBox.ObjectCollection" />
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>소유자가 그린 <see cref="T:System.Windows.Forms.ListBox" />가 만들어지고 목록 항목의 크기가 결정될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 항목이 그리기 전에 크기 지정에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Forms.ListBox.DrawItem> 이벤트입니다. 이 이벤트는만 때 발생 합니다 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성 <xref:System.Windows.Forms.DrawMode.OwnerDrawVariable>.  
  
 유효한 최대 높이 <xref:System.Windows.Forms.ListBox> 항목은 255 픽셀입니다. 설정 합니다 <xref:System.Windows.Forms.MeasureItemEventArgs.ItemHeight%2A> 의 속성을 <xref:System.Windows.Forms.MeasureItemEventArgs> 예기치 않은 결과가 발생할 수 있습니다이 이벤트를 처리 하는 경우 255 보다 큰 값으로.  
  
 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는 소유자가 그린 <xref:System.Windows.Forms.ListBox> 설정 하 여는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성을 <xref:System.Windows.Forms.DrawMode.OwnerDrawVariable> 및 처리를 <xref:System.Windows.Forms.ListBox.DrawItem> 및 <xref:System.Windows.Forms.ListBox.MeasureItem> 이벤트. 설정 하는 방법도 보여 줍니다 합니다 <xref:System.Windows.Forms.ListBox.BorderStyle%2A> 하 고 <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> 속성 및 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> 메서드.  
  
 이 예제를 실행 하려면 가져오는 빈 폼에 붙여 합니다 <xref:System.Drawing> 네임 스페이스 및 <xref:System.Windows.Forms> 네임 스페이스입니다. 호출 `InitializeOwnerDrawnListBox` 폼의 생성자에서 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리 메서드.  
  
 [!code-cpp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.ItemHeight" />
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 마우스 포인터로 <see cref="T:System.Windows.Forms.ListBox" /> 컨트롤을 클릭할 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiColumn">
      <MemberSignature Language="C#" Value="public bool MultiColumn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MultiColumn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.MultiColumn" />
      <MemberSignature Language="VB.NET" Value="Public Property MultiColumn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MultiColumn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MultiColumn : bool with get, set" Usage="System.Windows.Forms.ListBox.MultiColumn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 여러 열을 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox" />에서 여러 열을 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 <xref:System.Windows.Forms.ListBox> 세로 스크롤이 필요 없도록 하는 데 필요한 만큼의 열에 항목을 추가 합니다. 사용자는 키보드를 사용 하 여 현재 표시 되지 않는 열으로 이동할 수 있습니다. 설정 된 <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> 속성을 `true` 의 표시 영역에 현재 표시 되지 않은 열을 스크롤할 수 있도록 가로 스크롤 막대를 표시 하려면를 <xref:System.Windows.Forms.ListBox>입니다. 값을 <xref:System.Windows.Forms.ListBox.ColumnWidth%2A> 속성 각 열의 너비를 결정 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 간단한 두 개의 열 <xref:System.Windows.Forms.ListBox>합니다.  
  
 [!code-csharp[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">여러 열로 구성된 <see cref="T:System.Windows.Forms.ListBox" />가 가변 높이를 가질 수 없는 경우</exception>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
        <altmember cref="P:System.Windows.Forms.ListBox.ColumnWidth" />
      </Docs>
    </Member>
    <Member MemberName="NoMatches">
      <MemberSignature Language="C#" Value="public const int NoMatches = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 NoMatches = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ListBox.NoMatches" />
      <MemberSignature Language="VB.NET" Value="Public Const NoMatches As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int NoMatches = -1;" />
      <MemberSignature Language="F#" Value="val mutable NoMatches : int" Usage="System.Windows.Forms.ListBox.NoMatches" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>검색 중에 일치 항목을 찾지 못했음을 나타냅니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 상수에서 반환 되는 <xref:System.Windows.Forms.ListBox.FindString%2A>, <xref:System.Windows.Forms.ListBox.FindStringExact%2A>, 및 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> 메서드 검색에서 일치 하는 값이 없는 경우.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected override void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="listBox.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.UICuesEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ChangeUICues" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected override void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="listBox.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.DataSourceChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberChanged">
      <MemberSignature Language="C#" Value="protected override void OnDisplayMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDisplayMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDisplayMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDisplayMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDisplayMemberChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnDisplayMemberChanged : EventArgs -&gt; unit" Usage="listBox.OnDisplayMemberChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.DisplayMemberChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="listBox.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DrawItemEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListBox.DrawItem" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.ListBox.OnDrawItem%2A> 메서드는 파생된 클래스가 대리자를 연결 하지 않고 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 소유자가 그린 만드는 방법을 보여 줍니다 <xref:System.Windows.Forms.ListBox> 항목입니다. 코드를 사용 하는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성을 그리는 항목은 고정 된 크기 및 <xref:System.Windows.Forms.ListBox.DrawItem> 에 각 항목의 그리기를 수행 하는 이벤트를 <xref:System.Windows.Forms.ListBox>입니다. 메서드와 속성을 사용 하는 예제 코드는 <xref:System.Windows.Forms.DrawItemEventArgs> 클래스 항목을 그릴 이벤트 처리기에 매개 변수로 전달 합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 이라는 컨트롤 `listBox1` 는 폼에 추가 되었습니다는 <xref:System.Windows.Forms.ListBox.DrawItem> 예제 코드에 정의 된 이벤트 처리기 이벤트를 처리 합니다. 예제에는 항목에 추가 된도 필요 합니다 <xref:System.Windows.Forms.ListBox> 순서로 "Apple", "주황색" 및 "진한 보라" 텍스트를 사용 하 여 합니다.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.ListBox.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="listBox.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="listBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>열 너비 및 다른 특성을 설정할 수 있도록 창 핸들을 만든 시기를 지정합니다. 상속하는 클래스는 <see langword="base.OnHandleCreated" />를 호출해야 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="listBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary>항목이 제대로 설정 및 삭제되도록 재정의됩니다. 상속하는 컨트롤은 <see langword="base.OnHandleDestroyed" />를 호출해야 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="listBox.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListBox.MeasureItem" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 <xref:System.Windows.Forms.ListBox.OnMeasureItem%2A> 메서드는 파생된 클래스가 대리자를 연결 하지 않고 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.ListBox.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnParentChanged : EventArgs -&gt; unit" Usage="listBox.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ParentChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnResize : EventArgs -&gt; unit" Usage="listBox.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedIndexChanged">
      <MemberSignature Language="C#" Value="protected override void OnSelectedIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSelectedIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnSelectedIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSelectedIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSelectedIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSelectedIndexChanged : EventArgs -&gt; unit" Usage="listBox.OnSelectedIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.SelectedValueChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedValueChanged">
      <MemberSignature Language="C#" Value="protected override void OnSelectedValueChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSelectedValueChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnSelectedValueChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSelectedValueChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSelectedValueChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSelectedValueChanged : EventArgs -&gt; unit" Usage="listBox.OnSelectedValueChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.SelectedValueChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.ListBox.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.ListBox.Padding" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 컨트롤을 그릴 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.ListBox.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에 있는 모든 항목의 전체 높이를 가져옵니다.</summary>
        <value>컨트롤에 있는 항목의 높이를 합하여 픽셀로 나타낸 것입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 높이 결정 하는 <xref:System.Windows.Forms.ListBox> 수, 사용 가능한 모든 항목 목록에 표시 하기 위해 및 세로 스크롤 막대를 표시 하지 않도록 합니다. 경우에 있는 항목의 크기를 <xref:System.Windows.Forms.ListBox> 의 값을 사용 하 여 컨트롤 크기 조정 커서를 <xref:System.Windows.Forms.ListBox.PreferredHeight%2A> 속성 발생할 수 있습니다는 <xref:System.Windows.Forms.ListBox> 폼의 클라이언트 영역 외부의 크기를 조정할 수 또는 <xref:System.Windows.Forms.ListBox> 컨테이너.  
  
   
  
## Examples  
 다음 코드 예제에는 설정 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.Control.Size%2A> 의 속성을 <xref:System.Windows.Forms.ListBox> 의 값을 기반으로 <xref:System.Windows.Forms.ListBox.PreferredHeight%2A> 속성의 모든 항목을 표시 하기 위해는 <xref:System.Windows.Forms.ListBox> 스크롤 막대가 사용 하지 않고 합니다. 이 예제에서는 한 <xref:System.Windows.Forms.ListBox> 라는 컨트롤 `listBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[ListBox.PreferredHeight#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.PreferredHeight/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.PreferredHeight#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.PreferredHeight/CS/form1.cs#1)]
 [!code-vb[ListBox.PreferredHeight#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.PreferredHeight/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public override void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Refresh();" />
      <MemberSignature Language="F#" Value="override this.Refresh : unit -&gt; unit" Usage="listBox.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤이 해당 컨트롤의 클라이언트 영역을 강제로 무효화하도록 하고 컨트롤 자체와 모든 자식 컨트롤을 즉시 다시 그리도록 합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshItem">
      <MemberSignature Language="C#" Value="protected override void RefreshItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RefreshItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RefreshItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RefreshItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RefreshItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RefreshItem : int -&gt; unit" Usage="listBox.RefreshItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">새로 고칠 요소의 0부터 시작하는 인덱스입니다.</param>
        <summary>지정한 인덱스에 있는 항목을 새로 고칩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.ListControl.DisplayMember%2A> 속성이 설정 되어 속성에 할당 되는 데이터 소스의 <xref:System.Windows.Forms.ListControl.DisplayMember%2A> 변경 내용을 사용 하 여를 <xref:System.Windows.Forms.ListBox.RefreshItem%2A> 의 값을 업데이트 하는 방법은 <xref:System.Windows.Forms.ListBox> 컨트롤입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshItems">
      <MemberSignature Language="C#" Value="protected override void RefreshItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RefreshItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RefreshItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RefreshItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RefreshItems();" />
      <MemberSignature Language="F#" Value="override this.RefreshItems : unit -&gt; unit" Usage="listBox.RefreshItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>모든 <see cref="T:System.Windows.Forms.ListBox" /> 항목을 새로 고치고 이 항목에 대한 새 문자열을 검색합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected override void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="listBox.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">변경 전의 DPI 값입니다.</param>
        <param name="deviceDpiNew">변경 후의 DPI 값입니다.</param>
        <summary>DPI가 변경될 때 컨트롤 크기를 재조정하기 위한 상수를 제공합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public override void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetBackColor();" />
      <MemberSignature Language="F#" Value="override this.ResetBackColor : unit -&gt; unit" Usage="listBox.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackColor" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public override void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetForeColor();" />
      <MemberSignature Language="F#" Value="override this.ResetForeColor : unit -&gt; unit" Usage="listBox.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ForeColor" /> 속성을 기본값으로 다시 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.ListBox.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트가 오른쪽에서 왼쪽으로 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.RightToLeft" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에 메뉴가 오른쪽에서 왼쪽으로 기록 되는 언어를 지원할 수 있습니다. 이 속성 설정 된 경우 `true`, 항목 텍스트가 오른쪽에서 왼쪽으로 기본값 대신 표시 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="listBox.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">컨트롤의 높이와 너비 크기를 조정하는 인수입니다.</param>
        <param name="specified">컨트롤의 크기와 위치를 정의할 때 사용할 컨트롤 범위를 지정하는 <see cref="T:System.Windows.Forms.BoundsSpecified" /> 값입니다.</param>
        <summary>컨트롤의 위치, 크기, 안쪽 여백 및 여백을 조정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollAlwaysVisible">
      <MemberSignature Language="C#" Value="public bool ScrollAlwaysVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScrollAlwaysVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ScrollAlwaysVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollAlwaysVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ScrollAlwaysVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollAlwaysVisible : bool with get, set" Usage="System.Windows.Forms.ListBox.ScrollAlwaysVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>항상 세로 스크롤 막대가 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>세로 스크롤 막대를 항상 표시해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> 속성 세로 스크롤 막대는 항상 표시 여부를 나타냅니다 경우에의 항목 수가 <xref:System.Windows.Forms.ListBox> 세로 스크롤 막대를 표시 하는 것 필요 하지 않습니다. 기본적으로 <xref:System.Windows.Forms.ListBox> 충분 한 항목이 표시 경우 세로 스크롤 막대를 표시 합니다. 여러 열에 대 한 <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> 속성 가로 스크롤 막대가 표시 되는지 나타냅니다. 세로 스크롤 막대는 여러 열에 대 한이 속성의 값에 관계 없이 표시 되지 않습니다 <xref:System.Windows.Forms.ListBox>합니다.  
  
   
  
## Examples  
 소유자가 그린 다음 코드 예제에서는 <xref:System.Windows.Forms.ListBox> 설정 하 여는 <xref:System.Windows.Forms.ListBox.DrawMode%2A> 속성을 합니다 `OwnerDrawVariable` 값 및 처리 합니다 <xref:System.Windows.Forms.ListBox.DrawItem> 및 <xref:System.Windows.Forms.ListBox.MeasureItem> 이벤트입니다. 설정 하는 방법도 보여 줍니다 합니다 <xref:System.Windows.Forms.ListBox.BorderStyle%2A> 하 고 <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> 속성 및 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> 메서드.  
  
 이 예제를 실행 하려면 가져오는 빈 폼에 붙여 합니다 <xref:System.Drawing> 네임 스페이스 및 <xref:System.Windows.Forms> 네임 스페이스입니다. 호출 `InitializeOwnerDrawnListBox` 폼의 생성자에서 또는 <xref:System.Windows.Forms.Form.Load> 이벤트 처리 메서드.  
  
 [!code-cpp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndex">
      <MemberSignature Language="C#" Value="public override int SelectedIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectedIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedIndex" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectedIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedIndex : int with get, set" Usage="System.Windows.Forms.ListBox.SelectedIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있는 항목의 인덱스(0부터 시작)를 가져오거나 설정합니다.</summary>
        <value>현재 선택된 항목의 0부터 시작하는 인덱스입니다. 선택된 항목이 없으면 -1 값이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표준 <xref:System.Windows.Forms.ListBox>에서 선택한 항목의 인덱스를 확인 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.ListBox>합니다. 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 의 속성을 <xref:System.Windows.Forms.ListBox> 로 설정 되어 `SelectionMode.MultiSimple` 또는 `SelectionMode.MultiExtended` (다중 선택 나타내는 <xref:System.Windows.Forms.ListBox>) 목록에서 선택한 여러 항목을이 속성이 선택한 항목에 인덱스를 반환할 수 있습니다.  
  
 다중 선택에서 선택한 항목의 모든 인덱스를 포함 하는 컬렉션을 검색할 <xref:System.Windows.Forms.ListBox>를 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성입니다. 현재 선택 된 항목을 가져오려는 경우 합니다 <xref:System.Windows.Forms.ListBox>를 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 속성입니다. 또한 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성을 다중 선택에서 선택한 모든 항목을 가져올 <xref:System.Windows.Forms.ListBox>합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성을를 <xref:System.Windows.Forms.ListBox.TopIndex%2A> 속성의 표시 영역에 있는 항목의 목록 맨 위에 현재 선택된 된 항목을 이동할는 <xref:System.Windows.Forms.ListBox>. 또한 다음 예제에서는 사용 하 여 항목을 제거 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> 클래스 및 사용 하 여 모든 항목 선택 영역을 지우는 방법은 <xref:System.Windows.Forms.ListBox.ClearSelected%2A> 메서드. 코드 현재 선택한 항목을 먼저 이동 된 <xref:System.Windows.Forms.ListBox> 목록의 맨 위로 이동 합니다. 현재 선택한 항목 앞의 모든 항목을 제거 및에서 모든 선택을 취소 한 다음 코드는 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 항목이 포함 된 폼 추가 되 고에서 선택한 항목은 현재는 <xref:System.Windows.Forms.ListBox>합니다.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">할당된 값이 -1보다 작거나 항목 수보다 크거나 같은 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Windows.Forms.ListBox.SelectionMode" /> 속성은 <see langword="None" />로 설정됩니다.</exception>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndices" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItems" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItem" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectedIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectedIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.SelectedIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectedIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedIndexChanged : EventHandler " Usage="member this.SelectedIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.ListBox.SelectedIndex" /> 속성이나 <see cref="P:System.Windows.Forms.ListBox.SelectedIndices" /> 컬렉션이 변경될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 시기를 확인 하려면이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다의 선택한 인덱스를 <xref:System.Windows.Forms.ListBox> 변경 되었습니다. 현재 선택 영역을 기반으로 다른 컨트롤에서 정보를 표시 해야 할 때 유용할 수 있습니다는 <xref:System.Windows.Forms.ListBox>합니다. 다른 컨트롤에서 정보를 로드 하려면이 이벤트에 대 한 이벤트 처리기를 사용할 수 있습니다.  
  
 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성이로 설정 되어 <xref:System.Windows.Forms.SelectionMode.MultiSimple?displayProperty=nameWithType> 또는 <xref:System.Windows.Forms.SelectionMode.MultiExtended?displayProperty=nameWithType>, 변경의 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 선택 영역에서 항목을 제거 하는 등 컬렉션이이 이벤트를 발생 시킵니다.  
  
 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 이벤트를 검색 하 고 다른 항목을 선택 <xref:System.Windows.Forms.ListBox> 제어 합니다. 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 시기를 결정 하는 이벤트에서 선택한 항목을 <xref:System.Windows.Forms.ListBox> 변경 됩니다. 예제 코드를 사용 하 여 항목의 텍스트를 읽고 다음를 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 속성을 호출 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 다른 메서드 <xref:System.Windows.Forms.ListBox> 에서 반환 된 텍스트를 사용 하 여 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 첫 번째에서 <xref:System.Windows.Forms.ListBox>. 다른 항목이 있으면 <xref:System.Windows.Forms.ListBox>, 항목을 선택 합니다. 이 예제에서는 두 개의 <xref:System.Windows.Forms.ListBox> 컨트롤, 명명 된 `listBox1` 하 고 `listBox2`를 폼에 추가 된 둘 다 <xref:System.Windows.Forms.ListBox> 와 동일한 항목을 포함 하는 컨트롤입니다. 예제는 예제에 정의 된 이벤트 처리 메서드에 연결 되어 있는지도 필요 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 이벤트를 `listBox1`입니다.  
  
 [!code-cpp[ListBox.SelectedIndexChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndexChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndexChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndices">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.SelectedIndexCollection SelectedIndices { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/SelectedIndexCollection SelectedIndices" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedIndices" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedIndices As ListBox.SelectedIndexCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::SelectedIndexCollection ^ SelectedIndices { System::Windows::Forms::ListBox::SelectedIndexCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedIndices : System.Windows.Forms.ListBox.SelectedIndexCollection" Usage="System.Windows.Forms.ListBox.SelectedIndices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+SelectedIndexCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있는 모든 항목의 인덱스(0부터 시작)가 들어 있는 컬렉션을 가져옵니다.</summary>
        <value>현재 컨트롤에 선택되어 있는 항목의 인덱스가 들어 있는 <see cref="T:System.Windows.Forms.ListBox.SelectedIndexCollection" />입니다. 현재 선택된 항목이 없으면 비어 있는 <see cref="T:System.Windows.Forms.ListBox.SelectedIndexCollection" />이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다중 선택에 대 한 <xref:System.Windows.Forms.ListBox>,이 속성에서 선택한 모든 항목에 대 한 인덱스를 포함 하는 컬렉션을 반환 합니다 <xref:System.Windows.Forms.ListBox>합니다. 단일 선택에 대 한 <xref:System.Windows.Forms.ListBox>,이 속성에만 선택한 항목의 인덱스가 포함 된 단일 요소를 포함 하는 컬렉션을 반환 합니다 <xref:System.Windows.Forms.ListBox>합니다. 컬렉션의 항목을 조작 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>합니다.  
  
 <xref:System.Windows.Forms.ListBox> 클래스는 선택한 항목을 참조 하는 방법의 수를 제공 합니다. 사용 하는 대신 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 단일 선택에서 현재 선택한 항목의 인덱스 위치를 가져오는 속성 <xref:System.Windows.Forms.ListBox>를 사용할 수는 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성입니다. 현재 선택 된 항목을 가져오려는 경우 합니다 <xref:System.Windows.Forms.ListBox>, 항목의 인덱스 위치 대신는 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 속성입니다. 또한 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성을 다중 선택에서 선택한 모든 항목을 가져오려는 경우 <xref:System.Windows.Forms.ListBox>합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 의 항목에서 검색 텍스트의 모든 인스턴스를 검색 하는 방법의 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 버전을 사용 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 에 모든 항목의 지속적인 검색을 시작 검색 인덱스를 지정할 수 있도록 하는 메서드를 <xref:System.Windows.Forms.ListBox>. 이 예제에서는 시기를 결정 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox.FindString%2A> 메서드 재귀 검색을 방지 하기 위해 항목 목록의 맨 아래에 도달한 후에 목록 맨 위에서 검색을 시작 합니다. 항목이 발견 되 면를 <xref:System.Windows.Forms.ListBox>를 사용 하 여 선택 합니다 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드.  
  
 [!code-cpp[ListBox.FindString#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItem" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItems" />
      </Docs>
    </Member>
    <Member MemberName="SelectedItem">
      <MemberSignature Language="C#" Value="public object SelectedItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SelectedItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedItem" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SelectedItem { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedItem : obj with get, set" Usage="System.Windows.Forms.ListBox.SelectedItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있는 항목을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 현재 선택 항목을 나타내는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표준 <xref:System.Windows.Forms.ListBox>에서 선택한 항목을 확인 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.ListBox>합니다. 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 의 속성을 <xref:System.Windows.Forms.ListBox> 로 설정 되어 `SelectionMode.MultiSimple` 또는 `SelectionMode.MultiExtended` (나타내는 다중 선택 <xref:System.Windows.Forms.ListBox>) 여러 항목 목록에서 선택 되 고이 속성이 선택된 된 항목을 반환할 수 있습니다.  
  
 다중 선택에서 선택한 모든 항목을 포함 하는 컬렉션을 검색할 <xref:System.Windows.Forms.ListBox>를 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성입니다. 현재 선택한 항목의 인덱스 위치를 가져올 것인지를 <xref:System.Windows.Forms.ListBox>를 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성입니다. 또한 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성을 다중 선택에서 선택된 된 모든 인덱스 <xref:System.Windows.Forms.ListBox>합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 이벤트를 검색 하 고 다른 항목을 선택 <xref:System.Windows.Forms.ListBox> 제어 합니다. 예제에서는 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 시기를 결정 하는 이벤트에서 선택한 항목을 <xref:System.Windows.Forms.ListBox> 변경 됩니다. 예제 코드를 사용 하 여 항목의 텍스트를 읽고 다음를 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 속성을 호출 합니다 <xref:System.Windows.Forms.ListBox.FindString%2A> 다른 메서드 <xref:System.Windows.Forms.ListBox> 에서 반환 된 텍스트를 사용 하 여 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 첫 번째에서 <xref:System.Windows.Forms.ListBox>. 다른 항목이 있으면 <xref:System.Windows.Forms.ListBox>, 항목을 선택 합니다. 이 예제에서는 두 개의 <xref:System.Windows.Forms.ListBox> 컨트롤, 명명 된 `listBox1` 하 고 `listBox2`를 폼에 추가 된 둘 다 <xref:System.Windows.Forms.ListBox> 와 동일한 항목을 포함 하는 컨트롤입니다. 예제는 예제에 정의 된 이벤트 처리 메서드에 연결 되어 있는지도 필요 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> 이벤트를 `listBox1`입니다.  
  
 [!code-cpp[ListBox.SelectedIndexChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndexChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndexChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedItems">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.SelectedObjectCollection SelectedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/SelectedObjectCollection SelectedItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedItems As ListBox.SelectedObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::SelectedObjectCollection ^ SelectedItems { System::Windows::Forms::ListBox::SelectedObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedItems : System.Windows.Forms.ListBox.SelectedObjectCollection" Usage="System.Windows.Forms.ListBox.SelectedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+SelectedObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있는 항목을 포함하는 컬렉션을 가져옵니다.</summary>
        <value>현재 컨트롤에 선택되어 있는 항목을 포함하는 <see cref="T:System.Windows.Forms.ListBox.SelectedObjectCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다중 선택에 대 한 <xref:System.Windows.Forms.ListBox>,이 속성에서 선택한 모든 항목이 포함 된 컬렉션을 반환 합니다 <xref:System.Windows.Forms.ListBox>합니다. 단일 선택에 대 한 <xref:System.Windows.Forms.ListBox>,이 속성에만 선택한 항목이 포함 된 단일 요소를 포함 하는 컬렉션을 반환 합니다 <xref:System.Windows.Forms.ListBox>합니다. 컬렉션의 항목을 조작 하는 방법에 대 한 자세한 내용은 참조 하세요. <xref:System.Windows.Forms.ListBox.SelectedObjectCollection>합니다.  
  
 <xref:System.Windows.Forms.ListBox> 클래스는 선택한 항목을 참조 하는 방법의 수를 제공 합니다. 사용 하는 대신 합니다 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 단일 선택에서 현재 선택한 항목을 가져올 속성 <xref:System.Windows.Forms.ListBox>를 사용할 수 있습니다는 <xref:System.Windows.Forms.ListBox.SelectedItem%2A> 속성. 현재 선택 된 항목의 인덱스 위치를 가져오려는 경우 합니다 <xref:System.Windows.Forms.ListBox>, 자체 항목 대신 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성입니다. 또한 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성을 다중 선택에서 선택한 모든 항목의 인덱스 위치를 가져오려는 경우 <xref:System.Windows.Forms.ListBox>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionMode">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.SelectionMode SelectionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SelectionMode SelectionMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectionMode As SelectionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::SelectionMode SelectionMode { System::Windows::Forms::SelectionMode get(); void set(System::Windows::Forms::SelectionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionMode : System.Windows.Forms.SelectionMode with get, set" Usage="System.Windows.Forms.ListBox.SelectionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SelectionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 항목을 선택하는 방법을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.SelectionMode" /> 값 중 하나입니다. 기본값은 <see langword="SelectionMode.One" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성을 사용 하면 얼마나 많은 항목을 확인할 수 있습니다는 <xref:System.Windows.Forms.ListBox> 사용자를 한 번에 선택할 수 있으며 사용자에서 여러 항목을 선택할 수는 어떻게 합니다. 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성이 `SelectionMode.MultiExtended`, shift 및 마우스를 클릭 하거나 눌러 시프트 및 화살표 키 (위쪽 화살표, 아래쪽 화살표, 왼쪽 화살표 및 오른쪽 화살표) 중 하나에 현재 항목에 이전에 선택한 항목에서 선택을 확장 합니다. . CTRL 키를 누르고 마우스를 클릭 하면 목록의 항목을 선택 취소 하거나 선택 합니다. 속성이로 설정 된 경우 `SelectionMode.MultiSimple`, 마우스 클릭 또는 스페이스바를 누르면 선택 목록의 항목을 선택 취소 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.GetSelected%2A> 에서 항목을 확인 하는 방법을 <xref:System.Windows.Forms.ListBox> 선택 되지 않은 항목을 선택 하 고 선택 된 항목을 선택 취소 하기 위해 선택 됩니다. 예제도 사용 하 여 보여 줍니다는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성을 사용를 <xref:System.Windows.Forms.ListBox> 개를 사용 하 여 항목을 선택 합니다 <xref:System.Windows.Forms.ListBox.Sorted%2A> 속성에서 항목을 정렬 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 자동으로. 이 예제에서는 <xref:System.Windows.Forms.ListBox>명명 된 `listBox1`를 폼에 추가 되었습니다 합니다 `InitializeMyListBox` 에서 예제에 정의 된 메서드를 호출 합니다 <xref:System.Windows.Forms.Form.Load> 폼의 이벤트.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.SelectionMode" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.SelectionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="listBox.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Left" /> 속성 값입니다.</param>
        <param name="y">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Top" /> 속성 값입니다.</param>
        <param name="width">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Width" /> 속성 값입니다.</param>
        <param name="height">컨트롤의 새 <see cref="P:System.Windows.Forms.Control.Height" /> 속성 값입니다.</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 값의 비트 조합입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" /> 컨트롤의 지정된 범위를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 높이 <xref:System.Windows.Forms.ListBox> 제어 증가 및 감소의 배수를 <xref:System.Windows.Forms.ListBox.ItemHeight%2A> 속성입니다. 높이의 배수가 아닌 숫자 인지 <xref:System.Windows.Forms.ListBox.ItemHeight%2A>를 높이 <xref:System.Windows.Forms.ListBox> 여러는 높이 보다 작은 가장 큰 값으로 변경 됩니다.  
  
 일반적으로 지정된 된 매개 변수에서 제외 범위에 해당 하는 매개 변수는 현재 값과 함께 전달 됩니다. 예를 들어, 합니다 `height`, `width`, 또는 `x` 또는 `y` 의 속성을 <xref:System.Windows.Forms.Control.Location%2A> 컨트롤의 현재 인스턴스에 대 한 참조를 사용 하 여 로그인 속성을 전달할 수 있습니다. 그러나 전달 되는 모든 값 적용 하 고 컨트롤에 적용 됩니다.  
  
 합니다 `specified` 매개 변수는 컨트롤의 요소를 나타냅니다 <xref:System.Windows.Forms.Control.Bounds%2A> 응용 프로그램에서 변경 합니다. 예를 들어, 변경 하는 경우는 <xref:System.Windows.Forms.Control.Size%2A> 컨트롤의 합니다 `specified` 매개 변수 값이 <xref:System.Windows.Forms.BoundsSpecified.Size>합니다. 그러나 경우는 <xref:System.Windows.Forms.Control.Size%2A> 대 한 응답으로 조정 하는 <xref:System.Windows.Forms.Control.Dock%2A> 설정 되는 속성을 `specified` 매개 변수 값이 <xref:System.Windows.Forms.BoundsSpecified.None>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드를 변경 하려면 컨트롤의 범위를 적용 합니다. 파생된 클래스에 대 한 크기 제한을 추가할 수는 <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> 메서드.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetItemCore">
      <MemberSignature Language="C#" Value="protected override void SetItemCore (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItemCore(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetItemCore(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItemCore (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItemCore(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.SetItemCore : int * obj -&gt; unit" Usage="listBox.SetItemCore (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">개체의 배열 인덱스입니다.</param>
        <param name="value">개체입니다.</param>
        <summary>파생 클래스에서 지정된 인덱스를 사용하여 개체를 설정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItemsCore">
      <MemberSignature Language="C#" Value="protected override void SetItemsCore (System.Collections.IList value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItemsCore(class System.Collections.IList value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetItemsCore(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItemsCore (value As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItemsCore(System::Collections::IList ^ value);" />
      <MemberSignature Language="F#" Value="override this.SetItemsCore : System.Collections.IList -&gt; unit" Usage="listBox.SetItemsCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="value">컨트롤에 삽입할 개체의 배열입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 내용을 지우고 지정된 항목을 컨트롤에 추가합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSelected">
      <MemberSignature Language="C#" Value="public void SetSelected (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSelected(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetSelected(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSelected (index As Integer, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSelected(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetSelected : int * bool -&gt; unit" Usage="listBox.SetSelected (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">선택하거나 선택 취소할 <see cref="T:System.Windows.Forms.ListBox" /> 항목의 인덱스(0부터 시작)입니다.</param>
        <param name="value">지정된 항목을 선택하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 지정된 항목을 선택하거나 선택 취소합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다중 선택에서 항목의 선택 집합을 설정 하려면이 속성을 사용할 수 있습니다 <xref:System.Windows.Forms.ListBox>합니다. 단일 선택에서 항목을 선택 하려면 <xref:System.Windows.Forms.ListBox>를 사용 하 여는 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 컨트롤 열에 여러 항목을 표시 하는 컨트롤의 목록에서 선택한 항목이 둘 이상 있을 수 있습니다. 50 개의 항목을 추가 하는 예제 코드를 <xref:System.Windows.Forms.ListBox> 를 사용 하 여는 <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> 메서드를 <xref:System.Windows.Forms.ListBox.ObjectCollection> 클래스 및 선택 하 여 목록에서 항목 3는 <xref:System.Windows.Forms.ListBox.SetSelected%2A> 메서드. 코드를 다음 값을 표시 합니다 <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> 컬렉션 (통해를 <xref:System.Windows.Forms.ListBox.SelectedItems%2A> 속성) 및 <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> (통해를 <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> 속성). 이 예제 코드에서 호출에 하는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">지정된 인덱스가 유효한 값 범위를 벗어난 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Forms.ListBox.SelectionMode" /> 속성이 <see langword="None" />로 설정된 경우</exception>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="protected virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.Sort" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="listBox.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목을 정렬합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox.Sort%2A> 하는 경우 각 항목 자체에 다시 추가할 수집을 강제로 실행 합니다 <xref:System.Windows.Forms.ListBox.Sorted%2A> 속성은 `true`합니다. 각 항목은 다음 올바른 위치에 삽입 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.ListBox.Sort%2A> 메서드. 예제에서 상속 하는 방법을 보여 줍니다 합니다 <xref:System.Windows.Forms.ListBox> 클래스는 <xref:System.Windows.Forms.ListBox.Sort%2A> 사용자 정렬을 수행 하는 파생된 클래스에서 메서드. 실행 하려면이 예제에서는 빈 폼에 다음 코드를 붙여넣습니다.  
  
 [!code-cpp[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>고유한 정렬 루틴을 제공 하려면 파생된 클래스에서이 메서드를 재정의할 수 있습니다. 재정의 된 결과 액세스 <see cref="M:System.Windows.Forms.ListBox.Sort" /> 설정 하 여 메서드를 <see cref="P:System.Windows.Forms.ListBox.Sorted" /> 속성을 <see langword="true" />입니다. 항목을 추가 하는 경우는 <see cref="T:System.Windows.Forms.ListBox" />, 것이 항목을 먼저 정렬 한 다음 새 항목을 추가 하는 것이 효율적입니다.</para></block>
        <altmember cref="P:System.Windows.Forms.ListBox.Sorted" />
      </Docs>
    </Member>
    <Member MemberName="Sorted">
      <MemberSignature Language="C#" Value="public bool Sorted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Sorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Sorted" />
      <MemberSignature Language="VB.NET" Value="Public Property Sorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Sorted { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Sorted : bool with get, set" Usage="System.Windows.Forms.ListBox.Sorted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 항목이 사전순으로 정렬되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 항목이 정렬되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 된 <xref:System.Windows.Forms.ListBox.Sorted%2A> 자동으로 정렬 하는 속성에서 사전순으로 문자열을 <xref:System.Windows.Forms.ListBox>. 항목이 추가 되는 정렬 된를 <xref:System.Windows.Forms.ListBox>, 항목 정렬 된 목록에서 적절 한 위치로 이동 됩니다. 항목을 추가 하는 경우는 <xref:System.Windows.Forms.ListBox>, 것이 항목을 먼저 정렬 한 다음 새 항목을 추가 하는 것이 효율적입니다.  
  
 A <xref:System.Windows.Forms.ListBox> 사용 하 여 해당 <xref:System.Windows.Forms.ListBox.Sorted%2A> 로 설정 `true` 사용 하 여 데이터에 바인딩되지 않아야는 <xref:System.Windows.Forms.ListControl.DataSource%2A> 속성입니다. 정렬 표시 데이터에 바인딩된 <xref:System.Windows.Forms.ListBox>, 정렬을 지 원하는 데이터 소스에 바인딩해야 하며, 데이터 소스에서 정렬을 제공 했습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.GetSelected%2A> 에서 항목을 확인 하는 방법을 <xref:System.Windows.Forms.ListBox> 선택 되지 않은 항목을 선택 하 고 선택 된 항목을 선택 취소 하기 위해 선택 됩니다. 예제도 사용 하 여 보여 줍니다는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 속성을 사용를 <xref:System.Windows.Forms.ListBox> 개를 사용 하 여 항목을 선택 합니다 <xref:System.Windows.Forms.ListBox.Sorted%2A> 속성에서 항목을 정렬 하는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 자동으로. 이 예제에서는 <xref:System.Windows.Forms.ListBox>명명 된 `listBox1`를 폼에 추가 되었습니다 합니다 `InitializeMyListBox` 에서 예제에 정의 된 메서드를 호출 합니다 <xref:System.Windows.Forms.Form.Load> 폼의 이벤트.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.ListBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 현재 선택되어 있는 항목의 텍스트를 가져오거나 검색합니다.</summary>
        <value>현재 컨트롤에 선택되어 있는 항목의 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값은 문자열 값으로 설정 된 경우는 <xref:System.Windows.Forms.ListBox> 내에서 항목을 검색 합니다 <xref:System.Windows.Forms.ListBox> 지정 된 텍스트와 일치 하 고 항목을 선택 합니다. 현재 선택 된 항목을 확인 하려면이 속성을 이용할 수 있습니다는 <xref:System.Windows.Forms.ListBox>합니다. 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 의 속성을 <xref:System.Windows.Forms.ListBox> 로 설정 되어 `SelectionMode.MultiExtended`, 처음 선택된 된 항목의 텍스트를 반환 하는이 속성입니다. 경우는 <xref:System.Windows.Forms.ListBox.SelectionMode%2A> 의 속성을 <xref:System.Windows.Forms.ListBox> 로 설정 되지 않은 `SelectionMode.None`, 처음 선택된 된 항목의 텍스트를 반환 하는이 속성.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.ListBox.Text" /> 속성이 변경될 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopIndex">
      <MemberSignature Language="C#" Value="public int TopIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TopIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.TopIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TopIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TopIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TopIndex : int with get, set" Usage="System.Windows.Forms.ListBox.TopIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 가장 먼저 표시되는 항목의 인덱스를 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 가장 먼저 표시되는 항목의 0부터 시작하는 인덱스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처음에 인덱스 위치 영 (0) 인 항목의 표시 영역 위쪽에는 <xref:System.Windows.Forms.ListBox>합니다. 하는 경우의 콘텐츠는 <xref:System.Windows.Forms.ListBox> 스크롤 된 경우 컨트롤의 표시 영역 맨 위에 있는 다른 항목 일 수 있습니다. 이 속성을 사용 하 여 내에서 인덱스를 가져올 수 있습니다 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection> 에 대 한는 <xref:System.Windows.Forms.ListBox> 현재 컨트롤의 표시 영역 위쪽에 배치 되는 항목의 합니다. 또한 컨트롤의 표시 영역 맨 위에 있는 목록에서 항목을 배치 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> 속성을를 <xref:System.Windows.Forms.ListBox.TopIndex%2A> 속성의 표시 영역에 있는 항목의 목록 맨 위에 현재 선택된 된 항목을 이동할는 <xref:System.Windows.Forms.ListBox>. 또한 다음 예제에서는 사용 하 여 항목을 제거 하는 방법에 설명 합니다 <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> 메서드의 <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> 클래스 및 사용 하 여 모든 항목 선택 영역을 지우는 방법은 <xref:System.Windows.Forms.ListBox.ClearSelected%2A> 메서드. 코드 현재 선택한 항목을 먼저 이동 된 <xref:System.Windows.Forms.ListBox> 목록의 맨 위로 이동 합니다. 현재 선택한 항목 앞의 모든 항목을 제거 및에서 모든 선택을 취소 한 다음 코드는 <xref:System.Windows.Forms.ListBox>합니다. 이 예제에서는 <xref:System.Windows.Forms.ListBox> 항목이 포함 된 폼 추가 되 고에서 선택한 항목은 현재는 <xref:System.Windows.Forms.ListBox>합니다.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="listBox.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />의 문자열 표현을 반환합니다.</summary>
        <returns>컨트롤 형식, <see cref="T:System.Windows.Forms.ListBox" /> 컨트롤에 있는 항목 수 및 <see cref="T:System.Windows.Forms.ListBox" />에 있는 첫 번째 항목의 Text 속성(항목 수가 0이 아닌 경우)을 설명하는 문자열입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCustomTabOffsets">
      <MemberSignature Language="C#" Value="public bool UseCustomTabOffsets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCustomTabOffsets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.UseCustomTabOffsets" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCustomTabOffsets As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCustomTabOffsets { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCustomTabOffsets : bool with get, set" Usage="System.Windows.Forms.ListBox.UseCustomTabOffsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />가 <see cref="P:System.Windows.Forms.ListBox.CustomTabOffsets" /> 정수 배열을 사용하여 문자열을 그릴 때 탭 문자를 인식하고 확장하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox" />가 탭 문자를 인식하고 확장하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.CustomTabOffsets" />
      </Docs>
    </Member>
    <Member MemberName="UseTabStops">
      <MemberSignature Language="C#" Value="public bool UseTabStops { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTabStops" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.UseTabStops" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTabStops As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTabStops { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTabStops : bool with get, set" Usage="System.Windows.Forms.ListBox.UseTabStops" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ListBox" />에서 해당 문자열을 그릴 때 탭 문자를 인식하고 확장할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 탭 문자를 확장할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.ListBox> 탭 문자를 사용 하 여 항목을 표시 하 합니다.  
  
 [!code-cpp[ListBox.UseTabStops#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.UseTabStops/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.UseTabStops#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.UseTabStops/CS/form1.cs#1)]
 [!code-vb[ListBox.UseTabStops#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.UseTabStops/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 관리 되지 않는 코드를 사용 하 여 작동 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WmReflectCommand">
      <MemberSignature Language="C#" Value="protected virtual void WmReflectCommand (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WmReflectCommand(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.WmReflectCommand(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WmReflectCommand (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WmReflectCommand(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WmReflectCommand :  -&gt; unit&#xA;override this.WmReflectCommand :  -&gt; unit" Usage="listBox.WmReflectCommand m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">최상위 창에서 <see cref="T:System.Windows.Forms.Message" /> 컨트롤로 보낸 <see cref="T:System.Windows.Forms.ListBox" />입니다.</param>
        <summary><see cref="T:System.Windows.Forms.ListView" /> 컨트롤이 최상위 창에서 받는 명령 메시지를 처리합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="listBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows 메시지 개체입니다.</param>
        <summary>목록 창 프로시저입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 추가 기능을 추가 하려면이 설정을 재정의할 수 있지만 호출 해야 상속 하는 클래스는 <xref:System.Windows.Forms.ListBox.WndProc%2A> 메서드를 기본 클래스 목록 계속 제대로 작동 하는지 확인 하세요.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 관리 되지 않는 코드를 사용 하 여 작동 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>