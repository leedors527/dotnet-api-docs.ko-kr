<Type Name="Menu" FullName="System.Windows.Forms.Menu">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65c4ee85e602c92ea0571c06d20a362c5572fab0" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56368068" /></Metadata><TypeSignature Language="C#" Value="public abstract class Menu : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Menu extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Menu" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Menu&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Menu abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Menu = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ListBindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Windows.Forms.MenuDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>모든 메뉴의 기본 기능을 나타냅니다. <see cref="T:System.Windows.Forms.ToolStripDropDown" /> 및 <see cref="T:System.Windows.Forms.ToolStripDropDownMenu" />는 <see cref="T:System.Windows.Forms.Menu" /> 컨트롤에 새로운 기능이 추가된 것으로, 이전 컨트롤 버전을 대체합니다. 그러나 이전 버전과의 호환성 및 앞으로의 사용 가능성을 고려하여 <see cref="T:System.Windows.Forms.Menu" />를 유지하도록 선택할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스는 기본 클래스를 <xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, 및 <xref:System.Windows.Forms.ContextMenu> 클래스입니다. 이 클래스의 인스턴스를 만들 수 없습니다. 애플리케이션 구성에 대 한 메뉴 <xref:System.Windows.Forms.MenuItem> 개체입니다. 기타를 포함할 수 있습니다 이러한 <xref:System.Windows.Forms.MenuItem> 하위 메뉴 항목을 나타내는 개체입니다. <xref:System.Windows.Forms.MenuItem> 개체에 저장할 수는 <xref:System.Windows.Forms.MainMenu> 폼에는 전체 메뉴 구조로 표시 또는 <xref:System.Windows.Forms.ContextMenu> 바로 가기 메뉴를 표시 하는 데 사용 되는 합니다. 이 클래스는 모든 메뉴 클래스에 공통 된 기능을 제공 합니다.  
  
 많은 기본 클래스와 달리는 <xref:System.Windows.Forms.Menu> 클래스 파생된 클래스를 사용 하 여 다양 한 속성을 정의 합니다. 메뉴를 (MDI) 다중 문서 인터페이스 애플리케이션에서 사용 하는 경우 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.Menu.MdiListItem%2A> 지정 하는 속성을 <xref:System.Windows.Forms.MenuItem> 애플리케이션에서 열려 있는 MDI 자식 폼의 목록을 표시 하는 합니다. 합니다 <xref:System.Windows.Forms.Menu.MenuItems%2A> 속성의 목록이 들어 <xref:System.Windows.Forms.MenuItem> 메뉴 클래스에 저장 된 개체입니다. 에 대 한는 <xref:System.Windows.Forms.MainMenu> 또는 <xref:System.Windows.Forms.ContextMenu>,이 속성을 모두 포함 된 <xref:System.Windows.Forms.MenuItem> 표시 되는 개체입니다. 에 <xref:System.Windows.Forms.MenuItem>, <xref:System.Windows.Forms.Menu.MenuItems%2A> 속성 연결 된 하위 메뉴 항목을 나타냅니다.  
  
 모든 파생된 메뉴 클래스에 대해 제공 되는 속성 외에 <xref:System.Windows.Forms.Menu> 클래스에서는 메서드를 같은 <xref:System.Windows.Forms.Menu.CloneMenu%2A> 및 <xref:System.Windows.Forms.Menu.MergeMenu%2A>, 기존 메뉴에서 새 메뉴를 만드는 데 사용할 수 하 고 두 개의 메뉴 구조를 병합할 수도 함께 합니다.  
  
 합니다 <xref:System.Windows.Forms.Menu> 클래스에는 또한 중첩 된 클래스 정의 <xref:System.Windows.Forms.Menu.MenuItemCollection>합니다. 이 클래스의 컬렉션을 정의 <xref:System.Windows.Forms.MenuItem> 사용 되는 개체는 <xref:System.Windows.Forms.Menu.MenuItems%2A> 속성입니다. 메서드를 사용할 수 있습니다는 <xref:System.Windows.Forms.Menu.MenuItemCollection> 클래스에서 메뉴 항목 추가 및 제거 하는 <xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.ContextMenu>, 또는 <xref:System.Windows.Forms.MenuItem>합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스인 <xref:System.Windows.Forms.MenuItem>폼의 메뉴 구조를 만듭니다. 예제 코드에서는 추가 <xref:System.Windows.Forms.MenuItem> 최상위 메뉴 항목을 나타내는 글꼴 크기를 선택 하는 것에 대 한 하위 메뉴 항목을 추가 하 고 다음 애플리케이션에서 크고 작은 글꼴 선택 옵션을 나타내는 해당 메뉴 항목에 두 개의 하위 메뉴 항목을 추가 합니다. 예제에는 필요는 <xref:System.Windows.Forms.MainMenu> 개체인 `mainMenu1` 및 4 <xref:System.Windows.Forms.MenuItem> 명명 된 개체 `menuItem1`, `menuItem2`, `menuItem3`, 및 `menuItem4`합니다.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
    <altmember cref="T:System.Windows.Forms.MenuItem" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Menu (System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.#ctor(System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Menu(cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Menu : System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.Menu" Usage="new System.Windows.Forms.Menu items" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="items">메뉴에 추가할 개체를 포함하는 <see cref="T:System.Windows.Forms.MenuItem" /> 형식의 배열입니다.</param>
        <summary><see cref="T:System.Windows.Forms.Menu" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이후 <xref:System.Windows.Forms.Menu> 는 추상 클래스에서 상속 된 클래스에서 메뉴 생성자를 호출할 수만 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected internal void CloneMenu (System.Windows.Forms.Menu menuSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CloneMenu(class System.Windows.Forms.Menu menuSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.CloneMenu(System.Windows.Forms.Menu)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CloneMenu (menuSrc As Menu)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CloneMenu(System::Windows::Forms::Menu ^ menuSrc);" />
      <MemberSignature Language="F#" Value="member this.CloneMenu : System.Windows.Forms.Menu -&gt; unit" Usage="menu.CloneMenu menuSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuSrc" Type="System.Windows.Forms.Menu" />
      </Parameters>
      <Docs>
        <param name="menuSrc">복사할 <see cref="T:System.Windows.Forms.Menu" />입니다.</param>
        <summary>현재 <see cref="T:System.Windows.Forms.Menu" />에 매개 변수로 전달되는 <see cref="T:System.Windows.Forms.Menu" />를 복사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 전체 목록을 복사 <xref:System.Windows.Forms.MenuItem> 개체 (에 저장 합니다 <xref:System.Windows.Forms.Menu> 에 전달 된 `menuSrc`) 현재 메뉴에 있습니다. 파생된 클래스에서이 메서드를 사용 하 여 복제 수 있습니다 <xref:System.Windows.Forms.MenuItem> 개체입니다. 파생 되는 다른 클래스에서 다시 사용할 수 있습니다 <xref:System.Windows.Forms.Menu>와 같은 <xref:System.Windows.Forms.MainMenu>를 <xref:System.Windows.Forms.ContextMenu>, 및 <xref:System.Windows.Forms.MenuItem>합니다.  
  
   
  
## Examples  
 이 예제에서는 주 메뉴를 만듭니다 `mainMenu1`, 세 가지 메뉴 항목을 사용 하 여: `File`를 `Edit`, 및 `View`합니다. 사용 하 여는 <xref:System.Windows.Forms.Menu.CloneMenu%2A> 복사 하는 방법 `mainMenu1` 에 `mainMenu2`입니다. 그런 다음 복제 된 메뉴 폼에 사용 된 하 고 표시 됩니다. 이 프로그램을 이미 만들었다고 필요는 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[CloneMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CloneMenu/CPP/form1.cpp#1)]
 [!code-csharp[CloneMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CloneMenu/CS/form1.cs#1)]
 [!code-vb[CloneMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CloneMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.MainMenu" />
      </Docs>
    </Member>
    <Member MemberName="CreateMenuHandle">
      <MemberSignature Language="C#" Value="protected virtual IntPtr CreateMenuHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int CreateMenuHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.CreateMenuHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateMenuHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr CreateMenuHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateMenuHandle : unit -&gt; nativeint&#xA;override this.CreateMenuHandle : unit -&gt; nativeint" Usage="menu.CreateMenuHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Menu" />의 새 핸들을 만듭니다.</summary>
        <returns>메서드가 성공했으면 메뉴에 대한 핸들이고, 실패했으면 <see langword="null" />입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 관리 되지 않는 코드를 사용 하 여 작동 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menu.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary><see cref="T:System.Windows.Forms.Menu" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Menu.Dispose%2A> 사용을 마치면 <xref:System.Windows.Forms.Menu>를 호출합니다. <xref:System.Windows.Forms.Menu.Dispose%2A> 메서드를 사용하면 <xref:System.Windows.Forms.Menu>를 사용할 수 없게 됩니다. 호출한 후 <xref:System.Windows.Forms.Menu.Dispose%2A>에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Windows.Forms.Menu> 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Menu.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.Windows.Forms.Menu>를 호출하십시오. 이 고, 그렇지 리소스를 <xref:System.Windows.Forms.Menu> 가 사용 하 여 확보 되지 것입니다. 가비지 컬렉션 호출 될 때까지 <xref:System.Windows.Forms.Menu> 개체의 소멸자입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindHandle">
      <MemberSignature Language="C#" Value="public const int FindHandle = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 FindHandle = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Menu.FindHandle" />
      <MemberSignature Language="VB.NET" Value="Public Const FindHandle As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int FindHandle = 0;" />
      <MemberSignature Language="F#" Value="val mutable FindHandle : int" Usage="System.Windows.Forms.Menu.FindHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" /> 메서드가 핸들을 검색하도록 지정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMenuItem">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuItem FindMenuItem (int type, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.MenuItem FindMenuItem(int32 type, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindMenuItem (type As Integer, value As IntPtr) As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::MenuItem ^ FindMenuItem(int type, IntPtr value);" />
      <MemberSignature Language="F#" Value="member this.FindMenuItem : int * nativeint -&gt; System.Windows.Forms.MenuItem" Usage="menu.FindMenuItem (type, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Int32" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Windows.Forms.MenuItem" />을 찾는 데 사용할 항목의 형식입니다.</param>
        <param name="value"><see cref="T:System.Windows.Forms.MenuItem" />을 찾는 데 사용할 항목입니다.</param>
        <summary>지정된 값이 포함된 <see cref="T:System.Windows.Forms.MenuItem" />을 가져옵니다.</summary>
        <returns>값과 일치하는 <see cref="T:System.Windows.Forms.MenuItem" />을 반환하고, 그렇지 않으면 <see langword="null" />을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 검색할를 <xref:System.Windows.Forms.MenuItem> 전달 핸들을 사용 합니다 <xref:System.Windows.Forms.Menu.FindHandle> 형식과 핸들 필드는 <xref:System.Windows.Forms.MenuItem> 값으로 찾으려는.  
  
 검색할를 <xref:System.Windows.Forms.MenuItem> 전달 바로 가기를 사용 합니다 <xref:System.Windows.Forms.Menu.FindShortcut> 형식에 대 한 바로 가기 값으로 필드를 <xref:System.Windows.Forms.MenuItem> 값으로 찾으려는.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 하는 컨트롤입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FindMergePosition">
      <MemberSignature Language="C#" Value="protected int FindMergePosition (int mergeOrder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int32 FindMergePosition(int32 mergeOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.FindMergePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Function FindMergePosition (mergeOrder As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; int FindMergePosition(int mergeOrder);" />
      <MemberSignature Language="F#" Value="member this.FindMergePosition : int -&gt; int" Usage="menu.FindMergePosition mergeOrder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOrder" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="mergeOrder">병합될 메뉴 항목의 병합 순서 위치입니다.</param>
        <summary>메뉴 항목이 메뉴에 삽입될 위치를 반환합니다.</summary>
        <returns>메뉴 항목이 메뉴에 삽입될 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메뉴 항목이 메뉴를 구성 하는 경우를 가정 하는 상대 위치를 지정 하는 메뉴 항목의 병합 순서는 <xref:System.Windows.Forms.MenuItem> 포함 된 다른 항목과 병합 될 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindShortcut">
      <MemberSignature Language="C#" Value="public const int FindShortcut = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 FindShortcut = (1)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Menu.FindShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Const FindShortcut As Integer  = 1" />
      <MemberSignature Language="C++ CLI" Value="public: int FindShortcut = 1;" />
      <MemberSignature Language="F#" Value="val mutable FindShortcut : int" Usage="System.Windows.Forms.Menu.FindShortcut" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" /> 메서드가 바로 가기를 검색하도록 지정합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ContextMenu GetContextMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.ContextMenu GetContextMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.GetContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextMenu () As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::ContextMenu ^ GetContextMenu();" />
      <MemberSignature Language="F#" Value="member this.GetContextMenu : unit -&gt; System.Windows.Forms.ContextMenu" Usage="menu.GetContextMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메뉴가 들어 있는 <see cref="T:System.Windows.Forms.ContextMenu" />를 가져옵니다.</summary>
        <returns>이 메뉴가 들어 있는 <see cref="T:System.Windows.Forms.ContextMenu" />입니다. 기본값은 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면에 대 한 참조를 가져올 수 있습니다는 <xref:System.Windows.Forms.ContextMenu> 이 메뉴에 포함 됩니다. 이 속성은 반환 `null` 메뉴에서 포함 되지 않은 경우는 <xref:System.Windows.Forms.ContextMenu>합니다. 이 메뉴에 포함 된 경우 발생할 수 있습니다는 <xref:System.Windows.Forms.MenuItem> 또는 <xref:System.Windows.Forms.MainMenu>, 메뉴는 메뉴에 포함 되지 않은 경우 또는 합니다. 여부를 메뉴를 현재 사용 중인지를 확인 하 고 위치를 확인 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 이 예제를 사용 하 여 합니다 <xref:System.Windows.Forms.Menu.GetContextMenu%2A> 메서드를 포함 하는 바로 가기 메뉴에 대 한 참조를 가져올 `menuItem1` 또는 `menuItem2`, 메시지 상자에 바로 가기 메뉴 정보를 표시 합니다. 두 항목을 사용 하 여 프로그래밍 방식으로 바로 가기 메뉴를 만들 `New` 고 `Open`입니다. 그런 다음 적절 한 이벤트 처리기를 만들어이 기능 이러한 항목에 추가 합니다. 예제를 실행 하는 경우 바로 가기 메뉴를 표시 하기 위해 폼을 마우스 오른쪽 단추로 클릭을 알려 주는 메시지 상자를 얻게 됩니다. 그런 다음 메뉴 항목을 클릭 하면 다른 메시지를 항목 했 고 정보를 포함 하는 바로 가기 메뉴에 표시를 가져옵니다. 이 예제에서는 이미 만든를 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[GetContextMenu2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/GetContextMenu2/CPP/form1.cpp#1)]
 [!code-csharp[GetContextMenu2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/GetContextMenu2/CS/form1.cs#1)]
 [!code-vb[GetContextMenu2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/GetContextMenu2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Menu.GetMainMenu" />
      </Docs>
    </Member>
    <Member MemberName="GetMainMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu GetMainMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.MainMenu GetMainMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.GetMainMenu" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMainMenu () As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::MainMenu ^ GetMainMenu();" />
      <MemberSignature Language="F#" Value="member this.GetMainMenu : unit -&gt; System.Windows.Forms.MainMenu" Usage="menu.GetMainMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메뉴가 들어 있는 <see cref="T:System.Windows.Forms.MainMenu" />를 가져옵니다.</summary>
        <returns>이 메뉴가 들어 있는 <see cref="T:System.Windows.Forms.MainMenu" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면에 대 한 참조를 가져올 수 있습니다는 <xref:System.Windows.Forms.MainMenu> 이 메뉴에 있는 현재 합니다. 이 속성은 반환 `null` 메뉴에서 포함 되지 않은 경우는 <xref:System.Windows.Forms.MainMenu>합니다. 이 메뉴에 포함 된 경우 발생할 수 있습니다는 <xref:System.Windows.Forms.MenuItem> 또는 <xref:System.Windows.Forms.ContextMenu>, 메뉴는 메뉴에 포함 되지 않은 경우 또는 합니다. 여부를 메뉴를 현재 사용 중인지를 확인 하 고 위치를 확인 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 이 예제에서는 선언를 <xref:System.Windows.Forms.MainMenu>, `mainMenu1`, 및 4 메뉴 항목을 `menuItem1`를 `menuItem2`를 `menuItem3`, 및 `menuItem4`합니다. 처음 세 가지 메뉴 항목에 추가 됩니다 `mainMenu1` 표시 합니다. 프로그램을 확인 하는 경우 `menuItem3` 사용 되는 `true`, 사용 되는 형식을 결정 하 고 합니다. 레이블 텍스트를 호스팅하는 폼의 이름을 표시 되는 <xref:System.Windows.Forms.MainMenu>합니다. 테스트 되는 메뉴 항목을 변경 하는 경우 `menuItem4`, 조건이 `false` 때문에 `menuItem4` 사용 되지 않은 합니다. 이 예제에서는 만든를 <xref:System.Windows.Forms.Form> 라는 `MyForm` 포함 하는 <xref:System.Windows.Forms.Label> 라는 `label1`합니다.  
  
 [!code-cpp[GetMainMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/GetMainMenu/CPP/form1.cpp#1)]
 [!code-csharp[GetMainMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/GetMainMenu/CS/form1.cs#1)]
 [!code-vb[GetMainMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/GetMainMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Menu.GetContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Menu.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴의 창 핸들을 나타내는 값을 가져옵니다.</summary>
        <value>메뉴의 HMENU 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스 또는 해당 파생된 클래스에서 제공 하는 기능 외부 메뉴로 특수 작업을 수행 하려면 메뉴에 대 한 핸들을 가져오려면이 속성을 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public virtual bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.Menu.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메뉴에 메뉴 항목이 들어 있는지 여부를 나타내는 값을 가져옵니다. 이 속성은 읽기 전용입니다.</summary>
        <value>이 메뉴에 <see cref="T:System.Windows.Forms.MenuItem" /> 개체가 들어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 있는지 여부를 확인 하려면 <xref:System.Windows.Forms.MenuItem> 개체는이 메뉴에 할당 됩니다. 이 확인 하는 것에 대 한 `null` 에 <xref:System.Windows.Forms.Menu.MenuItems%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.MainMenu> 두 개의 <xref:System.Windows.Forms.MenuItem> 개체입니다. 사용 하 여는 <xref:System.Windows.Forms.Menu.IsParent%2A> 속성을 확인 하는지 여부를 `mainMenu1` 메뉴 항목을 포함 합니다. 조건이 `true`를 설정 합니다 <xref:System.Windows.Forms.MainMenu.RightToLeft%2A> 속성을 `true` 하려면 주 메뉴를 바인딩합니다는 <xref:System.Windows.Forms.Form>합니다. 이 예제를 실행 하려면를 <xref:System.Windows.Forms.Form> 라는 만든 `Form1`합니다.  
  
 [!code-cpp[IsParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IsParent/CPP/form1.cpp#1)]
 [!code-csharp[IsParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IsParent/CS/form1.cs#1)]
 [!code-vb[IsParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IsParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">에 관리 되지 않는 코드를 사용 하 여 작동 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Forms.Menu.MenuItems" />
      </Docs>
    </Member>
    <Member MemberName="MdiListItem">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuItem MdiListItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuItem MdiListItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.MdiListItem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiListItem As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuItem ^ MdiListItem { System::Windows::Forms::MenuItem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MdiListItem : System.Windows.Forms.MenuItem" Usage="System.Windows.Forms.Menu.MdiListItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>MDI(다중 문서 인터페이스) 자식 폼의 목록을 표시하는 데 사용되는 <see cref="T:System.Windows.Forms.MenuItem" />을 나타내는 값을 가져옵니다.</summary>
        <value>응용 프로그램에 열려 있는 MDI 자식 폼의 목록을 표시하는 메뉴 항목을 나타내는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 확인 하려면이 속성을 사용할 수 있는지 여부를 <xref:System.Windows.Forms.MenuItem> MDI 애플리케이션에서 열려 있는 자식 창의 목록을 표시할 지정 되었습니다. 특정을 사용 하 <xref:System.Windows.Forms.MenuItem> 은 MDI 목록으로 설정 합니다 <xref:System.Windows.Forms.MenuItem.MdiList%2A> 속성에는 <xref:System.Windows.Forms.MenuItem> 사용할 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MdiList" />
      </Docs>
    </Member>
    <Member MemberName="MenuItems">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu.MenuItemCollection MenuItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu/MenuItemCollection MenuItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.MenuItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MenuItems As Menu.MenuItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu::MenuItemCollection ^ MenuItems { System::Windows::Forms::Menu::MenuItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuItems : System.Windows.Forms.Menu.MenuItemCollection" Usage="System.Windows.Forms.Menu.MenuItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu+MenuItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>해당 메뉴와 연결된 <see cref="T:System.Windows.Forms.MenuItem" /> 개체의 컬렉션을 나타내는 값을 가져옵니다.</summary>
        <value>메뉴에 저장된 <see cref="T:System.Windows.Forms.Menu.MenuItemCollection" /> 개체의 목록을 나타내는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴에서 현재 저장 되어 있는 메뉴 항목의 목록에 대 한 참조를 얻으려면이 속성을 사용할 수 있습니다. 에 대 한 <xref:System.Windows.Forms.MainMenu> 하 고 <xref:System.Windows.Forms.ContextMenu> 개체는 <xref:System.Windows.Forms.Menu.MenuItems%2A> 컨트롤의 메뉴 전체 구조를 포함 하는 속성입니다. 에 대 한는 <xref:System.Windows.Forms.MenuItem> 클래스를 <xref:System.Windows.Forms.Menu.MenuItems%2A> 속성에 연결 된 하위 메뉴 항목의 목록을 포함 합니다 <xref:System.Windows.Forms.MenuItem>합니다. (이 속성에 의해 제공 됨) 메뉴의 메뉴 항목의 컬렉션에 대 한 참조를 사용 하 여 추가 및 메뉴 항목을 제거, 메뉴 항목의 총 수를 확인 하 수 컬렉션에서 메뉴 항목의 목록을 지웁니다. 메뉴에 메뉴 항목 컬렉션을 유지 관리에 대 한 자세한 내용은 참조는 <xref:System.Windows.Forms.Menu.MenuItemCollection?displayProperty=nameWithType> 설명서.  
  
   
  
## Examples  
 다음 코드 예제에서는 파생된 클래스의 인스턴스를 만듭니다 <xref:System.Windows.Forms.MainMenu>를 추가 하 고는 <xref:System.Windows.Forms.MenuItem> 개체의 컬렉션 <xref:System.Windows.Forms.MenuItem> 개체입니다. 이 예제에는이 예제에서 정의 된 메서드를 폼에 대 한 클래스 내에 있는 이며 해당 폼 클래스의 메서드를 호출한 필요 합니다.  
  
 [!code-cpp[Classic Menu.MenuItems Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu.MenuItems Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu.MenuItems Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu.MenuItems Example/CS/source.cs#1)]
 [!code-vb[Classic Menu.MenuItems Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu.MenuItems Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu.MenuItemCollection" />
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual void MergeMenu (System.Windows.Forms.Menu menuSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MergeMenu(class System.Windows.Forms.Menu menuSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.MergeMenu(System.Windows.Forms.Menu)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MergeMenu (menuSrc As Menu)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MergeMenu(System::Windows::Forms::Menu ^ menuSrc);" />
      <MemberSignature Language="F#" Value="abstract member MergeMenu : System.Windows.Forms.Menu -&gt; unit&#xA;override this.MergeMenu : System.Windows.Forms.Menu -&gt; unit" Usage="menu.MergeMenu menuSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuSrc" Type="System.Windows.Forms.Menu" />
      </Parameters>
      <Docs>
        <param name="menuSrc">현재 메뉴의 메뉴 항목과 병합할 메뉴 항목이 포함된 <see cref="T:System.Windows.Forms.Menu" />입니다.</param>
        <summary>한 메뉴의 <see cref="T:System.Windows.Forms.MenuItem" /> 개체를 현재 메뉴와 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 병합 <xref:System.Windows.Forms.MenuItem> 현재 메뉴를 사용 하 여 한 메뉴에서 개체입니다. <xref:System.Windows.Forms.MenuItem> 개체의 값에 따라 병합 되는 <xref:System.Windows.Forms.MenuItem.MergeType%2A?displayProperty=nameWithType> 및 <xref:System.Windows.Forms.MenuItem.MergeOrder%2A?displayProperty=nameWithType> 속성입니다.  
  
 메뉴 병합을 해당 활성 MDI 자식 폼의 문서 MDI (다중 인터페이스) 부모 폼의 메뉴 병합을 일반적으로 수행 됩니다. 이.NET Framework 공용 언어 런타임에 의해 자동으로 수행 됩니다. 예를 들어 MDI 부모 폼 파일 처리에 대 한 메뉴 집합을 포함 하는 경우 MDI 자식 폼에도 파일 관련 메뉴 항목이 메뉴 집합 자식 폼은 MDI 부모 폼에 표시 될 때 설정 하는 단일 파일 메뉴에 자동으로 병합 됩니다.  
  
 사용할 수는 <xref:System.Windows.Forms.Menu.MergeMenu%2A> 메서드 MDI 애플리케이션의 일부분이 아닌 두 개의 메뉴 구조를 병합 하는 경우. 이 구현에서 호출할 수는 <xref:System.Windows.Forms.MainMenu> 나 <xref:System.Windows.Forms.ContextMenu> 클래스에서 파생 되는 두 개 이상의 개체를 병합 하려면 <xref:System.Windows.Forms.Menu>합니다.  
  
 두 병합 <xref:System.Windows.Forms.MenuItem> 사용 하 여 개체를 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A?displayProperty=nameWithType> 메서드.  
  
   
  
## Examples  
 이 예제에서는 두 개의 메뉴를 만듭니다 `mainMenu1` 고 `mainMenu2`입니다. 첫 번째 메뉴 하나가 포함 되어 있습니다 <xref:System.Windows.Forms.MenuItem>, `File`, 두 번째 1 개와 <xref:System.Windows.Forms.MenuItem>, `Edit`합니다. 사용 하는 <xref:System.Windows.Forms.Menu.MergeMenu%2A> 메서드를 `mainMenu2` 병합 되어 `mainMenu1`합니다. 표시 하는 경우 `mainMenu1` 두 가지 메뉴 항목이 포함 됩니다 `File` 고 `Edit`입니다. 이 예제에서는 만든를 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[MergeMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MergeMenu/CPP/form1.cpp#1)]
 [!code-csharp[MergeMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MergeMenu/CS/form1.cs#1)]
 [!code-vb[MergeMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MergeMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">메뉴를 자체 병합하려고 시도한 경우</exception>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Menu.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Menu" />의 이름을 가져오거나 설정합니다.</summary>
        <value>이름을 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 디자인 타임에이 속성은 컨트롤의 프로그래밍 id로 설정 됩니다. 그러나이 속성은 아무런 영향을 미치지 컨트롤에서 런타임 시.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="menu.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>명령 키를 처리합니다.</summary>
        <returns>컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Menu.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤과 연관된 사용자 정의 데이터를 가져오거나 설정합니다.</summary>
        <value>데이터를 나타내는 개체입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menu.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.String" /> 컨트롤을 나타내는 <see cref="T:System.Windows.Forms.Menu" />을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.String" />를 나타내는 <see cref="T:System.Windows.Forms.Menu" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Menu.ToString%2A> 메서드가 반환 되는 <xref:System.String> 형식과의 항목 수를 포함 하는 <xref:System.Windows.Forms.Menu.MenuItems%2A> 컨트롤의 속성.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>