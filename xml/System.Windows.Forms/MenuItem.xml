<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e96b9a562587ce1b84c0314819619ffe1f760d2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55340287" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.Forms.MainMenu" /> 또는 <see cref="T:System.Windows.Forms.ContextMenu" /> 내에 표시되는 개별 항목을 나타냅니다. <see cref="T:System.Windows.Forms.ToolStripMenuItem" />은 이전 버전의 <see cref="T:System.Windows.Forms.MenuItem" /> 컨트롤을 대체하고 확장한 컨트롤이지만 이전 버전과의 호환성 및 앞으로의 사용 가능성을 고려하여 <see cref="T:System.Windows.Forms.MenuItem" />를 유지하도록 선택할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 되려면에서를 <xref:System.Windows.Forms.MenuItem> 표시할 추가 해야 하는 <xref:System.Windows.Forms.MainMenu> 또는 <xref:System.Windows.Forms.ContextMenu>합니다. 하위 메뉴를 만들려면 추가할 수 있습니다 <xref:System.Windows.Forms.MenuItem> 개체를 <xref:System.Windows.Forms.Menu.MenuItems%2A> 부모 <xref:System.Windows.Forms.MenuItem>합니다.  
  
 <xref:System.Windows.Forms.MenuItem> 클래스 모양 및 메뉴 항목의 기능을 구성할 수 있는 속성을 제공 합니다. 메뉴 항목 옆의 확인란을 표시 하려면 사용 된 <xref:System.Windows.Forms.MenuItem.Checked%2A> 속성입니다. 상호 배타적인 메뉴 항목의 목록에서 선택한 메뉴 항목을 식별 하려면이 기능을 사용할 수 있습니다. 예를 들어, 텍스트의 색을 설정 하는 것에 대 한 메뉴 항목 집합이 있는 경우는 <xref:System.Windows.Forms.TextBox> 컨트롤을 사용할 수는 <xref:System.Windows.Forms.MenuItem.Checked%2A> 현재 선택 된 색을 식별 하는 속성입니다. <xref:System.Windows.Forms.MenuItem.Shortcut%2A> 속성 메뉴 항목을 선택 하기 위해 누르는 될 수 있는 키보드 조합을 정의를 사용할 수 있습니다.  
  
 에 대 한 <xref:System.Windows.Forms.MenuItem> 인터페이스 MDI (다중 문서) 애플리케이션에서 표시 되는 개체를 사용할 수는 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> MDI 메뉴 병합 방법 통합된 메뉴 구조를 만들려면 해당 자식 폼의 지 문으로 대 한 부모입니다. 때문에 <xref:System.Windows.Forms.MenuItem> 다시 사용할 수 없는 여러 위치에서 동시에 같은를 <xref:System.Windows.Forms.MainMenu> 및 <xref:System.Windows.Forms.ContextMenu>, 사용할 수 있습니다를 <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> 의 복사본을 만드는 메서드를 <xref:System.Windows.Forms.MenuItem> 다른 위치에서 사용 합니다.  
  
 <xref:System.Windows.Forms.MenuItem.Popup> 이벤트를 사용 하는 메뉴가 표시 되기 전에 작업을 수행할 수 있습니다. 예를 들어이 이벤트는 상태 코드에 따라 메뉴 항목 표시 / 숨기기에 대 한 이벤트 처리기를 만들 수 있습니다. <xref:System.Windows.Forms.MenuItem.Select> 이벤트를 사용 하면 메뉴 항목 위로 마우스 포인터를 이동할 때 애플리케이션의 메뉴 항목에 대 한 자세한 도움말을 제공 하는 등의 작업을 수행할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 폼의 메뉴 구조를 만듭니다. 예제 코드에서는 추가 <xref:System.Windows.Forms.MenuItem> 최상위 메뉴 항목을 나타내는 글꼴 크기를 선택 하는 것에 대 한 하위 메뉴 항목을 추가 하 고 다음 애플리케이션에서 크고 작은 글꼴 선택 옵션을 나타내는 해당 메뉴 항목에 두 개의 하위 메뉴 항목을 추가 합니다. 예제에는 필요는 <xref:System.Windows.Forms.MainMenu> 개체인 `mainMenu1` 및 4 <xref:System.Windows.Forms.MenuItem> 명명 된 개체 `menuItem1`, `menuItem2`, `menuItem3`, 및 `menuItem4`합니다.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>캡션이 비어 있는 <see cref="T:System.Windows.Forms.MenuItem" />을 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 빈 값을 만든 후 <xref:System.Windows.Forms.MenuItem> 사용이 생성자를 사용할 수 있습니다의 메서드와 속성을 <xref:System.Windows.Forms.MenuItem> 의 모양 및 동작을 지정 하는 클래스에 <xref:System.Windows.Forms.MenuItem>입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MenuItem> 생성자의이 버전을 사용 합니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">메뉴 항목의 캡션입니다.</param>
        <summary>메뉴 항목의 지정된 캡션을 사용하여 <see cref="T:System.Windows.Forms.MenuItem" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정 하는 경우는 `text` 매개 변수를 지정할 수도 있습니다 선택키가 액세스 키로 사용할 문자의 앞 '에 &' 문자를 배치 하 여 합니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다.  
  
 설정 합니다 `text` 매개 변수를 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.MenuItem> 는 생성 된 시간에 메뉴 항목의 캡션을 지정 하는 합니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">메뉴 항목의 캡션입니다.</param>
        <param name="onClick">이 메뉴 항목의 <see cref="T:System.EventHandler" /> 이벤트를 처리하는 <see cref="E:System.Windows.Forms.MenuItem.Click" />입니다.</param>
        <summary>메뉴 항목의 <see cref="E:System.Windows.Forms.MenuItem.Click" /> 이벤트에 대한 이벤트 처리기 및 지정된 캡션을 사용하여 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정 하는 경우는 `text` 매개 변수를 지정할 수도 있습니다 선택키가 앞에 '&' 선택 키로 사용할 문자를 배치 하 여 합니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다.  
  
 설정 합니다 `text` 매개 변수를 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
 처리 하는 대리자를 지정 하려면이 생성자를 사용할 수는 또한는 <xref:System.Windows.Forms.MenuItem.Click> 만들어지는 메뉴 항목에 대 한 이벤트입니다. 합니다 <xref:System.EventHandler> 이 생성자에 전달 하는 처리할 수 있는 이벤트 처리기를 호출 하도록 구성 되어야 합니다는 <xref:System.Windows.Forms.MenuItem.Click> 이벤트입니다. 이벤트를 처리 하는 방법은 참조 하세요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MenuItem> 지정 된 캡션 사용 하 여 개체 및 <xref:System.EventHandler> 처리할 이벤트 처리기에 연결 된 대리자는 <xref:System.Windows.Forms.MenuItem.Click> 메뉴 항목에 대 한 이벤트입니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">메뉴 항목의 캡션입니다.</param>
        <param name="items">이 메뉴 항목의 하위 메뉴 항목이 들어 있는 <see cref="T:System.Windows.Forms.MenuItem" /> 개체의 배열입니다.</param>
        <summary>메뉴 항목의 정의된 캡션 및 하위 메뉴 항목의 배열을 사용하여 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정 하는 경우는 `text` 매개 변수를 지정할 수도 있습니다 선택키가 앞에 '&' 선택 키로 사용할 문자를 배치 하 여 합니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다.  
  
 설정 합니다 `text` 매개 변수를 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
 `items` 매개 변수를 사용 하면이 메뉴 항목의 하위 메뉴를 정의할 메뉴 항목의 배열을 할당 합니다. 배열의 각 항목에 할당 된 메뉴 항목의 배열을 가질 수도 있습니다. 이 옵션을 사용 하면 전체 메뉴 구조를 만들고 메뉴 항목에 대 한 생성자에 할당할 수 있습니다.  
  
 이벤트를 처리 하는 방법은 참조 하세요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에에서 개체를 만듭니다는 지정 된 캡션, 이벤트를 처리 하는 메서드에 연결 된 이벤트 처리기를 사용 하 여 각 메뉴 항목 하위 메뉴 항목의 배열입니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">메뉴 항목의 캡션입니다.</param>
        <param name="onClick">이 메뉴 항목의 <see cref="T:System.EventHandler" /> 이벤트를 처리하는 <see cref="E:System.Windows.Forms.MenuItem.Click" />입니다.</param>
        <param name="shortcut"><see cref="T:System.Windows.Forms.Shortcut" /> 값 중 하나입니다.</param>
        <summary>메뉴 항목의 지정된 캡션, 이벤트 처리기 및 관련된 바로 가기 키를 사용하여 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정 하는 경우는 `text` 매개 변수를 지정할 수도 있습니다 선택키가 앞에 '&' 선택 키로 사용할 문자를 배치 하 여 합니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다. 이 생성자를 사용 하면 키보드 탐색을 제공 하는 액세스 키 외에도 바로 가기 키를 지정할 수 있습니다. 바로 가기 키를 사용 하면 메뉴 항목을 활성화 하는 키의 조합을 지정할 수 있습니다.  
  
 설정 합니다 `text` 매개 변수를 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
 처리 하는 대리자를 지정 하려면이 생성자를 사용할 수는 또한는 <xref:System.Windows.Forms.MenuItem.Click> 만들어지는 메뉴 항목에 대 한 이벤트입니다. 합니다 <xref:System.EventHandler> 이 생성자에 전달 하는 처리할 수 있는 이벤트 처리기를 호출 하도록 구성 되어야 합니다는 <xref:System.Windows.Forms.MenuItem.Click> 이벤트입니다. 이벤트를 처리 하는 방법은 참조 하세요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 지정 된 캡션, 바로 가기 키 및 메뉴 항목에 대 한 이벤트를 처리 하는 메서드에 연결 된 이벤트 처리기를 사용 하 여 개체를 만듭니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType"><see cref="T:System.Windows.Forms.MenuMerge" /> 값 중 하나입니다.</param>
        <param name="mergeOrder">병합된 메뉴에서 이 메뉴 항목이 놓여질 상대적 위치입니다.</param>
        <param name="shortcut"><see cref="T:System.Windows.Forms.Shortcut" /> 값 중 하나입니다.</param>
        <param name="text">메뉴 항목의 캡션입니다.</param>
        <param name="onClick">이 메뉴 항목의 <see cref="T:System.EventHandler" /> 이벤트를 처리하는 <see cref="E:System.Windows.Forms.MenuItem.Click" />입니다.</param>
        <param name="onPopup">이 메뉴 항목의 <see cref="T:System.EventHandler" /> 이벤트를 처리하는 <see cref="E:System.Windows.Forms.MenuItem.Popup" />입니다.</param>
        <param name="onSelect">이 메뉴 항목의 <see cref="T:System.EventHandler" /> 이벤트를 처리하는 <see cref="E:System.Windows.Forms.MenuItem.Select" />입니다.</param>
        <param name="items">이 메뉴 항목의 하위 메뉴 항목이 들어 있는 <see cref="T:System.Windows.Forms.MenuItem" /> 개체의 배열입니다.</param>
        <summary>메뉴 항목의 지정된 캡션, <see cref="T:System.Windows.Forms.MenuItem" />, <see cref="E:System.Windows.Forms.MenuItem.Click" /> 및 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 이벤트에 대해 지정된 이벤트 처리기, 바로 가기 키, 병합 유형 및 지정된 순서를 사용하여 <see cref="E:System.Windows.Forms.MenuItem.Popup" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정 하는 경우는 `text` 매개 변수를 지정할 수도 있습니다 선택키가 앞에 '&' 선택 키로 사용할 문자를 배치 하 여 합니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다.  
  
 설정 합니다 `text` 매개 변수를 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
 `items` 매개 변수를 사용 하면이 메뉴 항목의 하위 메뉴를 정의할 메뉴 항목의 배열을 할당 합니다. 배열의 각 항목에 할당 된 메뉴 항목의 배열을 가질 수도 있습니다. 이 옵션을 사용 하면 전체 메뉴 구조를 만들고 메뉴 항목에 대 한 생성자에 할당할 수 있습니다.  
  
 합니다 `mergeType` 고 `mergeOrder` 매개 변수를 사용 하면 다른 메뉴와 메뉴 항목 병합 될 때이 메뉴 항목에서 동작 하는 방법을 확인 하려면. 에 대해 지정 하는 값에 따라는 `mergeType` 매개 변수를 추가, 제거, 바꾸기, 하거나 메뉴 항목 및 해당 하위 메뉴 항목으로 병합 되는 메뉴와 병합 합니다. `mergeOrder` 매개 변수 메뉴 병합 될 때 만들어지는 메뉴 항목 배치 될 위치를 결정 합니다.  
  
 만들려면이 생성자를 사용할 수 있습니다는 또한는 <xref:System.Windows.Forms.MenuItem> 메뉴 항목 클릭을 처리 하는 코드에서 이벤트 처리기에 연결 되어 있습니다. 합니다 <xref:System.EventHandler> 이 생성자에 전달 하는 처리할 수 있는 이벤트 처리기를 호출 하도록 구성 해야 합니다 <xref:System.Windows.Forms.MenuItem.Click> 이벤트입니다. 이 생성자 버전을 사용 하 여 연결할 수도 있습니다는 <xref:System.Windows.Forms.MenuItem.Popup> 고 <xref:System.Windows.Forms.MenuItem.Select> 이 메뉴 항목을 선택 하는 경우를 결정 하는 이벤트입니다. 하위 메뉴 항목 옆에 있는 확인 표시 또는을 애플리케이션의 상태를 기반으로 하는 메뉴 항목을 사용할지 여부를 확인 하는 등의 작업에 대 한 이러한 이벤트를 사용할 수 있습니다. <xref:System.Windows.Forms.MenuItem.Select> 하 고 <xref:System.Windows.Forms.MenuItem.Click> 이벤트에 대해서만 발생 <xref:System.Windows.Forms.MenuItem> 부모 메뉴 항목이 아닌 개체입니다. 이벤트를 처리 하는 방법은 참조 하세요 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 캡션 및 바로 가기 키가 있는 메뉴 항목을 만듭니다. 메뉴 항목에는 또한 이벤트 처리기에 대 한 정의는 <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, 및 <xref:System.Windows.Forms.MenuItem.Select> 이벤트입니다. 이 메뉴 항목으로 병합 하는 경우 0의 병합 순서를 사용 하 여 메뉴에 메뉴 항목이 추가 됩니다.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" />이 새 줄(<see cref="T:System.Windows.Forms.MainMenu" /> 개체에 추가된 메뉴 항목의 경우)이나 새 열(<see cref="T:System.Windows.Forms.ContextMenu" />에 표시된 하위 메뉴 항목 또는 메뉴 항목의 경우)에 표시되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>새 줄 또는 새 열에 메뉴 항목이 표시되면 <see langword="true" />이고, 메뉴 항목이 기본 위치에 그대로 있으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.MenuItem.BarBreak%2A> 속성을 각 메뉴 항목 위치 of 가로로 서로 옆에 있는 세로 목록에 메뉴를 만듭니다. 이 속성을 사용 하 여 최상위 메뉴 항목의 여러 행을 포함 하는 메뉴 모음을 만들 수도 있습니다.  
  
 이 속성에서 다른 합니다 <xref:System.Windows.Forms.MenuItem.Break%2A> 에서 해당 막대는 각 메뉴 항목의 왼쪽된 가장자리에 표시 하는 속성이 합니다 <xref:System.Windows.Forms.MenuItem.Break%2A> 속성이로 설정 `true`합니다. 막대는 메뉴 항목은 최상위 메뉴 항목을 하는 경우에 표시 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.MenuItem> 두 하위 메뉴 항목을 사용 하 여 합니다. 세로 방향으로 사용 하는 대신 두 개의 하위 메뉴 항목 가로로 표시 되는 <xref:System.Windows.Forms.MenuItem.BarBreak%2A> 속성입니다.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>항목이 새 줄(<see cref="T:System.Windows.Forms.MainMenu" /> 개체에 추가한 메뉴 항목의 경우)이나 새 열(<see cref="T:System.Windows.Forms.ContextMenu" />에 표시된 메뉴 항목 또는 하위 메뉴 항목의 경우)에 표시되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>새 줄 또는 새 열에 메뉴 항목이 표시되면 <see langword="true" />이고, 메뉴 항목이 기본 위치에 그대로 있으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.MenuItem.Break%2A> 속성을 각 메뉴를 배치할 of 가로로 서로 옆에 있는 세로 목록에 메뉴를 만듭니다. 이 속성을 사용 하 여 최상위 메뉴 항목의 여러 행을 포함 하는 메뉴 모음을 만들 수도 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 맨 위 행에 하나의 메뉴 항목이 맨 아래 행에서 두 개의 최상위 메뉴 항목을 사용 하 여 메뉴를 만듭니다.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목의 텍스트 옆에 확인 표시가 나타나는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메뉴 항목 옆에 확인 표시가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.MenuItem.Checked%2A> 애플리케이션에 대 한 상태를 제공 하는 메뉴에서 다른 메뉴 항목과 함께에서 속성입니다. 예를 들어 그룹의 텍스트는 애플리케이션에 대해 표시할 글꼴 크기를 식별 하는 항목의 메뉴 항목에 확인 표시를 배치할 수 있습니다. 사용할 수도 있습니다는 <xref:System.Windows.Forms.MenuItem.Checked%2A> 상호 배타적인 메뉴 항목의 그룹에 선택한 메뉴 항목을 식별 하는 속성입니다.  
  
> [!NOTE]
>  이 속성 설정할 수 없습니다 `true` 최상위 메뉴 항목에 대 한 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MenuItem.Checked%2A> 속성을 애플리케이션의 상태를 지정 합니다. 이 예제에서는 그룹 메뉴 항목을 텍스트의 색 지정 되는 <xref:System.Windows.Forms.TextBox> 제어 합니다. 제공 된 이벤트 처리기에서 사용 되는 <xref:System.Windows.Forms.MenuItem.Click> 세 가지 메뉴 항목의 이벤트입니다. 각 메뉴 항목 텍스트 색을 지정 `menuItemRed` (빨간색) `menuItemGreen` (녹색) 또는 `menuItemBlue` (파란색). 이벤트 처리기는 메뉴 항목 클릭 했을 결정 선택한 메뉴 항목에 확인 표시를 배치 하 고 폼의 텍스트 색을 변경 <xref:System.Windows.Forms.TextBox> 제어 합니다. 이 예제에서는 <xref:System.Drawing> 네임 스페이스가이 코드에 배치 된 폼에 추가 되었습니다. 또한이 예제는 <xref:System.Windows.Forms.TextBox> 이라고 하는이 예제 코드에는 폼에 추가 되었습니다 `textBox1`합니다.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Windows.Forms.MenuItem" />이 최상위 메뉴이거나 자식을 갖는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목에 대해 정의된 바로 가기 키 또는 선택키를 사용하여 메뉴 항목을 클릭하거나 선택할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click> 이벤트가 발생할 때이 <xref:System.Windows.Forms.MenuItem> 클릭 하면 됩니다. 또한이 이벤트는 사용자가 키보드를 사용 하 여 메뉴 항목을 선택 하는 경우에 발생 하 고 Enter 키를 누릅니다. 발생할 수도 있습니다는 액세스 키 또는 바로 가기 키를 누르는 경우와 관련 된는 <xref:System.Windows.Forms.MenuItem>합니다. 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.Menu.MenuItems%2A> 에 대 한 속성을 <xref:System.Windows.Forms.MenuItem> 모든 항목이 포함이 이벤트가 발생 하지 않습니다. 부모 메뉴 항목에 대해서는이 이벤트가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.MenuItem.Click> 수행 하는 이벤트를 작업 하는 경우는 <xref:System.Windows.Forms.MenuItem> 를 클릭 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.MainMenu> 호출 `mainMenu1` 두 개 추가 <xref:System.Windows.Forms.MenuItem> 개체 `topMenuItem` (`File`) 및 `menuItem1` (`Open`). 그런 다음 연결 합니다 `Click` 이벤트를는 `menuItem1_Click` 이벤트 처리기입니다. 클릭할 때 합니다 `Open` 메뉴 항목을 <xref:System.Windows.Forms.OpenFileDialog> 초기화 되 고 표시 합니다. 만든이 예제는 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" />의 복사본을 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Forms.MenuItem" />의 복사본을 만듭니다.</summary>
        <returns>복제된 메뉴 항목을 나타내는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> 개체의 복사본을 획득 하지 않는 한 둘 이상의 위치에서 사용할 수 없습니다는 <xref:System.Windows.Forms.MenuItem>합니다. 사용 하기 위해이 메뉴 항목의 복사본을 만들려면이 메서드를 호출할 수는 <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, 또는 기타 <xref:System.Windows.Forms.MenuItem> 애플리케이션 내에서. 메뉴 항목을 복제 되는 경우 원래 메뉴 항목에 지정 된 모든 이벤트 처리기는 메뉴 항목의 복제 된 버전에서 작동 계속 됩니다. 예를 들어 사용자가 만든를 <xref:System.Windows.Forms.MenuItem> 및 연결 된 해당 <xref:System.Windows.Forms.MenuItem.Click> 이벤트 처리기에는 이벤트입니다. 메뉴 항목이 복제 되는 경우 복제 된 메뉴 항목은 동일한 이벤트 처리기를 호출 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 복제본을 <xref:System.Windows.Forms.MenuItem> 에 표시 된 <xref:System.Windows.Forms.ContextMenu>. 예제에는 필요를 <xref:System.Windows.Forms.MenuItem> 있는 <xref:System.Windows.Forms.MainMenu> 이름의 양식의 `menuItem1` 하 고를 <xref:System.Windows.Forms.ContextMenu> 라는 개체 `contextMenu1` 폼에 있는.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">복사할 메뉴 항목을 나타내는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Forms.MenuItem" />의 복사본을 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 애플리케이션 내에서 이미 만든 바로 가기 메뉴 또는 다른 메뉴 구조 사용에 대 한 메뉴 항목의 복사본을 만드는이 메서드를 호출 합니다. 이 버전의 <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> 특정을 지정할 수 있습니다 <xref:System.Windows.Forms.MenuItem> 메서드를 호출 하는 메뉴 항목 대신 복사 합니다. 이 메서드를 사용 하 여 새 <xref:System.Windows.Forms.MenuItem> 개체의 다른 복사본으로 <xref:System.Windows.Forms.MenuItem>입니다. 메뉴 항목을 복제 되는 경우 원래 메뉴 항목에 지정 된 모든 이벤트 처리기는 메뉴 항목의 복제 된 버전에서 작동 계속 됩니다. 예를 들어 사용자가 만든를 <xref:System.Windows.Forms.MenuItem> 및 연결 된 해당 <xref:System.Windows.Forms.MenuItem.Click> 이벤트 처리기에는 이벤트입니다. 메뉴 항목이 복제 되는 경우 복제 된 메뉴 항목은 동일한 이벤트 처리기를 호출 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 새 초기화 <xref:System.Windows.Forms.MenuItem> 기존 복사본을 사용 하 여 <xref:System.Windows.Forms.MenuItem> 에서 사용 되는 <xref:System.Windows.Forms.MainMenu> 양식의 합니다. 이 코드는 다음 복제 된 추가 <xref:System.Windows.Forms.MenuItem> 에 <xref:System.Windows.Forms.ContextMenu> 양식의 합니다. 이 예제에서는 <xref:System.Windows.Forms.MenuItem> 이미 생성 되어 명명 된 `menuItem1` 하 고는 <xref:System.Windows.Forms.ContextMenu> 컨트롤을 만들어야 라는 `contextMenu1`합니다.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목이 기본 메뉴 항목인지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>해당 메뉴 항목이 메뉴의 기본 항목이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴가 기본 메뉴 항목은 굵은 글꼴로 지정 합니다. 하위 메뉴를 두 번 클릭할 때 기본 항목을 포함 하는, 기본 항목을 선택 하 고 하위 메뉴를 닫습니다. 사용할 수는 <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> 메뉴 또는 바로 가기 메뉴에서 예상 되는 기본 동작을 나타내는 속성을 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 두 개의 하위 메뉴 항목을 사용 하 여 메뉴 항목을 만듭니다. 예제에서는 `menuItem2` 사용 하 여 기본 메뉴 항목으로는 <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> 속성입니다.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</param>
        <summary><see cref="T:System.Windows.Forms.MenuItem" />에서 사용하는 리소스(메모리 제외)를 삭제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Dispose%2A> 사용을 마치면 <xref:System.Windows.Forms.MenuItem>를 호출합니다. <xref:System.Windows.Forms.MenuItem.Dispose%2A> 메서드를 사용하면 <xref:System.Windows.Forms.MenuItem>를 사용할 수 없게 됩니다. 호출한 후 <xref:System.Windows.Forms.MenuItem.Dispose%2A>에 대 한 모든 참조를 해제 해야 합니다 <xref:System.Windows.Forms.MenuItem> 차지 했던 메모리를 가비지 수집에 의해 회수 될 수 있도록 합니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.MenuItem.Dispose%2A>에 대한 마지막 참조를 해제하기 전에 반드시 <xref:System.Windows.Forms.MenuItem>를 호출하십시오. 이 고, 그렇지 리소스를 <xref:System.Windows.Forms.MenuItem> 가 사용 하 여 확보 되지 것입니다. 가비지 컬렉션 호출 될 때까지 <xref:System.Windows.Forms.MenuItem> 개체의 소멸자입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목의 <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> 속성이 <see langword="true" />로 설정된 경우 메뉴 항목을 그리도록 요청할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Forms.DrawItemEventArgs> 에 전달 된 인수를 <xref:System.Windows.Forms.MenuItem.DrawItem> 이벤트 처리기를 제공는 <xref:System.Drawing.Graphics> 그리기 및 메뉴 항목의 화면에서 다른 그래픽 작업을 수행할 수 있는 개체입니다. 애플리케이션의 요구를 충족 하는 사용자 지정 메뉴를 만들려면이 이벤트 처리기를 사용할 수 있습니다. 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는 처리 하는 방법에 설명 합니다 <xref:System.Windows.Forms.MenuItem.DrawItem> 이벤트입니다. 그리는 항목으로 사용 하 여 메뉴이 예제는 <xref:System.Drawing.Brush> 및 <xref:System.Drawing.Font>, 다음 그립니다는 <xref:System.Drawing.Rectangle> 메뉴 항목입니다. 그리기를 통해 수행 됩니다 합니다 <xref:System.Drawing.Graphics> 의 이벤트 처리기에 전달 되는 개체는 <xref:System.Windows.Forms.DrawItemEventArgs> 매개 변수입니다. 이 예제에서는 초기화 되어는 <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> 항목에 대 한 속성 `true`합니다. C# 예제에서는 후 폼의 생성자에 다음 코드를 추가 `InitializeComponent`이벤트에 연결 합니다.  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목이 활성화되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메뉴 항목이 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> 즉 사용 안 함 상태를 나타내기 위해 회색으로 표시 됩니다. 부모 메뉴 항목이 비활성화 된 경우에 모든 하위 메뉴 항목이 표시 되지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.MenuItem.Popup> 이벤트에 있는지 여부를 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사에 대 한 지원을 제공 하 고 작업을 삭제 하는 개체에 표시 된 메뉴 표시 되기 전에 사용 하도록 설정 합니다. 이 예제에서는 확인 하는 경우 `textBox1`, <xref:System.Windows.Forms.TextBox> 폼에 컨트롤, 사용, 입력 포커스가에 사용 하도록 설정 하기 전에 선택한 텍스트를 <xref:System.Windows.Forms.MenuItem> 개체. 이 예제에서는 세 가지 <xref:System.Windows.Forms.MenuItem> 개체가 명명 된 만들어집니다 `menuCut`, `menuCopy`, 및 `menuDelete` 만들어졌습니다.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모 메뉴에서의 메뉴 항목 위치를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>부모 메뉴에서의 메뉴 항목 위치를 나타내며 0부터 시작하는 인덱스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 부모 메뉴의 메뉴 항목 컬렉션에서 메뉴 항목의 인덱싱된 위치를 제공 합니다. 해당 메뉴 내에서 다른 위치에 메뉴 항목 위치를 변경 하려면이 속성을 사용할 수 있습니다. 만들 때이 속성을 사용할 수도 있습니다는 <xref:System.Windows.Forms.MenuItem> 생성 시 메뉴 구조에서의 위치를 지정 합니다.  
  
   
  
## Examples  
 메뉴에서 두 개의 메뉴 항목의 위치를 전환 하는 다음 코드 예제입니다. 다음 코드 예제에서는 두 개의 <xref:System.Windows.Forms.MenuItem> 개체가 명명 된 만들어집니다 `menuItem1` 고 `menuItem2`입니다. 합니다 `menuItem1` 메뉴 항목이 메뉴에서 한 칸 아래로 이동 하는 동안 `menuItem2` 한 위치 위로 이동 합니다.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">할당된 값이 0보다 작거나 항목 수보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목에 자식 메뉴 항목이 포함된지를 나타내는 값을 가져옵니다.</summary>
        <value>메뉴 항목에 자식 메뉴 항목이 있으면 <see langword="true" />이고, 메뉴가 독립 실행형 메뉴 항목이면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용할 수는 <xref:System.Windows.Forms.MenuItem.Parent%2A> 전체 메뉴 구조를 통해 코드에서 탐색 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 연결 된 모든 하위 메뉴가 있는지 여부를 결정 한 <xref:System.Windows.Forms.MenuItem> 라는 `menuItem1`합니다. 설정 하 여 비활성화에 하위 메뉴가 있는지 알 수 없으면 합니다 <xref:System.Windows.Forms.MenuItem.Enabled%2A> 속성을 `false`입니다. 이 예제는 <xref:System.Windows.Forms.MenuItem> 라는 생성 `menuItem1`합니다.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목이 관련 폼 내에 표시되는 MDI(다중 문서 인터페이스) 자식 창의 목록으로 채워지는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메뉴 항목에 MDI 자식 창의 목록이 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 MDI 자식 창 목록에 표시할 메뉴 항목을 선택 하면 목록 메뉴 항목의 하위 메뉴로 표시 됩니다. MDI 자식 폼으로 정의 된 양식만 창 목록에 표시 됩니다. 9 개 밖에 자식 창은 한 번에 표시할 수 있습니다. 있는 경우 표시 되는 10 개 이상 자식 창, "더 많은 Windows..." 메뉴 항목을 창 목록의 끝에 표시 됩니다. 이 메뉴 항목을 클릭 하면 현재 활성화 된 자식 창의 전체 목록이 포함 된 대화 상자가 표시 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.MenuItem> MDI 폼에서 현재 열려 있는 MDI 자식 폼의 목록을 표시 하는 데 사용 되는 합니다.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목을 그리기 전에 메뉴에서 해당 메뉴 항목의 크기를 알아야 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 발생에 대 한 순서로 있어야 합니다 <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> 메뉴 항목의 속성으로 설정 `true`합니다. 소유자 그리기 메뉴는 메뉴 항목의 크기를 지정할 그릴 수 있도록 그리기 전에 이벤트가 발생 합니다. 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.MenuItem.MeasureItem> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.MenuItem> 라는 `MenuItem1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.MenuItem.MeasureItem> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메뉴 항목의 Windows 식별자를 나타내는 값을 가져옵니다.</summary>
        <value>이 메뉴 항목의 Windows 식별자입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 <see cref="T:System.Windows.Forms.MenuItem" />을 다른 <see cref="T:System.Windows.Forms.MenuItem" />과 병합합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Windows.Forms.MenuItem" />을 다른 <see cref="T:System.Windows.Forms.MenuItem" />과 병합하고 병합된 <see cref="T:System.Windows.Forms.MenuItem" />을 반환합니다.</summary>
        <returns>병합된 메뉴 항목을 나타내는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의를 호출 하는 경우 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, <xref:System.Windows.Forms.MenuItem> 은 현재 메뉴 항목과 병합할 수 있는 현재 항목의 기능에 영향을 주지 않고 다른 메뉴 항목의 복사본을 반환 합니다. 이 버전의 합니다 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> 호출 하는 것과 비슷합니다는 <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> 없는 매개 변수를 포함 하는 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">이 메뉴 항목과 병합할 메뉴 항목을 지정하는 <see cref="T:System.Windows.Forms.MenuItem" />입니다.</param>
        <summary>다른 메뉴 항목을 이 메뉴 항목과 병합합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목이 메뉴 항목의 값에 따라 병합 됩니다 <xref:System.Windows.Forms.MenuItem.MergeType%2A> 고 <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> 속성입니다. 이 버전의 합니다 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> 방법을 사용 하면 병합 두 <xref:System.Windows.Forms.MenuItem> 단일 메뉴에 개체 (및 해당 하위 메뉴). 메뉴 병합 문서 MDI (다중 인터페이스) 부모 폼과 자식 메뉴가 있을 때 자동으로 처리 됩니다. 이 버전의 병합 두 메서드를 사용할 수 있습니다 <xref:System.Windows.Forms.MenuItem> 개체 (및 해당 하위 메뉴 항목)에 <xref:System.Windows.Forms.MainMenu> 내에서 단일 메뉴에 컨트롤을 <xref:System.Windows.Forms.ContextMenu>입니다. 예를 들어,이 버전의를 호출할 수 있습니다 합니다 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> 단일 파일과 편집 메뉴의 메뉴 항목 병합 하는 방법 <xref:System.Windows.Forms.MenuItem> 및 수 있는 다음에 추가 하 여 표시를 <xref:System.Windows.Forms.ContextMenu>입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 버전의 합니다 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> 의 복사본을 만드는 메서드를 <xref:System.Windows.Forms.MenuItem> 과 다른 병합 합니다. 병합 된 <xref:System.Windows.Forms.MenuItem> 에 추가 되는 <xref:System.Windows.Forms.ContextMenu> 제어 합니다. 이 예제에서는 라는 두 개의 메뉴 항목이 있는지 `menuItem1` 및 `menuItem2` 하위 메뉴 항목을 포함 하는 및 <xref:System.Windows.Forms.ContextMenu> 라는 `contextMenu1` 메뉴 항목을 표시 합니다. `menuItem1` 및 `menuItem2` 내에 포함 된 다른 메뉴 항목이 있어야 합니다. 호출한 후 <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> 이루어지는 통합 된 메뉴가 만들어집니다.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목이 다른 항목과 병합될 때 메뉴 항목의 상대적 위치를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메뉴 항목의 병합 순서 위치를 나타내며 0부터 시작하는 인덱스입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴를 구성 하는 경우이 메뉴 항목이 놓여질 상대적 위치를 지정 하는 메뉴 항목의 병합 순서는 <xref:System.Windows.Forms.MenuItem> 포함 된 다른 항목과 병합 될 합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> 병합된 된 메뉴에 표시 되는 방식을 제어 하는 속성입니다. 프로젝트에 추가한 후 실행할 준비가 전체 예제입니다.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목의 메뉴가 다른 메뉴와 병합될 때 해당 메뉴 항목의 동작을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메뉴 항목의 병합 유형을 나타내는 <see cref="T:System.Windows.Forms.MenuMerge" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목의 병합 유형을 다른 메뉴 항목과 병합 되 고 병합 순서에 있을 때 메뉴 항목의 동작 방식을 나타냅니다. 둘 이상의 기존 메뉴에 따라 통합된 메뉴를 만들려면 병합 된 메뉴를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MenuItem> 사용 하 여 합니다 <xref:System.Windows.Forms.MenuItem.MergeType%2A> 및 <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> 첫 번째 위치에서 병합된 된 메뉴에 메뉴 항목 추가 되도록 지정 합니다.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.MenuMerge" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메뉴 항목과 연결된 니모닉 문자를 나타내는 값을 가져옵니다.</summary>
        <value>이 메뉴 항목과 연결된 니모닉 문자를 나타내는 문자입니다. <see cref="T:System.Windows.Forms.MenuItem" />의 텍스트에 지정된 니모닉 문자가 없으면 NUL 문자(ASCII 값 0)를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 니모닉 문자는 첫 번째 문자가 텍스트에 (&)를 앰퍼샌드 문자 뒤의 <xref:System.Windows.Forms.MenuItem>합니다. 이 속성의 텍스트에서 앰퍼샌드를 표시할 경우 앰퍼샌드가 사용 되 고 두 앰퍼샌드 문자 함께 배치 된 경우 니모닉을 반환 하지 것입니다는 <xref:System.Windows.Forms.MenuItem> 니모닉 문자를 정의 하는 대신 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Click" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.MenuItem.Click> 수행 하는 이벤트를 작업 하는 경우는 <xref:System.Windows.Forms.MenuItem> 를 클릭 합니다. 이 예에서는 만듭니다는 <xref:System.Windows.Forms.MainMenu> 호출 `mainMenu1` 두 개 추가 <xref:System.Windows.Forms.MenuItem> 개체 `topMenuItem` (`File`) 및 `menuItem1` (`Open`). 그런 다음 연결 합니다 `Click` 이벤트를는 `menuItem1_Click` 이벤트 처리기입니다. 클릭할 때 합니다 `Open` 메뉴 항목을 <xref:System.Windows.Forms.OpenFileDialog> 초기화 되 고 표시 합니다. 만든이 예제는 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> 메서드.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.DrawItemEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> 메서드.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Popup" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> 메서드.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Popup" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.MenuItem.Popup> 이벤트에 있는지 여부를 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사에 대 한 지원을 제공 하 고 작업을 삭제 하는 개체에 표시 된 메뉴 표시 되기 전에 사용 하도록 설정 합니다. 이 예제에서는 확인 하는 경우 `textBox1`, <xref:System.Windows.Forms.TextBox> 폼에 컨트롤, 사용, 입력 포커스가에 사용 하도록 설정 하기 전에 선택한 텍스트를 <xref:System.Windows.Forms.MenuItem> 개체. 이 예제에서는 세 가지 <xref:System.Windows.Forms.MenuItem> 개체가 명명 된 만들어집니다 `menuCut`, `menuCopy`, 및 `menuDelete` 만들어졌습니다.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> 메서드.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Select" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.MenuItem.Select> 의 이벤트를 <xref:System.Windows.Forms.MenuItem> 도움말 텍스트를 할당 하는 클래스를 <xref:System.Windows.Forms.StatusBarPanel> 의 <xref:System.Windows.Forms.StatusBar> 컨트롤입니다. 이 예제에서는 <xref:System.Windows.Forms.MenuItem> 명명 된 개체 `menuOpen`를 `menuSave`, 및 `menuExit` 에 추가 됩니다을 <xref:System.Windows.Forms.MainMenu> 폼의 컨트롤입니다. 또한이 예제는 <xref:System.Windows.Forms.StatusBar> 라는 컨트롤 `statusBar1` 폼에 추가 되었습니다. 합니다 <xref:System.Windows.Forms.StatusBar> 제어 있어야를 <xref:System.Windows.Forms.StatusBarPanel>입니다.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> 파생된 클래스에서 호출 해야 기본 클래스의 <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> 메서드.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 제공하는 코드에서 메뉴 항목을 그리는지 또는 Windows에서 메뉴 항목을 그리는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>코드를 사용하여 메뉴 항목을 그리면 <see langword="true" />이고, Windows에서 그리면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> 속성이 `true`, 메뉴 항목의 모든 그리기를 처리 해야 합니다. 사용자 고유의 특별 한 메뉴 표시를 만들려면이 기능을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제는 소유자가 그린 메뉴 항목을 사용 하 여 메뉴를 보여 줍니다. 예제 집합을 <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> 사용 하 여 속성을 `AddHandler` 문 및 `AddressOf` 처리 하는 대리자를 지정 하는 연산자를 <xref:System.Windows.Forms.MenuItem.DrawItem> 이벤트. 가져오는 폼에 붙여 예제를 실행 하는 <xref:System>, <xref:System.Windows.Forms>, 및 <xref:System.Drawing> 네임 스페이스입니다. 호출 `InitializeMenu` 폼의 생성자에서 또는 `Load` 메서드.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 메뉴 항목이 포함된 메뉴를 나타내는 값을 가져옵니다.</summary>
        <value>이 메뉴 항목이 들어 있는 메뉴를 나타내는 <see cref="T:System.Windows.Forms.Menu" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 가져올 수는 <xref:System.Windows.Forms.Menu> 하위 메뉴에 대 한 개체입니다. 캐스팅할 수 있습니다 합니다 <xref:System.Windows.Forms.Menu> 이 속성에서 반환 된 개체는 <xref:System.Windows.Forms.MenuItem> 조작 하는 개체입니다.  
  
   
  
## Examples  
 이 예에서는 주 메뉴 및 최상위 메뉴 항목을 만듭니다 `menuItem1` (`File`). 두 가지 메뉴 항목을 만들 수도 있습니다 `menuItem2` (`New`) 및 `menuItem3` (`Open`), 메뉴 항목 목록에 추가할 `menuItem1`합니다. 있는지 확인 한 다음 `menuItem3` 얻었습니다 부모는이 true 이면 메뉴 및 표시가 부모 메뉴의 정보를 메시지 상자에 있습니다. 이 예제에서는 만든를 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>클릭하는 동작을 시뮬레이션하는 <see cref="E:System.Windows.Forms.Control.Click" />의 <see cref="T:System.Windows.Forms.MenuItem" /> 이벤트를 생성합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 정보를 전달 하지 않고 코드를 통해 메뉴 항목을 활성화 하려면이 메뉴를 사용할 수 있습니다. 예를 들어, 호출 애플리케이션에서 발생 하는 동작에 따라 항목 메뉴를 활성화 하려는 경우는 <xref:System.Windows.Forms.MenuItem.PerformClick%2A> 메서드를 <xref:System.Windows.Forms.MenuItem>입니다.  
  
   
  
## Examples  
 메뉴 항목을 사용 하 여 프로그래밍 방식으로 클릭 하면이 예제에서는 `PerformClick` 메서드. 먼저 주 메뉴를 만듭니다 (`mainMenu1`)를 두 개의 추가 메뉴 항목이 `menuItem1` (`File`) 및 `menuItem2` (`Edit`). 또한 사용 하 여는 <xref:System.Windows.Forms.MenuItem.Click> 메뉴 항목을 클릭할 때 이벤트 처리기에 데이터를 전송 하는 이벤트입니다. 사용 하 여는 `PerformClick` 를 클릭 하는 방법의 `File` 메뉴 항목입니다. 애플리케이션을 시작할 때의 `File` 메뉴 항목이 활성화 되 고 "파일 메뉴를 클릭 합니다." 텍스트를 포함 하는 메시지 상자 화면에 표시 됩니다. 만든이 예제는 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 메뉴 항목의 <see cref="E:System.Windows.Forms.MenuItem.Select" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 발생 시킬 수 있습니다는 <xref:System.Windows.Forms.MenuItem.Select> 이벤트 처리기에 이벤트 정보를 전달 하지 않고 이벤트입니다.  
  
   
  
## Examples  
 메뉴 항목을 사용 하 여 프로그래밍 방식으로 선택 하면이 예제에서는 `PerformSelect` 메서드. 먼저 주 메뉴를 만듭니다 (`mainMenu1`)를 두 개의 추가 메뉴 항목이 `menuItem1` (`File`) 및 `menuItem2` (`Edit`). 또한 사용 하 여는 <xref:System.Windows.Forms.MenuItem.Select> 메뉴 항목이 선택 될 때 이벤트 처리기에 데이터를 전송 하는 이벤트입니다. 사용 하 여는 `PerformSelect` 메서드를 선택 합니다 `File` 메뉴 항목입니다. 애플리케이션을 시작할 때의 `File` 메뉴 항목을 선택 하 고 "파일 메뉴를 선택 합니다." 텍스트를 포함 하는 메시지 상자 화면에 표시 됩니다. 만든이 예제는 <xref:System.Windows.Forms.Form> 라는 `Form1`합니다.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목의 메뉴 항목 목록이 표시되기 전에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 메뉴 항목에 하위 메뉴 항목을 표시 하는 경우에 발생 합니다. 이 이벤트 처리기를 사용 하 여 추가, 제거, 사용, 사용 안 함, 또는 표시 되기 전에 애플리케이션의 상태에 따라 메뉴 항목을 선택 취소 합니다. 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.MenuItem.Popup> 이벤트에 있는지 여부를 <xref:System.Windows.Forms.MenuItem> 잘라내기, 복사에 대 한 지원을 제공 하 고 작업을 삭제 하는 개체에 표시 된 메뉴 표시 되기 전에 사용 하도록 설정 합니다. 이 예제에서는 확인 하는 경우 `textBox1`, <xref:System.Windows.Forms.TextBox> 폼에 컨트롤, 사용, 입력 포커스가에 사용 하도록 설정 하기 전에 선택한 텍스트를 <xref:System.Windows.Forms.MenuItem> 개체. 이 예제에서는 세 가지 <xref:System.Windows.Forms.MenuItem> 개체가 명명 된 만들어집니다 `menuCut`, `menuCopy`, 및 `menuDelete` 만들어졌습니다.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" />이 선택된 경우 확인 표시 대신 라디오 단추를 표시할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메뉴 항목이 선택될 때 확인 표시 대신 라디오 단추가 사용되면 <see langword="true" />이고, 표준 확인 표시가 표시되면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 확인 표시 반드시 메뉴 항목의 그룹에 대 한 배타적인 상태를 나타내지 않습니다. 메뉴 항목의 확인 표시를 상호 배타적인 임을 사용자에 게 나타내려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 <xref:System.Windows.Forms.MenuItem.Checked%2A> 애플리케이션의 상태를 변경할 속성입니다. 예제에서는 메뉴 항목의 그룹은 제공 된 텍스트의 색을 지정 하는 데 사용 되는 <xref:System.Windows.Forms.TextBox> 제어 합니다. 제공 된 이벤트 처리기를 사용한 예에서는 <xref:System.Windows.Forms.MenuItem.Click> 세 가지 메뉴 항목의 이벤트입니다. 각 메뉴 항목 색을 지정 `menuItemRed`하십시오 `menuItemGreen`, 또는 `menuItemBlue`합니다. 이벤트 처리기는 메뉴 항목 클릭 했을 결정 선택한 메뉴 항목에 확인 표시를 배치 하 고 폼의 텍스트 색을 변경 <xref:System.Windows.Forms.TextBox> 라는 컨트롤 `textBox1`합니다. 또한이 예제에서는 <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> 라디오 단추 확인을를 사용 하는 상호 배타적인 메뉴 항목을 표시 하는 방법을 보여 주기 위해 속성입니다. 이 예제에서는 <xref:System.Drawing?displayProperty=nameWithType> 네임 스페이스가이 코드를 포함 하는 폼에 추가 되었습니다.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목 위에 포인터를 놓으면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로이 이벤트는 메뉴 항목 위로 마우스 포인터를 놓으면 발생 합니다. 또한 사용자는 키보드 화살표 키를 사용 하 여 메뉴 항목으로 스크롤 하 여 메뉴 항목을 강조 하는 경우이 이벤트가 발생 합니다. 애플리케이션의 상태 표시줄에서이 메뉴 항목을 관련 된 자세한 도움말 문자열을 표시 하려면이 이벤트를 사용할 수 있습니다. 이벤트 처리에 대한 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md) 을 참조하십시오.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.Menu.MenuItems%2A> 에 대 한 속성을 <xref:System.Windows.Forms.MenuItem> 모든 항목이 포함이 이벤트가 발생 하지 않습니다. 부모 메뉴 항목에 대해서는이 이벤트가 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 코드 예제에 사용 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.MenuItem.Select> 의 이벤트를 <xref:System.Windows.Forms.MenuItem> 도움말 텍스트를 할당 하는 클래스를 <xref:System.Windows.Forms.StatusBarPanel> 의 <xref:System.Windows.Forms.StatusBar> 컨트롤입니다. 이 예제에서는 <xref:System.Windows.Forms.MenuItem> 명명 된 개체 `menuOpen`를 `menuSave`, 및 `menuExit` 에 추가 됩니다을 <xref:System.Windows.Forms.MainMenu> 폼의 컨트롤입니다. 또한이 예제는 <xref:System.Windows.Forms.StatusBar> 라는 컨트롤 `statusBar1` 폼에 추가 되었습니다. 합니다 <xref:System.Windows.Forms.StatusBar> 제어 있어야를 <xref:System.Windows.Forms.StatusBarPanel>입니다.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목과 연결된 바로 가기 키를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.Shortcut" /> 값 중 하나입니다. 기본값은 <see langword="Shortcut.None" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 바로 가기 키 키보드로 마우스 또는 기타 포인터 장치에 대 한 액세스 권한이 없는 사용자에 대 한 애플리케이션에 액세스할 수 있도록 메뉴 시스템에 메뉴 항목 사용 하는 사용자가 자주 활성화 하는 방법을 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메뉴 항목을 만드는, 캡션을 설정, 바로 가기 키를 할당, 메뉴 항목을 표시 하면 및 메뉴 항목에 대 한 바로 가기 키 표시 예제에는 필요는 <xref:System.Windows.Forms.MenuItem> 즉 만들었습니다 라는 `menuItem1`합니다.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">할당된 값이 <see cref="T:System.Windows.Forms.Shortcut" /> 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목과 연결된 바로 가기 키가 메뉴 항목 캡션 옆에 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>바로 가기 키 조합이 메뉴 항목 캡션 옆에 표시되면 <see langword="true" />이고, 바로 가기 키 조합이 표시되지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 공간을 절약 하거나 바로 가기 키 표시 되지 않도록 숨겨야 숨기려면 바로 가기 메뉴에서 사용자에 대 한 옵션을 제공 하려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메뉴 항목을 만드는, 캡션을 설정, 바로 가기 키를 할당, 메뉴 항목을 표시 하면 및 메뉴 항목에 대 한 바로 가기 키 표시 예제에는 필요는 <xref:System.Windows.Forms.MenuItem> 즉 만들었습니다 라는 `menuItem1`합니다.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목의 캡션을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>메뉴 항목의 텍스트 캡션입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴 항목에 대 한 캡션을 지정할 때에 앞에 '&' 선택 키로 사용할 문자를 배치 하 여 액세스 키를 지정할 수 있습니다. 예를 들어 "파일"에서 "F"가 선택 키를 지정 하려면 사용자는 표시 된 메뉴 항목에 대 한 캡션을 지정 "& 파일"입니다. 메뉴에 대 한 키보드 탐색을 위해이 기능을 사용할 수 있습니다.  
  
 이 속성을 "`-`" 메뉴 항목 (가로 선) 구분 기호 대신 표준 메뉴 항목을 표시 하면 됩니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메뉴 항목을 만드는, 캡션을 설정, 바로 가기 키를 할당, 메뉴 항목을 표시 하면 및 메뉴 항목에 대 한 바로 가기 키 표시 예제에는 필요는 <xref:System.Windows.Forms.MenuItem> 즉 만들었습니다 라는 `menuItem1`합니다.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" />를 나타내는 문자열을 반환합니다.</summary>
        <returns>현재 <see cref="T:System.Windows.Forms.MenuItem" />을(를) 나타내는 문자열입니다. 문자열에는 컨트롤의 형식과 <see cref="P:System.Windows.Forms.MenuItem.Text" /> 속성이 포함됩니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>메뉴 항목이 표시되는지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>해당 메뉴 항목이 메뉴에 표시되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 메뉴를 병합 하거나 메뉴를 사용 하지 않도록 설정 하지 않고도 메뉴 구조를 수정 하려면이 속성을 사용할 수 있습니다. 예를 들어, 애플리케이션의 메뉴에서 기능의 전체 섹션을 숨기려는 경우 해당 숨길 수 있습니다 사용자 로부터이 속성을 설정 하 여 `false`입니다.  
  
   
  
## Examples  
 다음 코드 예제에서는 메뉴 항목을 만드는, 캡션을 설정, 바로 가기 키를 할당, 메뉴 항목을 표시 하면 및 메뉴 항목에 대 한 바로 가기 키 표시 예제에는 필요는 <xref:System.Windows.Forms.MenuItem> 즉 만들었습니다 라는 `menuItem1`합니다.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>