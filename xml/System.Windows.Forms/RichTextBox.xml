<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7980be284b40488f6e919a5cdc02ff8a5f382054" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57961161" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows의 RichTextBox 컨트롤을 나타냅니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여는 <xref:System.Windows.Forms.RichTextBox> 컨트롤, 사용자를 입력 하 고 텍스트를 편집할 수 있습니다. 컨트롤의 표준 보다 더 많은 고급 서식 지정 기능을 제공 합니다 <xref:System.Windows.Forms.TextBox> 제어 합니다. 텍스트는 컨트롤에 직접 할당할 수 있습니다 하거나 서식 있는 텍스트 (rtf) 또는 일반 텍스트 파일에서 로드할 수 있습니다. 컨트롤 내의 텍스트 문자와 단락 형식을 할당할 수 있습니다.  
  
 <xref:System.Windows.Forms.RichTextBox> 컨트롤은 다양 한 컨트롤 내의 텍스트 부분에 서식 지정을 적용 하 여 속성을 제공 합니다. 텍스트의 서식을 변경할 것을 먼저 선택 해야 합니다. 선택한 텍스트만 문자와 단락 형식을 할당할 수 있습니다. 설정을 선택한 섹션 텍스트 내용이 되 면 선택도 형식이 동일한 설정을 사용 하 여 설정을 변경 될 때까지 다음에 입력 한 모든 텍스트 또는 컨트롤의 문서의 다른 섹션을 선택 합니다. <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> 속성을 사용 하면 텍스트를 굵게 또는 기울임꼴 있습니다. 또한 크기와 서체 텍스트를 변경 하려면이 속성을 사용할 수 있습니다. <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성을 사용 하면 텍스트의 색을 변경할 수 있습니다. 사용할 수는 글머리 기호 목록을 만들 수는 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성입니다. 단락을 설정 하 여 서식 지정을 조정할 수도 있습니다는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
 <xref:System.Windows.Forms.RichTextBox> 컨트롤 파일 열기 및 저장에 대 한 기능을 제공 하는 메서드를 제공 합니다. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 사용 하면 컨트롤에 기존 서식 있는 텍스트 또는 ASCII 텍스트 파일을 로드할 수 있습니다. 또한 이미 열려 데이터 스트림에서 데이터를 로드할 수 있습니다. <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 서식 있는 텍스트 또는 ASCII 텍스트 파일을 저장할 수 있습니다. 비슷합니다는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 사용할 수도 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 개방형 데이터 스트림에 저장 하는 방법입니다. <xref:System.Windows.Forms.RichTextBox> 컨트롤 텍스트 문자열을 찾기 위한 기능도 제공 합니다. <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드는 오버 로드 중에 텍스트 문자열을 컨트롤의 텍스트 내에서로 특정 문자를 찾습니다.  
  
 초기화할 수도 있습니다는 <xref:System.Windows.Forms.RichTextBox> 메모리에 저장 된 데이터를 제어 합니다. 예를 들어, 초기화할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 텍스트를 포맷 해야 하는 방법을 결정 하는 RTF 코드를 포함 하 여 표시할 텍스트를 포함 하는 문자열 속성입니다.  
  
 컨트롤 내의 텍스트를 웹 사이트에 대 한 링크와 같은 링크를 포함 하는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> 속성을 컨트롤의 텍스트에 링크를 적절 하 게 표시 합니다. 그런 다음 처리할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 링크와 관련 된 작업을 수행 하는 이벤트입니다. <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> 속성을 사용 하면 사용자가 조작에서 컨트롤 내의 텍스트를 보호할 수 있습니다. 컨트롤에서 보호 된 텍스트를 사용 하 여 처리할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트를 사용자가 보호 된 텍스트를 수정 하려고 하 고는 텍스트 보호 되어 있거나이 보호 된 텍스트를 조작할 수 있는 표준 방법을 사용 하 여 사용자를 제공 하는 사용자를 경고 하거나 시기를 결정 합니다.  
  
 이미 사용 하는 응용 프로그램 <xref:System.Windows.Forms.TextBox> 컨트롤을 적용 수 쉽게 사용 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 그러나 합니다 <xref:System.Windows.Forms.RichTextBox> 컨트롤의 동일한 64k 문자 용량 제한 없는 <xref:System.Windows.Forms.TextBox> 컨트롤입니다. <xref:System.Windows.Forms.RichTextBox> 일반적으로 텍스트를 조작 하 고 Microsoft Word와 같은 워드 프로세싱 응용 프로그램과 유사한 기능을 표시 하는 데 사용 됩니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType> 메서드는 사용 하지 않고 합니다 <xref:System.Windows.Forms.Control.KeyPress> 또는 <xref:System.Windows.Forms.Control.TextChanged> 이벤트입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> "Text." 라는 단어의 첫 번째 인스턴스에 대 한 검색 컨트롤에 RTF 파일을 로드 하는 컨트롤 그런 다음 코드는 글꼴 스타일, 글꼴 크기 및 선택한 텍스트의 글꼴 색을 변경 하 고 원본 파일에 변경 내용을 저장. 컨트롤을 추가 하 여 완료 된 예제 코드를 해당 <xref:System.Windows.Forms.Form>합니다. 이 예제는 예제 코드에서 만든 메서드를 추가 하려면를 <xref:System.Windows.Forms.Form> 클래스 및 폼의 생성자에서 호출 합니다. 이 예제에서는 "Text." 라는 단어가 포함 된 C 드라이브의 루트에 RTF 파일 생성도 필요  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 컨트롤의 속성이 `true`합니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> "Text." 라는 단어의 첫 번째 인스턴스에 대 한 검색 컨트롤에 RTF 파일을 로드 하는 컨트롤 그런 다음 코드는 글꼴 스타일, 글꼴 크기 및 선택한 텍스트의 글꼴 색을 변경 하 고 원본 파일에 변경 내용을 저장. 컨트롤을 추가 하 여 완료 된 예제 코드를 해당 <xref:System.Windows.Forms.Form>합니다. 이 예제는 예제 코드에서 만든 메서드를 추가 하려면를 <xref:System.Windows.Forms.Form> 클래스 및 폼의 생성자에서 호출 합니다. 이 예제에서는 "Text." 라는 단어가 포함 된 C 드라이브의 루트에 RTF 파일 생성도 필요  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 끌어서 놓기 작업을 수행할 수 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 끌어서 놓기 작업을 수행할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제에 사용 하 여 끌어서 놓기 작업을 수행 하는 방법을 보여 줍니다.는 <xref:System.Windows.Forms.ListBox> 놓을 항목이 포함 된 컨트롤을 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 양식 설정의 생성자는 <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> 속성을 `true` 끌어서 놓기 작업이 발생할 수 있도록는 <xref:System.Windows.Forms.RichTextBox>합니다. 예제에서는 합니다 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트를 <xref:System.Windows.Forms.ListBox> 호출 하 여 끌기 작업을 시작 하려면를 <xref:System.Windows.Forms.Control.DoDragDrop%2A> 메서드. 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragEnter> 이벤트 항목을 끄는 경우에 <xref:System.Windows.Forms.RichTextBox> 유효한 데이터 형식입니다. <xref:System.Windows.Forms.Control.DragDrop> 으로 끌어 온된 항목의 실제 삭제를 수행 하는 이벤트를 <xref:System.Windows.Forms.RichTextBox> 컨트롤 내에서 현재 커서 위치는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 합니다 <xref:System.Windows.Forms.Control.DragDrop> 및 <xref:System.Windows.Forms.Control.DragEnter> 예제에 정의 된 이벤트 처리기에 연결 된 이벤트입니다.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>사용하도록 설정되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>단어 단위로 선택 기능이 활성화되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>단어 단위로 선택 기능이 활성화되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 전체 단어 선택 컨트롤에서 텍스트의 일부를 선택 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번에 컨트롤의 클라이언트 영역 오른쪽에 여백을 때 컨트롤의 텍스트에 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자 자체 줄에 표시 되는 위치입니다. 이 세로 표시 위치에 있는 동안 단어의 일부에서 클릭 하면 텍스트를 세로로 표시 되도록 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 있어야 포함 된 폼을 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>컨트롤에 표시된 배경 이미지입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>컨트롤에 표시할 배경 이미지의 레이아웃입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>글머리 기호 스타일이 텍스트에 적용될 때 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 사용된 들여쓰기를 가져오거나 설정합니다.</summary>
        <value>글머리 기호 다음에 들여쓰기로 삽입된 픽셀의 수입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 글머리 기호 스타일이 텍스트의 단락에 적용할 설정 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을 `true` 설정한 후는 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성의 텍스트를 써야 하는 픽셀 수입니다. 단락의는 글머리 기호 스타일이 지정된 된 양의 글머리 기호 다음에 들여쓰기를 사용 하 여 적용 해야 합니다. 이 속성은 컨트롤의 텍스트 및 글머리 기호 항목의 목록에서 현재 선택한 글머리 내에서 현재 단락을만 영향을 줍니다. 글머리 기호 항목의 전체 목록에는 다양 한 들여쓰기 수준에 적용 하려면 글머리 기호 항목의 모든 텍스트를 설정 하기 전에 선택 해야 합니다 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을를 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 에서 글머리 기호 목록을 만들기 위한 속성을를 <xref:System.Windows.Forms.RichTextBox> 컨트롤. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 들여쓰기가 0보다 작은 경우</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat"><see cref="T:System.Windows.Forms.DataFormats.Format" /> 값 중 하나입니다.</param>
        <summary>지정된 데이터 형식으로 클립보드의 정보를 붙여넣을 수 있는지 여부를 확인합니다.</summary>
        <returns>지정된 데이터 형식으로 클립보드의 데이터를 붙여넣을 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여에 정보를 붙여넣을 수 있도록 하기 전에 지정 된 클립보드 데이터 형식으로 클립보드의 현재 내용이 되는지 여부를 결정 하는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 예를 들어,에 대 한 이벤트 처리기를 만들 수 있습니다는 <xref:System.Windows.Forms.MenuItem.Popup> 붙여넣기 명령 이벤트 <xref:System.Windows.Forms.MenuItem> 결정 하려면이 메서드를 사용 하 고 있는지 여부를 붙여넣기 <xref:System.Windows.Forms.MenuItem> 클립보드의 데이터 형식에 따라 사용 해야 합니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 비트맵을 붙여 메서드는 <xref:System.Windows.Forms.RichTextBox> 컨트롤. 비트맵 파일에서을 연 후이 예제에서는 사용 된 <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> 비트맵 Windows 클립보드에 복사 하는 방법. 예제에 대 한 형식을 검색 하는 마지막으로 <xref:System.Drawing.Bitmap> 개체를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> 형식에 붙여넣을 수 있는지 확인 하는 메서드를 <xref:System.Windows.Forms.RichTextBox> 컨트롤을 사용 하 여 다음를 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 데이터를 붙여 합니다.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" />에서 발생된 동작 중 다시 적용될 수 있는 동작이 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 내용에 다시 적용할 수 있는 실행 취소된 작업이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 확인 하려면이 속성을 사용할 수 있는지 여부를 마지막으로 실행 취소 작업을 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여 다시 적용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 텍스트의 삭제를 제외한 모든 작업을 다시 실행 작업을 제한 하려면 메서드를 합니다. 이 예제에서는 포함 된 폼이 있어야를 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업을 <xref:System.Windows.Forms.RichTextBox> 수행 되어이 예제의 코드를 호출 하기 전에 실행 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에 있는 내용의 크기가 조정될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.ContentsResized> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 핸들이 만들어지는 경우 필요한 작성 매개 변수를 가져옵니다.</summary>
        <value>컨트롤 핸들을 만들 때 필요한 작성 매개 변수가 포함된 <see cref="T:System.Windows.Forms.CreateParams" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>RichEdit 콜백 작업을 처리하는 데 사용할 <see langword="IRichEditOleCallback" /> 호환 개체를 만듭니다.</summary>
        <returns><see langword="IRichEditOleCallback" /> 인터페이스를 구현하는 개체</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">비관리 코드를 호출할 즉각적인 호출자가입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>기본 서식 있는 편집 기능에 액세스할 수 있도록 파생된 클래스에서이 메서드를 재정의할 수 있습니다. 이 메서드를 재정의 하는 경우 모든 끌어서 놓기 이벤트가 발생 하지 않습니다. 결과적으로, 끌어서 놓기 작업에 대 한 고유한 지원을 제공 해야 합니다. 에 대 한 자세한 내용은 합니다 <see langword="IRichEditOleCallback" /> 인터페이스의 플랫폼 SDK 설명서를 참조 하십시오 http://msdn.microsoft.com합니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 기본 크기를 가져옵니다.</summary>
        <value><see cref="T:System.Drawing.Size" /> 값입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URL(Uniform Resource Locator)이 컨트롤에 입력될 때 <see cref="T:System.Windows.Forms.RichTextBox" />에서 해당 URL의 서식을 자동으로 지정할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.RichTextBox" />에서 컨트롤에 링크로 입력된 URL의 서식을 자동으로 지정하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 설정 된 경우 `true`, 결정 되는 컨트롤에 입력 한 텍스트는 <xref:System.Windows.Forms.RichTextBox> URL은 자동으로 링크로 서식이 지정 되도록 합니다. 에 대 한 이벤트 처리기를 만들 수는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 컨트롤에서 이벤트 처리 모든 링크를 클릭 합니다. 합니다 <xref:System.Windows.Forms.LinkClickedEventArgs> 에 대 한 이벤트 처리기를 제공 하는 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 이벤트 링크를 처리 하기 위해 컨트롤에서 클릭 한 링크를 결정할 수 있도록 데이터를 제공 합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기가 포함 된 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 이벤트입니다. 문서 내 링크 클릭을 처리 하는 이벤트 처리기를 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 기본 브라우저의 인스턴스를 시작 (사용 하 여를 <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> 메서드)를 클릭 된 링크에 대 한 페이지를 표시 합니다. 이 예제에서는 이벤트 처리기에 연결 되어 있는지 필요 합니다 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 에 대 한 이벤트를 <xref:System.Windows.Forms.RichTextBox>입니다.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤을 두 번 클릭하면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌어서 놓기 작업을 완료하면 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 안으로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.DragEnter> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.DragEnter> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 범위 밖으로 개체를 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다. 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개체를 컨트롤의 범위 위로 끌 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다. 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap"><see cref="T:System.Drawing.Bitmap" /></param>
        <param name="targetBounds"><see cref="T:System.Drawing.Rectangle" /></param>
        <summary>이 메서드는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>텍스트, 그림 및 기타 데이터에서 끌어서 놓기 작업을 사용할 수 있게 하는 값을 가져오거나 설정합니다.</summary>
        <value>끌어서 놓기 작업을 사용하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" />의 내용에서 텍스트를 검색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자가 발견된 컨트롤 내의 위치이거나, 검색 문자를 찾지 못했거나 <paramref name="char" /> 매개 변수에 빈 검색 문자 집합을 지정한 경우에는 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문자에 지정 된 문자 목록에서 첫 번째 인스턴스에 대 한 검색 메서드는 `characterSet` 매개 변수 문자의 위치를 반환 합니다. 예를 들어, 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤에 텍스트 "The 빠른 Brown Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 4의 값을 반환 합니다. 대문자 및 소문자 검색에 다른 값으로 간주 됩니다.  
  
 속성을 음수 값을 반환 하는 경우 검색할 문자 된 컨트롤의 내용을 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하려면 문자 컨트롤에 포함 된 전체 문서를 검색 합니다. 경우 메서드의에 제공 된 문자 목록의 문자가 `characterSet` 매개 변수가 발견 되는이 메서드에서 반환 되는 값 컨트롤에 문자 위치의 인덱스입니다. 공백 문자의 위치를 결정할 때 메서드에서 문자로 간주 됩니다.  
  
   
  
## Examples  
 콘텐츠를 검색 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 메서드에 전달 되는 문자는 `text` 매개 변수입니다. 경우 내용의 합니다 `text` 배열에 포함 됩니다는 <xref:System.Windows.Forms.RichTextBox>이 고 그렇지 않으면 값의 인덱스를 반환 하는 메서드,-1을 반환 합니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 및 <xref:System.Windows.Forms.Button> 라는 컨트롤 `button1`가 연결할는 `Click` 에 정의 된 이벤트 처리기 예입니다.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자열을 검색합니다.</summary>
        <returns>검색 텍스트가 발견된 컨트롤 내의 위치이거나, 검색 문자열을 찾지 못했거나 <paramref name="str" /> 매개 변수에 빈 검색 문자열을 지정한 경우에는 -1입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색에 지정 된 텍스트를 `str` 매개 변수 컨트롤 내에서 첫 번째 문자의 위치를 반환 합니다. 음수 값을 반환 하는 속성을 검색할 텍스트 문자열을 컨트롤의 내용을 발견 되지 않았습니다. 컨트롤의 사용자에 게 제공할 수 있는 검색 기능을 만들려면이 메서드를 사용할 수 있습니다. 또한 특정 형식으로 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어, 사용자 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜에 대 한 검색 하 고 사용 하기 전에 적절 한 형식으로 대체 하는 메서드를 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 허용 하는 메서드를 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 되는 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 음수 값을 반환 하는 이러한 검색을 수행 (1).  
  
   
  
## Examples  
 전체 내용을 검색 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 문자열에 있으면 합니다 <xref:System.Windows.Forms.RichTextBox>의 값을 반환 하는 메서드 `true` 그렇지 않으면 반환 된 검색 텍스트를 강조 표시 `false`합니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 시작 지점부터 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색에 지정 된 문자 목록의 문자가 처음 나오는 `characterSet` 매개 변수 문자 위치를 반환 합니다. 예를 들어, 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤에 텍스트 "The 빠른 Brown Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 4의 값을 반환 합니다. 대문자 및 소문자 검색에 다른 값으로 간주 됩니다.  
  
 속성을 음수 값을 반환 하는 경우 검색할 문자 된 컨트롤의 내용을 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 경우 메서드의에 제공 된 문자 목록의 문자가 `characterSet` 매개 변수가 발견 되는이 메서드에서 반환 되는 값 컨트롤에 문자 위치의 인덱스입니다. 공백 문자의 위치를 결정할 때 메서드에서 문자로 간주 됩니다.  
  
 이 버전의를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하면 문자에 대 한 값을 지정 하 여 컨트롤의 텍스트 내에서 지정 된 시작 위치에서 집합을 검색 하는 `start` 매개 변수입니다. 0 값 검색 컨트롤의 문서 시작 부분에서 시작 해야 함을 나타냅니다. 이 버전을 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 이미 알고 있는 텍스트를 방지 하려면 검색 범위를 좁히려면 메서드 검색할 또는 검색에 중요 하지 않은 지정 된 문자가 없습니다.  
  
   
  
## Examples  
 콘텐츠를 검색 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 메서드에 전달 되는 문자는 `text` 매개 변수입니다. 내의 위치에서 검색이 시작 되는 <xref:System.Windows.Forms.RichTextBox> 에 지정 된를 `start` 의 매개 변수를 `FindMyText` 메서드. 텍스트 배열 콘텐츠가 있는 경우는 <xref:System.Windows.Forms.RichTextBox>이 고 그렇지 않으면 값의 인덱스를 반환 하는 메서드,-1을 반환 합니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 와 <xref:System.Windows.Forms.Button> 라는 컨트롤 `button1` 에 연결 된는 <xref:System.Windows.Forms.Control.Click> 에 정의 된 이벤트 처리기를 예입니다.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="options"><see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary>검색에 특정 옵션을 적용하여 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색에 지정 된 텍스트를 `str` 매개 변수 컨트롤 내에서 첫 번째 문자의 위치를 반환 합니다. 음수 값을 반환 하는 속성을 검색할 텍스트 문자열을 컨트롤의 내용을 발견 되지 않았습니다. 컨트롤의 사용자에 게 제공할 수 있는 검색 기능을 만들려면이 메서드를 사용할 수 있습니다. 또한 특정 형식으로 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어, 사용자 컨트롤에 날짜를 입력 하는 경우 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜에 대 한 검색 하 고 사용 하기 전에 적절 한 형식으로 대체 하는 메서드를 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하 고 검색 범위를 좁힐 수 있는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자를 일치 또는 부분 단어 대신 전체 단어를 검색할 수 있도록 하는 옵션을 지정할 수 있습니다. 지정 하 여 합니다 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래 에서부터 텍스트를 아래쪽 검색 방법 기본 맨 위 대신 맨 위로 이동에 대 한 검색할 수 있습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 허용 하는 메서드를 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 되는 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 음수 값을 반환 하는 이러한 검색을 수행 (1).  
  
   
  
## Examples  
 전체 내용을 검색 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 문자열에 있으면 합니다 <xref:System.Windows.Forms.RichTextBox>의 값을 반환 하는 메서드 `true` ; 텍스트를 강조 표시를 반환 합니다 `false`합니다. 또한이 예제에서는 지정 된 검색 문자열의 대/소문자 구분 검색의 옵션을 지정 합니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">검색할 문자 배열입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="end">컨트롤의 텍스트에서 검색이 끝날 위치입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트 범위에서 문자 목록의 문자가 처음 나오는 경우를 검색합니다.</summary>
        <returns>검색 문자를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문자에 지정 된 문자 목록에서 첫 번째 인스턴스에 대 한 검색 메서드는 `characterSet` 매개 변수 문자의 위치를 반환 합니다. 예를 들어, 'Q' 문자를 포함 하는 문자 배열을 전달 합니다. 컨트롤에 텍스트 "The 빠른 Brown Fox"를 포함 하는 경우는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 4의 값을 반환 합니다. 대문자 및 소문자 검색에 다른 값으로 간주 됩니다.  
  
 속성을 음수 값을 반환 하는 경우 검색할 문자 된 컨트롤의 내용을 찾을 수 없습니다. 컨트롤 내에서 문자 그룹을 검색 하려면이 메서드를 사용할 수 있습니다. 경우 메서드의에 제공 된 문자 목록의 문자가 `characterSet` 매개 변수가 발견 되는이 메서드에서 반환 되는 값 0부터 시작 하는 컨트롤에 문자 위치의 인덱스입니다. 공백 문자의 위치를 결정할 때 메서드에서 문자로 간주 됩니다.  
  
 이 버전의를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 사용 하면 문자에 대 한 값을 지정 하 여 컨트롤의 텍스트 범위에서 집합을 검색 하는 `start` 및 `end` 매개 변수입니다. 0에 대 한 값을 `start` 매개 변수는 컨트롤의 문서 시작 부분에서 검색이 시작 해야 함을 나타냅니다. -1 값은 `end` 매개 변수 지정 검색 컨트롤 내에서 텍스트의 끝에서 끝납니다. 이 버전을 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 응용 프로그램의 요구에 맞게 중요 하지 않은 문서의 영역 검색을 방지 하려면 컨트롤 내에서 텍스트의 특정 범위로 검색 범위를 좁히려면 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="characterSet" />가 null입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="start" />가 0보다 작거나 컨트롤의 텍스트 길이보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="options"><see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 옵션을 적용하여 컨트롤 내의 특정 위치에 있는 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색에 지정 된 텍스트를 `str` 매개 변수 및 반환 컨트롤 내에서 문자열 검색의 첫 번째 문자의 위치입니다. 음수 값을 반환 하는 속성을 검색할 텍스트 문자열을 컨트롤의 내용을 발견 되지 않았습니다. 컨트롤의 사용자에 게 제공할 수 있는 검색 기능을 만들려면이 메서드를 사용할 수 있습니다. 또한 특정 형식으로 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어, 사용자 컨트롤에 날짜를 입력 하는 경우 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜에 대 한 검색 하 고 사용 하기 전에 적절 한 형식으로 대체 하는 메서드를 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하 고 검색 범위를 좁힐 수 있는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자를 일치 또는 부분 단어 대신 전체 단어를 검색할 수 있도록 하는 옵션을 지정할 수 있습니다. 지정 하 여 합니다 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래 에서부터 텍스트를 아래쪽 검색 방법 기본 맨 위 대신 맨 위로 이동에 대 한 검색할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 또한 컨트롤의 텍스트 내에서 특정 시작 위치를 선택 하 여 텍스트에 대 한 검색 범위를 좁힐 수 있습니다. 이 기능은 텍스트는 수에 대 한 이미 검색이 또는 특정 텍스트를 검색 하는 없는 것으로 알려져 있는 발생 하지 않도록 설정할 수 있습니다. 경우는 `RichTextBoxFinds.Reverse` 에 값이 지정 합니다 `options` 매개 변수, 값을 `start` 매개 변수 검색은 문서의 맨 아래에 시작 하므로이 버전의를 사용 하는 경우 역방향 검색 종료 있는 위치를 나타냅니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 허용 하는 메서드를 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 되는 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 음수 값을 반환 하는 이러한 검색을 수행 (1).  
  
   
  
## Examples  
 전체 내용을 검색 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 메서드의 텍스트 매개 변수에 전달 된 첫 번째 인스턴스의 검색 문자열입니다. 검색 시작 위치는 메서드의 시작 매개 변수에 의해 지정 됩니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>, 그렇지 않으면-1 값을 반환 합니다; 메서드는 검색된 된 텍스트의 첫 번째 문자의 인덱스 위치를 반환 하 고 찾은 텍스트를 강조 표시 합니다. 또한이 예제에서는 지정 된 검색 문자열의 대/소문자 구분 검색의 옵션을 지정 합니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 `richTextBox1`합니다. 이 예제에서는 "다음 찾기" 형식의 작업 하는 데 사용할 수 있습니다. 검색 텍스트의 인스턴스를 찾은 값을 변경 하 여 텍스트의 다른 인스턴스를 찾을 수 있습니다는 `start` 매개 변수를 현재 일치 항목의 위치 이외의 위치에서 검색 합니다.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">컨트롤에서 찾을 텍스트입니다.</param>
        <param name="start">컨트롤의 텍스트에서 검색을 시작할 위치입니다.</param>
        <param name="end">컨트롤의 텍스트에서 검색이 끝날 위치입니다. 이 값은 음수 1(-1)과 같거나 <paramref name="start" /> 매개 변수보다 크거나 같아야 합니다.</param>
        <param name="options"><see cref="T:System.Windows.Forms.RichTextBoxFinds" /> 값의 비트 조합입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트에서 특정 옵션을 적용하여 컨트롤의 텍스트 범위 내에 있는 문자열을 검색합니다.</summary>
        <returns>검색 텍스트를 찾은 컨트롤 내의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 검색에 지정 된 텍스트를 `str` 매개 변수 및 반환 컨트롤 내에서 문자열 검색의 첫 번째 문자의 위치입니다. 음수 값을 반환 하는 속성을 검색할 텍스트 문자열을 컨트롤의 내용을 발견 되지 않았습니다. 컨트롤의 사용자에 게 제공할 수 있는 검색 기능을 만들려면이 메서드를 사용할 수 있습니다. 또한 특정 형식으로 바꿀 텍스트를 검색 하려면이 메서드를 사용할 수 있습니다. 예를 들어, 사용자 컨트롤에 날짜를 입력 하는 경우 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 문서에서 모든 날짜에 대 한 검색 하 고 사용 하기 전에 적절 한 형식으로 대체 하는 메서드를 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 컨트롤의 메서드.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드를 확장 하 고 검색 범위를 좁힐 수 있는 옵션을 지정할 수 있습니다. 검색 단어의 대/소문자를 일치 또는 부분 단어 대신 전체 단어를 검색할 수 있도록 하는 옵션을 지정할 수 있습니다. 지정 하 여 합니다 `RichTextBoxFinds.Reverse` 열거형에는 `options` 매개 변수를 문서의 맨 아래 에서부터 텍스트를 아래쪽 검색 방법 기본 맨 위 대신 맨 위로 이동에 대 한 검색할 수 있습니다. 이 버전의는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 메서드 또한 컨트롤의 텍스트 내에서 특정 시작 및 끝 위치를 선택 하 여 텍스트에 대 한 검색 범위를 좁힐 수 있습니다. 이 기능은 컨트롤의 텍스트의 특정 섹션에 검색 범위를 제한할 수를 설정할 수 있습니다. 음수 값에 할당 된 (1) 경우는 `end` 메서드는 텍스트의 끝까지 검색 매개 변수는 <xref:System.Windows.Forms.RichTextBox> 일반 검색에 대 한 합니다. 역방향 검색의 경우 값이 음수 1 (-1)에 할당 합니다 `end` 매개 변수를 위치로 정의한 텍스트 (아래쪽) 텍스트의 끝에서 검색할 수는 나타냅니다 `start` 매개 변수입니다. 경우는 `start` 및 `end` 전체 컨트롤 같은 값을 검색 하는 일반 검색 매개 변수가 제공 됩니다. 역방향 검색을 위한 전체 컨트롤을 검색 하지만 검색 문서의 맨 아래에서 시작 하 고 검색 문서의 맨 위로 이동 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.Find%2A> 허용 하는 메서드를 `string` 매개 변수 텍스트 내에서 둘 이상의 줄에 포함 되는 텍스트를 찾을 수 없습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. 음수 값을 반환 하는 이러한 검색을 수행 (1).  
  
   
  
## Examples  
 다음 코드 예제에서는 검색 텍스트의 섹션을 <xref:System.Windows.Forms.RichTextBox> 에 전달 된 첫 번째 인스턴스의 검색 문자열에 대 한는 `searchText` 메서드의 매개 변수입니다. 컨트롤 내의 텍스트에서 지정 된 검색 범위를 `searchStart` 고 `searchEnd` 메서드의 매개 변수입니다. 검색 문자열에 있으면는 <xref:System.Windows.Forms.RichTextBox>, 그렇지 않으면-1 값을 반환 합니다; 메서드는 검색된 된 텍스트의 첫 번째 문자의 인덱스 위치를 반환 하 고 찾은 텍스트를 강조 표시 합니다. 또한이 예제에서는 합니다 `options` 의 매개 변수는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 찾은 텍스트를 검색 문자열의 대/소문자와 일치 해야 함을 지정 하는 방법입니다. 예제는이 메서드가 있어야의 클래스에는 <xref:System.Windows.Forms.Form> 를 포함 하는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다. 첫 번째 후 검색 문자열의 인스턴스 발견 되었습니다, 텍스트의 다른 인스턴스를 찾으려면이 예제를 사용할 수 있습니다.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 매개 변수가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="start" /> 매개 변수가 0보다 작은 경우

또는 
<paramref name="end" /> 매개 변수가 <paramref name="start" /> 매개 변수보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 표시되는 텍스트의 글꼴을 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시되는 텍스트에 적용되는 <see cref="T:System.Drawing.Font" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultFont" /> 속성 값입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 전경색을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 전경색을 나타내는 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetCharFromPosition : System.Drawing.Point -&gt; char" Usage="richTextBox.GetCharFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="pt">검색할 위치입니다.</param>
        <summary>지정된 위치에 가장 가까운 문자를 검색합니다.</summary>
        <returns>지정된 위치의 문자입니다.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">검색할 위치입니다.</param>
        <summary>지정된 위치에 가장 가까운 문자의 인덱스를 검색합니다.</summary>
        <returns>지정된 위치의 0부터 시작하는 문자 인덱스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 지정 된 위치에 가장 가까운 문자 인덱스를 반환 하는이 메서드는 `pt` 매개 변수입니다. 문자 인덱스에는 공백을 포함 하 여 컨트롤에서 텍스트의 0부터 시작 인덱스가입니다. 텍스트에 사용자가 있는 마우스 좌표가 메서드에 전달 하 여 마우스를 확인 하려면이 메서드를 사용할 수 있습니다. 이 컨트롤의 텍스트에 단어 위에 마우스 포인터를 놓을 때 작업을 수행 하려는 경우에 유용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> 메서드를 <xref:System.Windows.Forms.RichTextBox.Find%2A> 내에서 특정 문자열을 검색 하는 방법을 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 문자열 내에 문자 인덱스를 표시를 <xref:System.Windows.Forms.RichTextBox> 컨트롤입니다. 이 예제에서는 컨트롤의 내용을 "brown" 라는 단어를 검색 하 고 검색 문자열이 발견 되는 문자 인덱스 위치를 반환 합니다. 이 예제에서는 있어야 포함 된 폼을 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 텍스트를 포함 하는 합니다. 또한 예제에서 코드에 연결 되어 있어야 합니다 <xref:System.Windows.Forms.Control.MouseDown> 의 이벤트는 <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">검색할 문자 인덱스 위치입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트 내에서 지정된 문자 위치의 줄 번호를 검색합니다.</summary>
        <returns>문자 인덱스가 있는 0부터 시작하는 줄 번호입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면에 지정 된 문자 인덱스를 기준으로 줄 번호를 확인 하는 `index` 메서드의 매개 변수입니다. 컨트롤의 텍스트의 첫 번째 줄 값 0을 반환합니다. <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드는 인덱싱된 문자가 위치한 컨트롤 내에서 실제 줄 번호를 반환 합니다. 예를 들어, 첫 번째 논리 줄의 텍스트 부분 컨트롤 줄 바꿈 다음 줄으로 된 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드는 지정된 된 문자 인덱스에 있는 문자가 두 번째 회선을 래핑하면 경우 1을 반환 합니다. 경우 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 로 설정 된 `false`, 없습니다 부분 줄 다음를 래핑하고 메서드를 지정된 된 문자 인덱스에 대 한 0을 반환 합니다. 내에 줄 특정 문자 인덱스를 확인 하려면이 메서드를 사용할 수 있습니다. 예를 들어, 호출 후의 <xref:System.Windows.Forms.RichTextBox.Find%2A> 텍스트를 검색 하는 방법 검색 결과 발견에 문자 인덱스를 가져올 수 있습니다. 반환 된 문자 인덱스를 사용 하 여이 메서드를 호출할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Find%2A> 단어 줄을 확인할 메서드를 찾을 수 있습니다.  
  
 경우도 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 예외를 throw 하지 않습니다 경우는 `index` 매개 변수는 값이 잘못 되었습니다. 예:  
  
-   경우는 `index` 매개 변수가 <xref:System.Int32.MinValue> 또는-1 이면 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 0을 반환 합니다.  
  
-   경우는 `index` 매개 변수는 텍스트 길이 또는 <xref:System.Int32.MaxValue>, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 필요가 없는 동일한 텍스트의 마지막 줄의 수를 반환으로 `Lines.Length-1`의 값에 따라는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 속성입니다.  
  
 이러한 경우에 호출 하기 전에 입력의 유효성을 검사 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>합니다.  
  
> [!NOTE]
>  문자 인덱스에 지정 된 경우는 `index` 매개 변수가 사용 가능한 컨트롤 내에 포함 된 줄 수를 초과 된 경우 마지막 줄 번호 반환 됩니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> 메서드. 예제를 실행 하려면 다음 코드를 포함 하는 폼의 붙여를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `RichTextBox1`, 이라는 단추가 `Button1` 및 이라는 두 개의 텍스트 상자 `TextBox1` 및 `TextBox2`합니다. 예제를 실행 하는 경우에 검색 문자열 입력 `TextBox2` 검색 결과를 얻으려면 단추를 클릭 합니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">위치를 검색할 문자의 인덱스입니다.</param>
        <summary>컨트롤 내에서 지정된 문자 인덱스의 위치를 검색합니다.</summary>
        <returns>지정된 문자의 위치입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하면 컨트롤에서 특정 문자의 인덱스를 위치한 확인할 수 있습니다. 컨트롤의 단어에 대 한 바로 가기 메뉴 항목 또는 도움말 정보를 표시 하는 등의 작업에 대 한이 메서드를 사용할 수 있습니다. 예를 들어, 사용자 컨트롤의 단어를 마우스 오른쪽 단추로 클릭할 때 사용자에 게 옵션 메뉴를 표시 하려는 경우 사용할 수이 메서드를 올바르게 표시할 단어의 위치를 확인 하는 <xref:System.Windows.Forms.ContextMenu> 제어 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>끌기 작업을 수행하는 동안 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 가로 스크롤 막대를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.HScroll> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.HScroll> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>한글 버전의 Windows 운영 체제에서 입력 방법을 전환할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.ImeChange> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.ImeChange> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>IME(입력기) 및 한국어 지원을 위한 <see cref="T:System.Windows.Forms.RichTextBox" /> 설정을 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" /> 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트 내에 있는 링크를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤 내에서 클릭 된 링크를 처리 하는 데이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다. 이벤트 처리기에 제공 된 정보를 사용 하는 문서에서 클릭 한 링크를 확인할 수 있습니다.  
  
> [!IMPORTANT]
>  기본적으로 링크 텍스트로 표시 되 고은 클릭 가능 하지 않습니다. 클릭할 수 있는 집합을 <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> 속성을 `true`입니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에 대 한 이벤트 처리기가 포함 된 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 이벤트입니다. 문서 내 링크 클릭을 처리 하는 이벤트 처리기를 <xref:System.Windows.Forms.RichTextBox> 제어 하 고 기본 브라우저의 인스턴스를 시작 (사용 하 여를 <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> 메서드)를 클릭 된 링크에 대 한 페이지를 표시 합니다. 이 예제에서는 이벤트 처리기에 연결 되어 있는지 필요 합니다 <xref:System.Windows.Forms.RichTextBox.LinkClicked> 에 대 한 이벤트를 <xref:System.Windows.Forms.RichTextBox>입니다.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>파일의 내용을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">컨트롤로 로드할 파일의 이름 및 위치입니다.</param>
        <summary>RTF(서식 있는 텍스트 형식) 또는 표준 ASCII 텍스트 파일을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일을 로드 하는 경우는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 로드 되는 파일의 내용을 대체의 전체 내용을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값을 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작에 대 한 컨트롤에는 이전에 만든된 텍스트 또는 RTF 문서를 로드 하려면이 메서드를 사용할 수 있습니다. 파일을 저장 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드.  
  
> [!NOTE]
>  이 버전의 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드 로드 되는 파일이 RTF 문서가 없는 경우 예외가 발생 합니다. 다른 유형의 ASCII 텍스트 파일과 같은 파일을 로드 하려면에서 값을 허용 하는이 메서드의 다른 버전을 사용 합니다 <xref:System.Windows.Forms.RichTextBoxStreamType> 열거형을 매개 변수로 합니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 호출 하기 전에 컨트롤의 핸들이 만들어졌는지 확인 합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제에 RTF 파일을 엽니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.OpenFileDialog> 사용자 로부터 파일을 요청할 수 있는 대화 상자를 표시 하는 클래스입니다. 다음 코드를 RTF는 가정 하 고 파일 로드 파일을 문서화 합니다. 파일이 없으면 예제 코드에서는 예외가 throw 됩니다. 이 예제에서이 코드가 필요는 <xref:System.Windows.Forms.Form> 가 있는 클래스를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">으로 파일을 엽니다. 연결 된 열거형: 합니다 <see langword="Read" /> 의 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data"><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드할 데이터 스트림입니다.</param>
        <param name="fileType"><see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>기존 데이터 스트림의 내용을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전을 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 로드 하는 방법의 <xref:System.Windows.Forms.RichTextBox> 데이터의 기존 스트림에서 데이터를 사용 하 여 합니다. 컨트롤에 로드 되는 데이터의 전체 내용을 대체 합니다 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값을 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작에 대 한 컨트롤에 데이터 스트림으로 이전에 열려 있는 파일을 로드 하려면이 메서드를 사용할 수 있습니다. 컨트롤의 내용을 스트림으로 다시 저장 하려는 경우 사용할 수 있습니다 합니다 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 허용 하는 메서드를 <xref:System.IO.Stream> 개체를 매개 변수로 합니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드 또한 컨트롤에 로드 되는 데이터의 형식을 지정할 수 있습니다. 이 기능을 사용 하면 컨트롤에 RTF (서식) 문서 서식 있는 텍스트 이외의 데이터를 포함 하는 데이터 스트림을 사용할 수 있습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 호출 하기 전에 컨트롤의 핸들이 만들어졌는지 확인 합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 및 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 스트림과 메서드. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>를 <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> 멤버입니다.  
  
 이 프로젝트에 복사할 때 실행할 준비가 되는 전체 예제입니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">컨트롤로 로드할 파일의 이름 및 위치입니다.</param>
        <param name="fileType"><see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary>특정 형식의 파일을 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤로 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파일을 로드 하는 경우는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드를 로드 되는 파일의 내용을 대체의 전체 내용을 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이렇게 하면 값을 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 및 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성을 변경 합니다. 조작에 대 한 컨트롤에는 이전에 만든된 텍스트 또는 서식 있는 텍스트 RTF (서식) 문서를 로드 하려면이 메서드를 사용할 수 있습니다. 파일을 저장 하려는 경우 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드.  
  
 이 버전을 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 로드 되는 파일의 파일 형식을 지정 하는 방법입니다. 이 기능을 사용 하면 컨트롤에 RTF 문서 이외의 파일을 로드할 수 있습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드는 파일을 열에 대 한 핸들을 만들 때까지 <xref:System.Windows.Forms.RichTextBox>합니다. 호출 하기 전에 컨트롤의 핸들이 만들어졌는지 확인 합니다 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 메서드.  
  
   
  
## Examples  
 다음 코드 예제는 텍스트 파일을 엽니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 사용은 <xref:System.Windows.Forms.OpenFileDialog> 사용자 로부터 파일을 요청할 수 있는 대화 상자를 표시 하는 클래스입니다. 코드는 다음에 해당 파일을 로드 합니다 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는이 버전의 사용을 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 표준 서식 있는 텍스트 형식 대신 ASCII 텍스트 파일로 파일을 열 수를 지정 하는 방법입니다. 이 예제에서이 코드가 필요는 <xref:System.Windows.Forms.Form> 가 있는 클래스를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤에 파일을 로드하는 동안 오류가 발생한 경우</exception>
        <exception cref="T:System.ArgumentException">로드되는 파일이 RTF 문서가 아닌 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">으로 파일을 엽니다. 연결 된 열거형: 합니다 <see langword="Read" /> 의 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RichTextBox 컨트롤에 입력하거나 붙여넣을 수 있는 최대 문자 수를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 입력할 수 있는 문자 수입니다. 기본값은 <see cref="F:System.Int32.MaxValue" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 0으로 설정 된 컨트롤에 입력할 수 있는 텍스트의 최대 길이 문자의 64KB입니다. 이 속성은 일반적으로 사용 하는 경우는 <xref:System.Windows.Forms.RichTextBox> 서식 있는 텍스트 RTF (서식) 텍스트 한 줄을 표시 하는 데 사용 됩니다. 우편 번호 및 전화 번호와 같은 값에 대 한 컨트롤에 입력 된 텍스트의 길이를 제한 하거나 데이터를 데이터베이스에 입력 해야 할 때 입력 한 텍스트의 길이 제한 하려면이 속성을 사용할 수 있습니다. 데이터베이스의 해당 필드의 최대 길이를 컨트롤에 입력 한 텍스트를 제한할 수 있습니다.  
  
> [!NOTE]
>  코드에서 값을 설정할 수 있습니다 합니다 <xref:System.Windows.Forms.TextBoxBase.Text%2A> 길이가 지정 된 값 보다 큰 값으로 속성을 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 속성입니다. 이 속성은 런타임 시 컨트롤에 입력 한 텍스트를만 영향을 줍니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> 텍스트에 할당 되는 경우를 결정 하는 속성을 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 할당 된 값 보다 큽니다.는 <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> 속성. 예제에서는 텍스트를 더 큰 없는 경우는 <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> 속성을 컨트롤에 텍스트를 할당 합니다. 이 예제에서는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다 및 예제에서 메서드는 컨트롤에 붙여 넣을 수 있는 매개 변수를 제공 하는 텍스트를 사용 하 여 호출 되는 합니다. 예제에는 항목을 필요 합니다 <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> 속성이 텍스트 항목으로 제한 하려면 값으로 설정 되어를 <xref:System.Windows.Forms.RichTextBox>입니다.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">속성에 할당된 값이 0보다 작은 경우</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 컨트롤이 여러 줄을 입력할 수 있는 <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤인지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 컨트롤이 여러 줄을 입력할 수 있는 <see cref="T:System.Windows.Forms.RichTextBox" />이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.HScroll" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.ImeChange" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Forms.LinkClickedEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.Protected" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected override void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 개체입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="richTextBox.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터가 들어 있는 개체입니다.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.VScroll" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트가 발생하면 대리자를 통해 이벤트 처리기가 호출됩니다. 자세한 내용은 [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
 또한 <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> 메서드를 사용하면 파생 클래스가 대리자를 연결하지 않고도 이벤트를 처리할 수 있습니다. 이는 파생 클래스에서 이벤트를 처리하는 기본 방법입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 클래스에서 <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />를 재정의하는 경우 등록된 대리자가 이벤트를 받도록 기본 클래스의 <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> 메서드를 호출해야 합니다.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">클립보드에서 가져오는 데이터의 클립보드 형식입니다.</param>
        <summary>클립보드의 내용을 지정된 클립보드 형식으로 붙여넣습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에 클립보드에서 데이터를 붙여이 메서드를 사용할 수 있습니다. 이 버전의 합니다 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드는 다른는 <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> 메서드를 사용 하면 지정된 된 클립보드 형식에만 텍스트를 붙여 합니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> 클립보드 내의 데이터는 지정 된 클립보드 형식 인지 여부를 결정 하는 방법입니다. 이 버전의를 호출할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 적절 한 데이터 형식을 사용 하 여 붙여넣기 작업은 수 있도록 하는 방법입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 비트맵을 붙여 메서드는 <xref:System.Windows.Forms.RichTextBox> 컨트롤. 비트맵 파일에서을 연 후이 예제에서는 사용 된 <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> 비트맵 Windows 클립보드에 복사 하는 방법. 예제에 대 한 형식을 검색 하는 마지막으로 <xref:System.Drawing.Bitmap> 개체, 형식에 붙여넣을 수 있는지 확인 합니다 <xref:System.Windows.Forms.RichTextBox> 컨트롤을 사용 하 여를 <xref:System.Windows.Forms.RichTextBox.Paste%2A> 메서드 데이터를 붙여넣을.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">클립보드에서 읽기. 연관 된 열거형: 합니다 <see langword="AllClipboard" /> 의 값 <see cref="T:System.Security.Permissions.UIPermissionClipboard" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="m">처리할 창 메시지를 나타내며 참조에 의해 전달되는 <see cref="T:System.Windows.Forms.Message" />입니다.</param>
        <param name="keyData">처리할 키를 나타내는 <see cref="T:System.Windows.Forms.Keys" /> 값 중 하나입니다.</param>
        <summary>명령 키를 처리합니다.</summary>
        <returns>컨트롤이 문자를 처리하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 보호된 텍스트를 수정하려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 컨트롤에서 protected로 표시 된 텍스트를 수정 하려고 하는 시기를 결정 하는 응용 프로그램에서이 이벤트에 대 한 이벤트 처리기를 만들 수 있습니다. 이벤트 처리기는 보호 된 텍스트를 수정 하려고 하는 사용자에 게 알립니다. 또는 사용자가 텍스트에 대 한 적절 한 변경할 수 있는 대화 상자를 표시 하려면 사용할 수 있습니다. 예를 들어 날짜 보호 영역을 사용 하는 경우 사용자가 다음 컨트롤의 텍스트에 적용할 수 있는 날짜를 선택할 수 있도록 대화 상자를 표시할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 이벤트는 이 클래스와 관련이 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>컨트롤에서 실행 취소한 마지막 작업을 다시 적용합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 컨트롤에 마지막으로 실행 취소 작업을 다시 적용 하는 방법입니다. <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 메서드를 사용 하면 사용자가 실행 취소 한 마지막 작업 컨트롤에 다시 적용할 수 있는지 여부를 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 텍스트의 삭제를 제외한 모든 작업을 다시 실행 작업을 제한 하려면 메서드를 합니다. 이 예제에서는 포함 된 폼이 있어야를 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업을 <xref:System.Windows.Forms.RichTextBox> 수행 되어이 예제의 코드를 호출 하기 전에 실행 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 메서드를 호출할 때 컨트롤에 다시 적용할 수 있는 동작의 이름을 가져옵니다.</summary>
        <value><see cref="M:System.Windows.Forms.RichTextBox.Redo" /> 메서드를 호출할 때 수행되는 동작의 이름을 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 빈 문자열을 반환 하는 경우 (""), 작업이 없는 컨트롤에 적용할 사용할 수 있습니다. 마지막 작업 실행 취소를 확인 하려면이 메서드를 사용할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 다시 호출 하 여 컨트롤에 적용할 수 있는 컨트롤을 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 메서드 구성 됩니다. 모든 작업을 사용 하 여 컨트롤에 적용할 수 있는지 여부를 확인할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> 및 <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> 속성 및 <xref:System.Windows.Forms.RichTextBox.Redo%2A> 텍스트의 삭제를 제외한 모든 작업을 다시 실행 작업을 제한 하려면 메서드를 합니다. 이 예제에서는 포함 된 폼이 있어야를 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 내에서 작업을 <xref:System.Windows.Forms.RichTextBox> 수행 되어이 예제의 코드를 호출 하기 전에 실행 취소 합니다.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성은 이 클래스와 관련이 없습니다.</summary>
        <value>바로 가기 키를 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 이 클래스와 관련이 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤 내에서 한 줄의 텍스트 크기를 가져오거나 설정합니다.</summary>
        <value>컨트롤 내에 있는 한 줄의 텍스트 크기(픽셀)입니다. 기본값은 0입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 0 보다 큰 값은 컨트롤에 입력 하는 경우 표시 되지 않는 여백은 지정 된 컨트롤의 왼쪽에서 픽셀 수 있는 컨트롤에 배치 됩니다. 이 여백을 벗어나는 입력 텍스트 컨트롤에서 텍스트의 다음 줄에 배치 됩니다. 이 속성에 추가 속성이 설정 된 후에 컨트롤에 입력 텍스트 컨트롤에 현재 입력 된 모든 텍스트를 영향을 줍니다. 에 입력 된 모든 텍스트에 대 한 최대 선 두께 지정 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번에 컨트롤의 클라이언트 영역 오른쪽에 여백을 때 컨트롤의 텍스트에 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자 자체 줄에 표시 되는 위치입니다. 이 세로 표시 위치에 있는 동안 단어의 일부에서 클릭 하면 텍스트를 세로로 표시 되도록 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 있어야 포함 된 폼을 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 값이 0보다 작은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 RTF(서식 있는 텍스트 형식) 코드를 포함하여, <see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 텍스트를 가져오거나 설정합니다.</summary>
        <value>RTF 형식으로 된 컨트롤의 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 표시 하거나 컨트롤의 텍스트에 정의 된 지정 된 RTF 서식을 사용 하 여 컨트롤의 텍스트를 추출 하는 컨트롤에 RTF 형식의 텍스트를이 속성을 사용할 수 있습니다. 이 속성은 Microsoft Word 또는 Windows 워드 패드와 같은 다른 RTF 원본의 RTF 텍스트 컨트롤에 할당 하는 경우에 일반적으로 사용 됩니다.  
  
 변경 하는 경우는 <xref:System.Windows.Forms.Control.RightToLeft%2A> 서식이 없는 원시 텍스트에만 런타임에 속성은 유지 합니다.  
  
 RTF 코드에 대 한 참조는 MSDN library에서 "서식 있는 텍스트 형식 (rtf 서식) 사양, 버전 1.6" http://msdn.microsoft.com/library합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" />의 내용을 파일로 저장합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">저장할 파일의 이름 및 위치입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" />의 내용을 RTF(서식 있는 텍스트 형식) 파일로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 컨트롤의 전체 내용을 Microsoft Word 및 Windows 워드 패드와 같은 다른 프로그램에서 사용할 수 있는 RTF 파일에 저장 합니다. 파일 이름을 지정 하는 경우에 전달 되는 `path` 매개 변수가 이미 지정된 된 디렉터리에서 예 고 없이 파일을 덮어쓰게 됩니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 파일의 내용을 로드 하는 방법의 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
> [!NOTE]
>  컨트롤의 내용을 다른 형식으로 ASCII 텍스트 등의 파일 형식에 저장 하려면 다른 버전의 값을 허용 하는이 메서드를 사용 하 여는 <xref:System.Windows.Forms.RichTextBoxStreamType> 열거형을 매개 변수로 합니다.  
  
   
  
## Examples  
 콘텐츠를 저장 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> RTF 파일을 제어 합니다. 예제에서는 <xref:System.Windows.Forms.SaveFileDialog> 클래스 사용자, 경로 및 파일의 이름에서 요청 하 여 저장 하려면 대화 상자를 표시 합니다. 코드 서식 있는 텍스트 콘텐츠를 가정 하 고 파일을 저장 합니다. 파일이 이미 있으면 자동으로 덮어씁니다. 이 예제에서이 코드가 필요는 <xref:System.Windows.Forms.Form> 가 있는 클래스를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">저장할 파일이 들어 있는 데이터 스트림입니다.</param>
        <param name="fileType"><see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 내용을 열려 있는 데이터 스트림으로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 이미 열려 있는 데이터 스트림에 컨트롤의 전체 콘텐츠를 저장할 수 있습니다. 데이터 스트림 파일에 정보를 저장할 수 있습니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 파일의 내용을 로드 하는 방법의 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 이 버전의 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드 또한 정보를 전송 될 데이터 형식을 지정할 수 있습니다는 <xref:System.IO.Stream> 개체입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 및 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 스트림과 메서드. 사용 하는 방법도 보여 줍니다 합니다 <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>를 <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, 및 <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> 멤버입니다.  
  
 이 프로젝트에 복사할 때 실행할 준비가 되는 전체 예제입니다.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fileType" /> 매개 변수에 지정된 파일 형식이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 만들거나 파일을 수정 합니다. 연결 된 열거형: 합니다 <see langword="Write" /> 의 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">저장할 파일의 이름 및 위치입니다.</param>
        <param name="fileType"><see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> 값 중 하나입니다.</param>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 내용을 특정 형식의 파일로 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 컨트롤의 전체 내용을 Microsoft Word 및 Windows 워드 패드와 같은 다른 프로그램에서 사용할 수 있는 RTF 파일에 저장 합니다. 파일 이름을 지정 하는 경우에 전달 되는 `path` 매개 변수가 이미 지정된 된 디렉터리에서 예 고 없이 파일을 덮어쓰게 됩니다. 사용할 수는 <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> 파일의 내용을 로드 하는 방법의 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 이 버전의는 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 메서드를 사용 하면 컨트롤의 내용을 저장 하는 파일 형식을 지정할 수 있습니다. 컨트롤의 내용에 따라 적절 한 형식으로 파일 저장 되는 확인이 기능을 사용할 수 있습니다. 예를 들어, 문서에 글꼴 스타일 색 지정에 차이가 없는 경우 있습니다 수 다른이름으로 파일 ASCII 텍스트 파일을 설정 하 여 합니다 `fileType` 매개 변수를 `RichTextBoxStreamType.PlainText`입니다.  
  
   
  
## Examples  
 콘텐츠를 저장 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> ASCII 텍스트 파일에 있습니다. 예제에서는 <xref:System.Windows.Forms.SaveFileDialog> 클래스 경로 파일 이름을 사용자 로부터 요청 대화 상자를 표시 합니다. 코드는 컨트롤의 내용을 해당 파일에 저장합니다. 이 예제에서는이 버전의 사용을 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> 표준 서식 있는 텍스트 형식 대신 ASCII 텍스트 파일로 파일을 저장할 수 있는지를 지정 하는 방법입니다. 이 예제에서이 코드가 필요는 <xref:System.Windows.Forms.Form> 가 있는 클래스를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="fileType" /> 매개 변수에 지정된 파일 형식이 잘못된 경우</exception>
        <exception cref="T:System.IO.IOException">컨트롤의 내용을 파일에 저장하는 동안 오류가 발생한 경우</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">페이지를 만들거나 파일을 수정 합니다. 연결 된 열거형: 합니다 <see langword="Write" /> 의 값 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />합니다.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에 표시할 스크롤 막대의 형식을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 값 중 하나입니다. 기본값은 <see langword="RichTextBoxScrollBars.Both" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 사용자에 게 가로 및 세로 스크롤 막대를 제공할 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 컨트롤 외부에 컨트롤의 실제 크기는 컨트롤 내의 텍스트를 스크롤할 수 있도록 합니다. 또한 컨트롤의 내용을 스크롤하여 제한 하려면 컨트롤에서 스크롤 막대를 제거 하려면이 속성을 사용할 수 있습니다.  
  
> [!NOTE]
>  가로 스크롤 막대가 표시 되지 것입니다 경우는 <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> 됩니다 `true`의 값에 관계 없이는 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 값이 <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> 열거형에 정의되지 않은 경우</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 현재 선택된 RTF(서식 있는 텍스트 형식)의 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 선택된 RTF 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 RTF 서식 지정 코드를 포함 하는 컨트롤에서 선택한 텍스트를 가져올 수 있습니다. 서식 및 붙여넣기를 사용 하 여 전체 RTF를 허용 하는 다른 응용 프로그램의 텍스트를 Microsoft Word 및 Windows 워드 패드와 같은 텍스트를 지정 하거나, 컨트롤에서 텍스트를 복사 하려면이 속성을 사용할 수 있습니다. 선택한 텍스트를 RTF 서식 지정 코드 없이 사용 하십시오는 <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> 속성입니다.  
  
 현재 선택 된 텍스트가이 속성에 지정 된 텍스트 삽입 지점에 삽입 됩니다. 텍스트를 선택 하는 경우이 속성에 할당 된 모든 텍스트를 선택한 텍스트를 바꿉니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 내에서 선택된 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에서 선택된 텍스트를 나타내는 문자열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을를 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 에서 글머리 기호 목록을 만들기 위한 속성을를 <xref:System.Windows.Forms.RichTextBox> 컨트롤. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역 또는 삽입 지점에 적용할 맞춤 방식을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 값 중 하나입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컨트롤에서 선택 된 단락이 없는 경우이 속성을 설정할 맞춤 설정을 삽입 지점이 표시 되는 물론 단락 맞춤 속성 설정을 포함 하는 단락 뒤 생성에 대 한 단락에 적용 됩니다. 예를 들어, 경우에 두 단락을 <xref:System.Windows.Forms.RichTextBox> 컨트롤과 삽입점은 두 번째 단락 내에 위치 합니다. 설정한 경우에 <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 속성을 `HorizontalAlignment.Center`, 컨트롤 내에서 삽입 지점에 있는 단락의 가운데에 표시 됩니다. 세 번째 단락 두 번째 단락 뒤 만들어지면 것도 가운데에 정렬 됩니다는 컨트롤의 합니다.  
  
 속성이 설정 된 경우 컨트롤 내에서 선택 되, 선택한 모든 단락을이 속성 설정에 따라 정렬 됩니다. 생성 되는 문서에서 단락에 맞게이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox>합니다. 예를 들어, 가운데 맞춤 될 문서의 모든 단락을 하려는 경우 컨트롤의 모든 단락을 선택 하 수 설정 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 속성을 `HorizontalAlignment.Center`입니다.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> 반환 `SelectionAlignment.Left` 텍스트 선택 영역이 혼합 된 여러 단락을 포함 하는 경우.  
  
   
  
## Examples  
 다음 코드 예제 내에서 텍스트를 정렬 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">지정된 값이 <see cref="T:System.Windows.Forms.HorizontalAlignment" /> 클래스에 정의된 값 중 하나가 아닌 경우</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤에서 텍스트를 선택할 때 표시되는 텍스트 색을 가져오거나 설정합니다.</summary>
        <value>텍스트를 선택했을 때의 텍스트 색을 나타내는 <see cref="T:System.Drawing.Color" />입니다. 기본값은 <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> 속성 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> 가져오거나에서 선택한 텍스트의 색을 설정 하 여 <xref:System.Windows.Forms.RichTextBox>입니다. 현재 선택 된 텍스트가 있는 경우는 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> 캐럿의 현재 위치에 속성이 적용 됩니다. 해당 위치에서 입력 된 문자에 지정 된 <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 선택 영역 또는 삽입 지점에 글머리 기호 스타일이 적용되어 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>현재 선택 영역 또는 삽입 지점에 적용된 글머리 기호 스타일이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 선택한 텍스트가 없는 경우 현재 삽입 지점에 삽입 포인터 후 사용자가 입력 하는 모든 단락 글머리 기호 스타일이 적용 됩니다. 삽입 지점이 이동 될 때까지 또는 빈 글머리 기호 항목에서 Enter 키를 누를 때 컨트롤의 텍스트에 글머리 기호 스타일이 적용 됩니다.  
  
 텍스트 컨트롤 내에서이 속성을 설정 하는 경우를 선택 하는 경우 선택한 텍스트 내에서 모든 단락의 글머리 기호 목록에 있는 글머리 기호 항목으로 변환 됩니다. 글머리 기호 목록에서 만든 문서 내에서 만들려면이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다.  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> 속성을 사용 하면 글머리 기호 및 글머리 기호 항목의 텍스트 사이 적용할 들여쓰기 정도 지정할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> 속성을를 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, 및 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 에서 글머리 기호 목록을 만들기 위한 속성을를 <xref:System.Windows.Forms.RichTextBox> 컨트롤. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1` 폼에 만들어집니다.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 내의 텍스트 선택 영역이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 사용자가 컨트롤 내에서 텍스트 선택을 변경 하는 경우에 대 한 이벤트 처리기를 만들 수 있습니다. 사용자가 응용 프로그램 내에서 작업을 완료 될 때까지 선택한 텍스트를 유지 하려면이 이벤트에 대 한 이벤트 처리기를 사용할 수 있습니다.  
  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.SelectionChanged> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.SelectionChanged> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트가 기준선 위에 위 첨자로 표시되거나 기준선 아래에 아래 첨자로 표시되는지 여부를 가져오거나 설정합니다.</summary>
        <value>문자 오프셋을 지정하는 숫자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값은-2000 및 2000 사이 여야 합니다.  
  
 이 속성은 0으로 설정 하는 경우 텍스트 기준선에 나타납니다. 양수 이면 수는 발생 된 기준선을 초과 텍스트 선택에 사용 되는 픽셀 수를 지정 합니다. 음수 이기이 수 픽셀 수는 아래 첨자 텍스트 선택 지정 합니다. 위 첨자 또는 아래 첨자 텍스트를 지정 하려면이 속성을 사용할 수 있습니다.  
  
 선택한 텍스트가 없는 경우 현재 삽입 지점에 삽입 포인터 후 사용자가 입력 하는 모든 텍스트를 오프셋을 적용 합니다. 문자 오프셋에 삽입점 컨트롤 내에서 다른 섹션으로 이동할 때 또는 다른 값으로 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 수치 연산 식으로 이러한 응용 프로그램에 대 한 첨자 및 아래 첨자 텍스트를 만들려면이 속성을 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 코드 예제에서 위 첨자 및 아래 첨자 텍스트를 지정 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> 속성입니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 값이 -2000보다 작거나 2000보다 큰 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역 또는 삽입 지점의 텍스트 색을 가져오거나 설정합니다.</summary>
        <value>현재의 텍스트 선택 영역이나 삽입 지점 다음에 입력된 텍스트에 적용할 색을 나타내는 <see cref="T:System.Drawing.Color" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 반환 하는 경우 현재 선택한 텍스트에 지정 된 둘 이상의 색 `Color.Empty`합니다. 현재 선택 된 텍스트가 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트를 현재 삽입 지점으로이 속성에 지정 된 텍스트 색이 적용 됩니다. 텍스트 색 설정에 속성을 다른 색 또는 삽입 지점 컨트롤 내에서 다른 섹션으로 이동할 때 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 텍스트 색을 변경 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox>합니다.  
  
 텍스트 컨트롤에서 굵게 표시 된 사용을 <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> 굵게 스타일이 지정 된 새 글꼴을 할당 하는 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제는 <xref:System.Windows.Forms.ColorDialog> 시점 현재 텍스트 선택 영역이 나 현재 삽입 한 후 입력 한 텍스트의 색을 지정 하려면 사용자에 게는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제는 예제에 정의 된 메서드를 추가 하려면를 <xref:System.Windows.Forms.Form> 포함 된 클래스를 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역 또는 삽입 지점의 글꼴을 가져오거나 설정합니다.</summary>
        <value>현재의 텍스트 선택 영역이나 삽입 지점 다음에 입력된 텍스트에 적용할 글꼴을 나타내는 <see cref="T:System.Drawing.Font" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 현재 선택한 텍스트에 지정 된 둘 이상의 글꼴 있으면 `null`합니다. 현재 선택 된 텍스트가 있는 경우이 속성에 지정 된 글꼴 현재 삽입 지점에 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트에 적용 됩니다. 글꼴 설정에는 다른 글꼴 또는 삽입 지점 컨트롤 내에서 다른 섹션으로 이동할 때 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 텍스트의 글꼴 스타일을 변경 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox>합니다. 굵게, 기울임꼴 및 밑줄이 그어진 컨트롤의 텍스트를 만들 수 있습니다. 또한 텍스트와 텍스트에 적용 된 글꼴 크기를 변경할 수 있습니다.  
  
 컨트롤의 텍스트 색을 변경 하려면 사용 된 <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> 속성입니다.  
  
   
  
## Examples  
 텍스트 선택 영역이 나 삽입 지점 내에서 뒤에 입력 한 텍스트에 대 한 설정 현재 글꼴 굵게 스타일을 변경 하는 다음 코드 예제는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 이 예제에서는 코드에서 메서드 내에 포함 되어 있음을 <xref:System.Windows.Forms.Form>합니다. 또한이 예제는 <xref:System.Windows.Forms.RichTextBox>명명 된 `richTextBox1`에 추가 되었습니다는 <xref:System.Windows.Forms.Form>합니다.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택된 단락에 있는 텍스트 첫 줄의 왼쪽 가장자리와 다음 줄의 왼쪽 가장자리 사이의 거리를 가져오거나 설정합니다.</summary>
        <value>현재 텍스트 선택 영역 또는 삽입 지점에 적용된 첫 줄 들여쓰기의 거리(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 된 텍스트가 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트를 삽입 지점이 표시 되는 단락 첫 줄 들여쓰기가 적용 됩니다. 첫 줄 들여쓰기 설정이 컨트롤 내에서 다른 단락으로 삽입 지점을 이동 될 때까지 또는 다른 값으로 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여 단락 첫 줄 들여쓰기를 적용할 수 있습니다.  
  
 선택 된 단락 첫 줄 들여쓰기를 설정 하려면 사용 된 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 첫 줄 들여쓰기를 지정 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택 영역이 시작되는 줄의 들여쓰기 길이(픽셀)를 가져오거나 설정합니다.</summary>
        <value>현재 텍스트 선택 영역 또는 삽입 지점의 왼쪽에 적용된 들여쓰기 거리(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 된 텍스트가 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트를 삽입 지점이 표시 되는 단락 들여쓰기 설정이 적용 됩니다. 들여쓰기 설정에는 컨트롤 내에서 다른 단락으로 삽입 지점을 이동 될 때까지 또는 다른 값으로 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여 문서에 포함 된 단락 들여쓰기를 <xref:System.Windows.Forms.RichTextBox>입니다. 와 함께에서이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> 단락에서 단락 표시를 만들려고 합니다.  
  
 컨트롤의 단락에 대 한 첫 줄 들여쓰기를 만들려면, 사용 된 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 들여쓰기 형식의 텍스트로 지정 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 속성입니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤에서 선택된 문자의 수를 가져오거나 설정합니다.</summary>
        <value>텍스트 상자에서 선택한 문자 수입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 문자가 현재 선택 된 텍스트 상자 컨트롤에서 선택한 텍스트에 대 한 작업을 수행 하기 전에 확인 하려면이 속성을 사용할 수 있습니다. 작업을 단일 문자를 수행 하는 경우 선택 된 문자 (공백 포함)의 총 수를 확인 하려면이 속성을 이용할 수 있습니다는 `for` 루프입니다.  
  
   
  
## Examples  
 다음 코드 예제를 사용 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> 속성 내에서 텍스트를 선택 하는 경우를 확인 하는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 예제에서는 한 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 폼에 추가 되었습니다. 또한이 예제는 `richTextBox1` 컨트롤에서 선택 된 텍스트를 포함 합니다.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 텍스트 선택 영역이 보호되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>현재 선택 영역의 내용을 변경할 수 없으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 된 텍스트가 경우 보호 설정은 삽입 지점이 표시 되는 단락을 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트에 적용 됩니다. 보호 설정을 삽입 지점을 다른 단락 컨트롤 내에서 이동할 때까지 또는 다른 값으로 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 사용자 컨트롤 내의 텍스트 부분을 수정 하지 않도록 하려면이 속성을 사용할 수 있습니다.  
  
 이 속성 설정 된 경우 `true`, <xref:System.Windows.Forms.RichTextBox.Protected> 이벤트는 사용자가 현재 선택한 텍스트를 변경 하려고 할 때 발생 합니다.  
  
> [!NOTE]
>  이 속성은 반환 `true` 컨트롤 내에서 전체 선택 영역이 보호 된 콘텐츠를 포함 하는 경우에 합니다.  
  
   
  
## Examples  
 다음 코드 예제 내에서 보호 된 텍스트를 지정 하는 방법에 설명 합니다 <xref:System.Windows.Forms.RichTextBox> 를 사용 하 여는 <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> 속성입니다. 이 예제에서는 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`를 폼에 추가 되었습니다는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 "RichTextBox." 라는 단어를 포함 하는 추가 텍스트  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 오른쪽 가장자리와 현재 삽입 지점에서 선택되거나 추가된 텍스트의 오른쪽 가장자리 사이의 거리(픽셀)입니다.</summary>
        <value>현재 선택 영역 또는 삽입 지점의 오른쪽에 있는 들여쓰기 공간의 크기(픽셀)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 된 텍스트가 삽입 지점 다음 컨트롤에 입력 된 모든 텍스트를 삽입 지점이 표시 되는 단락 들여쓰기 설정이 적용 됩니다. 들여쓰기 설정에는 컨트롤 내에서 다른 단락으로 삽입 지점을 이동 될 때까지 또는 다른 값으로 속성이 변경 될 때까지 적용 됩니다.  
  
 컨트롤 내에서 텍스트를 선택 하는 경우 선택한 텍스트 및 텍스트 텍스트 선택을 적용이 속성의 값을 갖게 됩니다 후 입력 합니다. 이 속성을 사용 하 여 문서에 포함 된 단락 들여쓰기를 <xref:System.Windows.Forms.RichTextBox>입니다. 와 함께에서이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> 단락에서 단락 표시를 만들려고 합니다.  
  
 컨트롤의 단락에 대 한 첫 줄 들여쓰기를 만들려면, 사용 된 <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> 속성입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 오른쪽 여백에를 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 를 사용 하는 <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> 속성입니다. 예제 있어야 포함 된 폼을 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`, 및 예제 코드는 양식의 클래스 내에서 이벤트에서 호출 되는 합니다.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" /> 컨트롤의 절대 탭 정지 위치를 가져오거나 설정합니다.</summary>
        <value>각 멤버가 탭 오프셋(픽셀)을 지정하는 배열입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 각 탭에서 현재 선택한 텍스트에 대 한 간격을 포함 하는 배열을 가져올 수 있습니다는 <xref:System.Windows.Forms.RichTextBox> 제어 합니다. 다음 텍스트 선택 영역 내에서 각 탭의 크기를 조정 하려면이 속성을 사용할 수 있습니다. 예를 들어, 문서 내에서 탭 간격을 조정 하려는 경우 전체 문서를 선택 하 수 탭 공백 사용 하 여 목록을 가져오려면는 <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> 속성입니다. 그런 다음 새 값을 조정 하 고이 속성에 할당할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">배열의 요소 수가 최대값인 32개보다 많은 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤 내에서 선택 유형을 가져옵니다.</summary>
        <value><see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" /> 값의 비트 조합입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 선택 영역에서 컨트롤 내에서 작업을 수행할 때 선택 항목을 올바르게 처리 하기 위해 컨트롤에서 현재 선택 된 데이터의 형식을 확인 하려면이 속성을 사용할 수 있습니다. 속성의 값 조합을 나타낼 수는 <xref:System.Windows.Forms.RichTextBoxSelectionTypes> 다양 한 유형의 현재 선택 영역에서 개체를 나타내는 열거형입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>선택 영역 여백이 <see cref="T:System.Windows.Forms.RichTextBox" />에 표시되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>선택 영역 여백이 컨트롤에서 활성화되어 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가 쉽게 텍스트의 줄을 선택할 수 있도록이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox>합니다. 선택 영역 여백을 왼쪽에 추가 되는 <xref:System.Windows.Forms.RichTextBox>합니다. 이 여백 쉽게 사용자 컨트롤의 왼쪽에서 시작 하는 텍스트를 선택 합니다. 사용자는 단일 텍스트 줄을 선택 하려면 선택 영역 여백을 클릭 하거나 두 번 클릭 한 줄에 포함 된 전체 단락을 선택 하려면 두 번 클릭 수 있습니다.  
  
> [!NOTE]
>  경우는 <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> 속성이 `true`설정 합니다 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성을 `RichTextBoxScrollBars.Horizontal`, `RichTextBoxScrollBars.Vertical`, 또는 `RichTextBoxScrollBars.Both` 스크롤 막대가 표시 되지 것입니다. 하는 동안 스크롤 막대를 표시 하기 위해를 <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> 속성이로 설정 되어 `true`설정 합니다 <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> 속성을 `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`, 또는 `RichTextBoxScrollBars.ForcedBoth`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>RichTextBox의 현재 텍스트를 가져오거나 설정합니다.</summary>
        <value>컨트롤에 표시된 텍스트입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 여러 줄의 텍스트를 표시 하는 <xref:System.Windows.Forms.RichTextBox>로 설정 합니다 <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> 속성을 `true`. 읽기 사용 하거나 여러 줄 텍스트 상자의 텍스트를 설정 하려면 사용 된 <xref:System.Windows.Forms.TextBoxBase.Lines%2A> 속성입니다. 합니다 <xref:System.Windows.Forms.RichTextBox.Text%2A> 속성의 내용에 적용 된 서식에 대 한 정보가 반환 되지 않습니다는 <xref:System.Windows.Forms.RichTextBox>합니다. (Rtf 서식) 코드는 서식 있는 텍스트를 가져오려면는 <xref:System.Windows.Forms.RichTextBox.Rtf%2A> 속성입니다. 에 입력할 수 있는 텍스트의 크기는 <xref:System.Windows.Forms.RichTextBox> 컨트롤 사용 가능한 시스템 메모리에 의해서만 제한 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 텍스트 길이를 가져옵니다.</summary>
        <value>컨트롤의 텍스트에 포함된 문자의 수입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> 메서드를 호출할 때 컨트롤에서 실행 취소할 수 있는 동작의 이름을 가져옵니다.</summary>
        <value>실행 취소할 수 있는 동작의 이름입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하면 실행 취소할 수 있는 컨트롤 내에서 수행 된 마지막 동작을 확인할 수 있습니다. 이 속성을 사용 하 여 컨트롤의 사용자가 실행 취소할 수 있는 작업을 제한할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>컨트롤의 세로 스크롤 막대를 클릭할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트를 처리 하는 방법에 대 한 자세한 내용은 참조 하세요. [이벤트 처리 및 발생](~/docs/standard/events/index.md)합니다.  
  
   
  
## Examples  
 다음 코드 예제에서는이 멤버를 사용 하는 방법을 보여 줍니다. 예제에서는 이벤트 처리기에서 보고서를 <xref:System.Windows.Forms.RichTextBox.VScroll> 이벤트입니다. 이 보고서를 통해 이벤트 발생 하 고 도움이 될 수 있습니다 디버깅 하는 경우를 학습할 수 있습니다. 자주 발생 하는 이벤트 또는 여러 이벤트를 보고 하려면 바꾸는 것이 좋습니다 <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> 사용 하 여 <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> 줄에 메시지를 추가 또는 <xref:System.Windows.Forms.TextBox>합니다.  
  
 예제 코드를 실행 하려면 형식의 인스턴스를 포함 하는 프로젝트에 붙여넣습니다 <xref:System.Windows.Forms.RichTextBox> 라는 `RichTextBox1`합니다. 연결 된 이벤트 처리기는 확인 된 <xref:System.Windows.Forms.RichTextBox.VScroll> 이벤트입니다.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Windows 메시지 개체입니다.</param>
        <summary>Windows 메시지를 처리합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.RichTextBox" />의 현재 확대/축소 수준을 가져오거나 설정합니다.</summary>
        <value>컨트롤의 내용이 확대/축소되는 비율입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값은 1/64 (0.015625) 사이의 64.0 포함 하지 않습니다 수 있습니다. 값이 1.0 없습니다 확대/축소 컨트롤에 적용 되지 않음을 나타냅니다. 문서에 트루타입 글꼴 확대/축소 기능을 최적으로 수행 합니다. 글꼴이 트루타입 없는 컨트롤의 문서 내에서 사용 되는 경우는 <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> 속성은 가장 가까운 정수 값을 사용 합니다. 사용자를 사용 하도록 설정 하려면이 속성을 사용할 수는 <xref:System.Windows.Forms.RichTextBox> 설명서를 보거나 더 많은 문서 화면에 표시 될 수 있도록 뷰를 축소 하려면 작은 섹션으로 확대/축소 컨트롤입니다.  
  
   
  
## Examples  
 다음 코드 예제에는 만드는 방법을 보여 줍니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트를 확대 하는, 단어를 두 번에 컨트롤의 클라이언트 영역 오른쪽에 여백을 때 컨트롤의 텍스트에 단어를 자동으로 선택 합니다. 경우는 <xref:System.Windows.Forms.RichTextBox> 컨트롤에 작은 폭이이 코드를 사용 하 여 만들어집니다는 <xref:System.Windows.Forms.RichTextBox> 텍스트의 각 문자 자체 줄에 표시 되는 위치입니다. 이 세로 표시 위치에 있는 동안 단어의 일부에서 클릭 하면 텍스트를 세로로 표시 되도록 팩트에 관계 없이 단어의 모든 문자 선택 됩니다. 이 예제에서는 있어야 포함 된 폼을 <xref:System.Windows.Forms.RichTextBox> 라는 컨트롤 `richTextBox1`합니다.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">지정된 확대/축소 비율이 허용 범위에 속하지 않는 경우</exception>
      </Docs>
    </Member>
  </Members>
</Type>