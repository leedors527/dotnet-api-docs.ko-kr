<Type Name="HwndSource" FullName="System.Windows.Interop.HwndSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e02cc276bc8f0883740120145f09102ac1c53cc2" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004583" /></Metadata><TypeSignature Language="C#" Value="public class HwndSource : System.Windows.PresentationSource, IDisposable, System.Windows.Interop.IKeyboardInputSink, System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi HwndSource extends System.Windows.PresentationSource implements class System.IDisposable, class System.Windows.Interop.IKeyboardInputSink, class System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.HwndSource" />
  <TypeSignature Language="VB.NET" Value="Public Class HwndSource&#xA;Inherits PresentationSource&#xA;Implements IDisposable, IKeyboardInputSink, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class HwndSource : System::Windows::PresentationSource, IDisposable, System::Windows::Interop::IKeyboardInputSink, System::Windows::Interop::IWin32Window" />
  <TypeSignature Language="F#" Value="type HwndSource = class&#xA;    inherit PresentationSource&#xA;    interface IDisposable&#xA;    interface IWin32Window&#xA;    interface IKeyboardInputSink" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.PresentationSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IKeyboardInputSink</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Win32 창에 WPF(Windows Presentation Foundation) 콘텐츠를 표시합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  이 클래스의 많은 멤버는 Internet 보안 영역에서 사용할 수 없는 경우  
  
 <xref:System.Windows.Interop.HwndSource> 를 구현 하는 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 포함할 수 있는 창 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 콘텐츠입니다. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 측정 및 렌더링는 입력을 대화형 창에서 콘텐츠 정렬 됩니다. 때문에 합니다 <xref:System.Windows.Interop.HwndSource> 와 상호 운용 하도록 설계 된 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)],이 클래스는 여러 가지 하위 수준의 노출 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 기능입니다. 다음을 수행 하려면이 클래스를 사용할 수 있습니다.  
  
-   창 스타일, 창 클래스 스타일을 지정 하 고 확장 창 스타일입니다.  
  
-   창 프로시저에 연결 합니다.  
  
-   창 핸들 (HWND)에 대 한 액세스를 제공 합니다.  
  
-   창을 소멸 합니다.  
  
 <xref:System.Windows.Interop.HwndSource> 클래스는 일반 상호 운용성을 위해 설계 되었습니다 되며 관리 되는 HWND 래퍼로 설계 되지 않았습니다. 일반적으로 창이 나 해당 상태를 검사 하는 것에 대 한 속성을 조작 하기 위한 관리 되는 메서드를 제공 하지 않습니다. 대신 합니다 <xref:System.Windows.Interop.HwndSource> 클래스에 대 한 액세스를 제공 합니다 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창 핸들 (HWND)을 통해를 <xref:System.Windows.Interop.HwndSource.Handle%2A> PInvoke 기법을 통해 전달 될 수 있는 속성을 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 창 조작 하기 위해.  
  
 **생성**  
  
 다양 한 측면을 <xref:System.Windows.Interop.HwndSource> 생성 시에만 지정할 수 있습니다. 만들려는 <xref:System.Windows.Interop.HwndSource>, 먼저 만듭니다는 <xref:System.Windows.Interop.HwndSourceParameters> 구조체이 고 필요한 매개 변수를 사용 하 여 채웁니다. 이러한 매개 변수는 다음과 같습니다.  
  
-   클래스, 창 및 확장된 창 스타일입니다. 창을 만든 후 스타일을 변경 하려면 PInvoke를 사용 해야 합니다. 창을 만든 후에 모든 스타일을 변경할 수 있습니다. 참조 된 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창 스타일을 변경 하기 전에 설명서.  
  
-   창의 초기 위치입니다.  
  
-   크기 지정 되거나 결정된 된 크기에서 결정 해야 하는지 여부를 포함 하는 창의 초기 크기는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 콘텐츠입니다.  
  
-   부모 창입니다.  
  
-   <xref:System.Windows.Interop.HwndSourceHook> 창 프로시저 체인에 포함 합니다. 생성 시 후크를 지정 하는 경우 모든 창의 메시지를 받습니다. 사용할 수 있습니다 <xref:System.Windows.Interop.HwndSource.AddHook%2A> 창을 만든 후 후크를 추가 합니다.  
  
-   투명도 설정입니다. 최상위 창을 바탕 화면의 픽셀 별 투명도 따라 다른 windows와 함께 사용 하도록 구성할 수 있습니다는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 콘텐츠입니다. 이 작업이 가능 하도록 설정 합니다 <xref:System.Windows.Interop.HwndSourceParameters.UsesPerPixelOpacity%2A> 속성에는 <xref:System.Windows.Interop.HwndSourceParameters> 에 `true`입니다. 이 속성을 통해서만 생성 시에 지정할 수는 <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> 생성자 서명 하며 여러 가지 제한을 적용 합니다.  
  
 데이터로 채운 후는 <xref:System.Windows.Interop.HwndSourceParameters> 구조체를 전달 하는 <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> 에 대 한 생성자는 <xref:System.Windows.Interop.HwndSource>합니다.  
  
 **개체 수명**  
  
 <xref:System.Windows.Interop.HwndSource> 는 일반 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 개체와 수명이 가비지 수집기에 의해 관리 됩니다. 때문에 합니다 <xref:System.Windows.Interop.HwndSource> 관리 되지 않는 리소스를 나타내는 <xref:System.Windows.Interop.HwndSource> 구현 <xref:System.IDisposable>합니다. 동기적으로 호출 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 즉시 제거는 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창 소유자 스레드에서 호출 하는 경우. 다른 스레드에서 호출 하는 경우는 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창 비동기적으로 제거 됩니다. 호출 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 명시적으로 상호 운용 코드에서 해야 할 수도 있습니다 특정 상호 운용 시나리오에 대 한 합니다.  
  
 **창 프로시저**  
  
 <xref:System.Windows.Interop.HwndSource> 클래스 자체 창 프로시저를 구현 합니다. 이 창 프로시저 레이아웃, 렌더링, 관련 된 것과 같은 중요 한 창 메시지를 처리 하는 데 사용 되 고 입력 합니다. 그러나 직접 사용 하기 위해 창 프로시저도 연결할 수 있습니다. 설정 하 여 사용자 고유의 후크를 생성 하는 동안 지정할 수 있습니다는 <xref:System.Windows.Interop.HwndSourceParameters.HwndSourceHook%2A?displayProperty=nameWithType> 속성 또는 사용자가 이용할 수 있습니다 <xref:System.Windows.Interop.HwndSource.AddHook%2A> 및 <xref:System.Windows.Interop.HwndSource.RemoveHook%2A> 추가 하 고 창을 만든 후 후크를 제거 합니다. 마지막-후입선출 순서에 후크를 처리 하는 기본 제공 하기 전에 실행할 수 있도록 하는 후크를 호출 합니다. 실제 후크 약한 참조로 유지 됩니다. 따라서 후크 대리자의 수명을 관리 하는 있는지 확인 합니다.  
  
 에 대 한 자세한 내용은 <xref:System.Windows.Interop.HwndSource> 상호 운용 다른 클래스를 살펴보고 [WPF 및 Win32 상호 운용성](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)합니다.  
  
 통지 하는 방법에 대 한 생성자 <xref:System.Windows.Interop.HwndSource> 유사한 매개 변수는 매개 변수를 사용 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 와 같은 함수 [CreateWindowEx](https://go.microsoft.com/fwlink/?LinkID=98462)합니다.  
  
 크기 조정 변환을를 적용 해야 합니다 <xref:System.Windows.Interop.HwndSource.RootVisual%2A> 의 <xref:System.Windows.Interop.HwndSource>합니다. 주의 참조 하십시오 <xref:System.Windows.Interop.HwndSource.RootVisual%2A>합니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Interop.HwndHost" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Interop.HwndSource" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (System.Windows.Interop.HwndSourceParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Interop.HwndSourceParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Windows.Interop.HwndSourceParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parameters As HwndSourceParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(System::Windows::Interop::HwndSourceParameters parameters);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : System.Windows.Interop.HwndSourceParameters -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource parameters" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parameters" Type="System.Windows.Interop.HwndSourceParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">창을 만들 하는 데 필요한 매개 변수를 포함 하는 구조체입니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Windows.Interop.HwndSource" /> 초기 설정을 포함 하는 구조체를 사용 하 여 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 이 생성자 시그니처는 일부 적절 한 초기 기본값을 포함 하는 기본 구조 때문에 특정 한 상황에서는 더 편리할 수 있습니다.  
  
> [!IMPORTANT]
>  이 시그니처를 사용 하는 경우 기본값을 사용 하지 마세요 <xref:System.Windows.Interop.HwndSourceParameters> 생성자를 생성 하는 <xref:System.Windows.Interop.HwndSourceParameters> 의 구조는 `parameters` 값입니다. 사용 해야 합니다는 <xref:System.Windows.Interop.HwndSourceParameters> 생성자는 초기 창 이름을 지정할 수 있도록 합니다. 기본값을 사용 하는 경우 <xref:System.Windows.Interop.HwndSourceParameters> 생성자 만들고는 <xref:System.Windows.Interop.HwndSource> 를 사용 하 여는 <xref:System.Windows.Interop.HwndSource> 초기 창 이름이 표현된 된 HWND에 대 한 구성 요구 사항 이므로 표시 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 클래스의 인스턴스를 만듭니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, name As String, parent As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, System::String ^ name, IntPtr parent);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * string * nativeint -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, name, parent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 창의 스타일 클래스입니다.</param>
        <param name="style">[!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="exStyle">확장 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="x">창의 왼쪽 가장자리 위치입니다.</param>
        <param name="y">창의 위쪽 가장자리의 위치입니다.</param>
        <param name="name">창의 이름입니다.</param>
        <param name="parent">창의 부모 창의 핸들입니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Windows.Interop.HwndSource" /> 클래스 지정 된 클래스 스타일, 스타일, 스타일, x-y 위치, 이름 및 부모 창을 확장 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 클래스의 인스턴스를 만듭니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, width As Integer, height As Integer, name As String, parent As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, System::String ^ name, IntPtr parent);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * int * int * string * nativeint -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, width, height, name, parent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 창의 스타일 클래스입니다.</param>
        <param name="style">[!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="exStyle">확장 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="x">창의 왼쪽 가장자리 위치입니다.</param>
        <param name="y">창의 위쪽 가장자리의 위치입니다.</param>
        <param name="width">창의 너비입니다.</param>
        <param name="height">창의 높이입니다.</param>
        <param name="name">창의 이름입니다.</param>
        <param name="parent">창의 부모 창의 핸들입니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Windows.Interop.HwndSource" /> 클래스 지정 된 클래스 스타일, 스타일, 스타일, x-y 위치, 너비, 높이, 이름 및 부모 창을 확장 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 클래스의 인스턴스를 만듭니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent, bool adjustSizingForNonClientArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (classStyle As Integer, style As Integer, exStyle As Integer, x As Integer, y As Integer, width As Integer, height As Integer, name As String, parent As IntPtr, adjustSizingForNonClientArea As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, System::String ^ name, IntPtr parent, bool adjustSizingForNonClientArea);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.HwndSource : int * int * int * int * int * int * int * string * nativeint * bool -&gt; System.Windows.Interop.HwndSource" Usage="new System.Windows.Interop.HwndSource (classStyle, style, exStyle, x, y, width, height, name, parent, adjustSizingForNonClientArea)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
        <Parameter Name="adjustSizingForNonClientArea" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classStyle">[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 창의 스타일 클래스입니다.</param>
        <param name="style">[!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="exStyle">확장 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 창에 대 한 스타일입니다.</param>
        <param name="x">창의 왼쪽 가장자리 위치입니다.</param>
        <param name="y">창의 위쪽 가장자리의 위치입니다.</param>
        <param name="width">창의 너비입니다.</param>
        <param name="height">창의 높이입니다.</param>
        <param name="name">창의 이름입니다.</param>
        <param name="parent">창의 부모 창의 핸들입니다.</param>
        <param name="adjustSizingForNonClientArea"><see langword="true" /> 레이아웃 관리자 크기 조정; 비클라이언트 영역을 포함 하려면 그렇지 않으면 <see langword="false" />합니다.</param>
        <summary>새 인스턴스를 초기화 합니다 <see cref="T:System.Windows.Interop.HwndSource" /> 창 자동 크기 조정 여부를 지정 하 여 지정 된 클래스 스타일, 스타일, 스타일, x-y 위치, 너비, 높이, 이름 및 부모 창에서 확장을 사용 하 여 클래스입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 클래스의 인스턴스를 만듭니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public bool AcquireHwndFocusInMenuMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcquireHwndFocusInMenuMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcquireHwndFocusInMenuMode { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AcquireHwndFocusInMenuMode : bool" Usage="System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 창이 포함 된 WPF에 대해 Win32 포커스를 가져올지 여부를 결정 하는 값을 가져옵니다 <see cref="T:System.Windows.Interop.HwndSource" />합니다.</summary>
        <value>사용자가 메뉴를 조작하는 경우 창이 포함된 WPF에 대해 Win32 포커스를 가져오려면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들 때이 값이 설정 된 <xref:System.Windows.Interop.HwndSource> 설정 하 여를 <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> 매개 변수입니다.  
  
 기본 값으로 결정 됩니다는 <xref:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHook">
      <MemberSignature Language="C#" Value="public void AddHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHook (hook As HwndSourceHook)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHook(System::Windows::Interop::HwndSourceHook ^ hook);" />
      <MemberSignature Language="F#" Value="member this.AddHook : System.Windows.Interop.HwndSourceHook -&gt; unit" Usage="hwndSource.AddHook hook" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">처리기 구현 (기반는 <see cref="T:System.Windows.Interop.HwndSourceHook" /> 대리자) 창 메시지를 수신 합니다.</param>
        <summary>모든 창 메시지를 받는 이벤트 처리기를 추가 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 대부분 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 도달 하는 메시지를 <xref:System.Windows.Interop.HwndSource> 는 대략적인 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 동일 합니다. 사용할 <xref:System.Windows.Interop.HwndSource.AddHook%2A> 메시지에 없는 경우를 처리 하 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 와 동일 합니다.  
  
 합니다 <xref:System.Windows.Interop.HwndSourceHook> 대리자의 매개 변수 프로필 비슷합니다는 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 주 창 프로시저입니다. 모든 창 메시지의 주 창 프로시저를 <xref:System.Windows.Interop.HwndSource> 부모 창은 전달 됩니다는 <xref:System.Windows.Interop.HwndSourceHook> 대리자입니다.  
  
 후크 추가 된 순서 대로 호출 됩니다. 반환 후크가 있으면 `handled` = `true` 메시지에 대 한 호출 순서에서 그 후 후크 해당 메시지에 대해 호출 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">처리를 추가 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.HwndSourceHook" />
        <altmember cref="M:System.Windows.Interop.HwndSource.RemoveHook(System.Windows.Interop.HwndSourceHook)" />
      </Docs>
    </Member>
    <Member MemberName="AutoResized">
      <MemberSignature Language="C#" Value="public event System.Windows.AutoResizedEventHandler AutoResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.AutoResizedEventHandler AutoResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.AutoResized" />
      <MemberSignature Language="VB.NET" Value="Public Event AutoResized As AutoResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::AutoResizedEventHandler ^ AutoResized;" />
      <MemberSignature Language="F#" Value="member this.AutoResized : System.Windows.AutoResizedEventHandler " Usage="member this.AutoResized : System.Windows.AutoResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.AutoResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃을 <see cref="T:System.Windows.Interop.HwndSource" /> 자동으로 조정 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 동작 <xref:System.Windows.Interop.HwndSource> 콘텐츠와 통해 보고 된 변경 내용에 따라 창 영역을 자동으로 조정 하는 것은 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 레이아웃 시스템입니다. 현재 최소화 하거나 경우 창 크기가 조정 되지 않습니다 <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.Manual>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildKeyboardInputSinks">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.ChildKeyboardInputSinks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildKeyboardInputSinks As IEnumerable(Of IKeyboardInputSink)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Interop::IKeyboardInputSink ^&gt; ^ ChildKeyboardInputSinks { System::Collections::Generic::IEnumerable&lt;System::Windows::Interop::IKeyboardInputSink ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildKeyboardInputSinks : seq&lt;System.Windows.Interop.IKeyboardInputSink&gt;" Usage="System.Windows.Interop.HwndSource.ChildKeyboardInputSinks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__29))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__24))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__31))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>등록 된 입력 싱크의 시퀀스를 가져옵니다.</summary>
        <value>열거형의 키보드 입력 싱크의.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositionTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.HwndTarget CompositionTarget { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.HwndTarget CompositionTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.CompositionTarget" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositionTarget As HwndTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Interop::HwndTarget ^ CompositionTarget { System::Windows::Interop::HwndTarget ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositionTarget : System.Windows.Interop.HwndTarget" Usage="System.Windows.Interop.HwndSource.CompositionTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>호스팅된 창의 표시 관리자를 가져옵니다.</summary>
        <value>표시 관리자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 재정의 <xref:System.Windows.Interop.HwndSource.GetCompositionTargetCore%2A> 값을 재정의 하기 위해는 <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A> 반환 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandleRef">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.HandleRef CreateHandleRef ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.InteropServices.HandleRef CreateHandleRef() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.CreateHandleRef" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateHandleRef () As HandleRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::InteropServices::HandleRef CreateHandleRef();" />
      <MemberSignature Language="F#" Value="member this.CreateHandleRef : unit -&gt; System.Runtime.InteropServices.HandleRef" Usage="hwndSource.CreateHandleRef " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.HandleRef</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>에 대 한 창 핸들을 가져옵니다는 <see cref="T:System.Windows.Interop.HwndSource" />합니다. 창 핸들의 일부로 <see cref="T:System.Runtime.InteropServices.HandleRef" /> 구조입니다.</summary>
        <returns>이 대 한 창 핸들을 포함 하는 구조체 <see cref="T:System.Windows.Interop.HwndSource" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 가져온 핸들을 사용할 수 있습니다 <xref:System.Windows.Interop.HwndSource.CreateHandleRef%2A> 참조에는 <xref:System.Windows.Interop.HwndSource> 에서 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] 코드입니다. 메시지 처리 및 창의 동작과 같은 작업에 대 한 핸들을 사용 합니다.  
  
 방금 핸들을 사용 <xref:System.Windows.Interop.HwndSource.Handle%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.HwndSource.Handle" />
      </Docs>
    </Member>
    <Member MemberName="DefaultAcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public static bool DefaultAcquireHwndFocusInMenuMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DefaultAcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultAcquireHwndFocusInMenuMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool DefaultAcquireHwndFocusInMenuMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultAcquireHwndFocusInMenuMode : bool with get, set" Usage="System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>기본값을 가져오거나 설정 합니다. <see cref="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" /> 의 새 인스턴스에 대 한 값 <see cref="T:System.Windows.Interop.HwndSource" />합니다.</summary>
        <value>사용자가 메뉴를 조작하는 경우 창이 포함된 WPF에 대해 Win32 포커스를 가져오려면 <see langword="true" />이고 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새 인스턴스 <xref:System.Windows.Interop.HwndSource> 가 <xref:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode%2A> 다른 값을 매개 변수로 전달 되지 않으면이 기본 값으로 설정 합니다 <xref:System.Windows.Interop.HwndSource> 생성자를 사용 하 여 특정 인스턴스의 경우는 <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">이 속성을 가져오려면. 연결 된 열거형: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="P:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="hwndSource.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>사용 되는 모든 관리 되는 리소스를 해제 합니다 <see cref="T:System.Windows.Interop.HwndSource" />를 발생 시킵니다는 <see cref="E:System.Windows.Interop.HwndSource.Disposed" /> 이벤트입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 시작 관련 HWND에 대 한 정리 작업입니다. 경우 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 호출 되는 주 UI 스레드가 다른 스레드를 통해 정리 작업을 수 있습니다 될 때까지 지연 주 UI 스레드를 게시할 수 있습니다.  
  
 호출 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 명시적으로 상호 운용 코드에서 해야 할 수도 있습니다 특정 상호 운용 시나리오의 경우 때문에 <xref:System.Windows.Interop.HwndSource> 일부 상호 운용 시나리오에서 상호 운용 경계를 넘어 몇 가지 참조를 생성할 수 있습니다 하는 시기 적절 하 게 가비지 수집을 하지 못할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.HwndSource.IsDisposed" />
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberSignature Language="F#" Value="member this.Disposed : EventHandler " Usage="member this.Disposed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>발생 경우를 <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> 이 개체에서 호출 됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 <xref:System.Windows.Interop.HwndSource.Disposed> 이벤트가 발생 하 여 리소스를 해제 하기 전에 <xref:System.Windows.Interop.HwndSource>합니다. <xref:System.Windows.Interop.HwndSource.Disposed> 이벤트 이벤트를 발생 시키는 개체 제거에 대 한 모든 참조를 갖는 것을 나타냅니다.  
  
 사용 하 여 <xref:System.Windows.Interop.HwndSource.Disposed> 하며 <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> 호출을 피하기 위해 속성 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 두 번 (예외 발생).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.HwndSource.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.HwndDpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.HwndDpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DpiChanged As HwndDpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::HwndDpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.HwndDpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.HwndDpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HwndDpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 Hwnd의 모니터 DPI가 변경되거나 Hwnd가 다른 DPI의 모니터로 이동될 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.HwndSource FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Interop.HwndSource FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.FromHwnd(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHwnd (hwnd As IntPtr) As HwndSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Interop::HwndSource ^ FromHwnd(IntPtr hwnd);" />
      <MemberSignature Language="F#" Value="static member FromHwnd : nativeint -&gt; System.Windows.Interop.HwndSource" Usage="System.Windows.Interop.HwndSource.FromHwnd hwnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">제공 된 창 핸들입니다.</param>
        <summary>반환 된 <see cref="T:System.Windows.Interop.HwndSource" /> 지정 된 창의 개체입니다.</summary>
        <returns><see cref="T:System.Windows.Interop.HwndSource" /> 으로 지정 된 창에 대 한 개체는 <paramref name="hwnd" /> 창 핸들입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  이 방법은 사용할 수 없습니다 또는 부분 신뢰 인터넷 보안 영역에서 일반적입니다.  
  
 이 메서드를 사용 하 여 반환 하는 <xref:System.Windows.Interop.HwndSource> 상호 운용 창이 명시적으로 없는 창에 대 한 합니다. 이 대 한 절차가입니다.  
  
1.  만들기는 <xref:System.Windows.Interop.WindowInteropHelper> 인스턴스 (기본 제공 <xref:System.Windows.Window> 생성자 매개 변수로).  
  
2.  값을 가져올는 <xref:System.Windows.Interop.WindowInteropHelper.Handle%2A> 속성에서 <xref:System.Windows.Interop.WindowInteropHelper> 인스턴스.  
  
3.  해당 HWND 값에 대 한 매개 변수로 전달 <xref:System.Windows.Interop.HwndSource.FromHwnd%2A>합니다.  
  
 이 기술은 다음 일반 추가 하려는 경우에 유용할 수 있습니다 <xref:System.Windows.Interop.HwndSource.AddHook%2A> 메시지 창으로 처리 합니다. 그러나 만들 때마다는 <xref:System.Windows.Interop.HwndSource>를 제거 하는 일을 담당 수도 있습니다. 이 참인 경우에를 <xref:System.Windows.Application> 애플리케이션에 대 한 개체 <xref:System.Windows.Interop.HwndSource> 삭제 됩니다. 자세한 내용은 설명 부분을에서 참조 <xref:System.Windows.Interop.HwndSource>합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Interop.WindowInteropHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetCompositionTargetCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.CompositionTarget GetCompositionTargetCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.CompositionTarget GetCompositionTargetCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.GetCompositionTargetCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetCompositionTargetCore () As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::CompositionTarget ^ GetCompositionTargetCore();" />
      <MemberSignature Language="F#" Value="override this.GetCompositionTargetCore : unit -&gt; System.Windows.Media.CompositionTarget" Usage="hwndSource.GetCompositionTargetCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창의 표시 대상을 가져옵니다.</summary>
        <returns>창의 표시 대상을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현으로 동일한 결과 반환 합니다. <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>유형별 표시 대상을 반환 하려면이 메서드를 구현 합니다. <see cref="T:System.Windows.Interop.HwndSource" /> 반환 하려면이 메서드를 구현 <see cref="T:System.Windows.Interop.HwndTarget" />합니다.</para></block>
        <altmember cref="T:System.Windows.Media.CompositionTarget" />
        <altmember cref="P:System.Windows.Interop.HwndSource.CompositionTarget" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Interop.HwndSource.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Interop.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 대 한 창 핸들을 가져옵니다 <see cref="T:System.Windows.Interop.HwndSource" />합니다.</summary>
        <value>창 핸들입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  이 속성은 인터넷 보안 영역에서 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 포인터에 액세스할 수 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasFocusWithinCore">
      <MemberSignature Language="C#" Value="protected virtual bool HasFocusWithinCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasFocusWithinCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.HasFocusWithinCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HasFocusWithinCore () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool HasFocusWithinCore();" />
      <MemberSignature Language="F#" Value="abstract member HasFocusWithinCore : unit -&gt; bool&#xA;override this.HasFocusWithinCore : unit -&gt; bool" Usage="hwndSource.HasFocusWithinCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>싱크 또는 싱크에 포함된 된 구성 요소 중 하나에 포커스가 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <returns><see langword="true" /> 싱크 또는 싱크에 포함된 된 구성 요소 중 하나에 포커스가 있으면 그렇지 않으면 <see langword="false" />합니다.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.HasFocusWithin" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public override bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Interop.HwndSource.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나타내는 값을 가져옵니다 여부 <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> 이 호출 된 <see cref="T:System.Windows.Interop.HwndSource" />합니다.</summary>
        <value><see langword="true" /> 개체에 있으면 <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> 고, 그렇지 않으면 호출에 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 시작 관련 HWND에 대 한 정리 작업입니다. 경우 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 호출 되는 주 UI 스레드가 다른 스레드를 통해 정리 작업을 수 있습니다 될 때까지 지연 주 UI 스레드를 게시할 수 있습니다. 합니다 <xref:System.Windows.Interop.HwndSource.Disposed> 이벤트가 발생의 값과 <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> 됩니다 `false` 즉시 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 라고 합니다. 호출 하는 경우이 시간 동안 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 다시 <xref:System.Windows.Interop.HwndSource.Dispose%2A> 예외를 발생 시킵니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.HwndSource.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="KeyboardInputSiteCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.KeyboardInputSiteCore" />
      <MemberSignature Language="VB.NET" Value="Protected Property KeyboardInputSiteCore As IKeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Interop::IKeyboardInputSite ^ KeyboardInputSiteCore { System::Windows::Interop::IKeyboardInputSite ^ get(); void set(System::Windows::Interop::IKeyboardInputSite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.KeyboardInputSiteCore : System.Windows.Interop.IKeyboardInputSite with get, set" Usage="System.Windows.Interop.HwndSource.KeyboardInputSiteCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>구성 요소의 컨테이너에 대 한 참조를 가져오거나 설정 합니다. <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> 인터페이스입니다.</summary>
        <value>컨테이너의에 대 한 참조가 <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> ; 인터페이스 또는 <see langword="null" /> 사이트가 할당 되지 않은 경우. 기본값은 <see langword="null" />입니다.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.HwndDpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.HwndDpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnDpiChanged(System.Windows.HwndDpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As HwndDpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::HwndDpiChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.HwndDpiChangedEventArgs -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.HwndDpiChangedEventArgs -&gt; unit" Usage="hwndSource.OnDpiChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.HwndDpiChangedEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">이벤트의 인수입니다.</param>
        <summary>창의 DPI가 변경될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자가이 이벤트를 처리 하는 경우 WPF는 시각적 개체가 확장 되지 않습니다.  
  
> [!IMPORTANT]
>  이 메서드는 중요 한 데이터 액세스 <xref:System.Windows.Interop.HwndTarget>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMnemonicCore">
      <MemberSignature Language="C#" Value="protected virtual bool OnMnemonicCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMnemonicCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnMnemonicCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnMnemonicCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnMnemonicCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member OnMnemonicCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.OnMnemonicCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.OnMnemonicCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">니모닉 및 연결 된 데이터에 대 한 메시지입니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>이 싱크에 대 한 니모닉 (선택 키) 중 하나가 호출 될 때 호출 됩니다.</summary>
        <returns>메시지가 처리되었으면 <see langword="true" />이고, 처리되지 않았으면 <see langword="false" />입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="msg" /> WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, 또는 WM_DEADCHAR 없습니다.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterKeyboardInputSinkCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RegisterKeyboardInputSinkCore(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RegisterKeyboardInputSinkCore (sink As IKeyboardInputSink) As IKeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Interop::IKeyboardInputSite ^ RegisterKeyboardInputSinkCore(System::Windows::Interop::IKeyboardInputSink ^ sink);" />
      <MemberSignature Language="F#" Value="member this.RegisterKeyboardInputSinkCore : System.Windows.Interop.IKeyboardInputSink -&gt; System.Windows.Interop.IKeyboardInputSite" Usage="hwndSource.RegisterKeyboardInputSinkCore sink" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sink"><see cref="T:System.Windows.Interop.IKeyboardInputSink" /> 싱크 포함 된 구성 요소입니다.</param>
        <summary>등록 된 <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> 포함 된 구성 요소의 인터페이스입니다.</summary>
        <returns><see cref="T:System.Windows.Interop.IKeyboardInputSite" /> 포함된 된 구성 요소의 사이트입니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveHook">
      <MemberSignature Language="C#" Value="public void RemoveHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RemoveHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveHook (hook As HwndSourceHook)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveHook(System::Windows::Interop::HwndSourceHook ^ hook);" />
      <MemberSignature Language="F#" Value="member this.RemoveHook : System.Windows.Interop.HwndSourceHook -&gt; unit" Usage="hwndSource.RemoveHook hook" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">제거할 이벤트 처리기입니다.</param>
        <summary>에 의해 추가 된 이벤트 처리기 제거 <see cref="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  인터넷 보안 영역에서는이 메서드를 사용할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">처리기를 제거 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />
        <altmember cref="T:System.Windows.Interop.HwndSourceHook" />
      </Docs>
    </Member>
    <Member MemberName="RestoreFocusMode">
      <MemberSignature Language="C#" Value="public System.Windows.Input.RestoreFocusMode RestoreFocusMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.RestoreFocusMode RestoreFocusMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RestoreFocusMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreFocusMode As RestoreFocusMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::RestoreFocusMode RestoreFocusMode { System::Windows::Input::RestoreFocusMode get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreFocusMode : System.Windows.Input.RestoreFocusMode" Usage="System.Windows.Interop.HwndSource.RestoreFocusMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RestoreFocusMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가져옵니다는 <see cref="T:System.Windows.Input.RestoreFocusMode" /> 창에 대 한 합니다.</summary>
        <value><see cref="T:System.Windows.Input.RestoreFocusMode" /> 창에 대 한 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성에만 설정할 수 있습니다는 <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29?displayProperty=nameWithType> 생성자를 사용 하 여는 <xref:System.Windows.Interop.HwndSourceParameters.RestoreFocusMode%2A?displayProperty=nameWithType> 속성입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootVisual">
      <MemberSignature Language="C#" Value="public override System.Windows.Media.Visual RootVisual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual RootVisual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RootVisual" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property RootVisual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Media::Visual ^ RootVisual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RootVisual : System.Windows.Media.Visual with get, set" Usage="System.Windows.Interop.HwndSource.RootVisual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가져오거나 설정 합니다 <see cref="P:System.Windows.Media.CompositionTarget.RootVisual" /> 창입니다.</summary>
        <value>창의 루트 시각적 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 사용 하 여 연결할를 <xref:System.Windows.Controls.Page> 또는 시각적 개체를 다른 루트를 <xref:System.Windows.Interop.HwndSource>입니다.  
  
 배율 변환 해야 적용할 수 없습니다는 <xref:System.Windows.Interop.HwndSource.RootVisual%2A> 의 <xref:System.Windows.Interop.HwndSource> 이 비활성화할 수 있으므로 <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> 동작 합니다. 콘텐츠 확장 됩니다. 그러나 포함 하는 창의 않습니다. 변환 되는 개체에 적용 하는 대신 합니다 <xref:System.Windows.Interop.HwndSource.RootVisual%2A>, 개체의 자식 요소에 변환을 적용 합니다 <xref:System.Windows.Interop.HwndSource.RootVisual%2A>. 추가 포함 요소를 추가 해야 하는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 확장 가능한 개체를 제공 하기 위해 패널 등의 콘텐츠입니다.  
  
 추가할 수는 <xref:System.Windows.Window> 루트 visual로 최상위 창 (ws_overlapped) 으로만 하지만 자식 창이 아니라 합니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 속성을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Interop.HwndTarget.RootVisual" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Interop.HwndSource.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠에 맞게 창의 크기가 여부 및 방법을 가져오거나 설정 합니다.</summary>
        <value>열거형 값 중 하나입니다. 기본값은 <see cref="F:System.Windows.SizeToContent.Manual" />를 지정 하는 창 콘텐츠에 맞게 크기가 조정 되지 않습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 최종 사용자가 직접 경우 설정할 수 있습니다 하지 애플리케이션 UI 통해이 속성 기능 애플리케이션에 의해 노출 되는 합니다.  
  
 크기 조정 변환을를 적용 해야 합니다 <xref:System.Windows.Interop.HwndSource.RootVisual%2A> 의 <xref:System.Windows.Interop.HwndSource>이므로이 비활성화할 수 <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> 동작 합니다. 주의 참조 하십시오 <xref:System.Windows.Interop.HwndSource.RootVisual%2A>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.SizeToContent" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeToContentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeToContentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.SizeToContentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event SizeToContentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeToContentChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeToContentChanged : EventHandler " Usage="member this.SizeToContentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Interop.HwndSource.SizeToContent" /> 속성 값이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> 이벤트는 사용자 상호 작용으로 인해 변경 하는 경우에 발생 합니다. 설정 하는 경우 <xref:System.Windows.Window.SizeToContent%2A> 코드에서의 <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Interop.HwndSource.AutoResized" />
        <altmember cref="P:System.Windows.Interop.HwndSource.SizeToContent" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.HasFocusWithin">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.HasFocusWithin ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#HasFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Function HasFocusWithin () As Boolean Implements IKeyboardInputSink.HasFocusWithin" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin() = System::Windows::Interop::IKeyboardInputSink::HasFocusWithin;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.HasFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Media.FamilyTypefaceCollection.System#Collections#IList#Remove(System.Object)" />를 참조하세요.</summary>
        <returns><see langword="true" /> 싱크 또는 싱크에 포함된 된 구성 요소 중 하나에 포커스가 있으면 그렇지 않으면 <see langword="false" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#KeyboardInputSite" />
      <MemberSignature Language="VB.NET" Value=" Property KeyboardInputSite As IKeyboardInputSite Implements IKeyboardInputSink.KeyboardInputSite" />
      <MemberSignature Language="C++ CLI" Value="property System::Windows::Interop::IKeyboardInputSite ^ System::Windows::Interop::IKeyboardInputSink::KeyboardInputSite { System::Windows::Interop::IKeyboardInputSite ^ get(); void set(System::Windows::Interop::IKeyboardInputSite ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 멤버에 대한 설명은 <see cref="P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />를 참조하세요.</summary>
        <value>컨테이너의에 대 한 참조 <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> 인터페이스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 속성을 설정 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/0ffbde0d-701d-45a3-a6fa-dd71f4d9772e">WPF 및 Win32 상호 운용성 개요</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ee5258b7-6567-415a-9b1c-c0cbe46e79ef">입력 개요</related>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.OnMnemonic">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.OnMnemonic (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function OnMnemonic (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.OnMnemonic" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::OnMnemonic;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">니모닉 및 연결 된 데이터에 대 한 메시지입니다. 이 메시지 구조를 수정 하지 마십시오. 성능상의 이유로 참조로 전달 됩니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />를 참조하세요.</summary>
        <returns>메시지가 처리되었으면 <see langword="true" />이고, 처리되지 않았으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite IKeyboardInputSink.RegisterKeyboardInputSink (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberSignature Language="VB.NET" Value="Function RegisterKeyboardInputSink (sink As IKeyboardInputSink) As IKeyboardInputSite Implements IKeyboardInputSink.RegisterKeyboardInputSink" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::Interop::IKeyboardInputSite ^ System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System::Windows::Interop::IKeyboardInputSink ^ sink) = System::Windows::Interop::IKeyboardInputSink::RegisterKeyboardInputSink;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" />
      </Parameters>
      <Docs>
        <param name="sink"><see cref="T:System.Windows.Interop.IKeyboardInputSink" /> 싱크 포함 된 구성 요소입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />를 참조하세요.</summary>
        <returns><see cref="T:System.Windows.Interop.IKeyboardInputSite" /> 포함된 된 구성 요소의 사이트입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Function TabInto (request As TraversalRequest) As Boolean Implements IKeyboardInputSink.TabInto" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TabInto(System::Windows::Input::TraversalRequest ^ request) = System::Windows::Interop::IKeyboardInputSink::TabInto;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">첫 번째 또는 마지막 탭 정지에 포커스를 설정 해야 하는지 여부를 지정 합니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />를 참조하세요.</summary>
        <returns><see langword="true" /> 포커스가 요청 대로 설정 된 경우 <see langword="false" />탭 정지가 있을 경우.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateAccelerator (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateAccelerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateAccelerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">메시지와 연결 된 데이터입니다. 이 구조를 수정 하지 마십시오. 성능상의 이유로 참조로 전달 됩니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />를 참조하세요.</summary>
        <returns><see langword="true" /> 메서드 구현에서 메시지가 처리 된 경우 그렇지 않으면 <see langword="false" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateChar">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateChar (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Function TranslateChar (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean Implements IKeyboardInputSink.TranslateChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers) = System::Windows::Interop::IKeyboardInputSink::TranslateChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Interop.IKeyboardInputSink.TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">메시지와 연결 된 데이터입니다. 이 구조를 수정 하지 마십시오. 성능상의 이유로 참조로 전달 됩니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>이 멤버에 대한 설명은 <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />를 참조하세요.</summary>
        <returns><see langword="true" /> 메시지를 처리 하는 경우 및 <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> 고, 그렇지 않으면 호출 하지 않아야 <see langword="false" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Interop.HwndSource> 인스턴스가 <xref:System.Windows.Interop.IKeyboardInputSink> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected virtual bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TabIntoCore (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TabIntoCore(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.TabIntoCore : System.Windows.Input.TraversalRequest -&gt; bool" Usage="hwndSource.TabIntoCore request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="request">첫 번째 또는 마지막 탭 정지에 포커스를 설정 해야 하는지 여부를 지정 합니다.</param>
        <summary>첫 번째 탭 정지 또는 싱크의 마지막 탭 정지에 포커스를 설정 합니다.</summary>
        <returns><see langword="true" /> 포커스가 요청 대로 설정 된 경우 <see langword="false" />탭 정지가 있을 경우.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="request" />가 <see langword="null" />인 경우</exception>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TranslateAcceleratorCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TranslateAcceleratorCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.TranslateAcceleratorCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.TranslateAcceleratorCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">메시지와 연결 된 데이터입니다. 이 구조를 수정 하지 마십시오. 성능상의 이유로 참조로 전달 됩니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>Keydown 메시지 수준에서 키보드 입력을 처리합니다.</summary>
        <returns><see langword="true" /> 메서드 구현에서 메시지가 처리 된 경우 그렇지 않으면 <see langword="false" />합니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      </Docs>
    </Member>
    <Member MemberName="TranslateCharCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateCharCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateCharCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateCharCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TranslateCharCore (ByRef msg As MSG, modifiers As ModifierKeys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TranslateCharCore(System::Windows::Interop::MSG % msg, System::Windows::Input::ModifierKeys modifiers);" />
      <MemberSignature Language="F#" Value="abstract member TranslateCharCore :  * System.Windows.Input.ModifierKeys -&gt; bool&#xA;override this.TranslateCharCore :  * System.Windows.Input.ModifierKeys -&gt; bool" Usage="hwndSource.TranslateCharCore (msg, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">메시지와 연결 된 데이터입니다. 이 구조를 수정 하지 마십시오. 성능상의 이유로 참조로 전달 됩니다.</param>
        <param name="modifiers">보조키입니다.</param>
        <summary>전에 WM_CHAR, WM_SYSCHAR, WM_DEADCHAR 및 WM_SYSDEADCHAR 입력 메시지를 <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> 메서드가 호출 됩니다.</summary>
        <returns><see langword="true" /> 메시지를 처리 하는 경우 및 <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> 고, 그렇지 않으면 호출 하지 않아야 <see langword="false" />합니다.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">이 메서드를 호출 합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UsesPerPixelOpacity">
      <MemberSignature Language="C#" Value="public bool UsesPerPixelOpacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsesPerPixelOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.UsesPerPixelOpacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UsesPerPixelOpacity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UsesPerPixelOpacity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UsesPerPixelOpacity : bool" Usage="System.Windows.Interop.HwndSource.UsesPerPixelOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>원본 창 콘텐츠의 픽셀별 불투명도가 적용되는지 여부를 선언하는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 시스템은 픽셀 별 불투명도;를 사용 하는 경우 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 픽셀 별 불투명도 사용 하도록 설정 하면 시스템은 더 이상 비클라이언트 영역을 그립니다. 왜냐하면의 원래 용도 <xref:System.Windows.Interop.HwndSource.UsesPerPixelOpacity%2A> 상호 운용 시나리오에서 작동 하는 사각형이 아닌 최상위 UI를 표시 하는 것입니다. 따라서 사각형 비클라이언트 영역 비교를 표시합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>