<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eb09b92c85f6899f8f0386e85d5fda59b541d871" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39361143" /></Metadata><TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="0d52b-101">WPF 기본 XAML 판독기 및 연결된 XAML 개체 기록기를 사용하여 XAML 입력을 읽고 개체 그래프를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-101">Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-102">동기 <xref:System.Windows.Markup.XamlReader.Load%2A> 메서드는 정적 이지만 비동기 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> 메서드 정적 이며 인스턴스는 <xref:System.Windows.Markup.XamlReader> 클래스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-102">The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the <xref:System.Windows.Markup.XamlReader> class to use.</span></span>  
  
 <span data-ttu-id="0d52b-103">출력을 `Load` 메서드는 생성된 된 개체 트리 또는 개체 그래프의 루트 개체를 나타내는 단일 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-103">The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph.</span></span> <span data-ttu-id="0d52b-104">개체에서 만든 그래프 <xref:System.Windows.Markup.XamlReader> 일반적으로 런타임에 WPF 애플리케이션의 기존 개체 트리에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-104">Object graphs that are created by <xref:System.Windows.Markup.XamlReader> are typically added to the existing object tree of a WPF application at run time.</span></span> <span data-ttu-id="0d52b-105">그렇지 않은 경우 새 개체 그래프 WPF 애플리케이션 모델의 목적에 대 한 연결이 끊어진 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-105">Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</span></span> <span data-ttu-id="0d52b-106">즉, 렌더링 하지 않습니다 하 고 적용할 수 없습니다 액세스를 사용 하 여 개체 트리 기법으로 WPF 애플리케이션의 기본 개체 트리 (예를 들어 Api <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>).</span><span class="sxs-lookup"><span data-stu-id="0d52b-106">This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>).</span></span> <span data-ttu-id="0d52b-107">개체 트리 개념에 대 한 자세한 내용은 참조 하세요. [WPF의 트리](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-107">For more information on object tree concepts, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="0d52b-108"><xref:System.Windows.Markup.XamlReader> 다음과 같은 기본 시나리오를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-108"><xref:System.Windows.Markup.XamlReader> supports the following primary scenarios:</span></span>  
  
-   <span data-ttu-id="0d52b-109">**복제 개체 팩터리**: 참조 형식이 일반적으로 추가적인 메커니즘 없이 WPF 개체 트리에서 둘 이상의 위치에 포함 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-109">**Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</span></span> <span data-ttu-id="0d52b-110">(공유에 대 한 지원을 제공 하거나 WPF에서 다시 사용 하는 추가 메커니즘의 예로 기반으로 하는 개체 <xref:System.Windows.Freezable>와 같은 일반적으로 공유할 수 있는 개체에 대 한 지원이 <xref:System.Windows.Media.Brush> 에서 항목으로 참조 되는 <xref:System.Windows.ResourceDictionary>.) 사용 하 여 개체를 serialize 할 개체 트리는 이미 있는 개체를 복제 하는 한 가지 방법은 <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-110">(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0d52b-111">사용할 직렬화 된 문자열 입력에 대 한 호출 <xref:System.Windows.Markup.XamlReader.Load%2A>, 스트림 또는 <xref:System.Xml.XmlReader> 중간자로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-111">You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.</span></span>  
  
-   <span data-ttu-id="0d52b-112">**적시에 정보를 기반으로 개체 생성**: 다른 방법으로 기존 개체의 상태를 변경 하는 런타임에 바인딩 또는 사용자가 제공한 입력 하는 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-112">**Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</span></span> <span data-ttu-id="0d52b-113">예를 들어 둘 이상의 속성을 설정 하려면 동일한 값을 사용 하거나 데이터 바인딩을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-113">For example you could use the same value to set more than one property, or use data binding.</span></span> <span data-ttu-id="0d52b-114">여기서도 만들 개체의 형식이 결정할 수 있는 런타임 시 또는 사용자 상호 작용 시나리오에 있는 경우 다음 개체를 만드는 이러한 문자열을 작성 하 여 있지만 <xref:System.Windows.Markup.XamlReader.Load%2A> 입력 유용한 기술 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-114">But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.</span></span>  
  
-   <span data-ttu-id="0d52b-115">**기존 리소스 기술을 사용 하 여**:는 <xref:System.IO.Stream> 형식에서 자주 사용 됩니다 다른 프레임 워크 또는 기술 응용 프로그램 경계를 넘어 데이터 나 개체를 전송 하는 것에 대 한 또는 이와 유사한 상황에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-115">**Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</span></span> <span data-ttu-id="0d52b-116">사용할 수는 <xref:System.IO.Stream> 저장소나 결국 애플리케이션의 일부로 개체를 만드는 데 사용 하는 XAML 형식의 데이터를 가져오는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-116">You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</span></span>  
  
-   <span data-ttu-id="0d52b-117">**고정 문서:** 응용 프로그램에서 WPF 응용 프로그램 개체 트리를 UI에 포함 하기 위해 로컬 또는 다운로드 한 XPS 문서를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-117">**Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0d52b-118">이 설명서를 따라 개체 트리로 달리 개체 그래프를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-118">This documentation sometimes describes an object graph, as opposed to an object tree.</span></span> <span data-ttu-id="0d52b-119">엄격한 부모-자식 관계를 항상 없으므로 런타임 WPF 애플리케이션의 런타임 개체 관계에서 개체 그래프를 보다 광범위 하 게 해당 용어는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-119">A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</span></span> <span data-ttu-id="0d52b-120">그러나 WPF에 두 개의 다른 트리 개념화 Api도 포함 되어 있으므로 (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) 트리 메타포 WPF의 대부분의 실제 사례를 적절 하 게 계속 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-120">However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF.</span></span> <span data-ttu-id="0d52b-121">그러나 XAML 언어 관점에서 개체 그래프 대개는 가장 좋은 방법은 생각 하는 XAML에서 개체가 생성 되는 방법에 대 한 XAML 언어 자체 반드시 지정 하지 않으므로 관계를 자세히 제공 하는 도우미 클래스 방법론에는 트리 구조 다시입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-121">From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</span></span>  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a><span data-ttu-id="0d52b-122">코드 액세스 보안, 느슨한 XAML 및 XamlReader</span><span class="sxs-lookup"><span data-stu-id="0d52b-122">Code Access Security, Loose XAML, and XamlReader</span></span>  
 <span data-ttu-id="0d52b-123">XAML은 개체 인스턴스화 및 실행을 직접적으로 나타내는 태그 언어입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-123">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="0d52b-124">따라서 XAML에서 만든 요소에는 생성된 해당 코드가 수행하는 것과 마찬가지로 시스템 리소스(예: 네트워크 액세스, 파일 시스템 IO)와 상호 작용하는 동일한 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-124">Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="0d52b-125">지원 합니다 [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] 보안 프레임 워크 [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-125">supports the [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)].</span></span> <span data-ttu-id="0d52b-126">즉, 인터넷 영역에서 실행되는 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 콘텐츠는 실행 권한이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-126">This means that [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions.</span></span> <span data-ttu-id="0d52b-127">이때 "느슨한 XAML"(컴파일되지 않은 XAML의 페이지가 로드 시 XAML 뷰어에 의해 해석됨) 및 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]는 일반적으로 이 인터넷 영역에서 실행되며 같은 권한 집합을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-127">"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.</span></span>  <span data-ttu-id="0d52b-128">하지만 완전히 신뢰할 수 있는 애플리케이션으로 로드된 XAML은 시스템 리소스에 대해 호스팅 애플리케이션과 동일한 액세스 권한을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-128">However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</span></span> <span data-ttu-id="0d52b-129">자세한 내용은 [WPF 부분 신뢰 보안](~/docs/framework/wpf/wpf-partial-trust-security.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0d52b-129">For more information, see [WPF Partial Trust Security](~/docs/framework/wpf/wpf-partial-trust-security.md).</span></span>  
  
 <span data-ttu-id="0d52b-130">에 대 한 이러한 문 미치는 <xref:System.Windows.Markup.XamlReader> 애플리케이션 디자인 로드 하려는 XAML에 대 한 신뢰 결정을 내려야 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-130">The implications of these statements for <xref:System.Windows.Markup.XamlReader> is that your application design must make trust decisions about the XAML you decide to load.</span></span> <span data-ttu-id="0d52b-131">신뢰할 수 없는 XAML을 로드 하는 경우에 결과 개체 그래프를 로드 하는 방법에 대 한 고유한 샌드 박싱 기술을 구현 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-131">If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</span></span>  
  
 <span data-ttu-id="0d52b-132"><xref:System.Windows.Markup.XamlReader> 부분 신뢰 코드로 호출할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-132"><xref:System.Windows.Markup.XamlReader> can also be called by partial trust code.</span></span> <span data-ttu-id="0d52b-133">이 경우 코드 액세스 보안에 대 한 인터넷 보안 영역 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-133">In this case, Internet security zone is applied for code access security.</span></span> <span data-ttu-id="0d52b-134">인터넷 보안 영역에서 유효 하지 않으면 로드 된 XAML에서 XAML 구문 분석 예외를 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-134">If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</span></span> <span data-ttu-id="0d52b-135">XBAP 및 플랫폼 수준에서 부분 신뢰를 수 있는 경우도 있는 <xref:System.Windows.Markup.XamlReader> 일부인 실행의 명시적 부분 신뢰로 호출 된 대로 동일한 예외 동작 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-135">Under XBAP and other cases that are partial trust at the platform level, where <xref:System.Windows.Markup.XamlReader> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</span></span>  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a><span data-ttu-id="0d52b-136">WPF XAML, XAML 판독기/기록기 및 XAML 언어 버전 관리</span><span class="sxs-lookup"><span data-stu-id="0d52b-136">WPF XAML, XAML Readers/Writers, and XAML Language Versioning</span></span>  
 <span data-ttu-id="0d52b-137">XAML2009와 같은 언어 기능에 포함 [X:reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) 하 고 [X:factorymethod](~/docs/framework/xaml-services/x-factorymethod-directive.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-137">XAML2009 includes language features such as [x:Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) and [x:FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md).</span></span> <span data-ttu-id="0d52b-138">시그니처를 사용할 수 있습니다 `Load` 또는 `Parse` 이러한 기능을 사용 하는 XAML을 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-138">You can use signatures of `Load` or `Parse` to load XAML that uses these features.</span></span> <span data-ttu-id="0d52b-139">그러나 이러한 언어 기능은 태그를 컴파일해야 하는 XAML에 대 한 지원 되지 않습니다 (에 대 한 XAML 같은 **페이지** 는 WPF 애플리케이션 또는 빌드 작업에서 태그 컴파일 작업을 포함 하는 모든 XAML에서 빌드 작업).</span><span class="sxs-lookup"><span data-stu-id="0d52b-139">However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</span></span>  
  
 <span data-ttu-id="0d52b-140">WPF 형식 및 WPF 기술 일반적 WPF 내부 요소에 대 한 액세스를 사용 하는 개념을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-140">WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</span></span> <span data-ttu-id="0d52b-141">예를 들어 WPF 종속성 속성을 구현 하는 방법을 효율적으로 형식 멤버 조회에 대 한 내부 기술에 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-141">For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</span></span> <span data-ttu-id="0d52b-142">이러한 내부 요소에 대 한 액세스 읽기 및 쓰기에 제공 된 Api XAML으로 사용 됩니다 <xref:System.Windows.Markup.XamlWriter> 하 고 <xref:System.Windows.Markup.XamlReader> 에서 <xref:System.Windows.Markup> 네임 스페이스 및 PresentationFramework 어셈블리입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-142">Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and <xref:System.Windows.Markup.XamlReader> from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly.</span></span> <span data-ttu-id="0d52b-143">그러나 하위 수준 XAML 판독기 및 XAML 작성기에서 System.Xaml 어셈블리로 마이그레이션 되었습니다 (클래스 기반 <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) WPF 내부 구조에 대 한 액세스 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-143">However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) do not have access to the WPF internals.</span></span> <span data-ttu-id="0d52b-144">모든 WPF 특정 어셈블리에 System.Xaml에는 종속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-144">There is no dependency from System.Xaml to any WPF-specific assembly.</span></span> <span data-ttu-id="0d52b-145">WPF 내부 구조에 대 한 액세스를 하지 않고 System.Xaml 판독기 및 작성기 올바르게 로드할 수 없습니다 또는 모든 WPF 저장 형식 또는 형식에 따라 WPF 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-145">Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</span></span> <span data-ttu-id="0d52b-146">특히 System.Xaml 판독기 및 작성기 지원 속성 저장소 또는 WPF 스타일, 리소스 사전 및 템플릿을 사용 하는 방법의 모든 세부 사항을 WPF 종속성 속성과 같은 개념을 이해 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-146">In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</span></span> <span data-ttu-id="0d52b-147">따라서는 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-147">Therefore you have a choice to make:</span></span>  
  
-   <span data-ttu-id="0d52b-148">WPF 형식을 로드 하는 경우 어떤 방식으로든에서 BAML 양식에서 XAML을 사용 하는, PresentationFramework XAML 판독기 및 XAML 작성기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-148">If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</span></span>  
  
-   <span data-ttu-id="0d52b-149">모든 WPF 형식 또는 BAML 양식의 XAML 사용 하지 않고도 다른 특정 기술을 XAML 판독기 또는 XAML 작성기 구현 프레임 워크에 관련 된 이유로 사용 하지 않는 경우 System.Xaml XAML 판독기 및 XAML 작성기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-149">If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</span></span>  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a><span data-ttu-id="0d52b-150">System.Xaml 구현은.NET 4의 백업</span><span class="sxs-lookup"><span data-stu-id="0d52b-150">System.Xaml Backing Implementation in .NET 4</span></span>  
 <span data-ttu-id="0d52b-151"><xref:System.Windows.Markup.XamlReader> WPF 프레임 워크 수준 XAML 파서에 대 한 호출 가능 API 화면이입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-151"><xref:System.Windows.Markup.XamlReader> is the callable API surface for the WPF framework-level XAML parser.</span></span> <span data-ttu-id="0d52b-152">동일한 기본 XAML 파서를 로드 하 고 대상으로 하는 WPF 애플리케이션에 대 한 구문 분석 하는 런타임에 XAML 성능도 [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] 고 [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-152">The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].</span></span>  
  
 <span data-ttu-id="0d52b-153">대상으로 하는 경우 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], 외부 API는 동일 하지만 구현의 일부는 기반을 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 다양 한 XAML을 구문 분석의 기술 및 보고 측면을 개선 하는 System.Xaml 어셈블리에 일반 XAML 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-153">If you are targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</span></span> <span data-ttu-id="0d52b-154">대상 지정 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 포함 하 여 System.Xaml 참조 및 구현의 세부 사항으로 System.Xaml에서 보고 된 예외가 발생할 때는 형식을 정의 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-154">Targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</span></span>  
  
## Examples  
 <span data-ttu-id="0d52b-155">다음 예제는 <xref:System.Windows.Controls.Button> 사용 하 여 문자열을 <xref:System.Windows.Markup.XamlWriter> 클래스.</span><span class="sxs-lookup"><span data-stu-id="0d52b-155">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="0d52b-156">문자열은 다음 다시 로드를 <xref:System.Windows.Controls.Button> 정적을 사용 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 메서드를 <xref:System.Windows.Markup.XamlReader> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-156">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0d52b-157"><see cref="T:System.Windows.Markup.XamlReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-157">Initializes a new instance of the <see cref="T:System.Windows.Markup.XamlReader" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0d52b-158">현재 보류 중인 비동기 로드 작업이 있으면 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-158">Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> 비동기 작업입니다. 따라서 일부 로드 작업이 중단 될 전에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0d52b-160"><see cref="T:System.Xaml.XamlSchemaContext" />에 대한 WPF 스키마 컨텍스트 설정을 나타내는 <see cref="T:System.Windows.Markup.XamlReader" /> 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-160">Returns a <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></summary>
        <returns><span data-ttu-id="0d52b-161"><see cref="T:System.Xaml.XamlSchemaContext" />에 대한 WPF 스키마 컨텍스트 설정을 나타내는 <see cref="T:System.Windows.Markup.XamlReader" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-161">A <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d52b-162">XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-162">Reads XAML input and returns the root of the corresponding object tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="0d52b-163">스트림 형식으로 로드할 XAML입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-163">The XAML to load, in stream form.</span></span></param>
        <summary><span data-ttu-id="0d52b-164">지정된 <see cref="T:System.IO.Stream" />에서 XAML 입력을 읽고 해당 개체 트리의 루트인 <see cref="T:System.Object" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-164">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an <see cref="T:System.Object" /> that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-165">만든 개체 트리의 루트에 있는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-165">The object at the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0d52b-166">저장 하는 다음 예제는 <xref:System.Windows.Controls.Button> 에 <xref:System.IO.MemoryStream> 사용 하 여를 <xref:System.Windows.Markup.XamlWriter> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-166">The following example saves a <xref:System.Windows.Controls.Button> into a <xref:System.IO.MemoryStream> using the <xref:System.Windows.Markup.XamlWriter> class.</span></span> <span data-ttu-id="0d52b-167">스트림에 다음 다시 로드를 <xref:System.Windows.Controls.Button> 정적을 사용 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 메서드를 <xref:System.Windows.Markup.XamlReader> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-167">The stream is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-168"><paramref name="stream" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-168"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="0d52b-169"><see cref="T:System.Xaml.XamlReader" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-169">A <see cref="T:System.Xaml.XamlReader" /> object.</span></span> <span data-ttu-id="0d52b-170">입력 XAML을 사용하여 초기화되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-170">This is expected to be initialized with input XAML.</span></span></param>
        <summary><span data-ttu-id="0d52b-171">제공된 <see cref="T:System.Xaml.XamlReader" />에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-171">Reads the XAML input through a provided <see cref="T:System.Xaml.XamlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-172">만든 개체 트리의 루트인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-172">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-173">입력 <xref:System.Xaml.XamlReader> 수 <xref:System.Windows.Baml2006.Baml2006Reader>입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-173">The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>.</span></span> <span data-ttu-id="0d52b-174">런타임 시 또는 지역화 도구를 위해 BAML에 로드 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-174">This is how you can load BAML at run time, or for localization tool purposes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-175"><paramref name="reader" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-175"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="0d52b-176">XML 형식으로 로드하기 위해 이미 XAML 입력을 로드한 <see cref="T:System.Xml.XmlReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-176">The <see cref="T:System.Xml.XmlReader" /> that has already loaded the XAML input to load in XML form.</span></span></param>
        <summary><span data-ttu-id="0d52b-177">지정된 <see cref="T:System.Xml.XmlReader" />에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-177">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-178">만든 개체 트리의 루트인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-178">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0d52b-179">다음 예제는 <xref:System.Windows.Controls.Button> 사용 하 여 문자열을 <xref:System.Windows.Markup.XamlWriter> 클래스.</span><span class="sxs-lookup"><span data-stu-id="0d52b-179">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="0d52b-180">문자열은 다음 다시 로드를 <xref:System.Windows.Controls.Button> 정적을 사용 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 메서드를 <xref:System.Windows.Markup.XamlReader> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-180">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-181"><paramref name="reader" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-181"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="0d52b-182">로드할 XAML 입력이 들어 있는 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-182">The stream that contains the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="0d52b-183">파서에서 사용하는 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-183">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="0d52b-184">지정된 <see cref="T:System.IO.Stream" />에서 XAML 입력을 읽고 해당 개체 트리의 루트인 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-184">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-185">만든 개체 트리의 루트인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-185">The object that is the root of the created object tree.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-186"><paramref name="stream" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-186"><paramref name="stream" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0d52b-187">또는</span><span class="sxs-lookup"><span data-stu-id="0d52b-187">-or-</span></span> 
 <span data-ttu-id="0d52b-188"><paramref name="parserContext" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-188"><paramref name="parserContext" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d52b-189">XAML 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-189">Reads XAML markup and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="0d52b-190">로드할 XAML 입력이 들어 있는 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-190">The stream containing the XAML input to load.</span></span></param>
        <summary><span data-ttu-id="0d52b-191">지정된 <see cref="T:System.IO.Stream" />에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-191">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-192">만든 개체 트리의 루트인 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-192">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-193">비동기 XAML 로드 작업은 루트 개체 순수 하 게 하는 개체를 반환 처음 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-193">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="0d52b-194">비동기적으로 XAML을 구문 분석 한 다음 계속 되 고 루트 아래의 모든 자식 개체가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-194">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="0d52b-195">이 동작 및 해당 개체 수명의 개념 WPF와의 상호 작용을 처리 하는 일반적인 WPF XAML 대조적입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-195">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="0d52b-196">일반적인 (비동기가 아닌) 상호 작용 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하 여 개체의 모든 속성이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-196">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="0d52b-197">해당 동작 상향식 방법론을 사용할 수 있으려면 마지막 개체인는 루트 개체 트리를 만드는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-197">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="0d52b-198">일반적으로 WPF 애플리케이션의 개체 트리의 특정 위치에 반환된 된 개체 할당, 콘텐츠는 기술 자료를 사용 하 여 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우에 증분 레이아웃 업데이트를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-198">You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="0d52b-199">따라서 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 경우 알림을 애플리케이션별 논리 또는 애플리케이션 상태를 사용 하는 <xref:System.Windows.Markup.XamlReader.LoadCompleted> 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-199">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="0d52b-200">되려면에서 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> 입력을 비동기적으로 XAML을 로드 하려면 입력 XAML 루트 요소 특성 및 값을 포함 해야 합니다 `x:SynchronousMode="Async"`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-200">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="0d52b-201">값은 대/소문자입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-201">The value is treated as case sensitive.</span></span> <span data-ttu-id="0d52b-202">XAML 입력된 루트에 없으면 `x:SynchronousMode="Async"`예외가 throw 되 고 호출은 동기 로드로 처리 됩니다 (참조 <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).</span><span class="sxs-lookup"><span data-stu-id="0d52b-202">If the XAML input root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).</span></span>  
  
 <span data-ttu-id="0d52b-203">인스턴스당 하나의 비동기 로드 작업을 <xref:System.Windows.Markup.XamlReader> 클래스는 한 번에 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-203">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="0d52b-204">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <xref:System.Windows.Markup.XamlReader> 클래스는 <xref:System.InvalidOperationException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-204">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-205"><paramref name="stream" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-205"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0d52b-206">여러 로드 조작은 동일한 <see cref="T:System.Windows.Markup.XamlReader" />로 동시에 보류됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-206">Multiple load operations are pending concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="0d52b-207">이미 XAML 입력을 로드한/읽은 기존 <see cref="T:System.Xml.XmlReader" />입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-207">An existing  <see cref="T:System.Xml.XmlReader" /> that has already loaded/read the XAML input.</span></span></param>
        <summary><span data-ttu-id="0d52b-208">지정된 <see cref="T:System.Xml.XmlReader" />에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-208">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-209">만든 개체 트리의 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-209">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-210">비동기 XAML 로드 작업은 루트 개체 순수 하 게 하는 개체를 반환 처음 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-210">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="0d52b-211">비동기적으로 XAML을 구문 분석 한 다음 계속 되 고 루트 아래의 모든 자식 개체가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-211">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="0d52b-212">이 동작 및 해당 개체 수명의 개념 WPF와의 상호 작용을 처리 하는 일반적인 WPF XAML 대조적입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-212">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="0d52b-213">일반적인 (비동기가 아닌) 상호 작용 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하 여 개체의 모든 속성이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-213">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="0d52b-214">해당 동작 상향식 방법론을 사용할 수 있으려면 마지막 개체인는 루트 개체 트리를 만드는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-214">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="0d52b-215">일반적으로 반환 된 개체를 할당 합니다 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> 일부 위치로 애플리케이션의 개체 트리는 콘텐츠 정보를 사용 하 여 계속 채워지고 및 전체가의 일부로 노출 되는 경우 증분 레이아웃 업데이트가 발생할 수는 UI입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-215">You typically would assign the returned object from <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="0d52b-216">따라서 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 경우 알림을 애플리케이션별 논리 또는 애플리케이션 상태를 사용 하는 <xref:System.Windows.Markup.XamlReader.LoadCompleted> 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-216">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="0d52b-217">되려면에서 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> XAML 입력을 비동기적으로 로드할 XAML 태그의 루트 요소 특성 및 값을 포함 해야 합니다 `x:SynchronousMode="Async"`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-217">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="0d52b-218">값은 대/소문자입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-218">The value is treated as case sensitive.</span></span> <span data-ttu-id="0d52b-219">XAML 태그 루트에 없으면 `x:SynchronousMode="Async"`예외가 throw 되지 고 호출은 동기 로드로 대신 처리 됩니다 (참조 <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).</span><span class="sxs-lookup"><span data-stu-id="0d52b-219">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).</span></span>  
  
 <span data-ttu-id="0d52b-220">인스턴스당 하나의 비동기 로드 작업을 <xref:System.Windows.Markup.XamlReader> 클래스는 한 번에 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-220">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="0d52b-221">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <xref:System.Windows.Markup.XamlReader> 클래스는 <xref:System.InvalidOperationException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-221">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-222"><paramref name="reader" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-222"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0d52b-223">여러 로드 조작은 동일한 <see cref="T:System.Windows.Markup.XamlReader" />를 사용하여 동시에 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-223">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="0d52b-224">로드할 XAML 입력이 들어 있는 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-224">A stream containing the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="0d52b-225">파서에서 사용하는 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-225">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="0d52b-226">지정된 <see cref="T:System.IO.Stream" />에서 XAML 입력을 읽고 해당 개체 트리의 루트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-226">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="0d52b-227">만든 개체 트리의 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-227">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-228">비동기 XAML 로드 작업은 루트 개체 순수 하 게 하는 개체를 반환 처음 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-228">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="0d52b-229">비동기적으로 XAML을 구문 분석 한 다음 계속 되 고 루트 아래의 모든 자식 개체가 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-229">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="0d52b-230">이 동작 및 해당 개체 수명의 개념 WPF와의 상호 작용을 처리 하는 일반적인 WPF XAML 대조적입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-230">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="0d52b-231">일반적인 (비동기가 아닌) 상호 작용 요소를 반환 하 고 로드 된 것으로 보고 하기 전에 모든 자식 컬렉션을 포함 하 여 개체의 모든 속성이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-231">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="0d52b-232">해당 동작 상향식 방법론을 사용할 수 있으려면 마지막 개체인는 루트 개체 트리를 만드는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-232">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="0d52b-233">일반적으로 애플리케이션의 개체 트리의 특정 위치에 반환된 된 개체 할당, 콘텐츠는 기술 자료를 사용 하 여 계속 채워지고 및 전체가 UI의 일부로 노출 되는 경우에 증분 레이아웃 업데이트를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-233">You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="0d52b-234">따라서 일반적인 격리 또는 XAML에서 비동기적으로 로드 된 모든 개체를 가상화 하 고 경우 알림을 애플리케이션별 논리 또는 애플리케이션 상태를 사용 하는 <xref:System.Windows.Markup.XamlReader.LoadCompleted> 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-234">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="0d52b-235">되려면에서 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> 태그를 비동기적으로 로드 하려면 XAML 태그의 루트 요소 특성 및 값을 포함 해야 합니다 `x:SynchronousMode="Async"`합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-235">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="0d52b-236">값은 대/소문자입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-236">The value is treated as case sensitive.</span></span> <span data-ttu-id="0d52b-237">XAML 태그 루트에 없으면 `x:SynchronousMode="Async"`예외가 throw 되 고 호출은 동기 로드로 처리 됩니다 (참조 <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).</span><span class="sxs-lookup"><span data-stu-id="0d52b-237">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).</span></span>  
  
 <span data-ttu-id="0d52b-238">인스턴스당 하나의 비동기 로드 작업을 <xref:System.Windows.Markup.XamlReader> 클래스는 한 번에 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-238">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="0d52b-239">동일한 인스턴스에서 둘 이상의 비동기 작업을 시도 하는 경우는 <xref:System.Windows.Markup.XamlReader> 클래스는 <xref:System.InvalidOperationException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-239">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0d52b-240"><paramref name="stream" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="0d52b-240"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0d52b-241">여러 로드 조작은 동일한 <see cref="T:System.Windows.Markup.XamlReader" />를 사용하여 동시에 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-241">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0d52b-242">비동기 로드 작업이 완료되면 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-242">Occurs when an asynchronous load operation completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted> 비동기 로드 작업을 중단 하는 경우에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted> is also raised when an asynchronous load operation aborts.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0d52b-244">지정된 텍스트 문자열에서 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-244">Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="0d52b-245">단일 텍스트 문자열인 입력 XAML입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-245">The input XAML, as a single text string.</span></span></param>
        <summary><span data-ttu-id="0d52b-246">지정된 텍스트 문자열에서 XAML 입력을 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-246">Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="0d52b-247">만든 개체 트리의 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-247">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-248">구현 호출 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 문자열에서 스트림을 만든 후에 내부적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-248">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="0d52b-249">참조 <xref:System.Windows.Markup.XamlReader.Load%2A> 가능한 예외와 같은 추가 정보.</span><span class="sxs-lookup"><span data-stu-id="0d52b-249">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="0d52b-250">단일 텍스트 문자열인 입력 XAML입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-250">The input XAML, as a single text string.</span></span></param>
        <param name="parserContext"><span data-ttu-id="0d52b-251">파서에서 사용하는 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-251">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="0d52b-252">지정된 <see cref="T:System.Windows.Markup.ParserContext" />를 사용하여 지정된 텍스트 문자열에서 XAML 태그를 읽고 지정된 태그의 루트에 해당하는 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-252">Reads the XAML markup in the specified text string (using a specified <see cref="T:System.Windows.Markup.ParserContext" />) and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="0d52b-253">만든 개체 트리의 루트입니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-253">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0d52b-254">구현 호출 하 여 <xref:System.Windows.Markup.XamlReader.Load%2A> 문자열에서 스트림을 만든 후에 내부적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="0d52b-254">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="0d52b-255">참조 <xref:System.Windows.Markup.XamlReader.Load%2A> 가능한 예외와 같은 추가 정보.</span><span class="sxs-lookup"><span data-stu-id="0d52b-255">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>