<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ada487929a3270b8b3a3f316486ea10531a71ff1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39762301" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>탐색을 지원하는 메서드, 속성 및 이벤트가 들어 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 브라우저 스타일 탐색의 컨텍스트 내에서 콘텐츠를 다운로드 하는 기능을 캡슐화 합니다.  
  
 콘텐츠 HTML 파일과.NET Framework 개체의 형식일 수 있습니다. 그러나 일반적으로 페이지는 콘텐츠를 탐색 하는 방법으로 기본 설정 (참조 <xref:System.Windows.Controls.Page>).  
  
 개체의 인스턴스를 제공 하 고 오버 로드를 호출 하 여 콘텐츠를 탐색할 수 있습니다는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 개체를 허용 하는 메서드:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 상대 또는 절대 URI 중 하나에 전달 하 여에 콘텐츠를 이동 하 게 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> URI를 허용 하는 메서드 오버 로드 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 URI에서 콘텐츠를 탐색 하는 경우 <xref:System.Windows.Navigation.NavigationService> 내용이 들어 있는 개체를 반환 합니다.  
  
 다음 이벤트를 통해 탐색의 수명을 추적할 수 있습니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>.  
  
 일부 이벤트 탐색 발생 될 때마다 발생 하는 발생 하는 이벤트 집합에는 (취소 됨, 중지 또는 실패) 형식 (콘텐츠 또는 콘텐츠 조각) 발생 하는 탐색 및 탐색을 완료 하는 방법에 따라 결정 됩니다.  
  
 다음 그림에서는 이러한 이벤트가 발생 하는 시퀀스를 보여 줍니다.  
  
 ![페이지 탐색 흐름 차트](~/add/media/navigationoverviewfigure11.png "페이지 탐색 흐름 차트")  
  
 하는 동안 또는 탐색 후 <xref:System.Windows.Navigation.NavigationService> 찾았고, 탐색 중인 콘텐츠에의 URI를 포함 하 여 콘텐츠에 대 한 정보를 제공 (<xref:System.Windows.Navigation.NavigationService.Source%2A>), 현재 콘텐츠의 URI (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>), 그리고 포함 된 개체는 탐색 된 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>).  
  
 콘텐츠를 탐색할 때 <xref:System.Windows.Navigation.NavigationService> 탐색 항목으로 탐색 기록에 기록 합니다. 호출 하 여 새 탐색 중 발생 하는 경우 후방 탐색 기록에 항목이 추가 됩니다는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 메서드를 호출 하 여 전방 탐색 기록의 항목으로 이동 하 여 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>합니다. 호출 하 여 탐색 기록을 뒤에 항목으로 이동 하 여 전방 탐색 기록에 항목이 추가 됩니다 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>합니다. <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 및 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 있는지 여부를 보고 하 고 전방 탐색 기록 항목 뒤에 각각 있습니다. 또한 가장 최근 항목이 후방 탐색 기록을 호출 하 여 제거할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>합니다.  
  
 기본적으로 <xref:System.Windows.Navigation.NavigationService> 탐색 기록의 콘텐츠 개체의 인스턴스를 저장 하지 않습니다. 대신 <xref:System.Windows.Navigation.NavigationService> 탐색 기록을 사용 하 여 탐색할 때마다 콘텐츠 개체의 새 인스턴스를 만듭니다. 이 동작은 큰 숫자 및 대규모 콘텐츠를 탐색할 때 과도 한 메모리 소비를 방지 하도록 설계 되었습니다. 따라서 콘텐츠 상태는 다음 탐색 간에 기억 되지 않습니다. 그러나 WPF 탐색 기록에 콘텐츠의 부분에 대 한 상태 저장할 수 있는 몇 가지 방법을 제공 합니다.  
  
 사용 하 여 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, 여러 인스턴스를 단일 페이지에 대 한 상태 집합을 기억할 수도 있습니다.  
  
 <xref:System.Windows.Navigation.NavigationService> `sealed` 클래스 및 따라서 인스턴스화할 수 없습니다; 대신 <xref:System.Windows.Navigation.NavigationService> 탐색기에서 탐색을 사용 하도록 설정 하는 데 사용 됩니다. WPF에는 두 검색 기가: <xref:System.Windows.Navigation.NavigationWindow> 고 <xref:System.Windows.Controls.Frame>입니다.  
  
 시각적 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 사용 하 여 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 통합된 된 사용자 환경을 제공 하는 탐색기로 합니다. 물리적으로 하지만 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 실제로 사용 하 여 <xref:System.Windows.Navigation.NavigationWindow> 탐색기로를 <xref:System.Windows.Application.MainWindow%2A> 의 속성을 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 에서 실행 되 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 에 대 한 참조를 반환 합니다를 <xref:System.Windows.Navigation.NavigationWindow>, 및 탐색 기록을 관리 하는 <xref:System.Windows.Navigation.NavigationWindow> 에서 관리 되는 탐색 기록을 사용 하 여 통합 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 다음과 같은 방법으로:  
  
-   호출 하 여 콘텐츠를 탐색 하는 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, 및 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 내에서 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 관련 탐색 기록 항목에도 추가 됩니다 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 탐색 기록 합니다.  
  
-   때 항목에는 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 탐색 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 선택 [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)] 하면 <xref:System.Windows.Navigation.NavigationService> 뒤로 또는 앞으로 이러한 항목에 연관 된 콘텐츠를 이동할입니다.  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame> 호스팅하는 탐색기의 탐색 기록을 사용 하 여 또는 자체 탐색 기록을 제공할 수 있습니다. 하는 경우 <xref:System.Windows.Controls.Frame> 자체 탐색 기록이 제공 자체적으로 탐색을 표시할 수 있습니다 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 탐색 기록의 항목을 탐색 하려면 호스트 탐색기의 탐색 기록에 이러한 항목이 추가 되지 않습니다 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) 및 결과적으로 탐색할 수 없습니다 탐색에서 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 각 (참조 <xref:System.Windows.Controls.Frame.JournalOwnership%2A>).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">특정 콘텐츠 조각에 연결된 응용 프로그램 정의 상태를 나타내는 <see cref="T:System.Windows.Navigation.CustomContentState" /> 개체입니다.</param>
        <summary>후방 탐색 기록에 <see cref="T:System.Windows.Navigation.CustomContentState" /> 개체가 들어 있는 항목을 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>를 <xref:System.Windows.Navigation.CustomContentState>, 및 <xref:System.Windows.Navigation.IProvideCustomContentState> 여러 집합이 현재 내용에 대 한 상태를 기억 하는 데 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" />가 <see langword="null" />이고 <see cref="T:System.Windows.Navigation.CustomContentState" /> 개체가 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" />에서 반환되지 않은 경우</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>후방 탐색 기록에 항목이 최소한 하나 이상 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>후방 탐색 기록에 하나 이상의 항목이 있는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 후방 탐색 기록에 항목이 최소한 하나 이상 있는지 여부를 확인 합니다. 이 속성을 호출 하기 전에 검사 해야 합니다 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>같으면 <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 라고 후방 탐색 기록에 항목이 없음 및는 <xref:System.InvalidOperationException> throw 됩니다.  
  
> [!NOTE]
>  여러 탐색기에서 탐색 기록을 공유할 경우 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 가장 최근 항목 뒤에 탐색 기록 되지 추가 된 여는 <xref:System.Windows.Navigation.NavigationService> 현재 탐색기.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>전방 탐색 기록에 항목이 최소한 하나 이상 있는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>전방 탐색 기록에 하나 이상의 항목이 있는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 전방 탐색 기록에 항목이 최소한 하나 이상 있는지 여부를 확인 합니다. 이 속성을 호출 하기 전에 검사 해야 합니다 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>같으면 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 라고 전방 탐색 기록에 항목이 없음 및는 <xref:System.InvalidOperationException> throw 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 콘텐츠가 들어 있는 개체의 참조를 가져오거나 설정합니다.</summary>
        <value>현재 콘텐츠가 들어 있는 개체의 참조에 해당하는 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 콘텐츠는 두 가지 방법 중 하나로 설정할 수 있습니다.  
  
-   개체에 대 한 참조를 설정 하 여 직접 합니다.  
  
-   호출 하 여 직접 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>, <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>합니다.  
  
 설정 <xref:System.Windows.Navigation.NavigationService> 탐색 비동기 이므로 새 탐색; 시작 <xref:System.Windows.Navigation.NavigationService.Content%2A> 설정 된 후 바로 검사 하면 값을 반환 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마지막으로 탐색된 콘텐츠의 URI를 가져옵니다.</summary>
        <value>A <see cref="T:System.Uri" /> 고, 그렇지 않으면 URI를 사용 하 여 탐색 하는 경우 마지막으로 탐색 된 콘텐츠의 <see langword="null" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 값을 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 속성이 다른 URI로 탐색 성공적으로 완료 될 때까지 변경 되지 않습니다.  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 조각만 URI를 사용 하 여 설정할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 조각을 탐색하기 시작할 때 발생합니다. 원하는 조각이 현재 콘텐츠에 있으면 즉시 발생하고, 다른 콘텐츠에 있으면 소스 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 콘텐츠가 로드된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 콘텐츠 조각은 콘텐츠는 명명 된 포함 된 <xref:System.Windows.UIElement>는 <xref:System.Windows.UIElement> 인 <xref:System.Windows.FrameworkElement.Name%2A> 예: 특성이 설정 되어:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 이동할는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 형식은 접미사를 사용 하는 URI를 제공 하 여 조각:  
  
 \#*FragmentName*  
  
 다음 콘텐츠 조각으로 참조 하는 URI의 예를 보여 줍니다.  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 원본 페이지를 로드 한 후 (후 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트가 발생), 조각 탐색이 시작 되는 <xref:System.Windows.Navigation.NavigationService> 찾으려고 시도 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 조각. 경우는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 조각이 <xref:System.Windows.Navigation.NavigationService> 내용 찾기 지시 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 조각에 표시할입니다. 이 동작을 변경 해야 할 경우를 처리할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 자체 조각 탐색 동작을 제공 합니다. <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 전달 되는 <xref:System.Windows.Navigation.FragmentNavigationEventArgs> 유용한 속성은이 목적을 위해 노출 하는 매개 변수 포함:  
  
-   이 탐색 서비스를 소유 하는 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   조각 이름입니다.  
  
 처리할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 사용자 고유의 사용자 지정 구현으로 기본 WPF 조각 구현을 재정의 하 합니다. 이렇게 하면 경우 설정 해야 합니다 <xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A> 를 `true`고, 그렇지 않으면 기본 WPF 조각 처리 동작이 적용 됩니다.  
  
 직접 내에서 탐색을 시작 하면이 안 된 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 이벤트 처리기입니다. 하므로 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 에서 새 탐색을 시작 하는 기존 탐색을 하는 동안 발생을 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 이벤트 처리기가 발생 시킬 수 있는 중첩 된 탐색은 <xref:System.ExecutionEngineException> throw 됩니다. 대신 있습니다 간접적으로 시작할 수 탐색 항목으로 사용 하 여 비동기 작업을 만들어 여 <xref:System.Windows.Threading.Dispatcher>입니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>, 발생 <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
> [!IMPORTANT]
>  조각 탐색 느슨한 지원 되지 않습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지 (태그만 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일을 사용 하 여 `Page` 루트 요소로) 다음과 같은 경우:  
>   
>  • 완화의 조각을 탐색 하는 경우 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지입니다.  
>   
>  완화를 탐색할 때 • [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 느슨한 다른 조각에는 페이지 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지입니다.  
>   
>  그러나 느슨한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 페이지에서 자체 조각을 탐색할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 조각을 사용자 지정 탐색 동작을 제공 합니다. 이 경우 오류를 열고 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 하는 경우 페이지 소스의 조각 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 페이지를 찾을 수 없습니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">탐색기에서 호스팅되는 콘텐츠의 <see cref="T:System.Windows.DependencyObject" />입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.Navigation.NavigationService" />가 들어 있는 콘텐츠의 탐색기에 대한 <see cref="T:System.Windows.DependencyObject" />의 참조를 가져옵니다.</summary>
        <returns>지정된 <see cref="T:System.Windows.DependencyObject" />가 들어 있는 콘텐츠의 탐색기에 대한 <see cref="T:System.Windows.Navigation.NavigationService" />의 참조입니다. 경우에 따라 <see langword="null" />일 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기에는 <xref:System.Windows.Navigation.NavigationService> 콘텐츠 탐색을 처리 하는 합니다. WPF에는 두가지: <xref:System.Windows.Navigation.NavigationWindow> 고 <xref:System.Windows.Controls.Frame>입니다. 탐색기 탐색 요청을 처리 하 고 탐색 수명 관리를으로 구현 되는 WPF 탐색 서비스를 사용 하 여 <xref:System.Windows.Navigation.NavigationService> 클래스입니다. 탐색기에서 호스트 되는 콘텐츠를 탐색기에 대 한 참조를 가져올 수 있습니다 <xref:System.Windows.Navigation.NavigationService> 를 호출 하 여는 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 메서드.  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 반환 `null` 경우는 `dependencyObject`:  
  
-   가 <xref:System.Windows.Navigation.NavigationWindow>합니다.  
  
-   가 <xref:System.Windows.Controls.Frame> 입니다.  
  
    1.  다른 탐색기에 의해 호스팅됩니다.  
  
    2.  에 해당 <xref:System.Windows.Controls.Frame.JournalOwnership%2A> 속성이 설정 <xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>합니다.  
  
-   탐색기에서 호스트 되는 콘텐츠 일부가 아닙니다.  
  
 WPF에 대 한 참조를 획득 하기 위해 두 개의 바로 가기를 제공 합니다 <xref:System.Windows.Navigation.NavigationService>:  
  
-   <xref:System.Windows.Navigation.NavigationService> 탐색을 처리 하는 <xref:System.Windows.Controls.Page> 에서 액세스할 수 있습니다 합니다 <xref:System.Windows.Controls.Page> 자체의 값을 가져오고 해당 <xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType> 속성입니다.  
  
-   합니다 <xref:System.Windows.Navigation.NavigationService> 에서 사용 되는 <xref:System.Windows.Controls.Frame> 탐색을 처리 하는 데의 가치를 창출 하 여 액세스할 수 있습니다는 <xref:System.Windows.Controls.Frame.NavigationService%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게를 <xref:System.Windows.Controls.UserControl> 탐색 서비스를 호출 하 여 검색할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>합니다.  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> 매개 변수가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>후방 탐색 기록(있는 경우)에서 최신 항목을 탐색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하기 전에 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 후방 탐색 기록에 항목이 있는지 여부를 확인 하려면 속성을 검사할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 가장 최근 항목 뒤에 후방 탐색 기록 탐색, 있는 경우.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">후방 탐색 기록에 항목이 없을 때 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" />이 호출된 경우</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>전방 탐색 기록(있는 경우)에서 최신 항목을 탐색합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하기 전에 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>, <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 전방 탐색 기록에 항목이 있는지 여부를 확인 하려면 속성을 검사할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 있을 경우 전방 탐색 기록에서 가장 최근 항목으로 이동 합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">전방 탐색 기록에 항목이 없을 때 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />가 호출된 경우</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>탐색된 콘텐츠가 로드 및 구문 분석되어 렌더링되기 시작할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 로드 완료 시 탐색 요청에 대 한 관련 정보를 검색 하는 경우. 이 정보를 확인할 합니다 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트 처리기를 포함:  
  
-   콘텐츠를 해당 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>합니다.  
  
-   응답 세부 정보 (사용 하는 <xref:System.Net.WebResponse> 개체).  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 원본 페이지를 찾거나 경우 로드 될 수 없습니다 발생 하지 않습니다 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 발생 합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>, 발생 <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 소스 콘텐츠를 비동기적으로 탐색합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">탐색 대상 콘텐츠가 들어 있는 개체입니다.</param>
        <summary>개체에 들어 있는 콘텐츠를 비동기적으로 탐색합니다.</summary>
        <returns>탐색이 취소되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 으로 이동 합니다 <xref:System.Object> 에 지정 된 `root` 다음 조건이 true 인 경우:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트가 취소 되지 않습니다.  
  
-   웹 요청 (참조 <xref:System.Windows.Navigation.NavigationService.Navigating>)를 만들 수 있습니다.  
  
 하는 경우 `root` 됩니다 `null`, 기존 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 지워집니다.  
  
> [!NOTE]
>  웹 콘텐츠를 다운로드할 웹 예외가 나타날 수 있습니다 (예를 들어 404: 파일을 찾을 수 없습니다). 이러한 예외를 처리할 수 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>입니다.  
  
   
  
## Examples  
 다음 예제에서는 탐색 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.Page> 원본 콘텐츠 트리를 포함 하는 개체입니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">해당 콘텐츠의 URI가 초기화된 <see cref="T:System.Uri" /> 개체입니다.</param>
        <summary>URI에 지정된 콘텐츠를 비동기적으로 탐색합니다.</summary>
        <returns>탐색이 취소되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 변수의 `source` 은 웹 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 또는 유효한 pack URI (참조 [WPF의 Pack Uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md)).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 지정 된 URI로 이동 됩니다 `source` 다음 조건이 true 인 경우:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트가 취소 되지 않습니다.  
  
-   웹 요청 (참조 <xref:System.Windows.Navigation.NavigationService.Navigating>)를 만들 수 있습니다.  
  
 하는 경우 `source` 됩니다 `null`, 기존 콘텐츠 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 지워집니다.  
  
> [!NOTE]
>  웹 콘텐츠를 다운로드할 웹 예외가 나타날 수 있습니다 (예를 들어 404: 파일을 찾을 수 없습니다). 이러한 예외를 처리할 수 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>입니다.  
  
 사용할 수 있습니다 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 콘텐츠 조각으로 이동 합니다. URI로 식별 된 콘텐츠가 현재 콘텐츠 인 경우 다시 다운로드 되지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 URI로 이동 하는 방법을 보여 줍니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">탐색 대상 콘텐츠가 들어 있는 개체입니다.</param>
        <param name="navigationState">탐색 도중 처리하는 데 사용할 데이터가 들어 있는 개체입니다.</param>
        <summary>개체에 들어 있는 콘텐츠를 비동기적으로 탐색하고, 탐색 도중 처리하는 데 사용할 데이터가 들어 있는 개체를 전달합니다.</summary>
        <returns>탐색이 취소되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 같은 동작 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>이지만 개체 URI 대신 전달 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 탐색 하는 방법을 보여 줍니다는 <xref:System.Windows.Controls.Page> 개체 소스 콘텐츠를 포함 하 고 탐색 상태를 전달 합니다.  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">해당 콘텐츠의 URI가 초기화된 <see cref="T:System.Uri" /> 개체입니다.</param>
        <param name="navigationState">탐색 도중 처리하는 데 사용할 데이터가 들어 있는 개체입니다.</param>
        <summary>URI에 있는 소스 콘텐츠를 비동기적으로 탐색하고, 탐색 도중 처리에 사용할 데이터가 들어 있는 개체를 전달합니다.</summary>
        <returns>탐색이 취소되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색은 비동기적 이므로 이므로 여러 탐색을 동시에 진행 될 수 있습니다. 예를 들어, 단일 페이지에 두 개의 자식 프레임이 있는 경우 모두 프레임을 탐색할 수 있습니다. 이 예에서 발생 하는 다양 한 탐색 이벤트 <xref:System.Windows.Navigation.NavigationService> 콘텐츠를 탐색 중인 각 부분에 대 한 번 발생 한 여러 되며 반드시 순서에 탐색이 요청을 수 있습니다. 따라서 특정 탐색 요청을 개별 요청에 관련 된 데이터를 처리 하는 경우 탐색에 대 한 모든 요청에서 사용 가능한 데이터를 사용할 수 없습니다. 대신, 사용할 수 있습니다 `navigationState` 탐색 요청을 처리 하는 탐색 관련이 대 한 데이터를 전달 합니다.  
  
 다음 이벤트 인수를 탐색 상태에 대 한 액세스를 제공합니다.  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (전달 된 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트).  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (전달 된 <xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트 처리기).  
  
   
  
## Examples  
 다음 예제에서는 URI로 이동 하 고 탐색 상태를 전달 하는 방법을 보여 줍니다.  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">해당 콘텐츠의 URI가 초기화된 <see cref="T:System.Uri" /> 개체입니다.</param>
        <param name="navigationState">탐색 도중 처리하는 데 사용할 데이터가 들어 있는 개체입니다.</param>
        <param name="sandboxExternalContent">
          <see langword="true" />인 경우 콘텐츠를 기본 인터넷 영역 권한 집합과 함께 부분 신뢰 보안 샌드박스로 다운로드합니다. 기본값은 <see langword="false" />입니다.</param>
        <summary>URI에 있는 소스 콘텐츠를 비동기적으로 탐색하고, 탐색 도중 처리할 탐색 상태가 들어 있는 개체를 전달하며 샌드박스에 콘텐츠를 전달합니다.</summary>
        <returns>탐색이 취소되지 않았으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 독립 실행형 응용 프로그램에만이 메서드는 및 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 콘텐츠입니다.  
  
 이 방법으로 동일한 동작이 나타납니다 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>를 확장 하 여 부분 신뢰 보안 샌드박스로 다운로드 중인 콘텐츠가 배치 되는 확인 (사용 권한-의 기본 인터넷 영역 집합을 사용 하 여 참조 [WPF 부분 신뢰 보안](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>탐색 대상 콘텐츠를 찾았고, 아직 완전히 로드되지 않았지만 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 속성을 통해 콘텐츠를 사용할 수 있는 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리 <xref:System.Windows.Navigation.NavigationService.Navigated> 다운로드를 시작할 때 탐색 요청에 대 한 관련 정보를 검색 하는 경우. 이 정보를 확인할 합니다 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.Navigated> 이벤트 처리기를 포함:  
  
-   원본 페이지입니다. 때 <xref:System.Windows.Navigation.NavigationService.Navigated> 이 발생 하면 원본 페이지의 일부 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 트리를 구문 분석 하 고 대상 콘텐츠 컨트롤에 연결 되었습니다.  
  
-   요청 된 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>합니다.  
  
-   응답 세부 정보 (사용 하는 <xref:System.Net.WebResponse> 개체).  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> 원본 페이지를 찾거나 경우 로드 될 수 없습니다 발생 하지 않습니다 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 발생 합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>, 발생 <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.Navigated>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>새 탐색이 요청되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 새 탐색 요청 되었지만 원본 하기 전에 콘텐츠 요청 될 때 포함 하는 경우 발생 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%2A>가 호출된 경우  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 또는 <xref:System.Windows.Navigation.NavigationService.GoForward%2A> 라고 (탐색에서 항목을 선택한 경우 또는 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]).  
  
-   콘텐츠 조각을 탐색 하는 경우  
  
 처리 <xref:System.Windows.Navigation.NavigationService.Navigating> 탐색이 시작 되기 전에 탐색 요청에 대 한 관련 정보를 검색 하는 경우. 이 정보를 확인할 합니다 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트 처리기입니다.  
  
 A <xref:System.Net.WebRequest> 탐색 만들어지고에서 사용할 수 있는 개체를 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 매개 변수는 실제 요청이 시점에서, 때문에 다시 구성할 수 있습니다는 <xref:System.Net.WebRequest> 개체, 필요한 경우.  
  
 처리할 수도 <xref:System.Windows.Navigation.NavigatingCancelEventArgs> 탐색을 취소할지를 설정 하 여 필요한 경우 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> true로 합니다. 탐색을 취소 하면 다른 탐색 이벤트가 발생 하지 않습니다.  
  
> [!NOTE]
>  응용 프로그램, 브라우저에서 호스팅되는 경우 취소 하 여 응용 프로그램에서 벗어날에서 사용자를 막을 수 없습니다는 <xref:System.Windows.Navigation.NavigationService.Navigating> 이벤트입니다.  
  
 탐색기에서 첫 번째 부분 콘텐츠를 탐색 하는 후 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>), 각 부분에서 탐색 되는 콘텐츠 탐색 기록에 추가 됩니다. 탐색 중인 콘텐츠에 대 한 상태 정보를 저장 해야 하는 경우 추가할 수 상태 해당 콘텐츠에 대 한 업무 일지 항목을 설정 하 여 <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> 사용 하 여를 <xref:System.Windows.Navigation.CustomContentState> 개체입니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.Navigating>, 발생 <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.Navigating> 정적 콘텐츠를 새로 고칠 요청이 수행 되었음을 여부 및 요청을 취소 하려는 경우를 감지할 수 있습니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요청된 콘텐츠를 탐색하는 동안 오류가 발생하면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 중 하나를 <xref:System.Net.WebException> 또는 <xref:System.IO.IOException> 탐색 중에 throw 되는 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 이벤트가 발생 합니다. <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 전달 되는 <xref:System.Windows.Navigation.NavigationFailedEventArgs> 예외 및 예외를 발생 시킨 탐색의 세부 정보에 대 한 정보를 캡슐화 하는 합니다.  
  
 예외가 실패 한 탐색에서 결과 처리 되지 않으면 다음 이벤트는 나열 된 순서로 발생 합니다.  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 또는 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>.  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 하나 이상의 탐색기에 의해 호스팅되면 `NavigationFailed` 그 중 하나에서 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>탐색 진행 정보를 제공하기 위해 다운로드하는 동안 정기적으로 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 전달 되는 <xref:System.Windows.Navigation.NavigationProgressEventArgs> 다음 진행률 정보를 노출 합니다.  
  
-   지금 다운로드 된 바이트 수 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>).  
  
-   다운로드 한 총 바이트 수 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>).  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 콘텐츠의 모든 1024 바이트에 대 한 다운로드 한 후 한 번 더 남아 있는 바이트 수는 1024 바이트 보다 작은 경우 발생 합니다. 이러한 이유로 처리 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 추적 하 고 현재 다운로드 진행률을 표시 하는 유용한 방법을 제공 합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 에 동일한 부분 콘텐츠를 탐색 하는 경우에 현재 로드 된 콘텐츠에 대해 콘텐츠 조각을 탐색 하는 경우 등 일부 경우에 발생 하지 않습니다 (즉, 값을 <xref:System.Windows.Navigation.NavigationService.Content%2A> 속성).  
  
 최종 컴파일된 XAML 리소스를 이동할 때 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 이벤트가 발생 하지 않을 수 있습니다. 즉, 다운로드가 끝나면 마지막 보고 있는지 <xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A> 값과 같지 않을 수 있습니다는 <xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A> 값입니다. 처리는 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 이벤트 탐색을 완료 하는 경우 알림을 받을 수 있습니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>, 발생 <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 메서드가 호출되거나 현재 탐색이 진행되는 동안 새 탐색이 요청될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 다운로드를 중지할 때 탐색 요청에 대 한 관련 정보를 검색 해야 합니다. 이 정보를 확인할 합니다 <xref:System.Windows.Navigation.NavigationEventArgs> 에 전달 되는 개체는 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 이벤트 처리기를 포함:  
  
-   요청 된 URI입니다.  
  
-   탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>).  
  
-   추가 데이터를 호출 하 여 탐색을 시작한 경우 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType> 또는 <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>합니다.  
  
> [!NOTE]
>  때 <xref:System.Windows.Navigation.NavigationService> 발생 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, 발생 <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> 이벤트에는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법을 보여 줍니다 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 콘텐츠를 다시 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 현재 콘텐츠 (의 값으로 지정 합니다 <xref:System.Windows.Navigation.NavigationService.Source%2A> 속성) 다시를 탐색 하는 <xref:System.Windows.Navigation.NavigationService> 콘텐츠를 다시 다운로드 하지 않습니다. 강제로 <xref:System.Windows.Navigation.NavigationService> 콘텐츠를 탐색 하는 다시 호출 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>합니다.  
  
 여부를 호출 하 여 현재 콘텐츠를 다시 탐색 하는 경우는 유의 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 또는 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>, 탐색 기록에 새 항목이 추가 되지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>후방 기록에서 최신 탐색 기록을 제거합니다.</summary>
        <returns>후방 탐색 기록에 <see cref="T:System.Windows.Navigation.JournalEntry" />가 있는 경우 최신 항목입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 두 개 이상의 탐색기 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 한 탐색기를 사용 하 여 수를 동일한 탐색 기록을 공유 <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A> 다른 탐색 창에서 발생 하는 탐색에 대 한 후방 탐색 기록 항목을 검색할 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 콘텐츠의 URI 또는 현재 탐색 대상인 새 콘텐츠의 URI를 가져오거나 설정합니다.</summary>
        <value>
          <see cref="T:System.Uri" /> 현재 콘텐츠 또는 현재 탐색 대상인 콘텐츠에 대 한 URI를 포함 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 표시 되 고 한 탐색기 보다 다른 URI로이 속성을 설정 하는 경우 (<xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>) 지정된 된 URI로 이동 합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 탐색을 취소 하지 않는 한, 탐색 URI에서 로드 되는 내용에 설정 됩니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 조각만 URI를 사용 하 여 설정할 수 있습니다 하 고 설정할 수 있는 `null`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 탐색 요청으로 인해 콘텐츠가 더 이상 다운로드되지 않게 중지합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 호출할 수는 즉시 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 반환 하 고 자식 프레임에서 진행 중인 탐색이 중지 됩니다.  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 호출 된 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 메서드를 발생 시킵니다는 <xref:System.Windows.Navigation.NavigationService.NavigationStopped> 이벤트입니다.  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 탐색을 시작한 동일한 스레드에서 호출 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 로드를 중지 하는 방법에 설명 합니다.  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>