<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d8f42d7fd84e44a45cf92bbe9edb7b518a077d4b" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53222267" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Windows Presentation Foundation 애플리케이션을 캡슐화합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 캡슐화 하는 클래스인 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 다음을 비롯 한 응용 프로그램별 기능을 합니다.  
  
-   **응용 프로그램 수명**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>를 <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>를 <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>를 <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>합니다.  
  
-   **응용 프로그램 범위 창, 속성 및 리소스 관리**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>를 <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>를 <xref:System.Windows.Application.Resources%2A>를 <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>합니다.  
  
-   **명령줄 매개 변수 및 종료 코드 처리**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>하십시오 <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>합니다.  
  
-   **탐색**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>를 <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>를 <xref:System.Windows.Application.NavigationFailed>를 <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>합니다.  
  
 <xref:System.Windows.Application> 해당 창, 속성 및 리소스 범위 서비스에 대 한 공유 액세스를 제공 하는 singleton 패턴을 구현 합니다. 결과적으로 인스턴스가 하나만 합니다 <xref:System.Windows.Application> 당 클래스를 만들 수 있습니다 <xref:System.AppDomain>합니다.  
  
 구현할 수는 <xref:System.Windows.Application> 태그, 태그 및 코드 숨김 또는 코드를 사용 합니다. 하는 경우 <xref:System.Windows.Application> 마크업 파일 태그 또는 태그 및 코드 숨김로 구성 해야 하는지 여부를 태그를 사용 하 여 구현 되는 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` 항목입니다.  
  
> [!NOTE]
>  독립 실행형 애플리케이션 필요 하지 않습니다는 <xref:System.Windows.Application> 개체를 사용자 지정을 구현 하는 것이 불가능 `static` 진입점 메서드 (`Main`)의 인스턴스를 만들지 않고 창이 열리는 <xref:System.Windows.Application>합니다. 그러나 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 필요는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 표준 애플리케이션은 어떻게만 태그를 사용 하 여 정의 합니다.  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 다음 예제에서는 표준 애플리케이션을 사용 하 여 정의 되는 방법만 코드:  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 다음 예제에서는 표준 애플리케이션은 어떻게 태그 및 코드 숨김의 조합을 사용 하 여 정의 합니다.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>공용 <see langword="static" /> (<see langword="Shared" /> Visual Basic의)이 형식의 멤버는 스레드로부터 안전 합니다. 또한를 <see cref="M:System.Windows.Application.FindResource(System.Object)" /> 하 고 <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> 메서드 및 <see cref="P:System.Windows.Application.Properties" /> 및 <see cref="P:System.Windows.Application.Resources" /> 속성은 스레드로부터 안전 합니다.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Application" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나의 인스턴스만 합니다 <xref:System.Windows.Application> 당 클래스를 만들 수 있습니다 <xref:System.AppDomain>를 단일 데이터 집합에 애플리케이션 범위 창, 속성 및 리소스에 대 한 공유 액세스를 보장 하기 위해. 따라서의 기본 생성자는 <xref:System.Windows.Application> 클래스 인스턴스가 초기화 되 고 첫 번째 인스턴스의 인지 검색를 <xref:System.AppDomain>그렇지 않을 경우는 <xref:System.InvalidOperationException> throw 됩니다.  
  
 합니다 <xref:System.Windows.Application> 현재 <xref:System.AppDomain> 정적에서 노출 되 <xref:System.Windows.Application.Current%2A> 속성입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Application" />당 <see cref="T:System.AppDomain" /> 클래스 인스턴스가 두 개 이상 만들어지는 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 포그라운드 애플리케이션이 될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나 이상의 열려 있는 창이 Windows Presentation Foundation 애플리케이션을 활성화 됩니다 (포그라운드 애플리케이션이 됨) 창 중 하나가 활성화 될 때 처음으로 애플리케이션이 시작 된 이후 또는 windows 중 하나가 활성화 되는 동안 애플리케이션이 활성 상태가 아닙니다: 활성화를 수행할지 특히 경우:  
  
-   애플리케이션의 첫 번째 창을 시작 합니다.  
  
-   사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 애플리케이션으로 전환 합니다.  
  
-   사용자는 애플리케이션에서 창 중 하나에 대 한 작업 표시줄 단추를 클릭합니다.  
  
 활성화 되는 시기를 감지 해야 하는 애플리케이션에서 처리할 수는 <xref:System.Windows.Application.Activated> 이벤트입니다.  
  
 애플리케이션 처음 활성화 한 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 모두 처리할 수는 애플리케이션의 동작 또는 상태 활성화 상태에 따라 달라 지, <xref:System.Windows.Application.Activated> 및 <xref:System.Windows.Application.Deactivated> 의 상태를 확인할 수 있습니다.  
  
 애플리케이션 활성화 되 면 <xref:System.Windows.Application.Activated> 애플리케이션이 활성 상태인 동안 얼마나 많은 windows 애플리케이션 내에서 활성화 됩니다에 관계 없이 애플리케이션이 비활성화 될 때까지 다시 발생 하지 것입니다.  
  
 <xref:System.Windows.Application.Activated> 에 대 한 발생 하지 않습니다 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 독립 실행형 애플리케이션을 활성화 및 비활성화 하는 경우를 감지 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 <see cref="T:System.Windows.Application" />에 대한 <see cref="T:System.AppDomain" /> 개체를 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Windows.Application" />에 대한 <see cref="T:System.AppDomain" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 가 당-<xref:System.AppDomain> 정적을 구현 하는 단일 형식 <xref:System.Windows.Application.Current%2A> 공유 액세스를 제공 하는 속성을 <xref:System.Windows.Application> 현재 인스턴스 <xref:System.AppDomain>합니다. 이 디자인 하 여 관리 되는 상태를 보장 <xref:System.Windows.Application>공유 리소스 및 상태를 포함 하 여은 단일 공유 위치에서 사용할 수 있습니다.  
  
 이 속성은 스레드로부터 안전 하며 모든 스레드에서 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 더 이상 포그라운드 애플리케이션이 아닐 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나 이상의 열려 있는 창이 Windows Presentation Foundation 애플리케이션을 비활성화 (포그라운드 애플리케이션이 더 이상) 사용자는 다음을 수행 하는 경우:  
  
-   ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 애플리케이션으로 전환 합니다.  
  
-   다른 애플리케이션의 창에 대 한 작업 표시줄 단추를 클릭합니다.  
  
 비활성화를 처리할 수를 검색 해야 하는 애플리케이션을 <xref:System.Windows.Application.Deactivated> 이벤트입니다.  
  
 애플리케이션 처음 활성화 한 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 모두 처리할 수는 애플리케이션의 동작 또는 상태 활성화 상태에 따라 달라 지, <xref:System.Windows.Application.Deactivated> 및 <xref:System.Windows.Application.Activated> 이벤트를 해당 상태를 확인 합니다.  
  
 <xref:System.Windows.Application.Deactivated> 에 대 한 발생 하지 않습니다 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 독립 실행형 애플리케이션을 비활성화 및 활성화 하는 경우를 감지 하는 방법을 보여 줍니다.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션에서 예외가 throw되었지만 처리되지 않은 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 Windows Presentation Foundation (올 이러한 예외를 보고할 수) 대화 상자에서 예외는 사용자에 게 알려줍니다 하며 애플리케이션에 자동으로 종료 처리 되지 않은 예외를 catch 합니다.  
  
 그러나는 애플리케이션을 중앙된 위치에서 사용자 지정 처리 되지 않은 예외 처리를 수행 하는 경우를 처리 해야 <xref:System.Windows.Application.DispatcherUnhandledException>합니다.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 발생 한 <xref:System.Windows.Application> 주 UI 스레드에서 실행 되는 코드에서 처리 되지 않은 각 예외에 대 한 합니다.  
  
 예외가 처리 되지 않은 경우에 UI 스레드 백그라운드 (스레드는 자체 <xref:System.Windows.Threading.Dispatcher>) 또는 백그라운드 작업자 스레드에서 (없이 스레드를 <xref:System.Windows.Threading.Dispatcher>), 예외 주 UI 스레드가에 전달 되지 않습니다. 따라서 <xref:System.Windows.Application.DispatcherUnhandledException> 발생 하지 않습니다. 이러한 상황에서는 다음을 수행 하는 코드를 작성 해야 합니다.  
  
1.  백그라운드 스레드에서 예외를 처리 합니다.  
  
2.  이러한 예외를 주 UI 스레드를 디스패치하십시오.  
  
3.  주 UI 스레드에서 처리를 허용 하도록 하지 않고도 rethrow <xref:System.Windows.Application.DispatcherUnhandledException> 발생 합니다.  
  
 자세한 내용은 참조는 [스레딩 모델](~/docs/framework/wpf/advanced/threading-model.md) 개요.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 이벤트 처리기에 전달 되는 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> 예외에 대 한 컨텍스트 정보를 포함 하는 인수 포함:  
  
-   예외 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   합니다 <xref:System.Windows.Threading.Dispatcher> 예외가 시작 된 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 이 정보를 사용 하 여 예외가 복구 가능한 지 여부를 결정할 수 있습니다. 복구 가능한 예외를 수 있습니다는 <xref:System.IO.FileNotFoundException>, 예를 들어, 복구할 수 없는 예외가 있을 때을 <xref:System.StackOverflowException>예를 들어 합니다.  
  
 처리 되지 않은 예외를 처리 하는 경우 <xref:System.Windows.Application.DispatcherUnhandledException>, 않으려는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 처리를 계속 하려면 설정 해야 합니다 <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> 속성을 `true`입니다.  
  
 다른 이벤트와 달리입니다 <xref:System.Windows.Application> 발생을 <xref:System.Windows.Application.DispatcherUnhandledException> 않습니다 하지 일치 하는 보호 가상 구현 (OnDispatcherUnhandledException). 따라서 클래스에서 파생 된 <xref:System.Windows.Application> 항상 사용 하 여 이벤트 처리기를 등록 해야 합니다 <xref:System.Windows.Application.DispatcherUnhandledException> 처리 되지 않은 예외를 처리 합니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하 여 처리 되지 않은 예외를 처리 하는 방법을 보여 줍니다는 <xref:System.Windows.Application.DispatcherUnhandledException> 이벤트입니다.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 종료되기 직전에 발생하며 취소할 수 없습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 이유 중 하나에 대 한 애플리케이션 종료 수 있습니다.  
  
-   합니다 <xref:System.Windows.Application.Shutdown%2A> 메서드를 <xref:System.Windows.Application> 의해 명시적으로 결정 또는 개체 호출 됩니다는 <xref:System.Windows.Application.ShutdownMode%2A> 속성입니다.  
  
-   사용자 로그 오프 하거나 종료 하 고 세션을 종료 합니다.  
  
 처리 하 여 애플리케이션 종료가 발생할 때를 감지할 수 있습니다는 <xref:System.Windows.Application.Exit> 이벤트, 필요에 따라 추가 처리를 수행 합니다.  
  
 처리할 수도 있습니다 <xref:System.Windows.Application.Exit> 검사 하거나 호출할 필요가 없는 경우 애플리케이션 종료 코드를 변경 하려면 <xref:System.Windows.Application.Shutdown%2A> 명시적으로 합니다. 종료 코드에서 노출 되는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 의 속성을 <xref:System.Windows.ExitEventArgs> 인수에 전달 되는 <xref:System.Windows.Application.Exit> 이벤트 처리기. 애플리케이션 실행을 중지, 종료 코드를 후속 처리에 대 한 운영 체제에 전달 됩니다.  
  
 애플리케이션에서 처리 하는 경우는 <xref:System.Windows.Application.SessionEnding> 이벤트 이후에 취소 하 고 <xref:System.Windows.Application.Exit> 발생 하지 않습니다 하 고 애플리케이션 종료 모드에 따라에서 실행을 계속 합니다.  
  
 종료 코드에서 설정할 수는 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]이지만 값이 무시 됩니다.  
  
 에 대 한 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> 다음과 같은 경우에 발생 합니다.  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 에서 탐색 합니다.  
  
-   [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]때 호스팅하는 탭은 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] 닫혀 있습니다.  
  
-   브라우저가 닫힌 경우  
  
 모든 경우의 값에는 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 속성은 무시 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 방법:  
  
-   처리는 <xref:System.Windows.Application.Exit> 이벤트입니다.  
  
-   검사 및 업데이트 합니다 <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 의 속성을 <xref:System.Windows.ExitEventArgs>입니다.  
  
-   격리 된 저장소에 애플리케이션 로그에 항목을 작성 합니다.  
  
-   격리 된 저장소에 애플리케이션 상태를 유지 합니다.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스 이름입니다.</param>
        <summary>지정된 키를 사용하여 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 리소스(예: <see cref="T:System.Windows.Style" /> 또는 <see cref="T:System.Windows.Media.Brush" />)를 검색하고 요청된 리소스가 없으면 예외를 throw합니다([XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md) 참조).</summary>
        <returns>요청된 리소스 개체입니다. 요청된 리소스가 없으면 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 먼저 살펴보겠습니다. 애플리케이션 범위 리소스를 관리 하 <xref:System.Windows.Application>에서 노출 되는 <xref:System.Windows.Application.Resources%2A> 속성입니다. 지정된 된 리소스는 애플리케이션 범위 리소스 집합에 없는 경우 <xref:System.Windows.Application.FindResource%2A> 옆에는 시스템 리소스를 검색 합니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 되는 이러한 합니다 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters> 형식을 각각 정적 속성입니다. 사용 하도록 <xref:System.Windows.Application.FindResource%2A> 을 얻으려면 이러한 형식은 또한 리소스 키 속성을 노출 전달할 수 있도록 만들어진 <xref:System.Windows.Application.FindResource%2A>예를 들어, <xref:System.Windows.SystemParameters.IconWidthKey%2A>합니다.  
  
 때문에 <xref:System.Windows.Application.FindResource%2A> 개체를 반환 합니다. 리소스가 발견 하는 경우 반환된 값을 적절 한 형식으로 캐스팅 해야 합니다.  
  
> [!IMPORTANT]
>  찾을 수 없는 키에 대 한이 메서드를 호출 하면 예외가 throw 됩니다. 경우 원하지 않는 호출에서 발생 하는 예외를 처리할 <xref:System.Windows.Application.FindResource%2A>, 호출 <xref:System.Windows.Application.TryFindResource%2A> 대신; <xref:System.Windows.Application.TryFindResource%2A> 반환을 `null` 참조할 때 요청된 된 리소스를 찾을 수 없으면 예외를 throw 하지 않습니다.  
  
 이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 <xref:System.Windows.Application.FindResource%2A> 처리 하는 리소스를 찾는 데 <xref:System.Windows.ResourceReferenceKeyNotFoundException> 경우 리소스를 찾을 수 없습니다.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">리소스를 찾을 수 없습니다.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 탐색기에서 콘텐츠 조각 탐색을 시작할 때 발생합니다. 원하는 조각이 현재 콘텐츠에 있으면 즉시 탐색이 발생하고, 원하는 조각이 다른 콘텐츠에 있으면 소스 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 콘텐츠가 로드된 후에 탐색이 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">느슨한 리소스에 매핑되는 상대 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 콘텐츠 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 콘텐츠 데이터 파일이 들어 있는 <see cref="T:System.Uri" />입니다. 느슨한 리소스가 없으면 null이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" />가 절대 <see cref="T:System.Uri" />인 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">쿠키가 만들어진 위치를 지정하는 <see cref="T:System.Uri" />입니다.</param>
        <summary><see cref="T:System.Uri" />에 의해 지정된 위치에 대한 쿠키를 검색합니다.</summary>
        <returns>쿠키가 있으면 <see cref="T:System.String" /> 값이고, 그렇지 않으면 <see cref="T:System.ComponentModel.Win32Exception" />이 throw됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 지정 된 쿠키를 검색 <xref:System.Uri>합니다. 쿠키를 검색할 수 없는 경우는 <xref:System.ComponentModel.Win32Exception> throw 됩니다. 쿠키 문자열 이름/값 쌍의 목록으로 구문 분석 하는 코드를 작성 해야 합니다.  
  
 쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 참조 하세요 [탐색 개요](~/docs/framework/wpf/app-development/navigation-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">지정된 쿠키를 검색하는 동안 문제가 발생하면 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />에서 호출된 <see langword="InternetGetCookie" /> 함수에 의해 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 오류가 발생합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 기반 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">비-파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형: <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">원본 사이트의 느슨한 리소스에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 원본 사이트 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 원본 사이트 데이터 파일에 대한 리소스 스트림이 들어 있는 <see cref="T:System.Uri" />입니다. 느슨한 리소스가 없으면 <see langword="null" />이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />가 상대 경로가 아니거나 절대 경로이지만 <c>pack://siteoforigin:,,,/</c> 형태가 아닌 경우</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">포함된 리소스로 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 <see cref="T:System.Uri" />에 있는 리소스 데이터 파일에 대한 리소스 스트림을 반환합니다([WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md) 참조).</summary>
        <returns>지정된 <see cref="T:System.Windows.Resources.StreamResourceInfo" />에 있는 리소스 데이터 파일에 대한 리소스 스트림이 들어 있는 <see cref="T:System.Uri" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />가 상대 경로가 아니거나 절대 경로이지만 <c>pack://application:,,,/</c> 형태가 아닌 경우</exception>
        <exception cref="T:System.IO.IOException"><see cref="T:System.Uri" />에 전달된 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />를 발견할 수 없습니다.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 탐색기에서 탐색한 콘텐츠가 로드 및 구문 분석되었으며 렌더링을 시작한 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>을 참조하세요.  
  
> [!NOTE]
>  와 같은 탐색된 된 콘텐츠의에서 이벤트를 수신 합니다 <xref:System.Windows.FrameworkElement.Loaded> 이벤트에 <xref:System.Windows.Controls.Page> 탐색된 된 콘텐츠의의 속성에 액세스 하기 전에 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]에 있는 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 파일을 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 애플리케이션 코드 파일 수 (으로 구성를 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 애플리케이션 데이터 파일 (리소스 파일이 나 콘텐츠 파일의 원본 사이트 파일을 참조 하세요 [WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">상대 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]에 있는 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 파일을 로드하고 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일의 루트 요소에 의해 지정된 개체의 인스턴스로 변환합니다.</summary>
        <returns>로드한 XAML 파일에 지정된 루트 요소의 인스턴스입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 루트 요소와 동일한 형식으로 반환 값을 명시적으로 변환 해야 하는 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일입니다.  
  
 합니다 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 애플리케이션 코드 파일 수 (으로 구성를 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 애플리케이션 데이터 파일 (리소스 파일이 나 콘텐츠 파일의 원본 사이트 파일을 참조 하세요 [WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" />가 절대 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.Exception">파일이 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일이 아닌 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일의 루트 요소와 같은 형식의 개체입니다.</param>
        <param name="resourceLocator">상대 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일에 매핑되는 <see cref="T:System.Uri" />입니다.</param>
        <summary>지정된 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]에 있는 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일을 로드하고 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 파일의 루트 요소가 지정하는 개체의 인스턴스로 변환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 합니다 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 파일에는 애플리케이션 코드 파일 수 (으로 구성를 [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] 페이지 항목) 또는 애플리케이션 데이터 파일 (리소스 파일이 나 콘텐츠 파일의 원본 사이트 파일을 참조 하세요 [WPF 애플리케이션 리소스, 콘텐츠 및 데이터 파일](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  이 메서드는 스레드로부터 안전 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" />가 null인 경우</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" />가 절대 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]인 경우</exception>
        <exception cref="T:System.Exception"><paramref name="component" />가 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 파일의 루트 요소와 일치하지 않는 형식인 경우</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 주 창을 가져오거나 설정합니다.</summary>
        <value>주 애플리케이션 창으로 지정된 <see cref="T:System.Windows.Window" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 첫 번째에 대 한 참조를 사용 하 여 자동으로 설정 됩니다 <xref:System.Windows.Window> 개체에서 인스턴스화되는 <xref:System.AppDomain>합니다.  
  
 다른 주 창을 설정 하 여 지정할 수 있습니다 <xref:System.Windows.Application.MainWindow%2A> 다른 할당 <xref:System.Windows.Application.Windows%2A> 개체는 <xref:System.Windows.Application.MainWindow%2A> 속성입니다.  
  
 경우는 <xref:System.Windows.Application.ShutdownMode%2A> 의 속성을 <xref:System.Windows.Application> 개체로 설정 됩니다 <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 주 창을 닫으면 애플리케이션을 종료 합니다.  
  
 설정 하는 것이 가능 합니다 <xref:System.Windows.Application.MainWindow%2A> 속성을 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]애플리케이션의 주 창 설정 하 여 생성 되는 창이 아닌 경우는 <xref:System.Windows.Application.StartupUri%2A> 속성에서 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. 두 가지 제한 된 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 방법은:  
  
-   지정할 수 있습니다는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Window> 또는 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-만 <xref:System.Windows.Navigation.NavigationWindow> 주 창으로 합니다.  
  
-   설정 해야 합니다는 <xref:System.Windows.UIElement.Visibility%2A> 지정할 속성 창, 그렇지 않으면 표시 되지 않습니다.  
  
 첫 번째에 대 한 참조가 <xref:System.Windows.Window> 인스턴스화할 개체도 첫 번째 항목으로 추가 됩니다는 <xref:System.Windows.Application.Windows%2A> 컬렉션입니다. 하는 경우 <xref:System.Windows.Application.MainWindow%2A> 다른 작업에 대 한 참조를 사용 하 여 설정한 <xref:System.Windows.Window>에서 항목의 순서는 동안 주 창에 대 한 참조를 사용 하 여 항목의 위치가 변경 됩니다 <xref:System.Windows.Application.Windows%2A> 동일 하 게 유지 합니다. 결과적으로 항상 사용 <xref:System.Windows.Application.MainWindow%2A> 주 창에서 첫 번째 항목 대신 가리키도록 <xref:System.Windows.Application.Windows%2A>합니다.  
  
> [!NOTE]
>  주 창의 경우는 <xref:System.Windows.Navigation.NavigationWindow>에 대 한 특정 액세스를 해야 <xref:System.Windows.Navigation.NavigationWindow> 값을 캐스팅 해야 멤버 <xref:System.Windows.Application.MainWindow%2A> 에 <xref:System.Windows.Navigation.NavigationWindow>입니다.  
>   
>  이 속성을 만든 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 기본 애플리케이션 창을 찾는 방법을 보여 줍니다.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 다음 예제에서는 설정 하는 방법을 보여 줍니다 <xref:System.Windows.Application.MainWindow%2A> 를 사용 하 여 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]입니다.  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 다음 예제에서는 인스턴스화하는 방법을 보여 줍니다는 <xref:System.Windows.Application.MainWindow%2A> 애플리케이션 시작 시 코드에서입니다.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Application.MainWindow" />가 브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)])에서 설정된 경우</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 탐색기에서 탐색 중인 콘텐츠를 찾은 경우에 발생합니다. 콘텐츠가 완전히 로드되지 않았을 수도 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 탐색기에서 새 탐색이 요청된 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 탐색기에서 요청된 내용을 탐색하는 동안 오류가 표시될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>탐색 진행률 정보를 제공하기 위해 애플리케이션의 탐색기에서 관리되는 다운로드 중에 정기적으로 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 탐색기의 <see langword="StopLoading" /> 메서드가 호출되거나 현재 탐색이 진행되는 동안 탐색기에서 새 탐색이 요청된 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 탐색기는 한 <xref:System.Windows.Navigation.NavigationWindow> 또는 <xref:System.Windows.Controls.Frame>합니다.  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>을 참조하세요.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Activated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A>는 <xref:System.Windows.Application.Activated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnActivated%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnActivated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Activated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Deactivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A>는 <xref:System.Windows.Application.Deactivated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnDeactivated%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnDeactivated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Deactivated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.ExitEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Exit" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A>는 <xref:System.Windows.Application.Exit> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다는 <xref:System.Windows.Application.OnExit%2A> 메서드. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnExit%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Exit> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.FragmentNavigation" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>는 <xref:System.Windows.Application.FragmentNavigation> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnFragmentNavigation%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnFragmentNavigation%2A> 기본 클래스의 경우 <xref:System.Windows.Application.FragmentNavigation> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.LoadCompleted" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A>는 <xref:System.Windows.Application.LoadCompleted> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnLoadCompleted%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnLoadCompleted%2A> 기본 클래스의 경우 <xref:System.Windows.Application.LoadCompleted> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Navigated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A>는 <xref:System.Windows.Application.Navigated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigated%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnNavigated%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Navigated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Navigating" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A>는 <xref:System.Windows.Application.Navigating> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigating%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnNavigating%2A> 기본 클래스의 경우 <xref:System.Windows.Application.Navigating> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.NavigationFailed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A>는 <xref:System.Windows.Application.NavigationFailed> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationFailed%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnNavigationFailed%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationFailed> 발생 해야 합니다.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.NavigationProgress" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A>는 <xref:System.Windows.Application.NavigationProgress> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationProgress%2A>합니다. 재정의 된 메서드를 명시적으로 호출 해야 <xref:System.Windows.Application.OnNavigationProgress%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationProgress> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.NavigationStopped" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A>는 <xref:System.Windows.Application.NavigationStopped> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnNavigationStopped%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnNavigationStopped%2A> 기본 클래스의 경우 <xref:System.Windows.Application.NavigationStopped> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.SessionEndingCancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.SessionEnding" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A>는 <xref:System.Windows.Application.SessionEnding> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnSessionEnding%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnSessionEnding%2A> 기본 클래스의 경우 <xref:System.Windows.Application.SessionEnding> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.Windows.StartupEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Application.Startup" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A>는 <xref:System.Windows.Application.Startup> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Application> 재정의할 수 있습니다 <xref:System.Windows.Application.OnStartup%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Application.OnStartup%2A> 기본 클래스의 경우는 <xref:System.Windows.Application.Startup> 이벤트 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 범위 속성의 컬렉션을 가져옵니다.</summary>
        <value>애플리케이션 범위 속성이 들어 있는 <see cref="T:System.Collections.IDictionary" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 사전을 통해 노출 <xref:System.Windows.Application.Properties%2A> 응용 프로그램 범위 속성을 저장 하는 데 사용할 수 있는 합니다. 이렇게 하면 모든 코드에서 상태를 공유할 수 있습니다는 <xref:System.AppDomain> 고유한 상태 코드를 작성할 필요 없이 스레드로부터 안전한 방식입니다.  
  
 속성에 저장 된 <xref:System.Windows.Application.Properties%2A> 반환 되는 적절 한 형식으로 변환할 수 있어야 합니다.  
  
 <xref:System.Windows.Application.Properties%2A> 속성은 스레드로부터 안전 하며 모든 스레드에서 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 어떻게 만들고 사용 하 여 애플리케이션 범위 속성을 사용 하 여 <xref:System.Windows.Application.Properties%2A>입니다.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 응용 프로그램의 리소스에 대한 팩 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 제공하는 <see cref="T:System.Reflection.Assembly" />를 가져오거나 설정합니다.</summary>
        <value>[!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 응용 프로그램의 리소스에 대한 팩 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 제공하는 <see cref="T:System.Reflection.Assembly" />에 대한 참조입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 에서 반환 된 값으로 식별 되는 항목이 어셈블리와 관련 하 여 런타임 시 리소스가 확인 되는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 메서드.  
  
 진입 어셈블리에서 반환 되는 어셈블리는 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 다음 일 수 있습니다.  
  
-   기본 애플리케이션 도메인에서 실행 하는 어셈블리입니다.  
  
-   첫 번째 어셈블리를 호출 하 여 실행할 <xref:System.AppDomain.ExecuteAssembly%2A>합니다.  
  
 그러나 다음 경우에는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리의 진입 어셈블리에 대 한 참조를 가져올 수 없습니다.  
  
-   관리 되지 않는 (네이티브) 애플리케이션 호스트는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리입니다.  
  
-   관리 되는 애플리케이션 호스트를 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 이외의 메서드를 사용 하 여 새 애플리케이션 도메인에 로드 하 여 어셈블리 <xref:System.AppDomain.ExecuteAssembly%2A>합니다.  
  
 이러한 경우 모두 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 반환 `null`, 및 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리의 리소스를 확인할 수 없습니다. 이러한 경우 <xref:System.Windows.Application.ResourceAssembly%2A> 한 번만 리소스를 확인 하는 데 사용 해야 하는 어셈블리에 대 한 참조를 사용 하 여 설정할 수 있습니다.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 리소스 어셈블리는 후 변경 됩니다 가능성이 없기 때문에 한 번 설정할만 수는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리가 로드 됩니다.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 설정할 수 없습니다는 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 어셈블리는 즉-진입 어셈블리를 검색할 수 있습니다 때 <xref:System.Reflection.Assembly.GetEntryAssembly%2A> 어셈블리에 대 한 참조를 반환 합니다. 대신 `null`합니다.  
  
 이 속성은 스레드로부터 안전 하며 모든 스레드에서 사용할 수 있습니다.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> .NET Framework 버전 3.5에서에서 도입 되었습니다.  자세한 내용은 [버전 및 종속성](~/docs/framework/migration-guide/versions-and-dependencies.md)을 참조하세요.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 응용 프로그램에 진입 어셈블리가 있거나 <see cref="P:System.Windows.Application.ResourceAssembly" />가 이미 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션 범위 리소스(예: 스타일 및 브러시)의 컬렉션을 가져오거나 설정합니다.</summary>
        <value>0개 이상의 애플리케이션 범위 리소스가 들어 있는 <see cref="T:System.Windows.ResourceDictionary" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A> 속성을 사용 하 여 windows 및 응용 프로그램의 요소 간에 리소스를 공유할 수 있습니다. 또한는 <xref:System.Windows.Application.Resources%2A> 속성이 다음과 같은 순서로 트래버스 되는 리소스 조회 경로에 포함 되어:  
  
1.  요소  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  시스템  
  
 따라서 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 요소는 애플리케이션 범위 리소스에 바인딩할 수 있습니다. 또한 리소스가 변경 되 면 리소스 시스템 하면 요소에 해당 리소스에 바인딩되는 속성 변경 내용을 반영 하도록 자동으로 업데이트 됩니다.  
  
 애플리케이션 범위 리소스 애플리케이션에서 일관 된 테마를 지원 하는 간단한 방법을 제공 합니다. 테마를 쉽게 만들 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 를 사용 하 여는 `Application.Resources` 태그입니다. 그러나 애플리케이션이 많은 테마 요소를 포함 하는 여러 테마를 지원 하기 쉬울 수 있습니다 하나를 사용 하 여 관리할 <xref:System.Windows.ResourceDictionary> 각 테마에 대 한 인스턴스. 이러한 방식으로 새 테마를 적용할 수를 적절 한 리소스 속성을 설정 하 여 <xref:System.Windows.ResourceDictionary>입니다.  
  
 <xref:System.Windows.Application.Resources%2A>를 사용 시에는 두 가지 고려할 사항이 있습니다. 첫 번째, 사전 *키* 개체 이므로 설정 하 고 (키가 대/소문자 구분 문자열을 사용 하는 경우 참고) 속성 값을 가져올 경우 정확히 동일한 개체 인스턴스를 사용 해야 합니다. 두 번째, 사전 *값* 개체 이므로 속성 값을 가져올 때 값을 원하는 형식으로 변환 해야 합니다.  
  
 <xref:System.Windows.Application.Resources%2A> 스레드로부터 안전 하 고 모든 스레드에서 사용할 수 있습니다.  
  
   
  
## Examples  
 이 예제를 사용 하는 방법을 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 일관 된 모양을 만들려면 애플리케이션 범위 리소스와 함께 합니다.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 다음 예제에서는 코드 및 XAML 애플리케이션 리소스를 설정 하는 방법을 보여 줍니다.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 다음 예제에서는 코드에서 애플리케이션 리소스를 가져오는 방법을 보여 줍니다.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Windows Presentation Foundation 애플리케이션을 시작합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Windows Presentation Foundation 애플리케이션을 시작합니다.</summary>
        <returns>애플리케이션이 종료될 때 운영 체제로 반환되는 <see cref="T:System.Int32" /> 애플리케이션 종료 코드입니다. 기본적으로 종료 코드 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 시작 하기 위해 호출 된 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 응용 프로그램입니다. 정의 하는 경우에 <xref:System.Windows.Application> 태그 또는 태그와 코드 숨김을 사용 하 여 <xref:System.Windows.Application.Run%2A> 암시적으로 호출 됩니다. 그러나 정의 하는 경우에 <xref:System.Windows.Application> 코드를 사용 하는 명시적으로 호출 해야 <xref:System.Windows.Application.Run%2A>합니다.  
  
 때 <xref:System.Windows.Application.Run%2A> 가 호출 <xref:System.Windows.Application> 새 연결 <xref:System.Windows.Threading.Dispatcher> UI 스레드로 인스턴스. 다음으로 <xref:System.Windows.Threading.Dispatcher> 개체의 <xref:System.Windows.Threading.Dispatcher.Run%2A> windows 메시지를 처리 하는 데 메시지 펌프를 시작 하는 메서드가 호출 됩니다. 마지막으로 <xref:System.Windows.Threading.Dispatcher> 호출 개체를 <xref:System.Windows.Application> 개체의는 <xref:System.Windows.Application.OnStartup%2A> 발생 하는 방법의 <xref:System.Windows.Application.Startup> 이벤트. 따라서 애플리케이션 실행 모델 이미 처리할 때 설정 되었으며 <xref:System.Windows.Application.Startup>,이 시점에서 애플리케이션 실행으로 간주 됩니다.  
  
 애플리케이션의 경우 실행이 중지 <xref:System.Windows.Application.Shutdown%2A> 가 호출 되 값을 <xref:System.Windows.Application.ShutdownMode%2A> 속성을 결정 하는 경우 <xref:System.Windows.Application.Shutdown%2A> 호출 되 고 자동으로 수행 하거나 명시적으로 해야 하는지 여부를 호출 합니다.  
  
 <xref:System.Windows.Application.Run%2A> 만든 스레드에서만에서 호출할 수는 <xref:System.Windows.Application> 개체입니다. 또한 <xref:System.Windows.Application.Run%2A> 에서 호출할 수 없습니다는 [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 하는 애플리케이션을 보여 줍니다 <xref:System.Windows.Application> 명시적으로 호출 되므로 야 <xref:System.Windows.Application.Run%2A>합니다.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)])에서 <see cref="M:System.Windows.Application.Run" />이 호출되는 경우</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">애플리케이션이 시작될 때 자동으로 열리는 <see cref="T:System.Windows.Window" />입니다.</param>
        <summary>Windows Presentation Foundation 애플리케이션을 시작하고 지정된 창을 엽니다.</summary>
        <returns>애플리케이션이 종료될 때 운영 체제로 반환되는 <see cref="T:System.Int32" /> 애플리케이션 종료 코드입니다. 기본적으로 종료 코드 값은 0입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 오버 로드를 확장 합니다 <xref:System.Windows.Application.Run%2A> 메서드는 애플리케이션 실행이 시작 된 후 지정 된 창을 엽니다.  
  
 코드를 정의 하는 경우 <xref:System.Windows.Application> 실행을 시작할 때 열리는 창, 명시적으로 호출 <xref:System.Windows.Application.Run%2A>합니다.  
  
 만드는 경우에 <xref:System.Windows.Application> 태그 또는 태그와 코드 숨김을 사용 하 여, 자동으로 창을 열 수 있습니다는 다음 기술 중 하나를 사용 하 여 중:  
  
-   설정 하 여 선언적으로 <xref:System.Windows.Application.StartupUri%2A>입니다.  
  
-   프로그래밍 방식으로 처리 하 여 <xref:System.Windows.Application.Startup>입니다.  
  
   
  
## Examples  
 다음 예제를 인스턴스화하는 수동으로 만든 정적 진입점 메서드를 사용 하 여 애플리케이션을 보여 줍니다 <xref:System.Windows.Application>를 호출 하기 전에 <xref:System.Windows.Application.Run%2A>입니다.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">브라우저에서 호스팅된 응용 프로그램(예: [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)])에서 <see cref="M:System.Windows.Application.Run" />이 호출되는 경우</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>사용자가 로그오프하거나 운영 체제를 종료하여 Windows 세션을 끝낼 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로 애플리케이션이 종료 될 때 사용자가 로그 오프 하거나 종료 하는 경우 발생 하는 Windows 세션이 종료 됩니다. 이 경우 Windows는 각 열린 애플리케이션을 종료를 요청 합니다. 그러나 있기 애플리케이션이이 경우 종료 준비가 되어 있지 않을 수 있습니다. 예를 들어, 애플리케이션에 일관 되지 않은 상태의 또는 장기 실행 작업 중에 데이터 있을 수 있습니다. 이러한 상황에서 세션 종료를 방지 하기 위해이 바람직 할 수 있습니다 하 고 사용자가 세션을 종료 하는지 여부를 결정 하는 옵션을 허용 하는 것이 더 효율적일 수 있습니다.  
  
 처리 하 여 세션이 끝날 때 감지할 수 있습니다는 <xref:System.Windows.Application.SessionEnding> 이벤트입니다. 애플리케이션 세션을 종료 하지 못하도록 해야 하는 경우는 <xref:System.Windows.SessionEndingCancelEventArgs> 이벤트 처리기에 전달 된 인수를 제공 합니다 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 로 설정 하는 `true` (기본값은 `false`).  
  
 하는 경우 <xref:System.Windows.Application.SessionEnding> 처리 되지 않았거나 취소 하지 않고 처리 됩니다 <xref:System.Windows.Application.Shutdown%2A> 라고 하며 <xref:System.Windows.Application.Exit> 이벤트가 발생 합니다.  
  
 세션이 종료 되는 이유에 대 한 자세한 정보를 얻으려면 애플리케이션을 검사할 수 <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, 중 하나인 합니다 <xref:System.Windows.ReasonSessionEnding> 값 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> 고 <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> 콘솔 응용 프로그램에서 발생 하지 않습니다.  
  
 <xref:System.Windows.Application.SessionEnding> 만든 스레드에서만 발생을 <xref:System.Windows.Application> 개체입니다.  
  
 <xref:System.Windows.Application.SessionEnding> XAML 브라우저 응용 프로그램 (Xbap) 발생 하지 않습니다.  
  
   
  
## Examples  
 다음 예제에서는 처리 하는 방법에 설명 합니다 <xref:System.Windows.Application.SessionEnding> 이벤트 취소 하 고 사용자입니다.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">쿠키를 만들어야 하는 위치를 지정하는 <see cref="T:System.Uri" />입니다.</param>
        <param name="value">쿠키 데이터가 들어 있는 <see cref="T:System.String" />입니다.</param>
        <summary><see cref="T:System.Uri" />에 의해 지정된 위치에 대한 쿠키를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 쿠키는 애플리케이션에서 클라이언트 컴퓨터의 애플리케이션 세션 (세션 쿠키) 중 또는 애플리케이션 세션 (영구 쿠키) 간에 저장 될 수 있는 데이터의 일부를 임의로. 호출 하 여 두 종류의 쿠키를 만들 수 있습니다 <xref:System.Windows.Application.SetCookie%2A>합니다.  
  
 쿠키 데이터는 일반적으로 다음 형식으로 이름/값 쌍의 형태를 가집니다.  
  
 `Name=Value`  
  
 이 형식의 문자열을 전달 하면 <xref:System.Windows.Application.SetCookie%2A>를 함께 <xref:System.Uri> 쿠키를 설정 해야 하는 위치 (일반적으로 애플리케이션 도메인).  
  
 에 전달 된 쿠키는 세션 쿠키 또는 영구 쿠키를 쿠키 문자열이 있는지 여부에 따라 달라 집니다 <xref:System.Windows.Application.SetCookie%2A> 만료 날짜를 포함 합니다. 세션 쿠키의 문자열에는 만료 날짜를 포함 하지 않습니다. 영구 쿠키에 대 한 문자열은 다음과 같은 형식 이어야 합니다.  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 현재에서 저장 된 영구 쿠키 [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] 설치의 Temporary Internet Files 폴더 만료 될 때까지,이 경우 삭제 됩니다. 만료 날짜가 과거 날짜/시간 값으로 설정 하 여 애플리케이션에서 영구 쿠키를 삭제할 수 있습니다.  
  
 쿠키에 대 한 개요 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]를 참조 하세요 [탐색 개요](~/docs/framework/wpf/app-development/navigation-overview.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">지정된 쿠키를 만드는 동안 문제가 발생하면 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />에서 호출된 <see langword="InternetSetCookie" /> 함수에 의해 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 오류가 발생합니다.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">파일 기반 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">비-파일 기반에 대 한 쿠키를 가져오기 위한 <see cref="T:System.Uri" />합니다. 연결 된 열거형: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>애플리케이션을 종료합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>애플리케이션을 종료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Windows.Application.Shutdown%2A> 호출 되는 애플리케이션 실행을 중지 합니다. 처리할 수 있습니다는 <xref:System.Windows.Application.Exit> 애플리케이션 실행이 중지, 적절 한 처리를 수행 하는 시기를 감지 하는 이벤트입니다.  
  
 <xref:System.Windows.Application.Shutdown%2A> 가 암시적으로 호출 Windows Presentation Foundation에서 다음과 같은 경우:  
  
-   때 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 된 <xref:System.Windows.ShutdownMode.OnLastWindowClose>합니다.  
  
-   경우는 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 된 <xref:System.Windows.ShutdownMode.OnMainWindowClose>합니다.  
  
-   사용자 세션을 종료 하는 경우 및 <xref:System.Windows.Application.SessionEnding> 이벤트 처리 되지 않은, 또는 취소 하지 않고 처리 합니다.  
  
 호출 <xref:System.Windows.Application.Shutdown%2A> 명시적으로 애플리케이션을 종료 하면 관계 없이 <xref:System.Windows.Application.ShutdownMode%2A> 설정 합니다. 그러나 경우 <xref:System.Windows.Application.ShutdownMode%2A> 로 설정 된 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>를 호출 해야 합니다 <xref:System.Windows.Application.Shutdown%2A> 는 애플리케이션을 종료 합니다.  
  
> [!IMPORTANT]
>  때 <xref:System.Windows.Application.Shutdown%2A> 는 호출 애플리케이션은 종료 여부에 관계 없이 <xref:System.Windows.Window.Closing> 열려 있는 창 모두의 이벤트를 취소 합니다.  
  
 이 메서드를 만든 스레드에서만에서 호출할 수는 <xref:System.Windows.Application> 개체입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">애플리케이션에 대한 정수 종료 코드입니다. 기본 종료 코드는 0입니다.</param>
        <summary>지정된 종료 코드를 운영 체제에 반환하는 애플리케이션을 종료합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 처리할 수 있습니다는 <xref:System.Windows.Application.Exit> 이벤트가 종료 코드를 설정 합니다. 그러나 명시적으로 호출 하는 경우 <xref:System.Windows.Application.Shutdown%2A>를 처리 하 고 <xref:System.Windows.Application.Exit> 종료 코드를 설정 하려면 호출할 수 있습니다만 <xref:System.Windows.Application.Shutdown%2A> 대신 합니다.  
  
 이 메서드를 만든 스레드에서만에서 호출할 수는 <xref:System.Windows.Application> 개체입니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Application.Shutdown" /> 메서드가 호출되게 하는 조건을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.ShutdownMode" /> 열거형 값입니다. 기본값은 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 애플리케이션의 경우에만 실행이 중지 된 <xref:System.Windows.Application.Shutdown%2A> 애플리케이션의 메서드가 호출 됩니다. 종료 값으로 지정 된 대로 명시적으로 또는 암시적으로 발생할 수 있습니다는 <xref:System.Windows.Application.ShutdownMode%2A> 속성입니다.  
  
 설정 하는 경우 <xref:System.Windows.Application.ShutdownMode%2A> 하 <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) 암시적으로 호출 <xref:System.Windows.Application.Shutdown%2A> 애플리케이션의 마지막 창의 닫을 때, 모든 현재 인스턴스화된 창을 주 창으로 설정 하는 경우에 (참조 <xref:System.Windows.Application.MainWindow%2A>).  
  
 A <xref:System.Windows.Application.ShutdownMode%2A> 의 <xref:System.Windows.ShutdownMode.OnMainWindowClose> 암시적으로 호출 하는 wpf <xref:System.Windows.Application.Shutdown%2A> 때의 <xref:System.Windows.Application.MainWindow%2A> 다른 창이 현재 열려 있는 경우에 닫습니다.  
  
 일부 애플리케이션의 수명 동안 때 주 창 또는 마지막 창이 닫히거나 되지 않을 수 있습니다 windows 종속 전혀 종속 아닐 수도 있습니다. 이러한 시나리오에 대해 설정 해야 합니다 <xref:System.Windows.Application.ShutdownMode%2A> 속성을 <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, 명시적인 요구 하는 <xref:System.Windows.Application.Shutdown%2A> 애플리케이션을 중지할 메서드 호출 합니다. 그렇지 않으면 애플리케이션 계속 백그라운드에서 실행 됩니다.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 선언적으로 구성할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 또는 코드에서 프로그래밍 방식으로 합니다.  
  
 이 속성을 만든 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 구성 방법을 보여 줍니다. <xref:System.Windows.Application.ShutdownMode%2A> 애플리케이션을 명시적으로 닫아야를 지정 합니다.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Application.Run" /> 개체의 <see cref="T:System.Windows.Application" /> 메서드가 호출될 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적인 Windows Presentation Foundation 애플리케이션을 시작할 때를 포함 하 여 다양 한 초기화 작업을 수행할 수 있습니다.  
  
-   명령줄 매개 변수를 처리 합니다.  
  
-   주 창 열기  
  
-   애플리케이션 범위 리소스를 초기화합니다.  
  
-   애플리케이션 범위 속성을 초기화 합니다.  
  
 주 창 및 사용 하 여 애플리케이션 범위 리소스를 선언적으로 지정할 수 있습니다 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> 고 <xref:System.Windows.Application.Resources%2A>각각). 경우에 따라 단, 리소스 또는 애플리케이션의 주 창만 확인할 수 있습니다 프로그래밍 방식으로 런타임 시. 또한 애플리케이션 범위 속성 및 명령줄 매개 변수에 사용할 수 있습니다만 프로그래밍 방식으로. 프로그래밍 방식으로 초기화를 처리 하 여 수행할 수는 <xref:System.Windows.Application.Startup> 다음을 포함 한 경우:  
  
-   가져오고에서 사용할 수 있는 명령줄 매개 변수를 처리를 <xref:System.Windows.StartupEventArgs.Args%2A> 의 속성을 <xref:System.Windows.StartupEventArgs> 에 전달 되는 클래스를 <xref:System.Windows.Application.Startup> 이벤트 처리기.  
  
-   애플리케이션 범위 리소스를 사용 하 여 초기화 된 <xref:System.Windows.Application.Resources%2A> 속성입니다.  
  
-   애플리케이션 범위 속성을 사용 하 여 초기화 된 <xref:System.Windows.Application.Properties%2A> 속성입니다.  
  
-   페이지를 인스턴스화하고 windows 하나 (또는 이상)를 표시 합니다.  
  
> [!NOTE]
>  정적 호출 하 여 명령줄 매개 변수를 가져올 수도 있습니다 <xref:System.Environment.GetCommandLineArgs%2A> 메서드는 <xref:System.Environment> 개체입니다. 그러나 <xref:System.Environment.GetCommandLineArgs%2A> 실행 하려면 완전 신뢰가 필요 합니다.  
  
 설정 하는 경우 <xref:System.Windows.Application.StartupUri%2A> 를 사용 하 여 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], 만든 주 창에서 사용할 수 없는.를 <xref:System.Windows.Application.MainWindow%2A> 속성 또는 <xref:System.Windows.Application.Windows%2A> 의 속성을 <xref:System.Windows.Application> 후 될 때까지 개체를 <xref:System.Windows.Application.Startup> 이벤트가 처리. 새 window 개체를 수동으로 생성 해야 하는 시작 하는 동안 주 창에 대 한 액세스를 해야 하는 경우에 <xref:System.Windows.Application.Startup> 이벤트 처리기입니다.  
  
> [!NOTE]
>  애플리케이션에서 사용 하는 경우 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 자격 증명 정책을 지정 하려면 설정 해야 <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> 한 후 <xref:System.Windows.Application.Startup> 고, 그렇지 않으면 발생 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 기본 내부 정책을 직접 후로 설정 합니다는 <xref:System.Windows.Application.Startup> 이벤트가 발생 합니다.  
  
 에 전달 되는 명령줄 인수를 <xref:System.Windows.Application.Startup> 이벤트 처리기는 동일 하지는 [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] 쿼리 문자열 매개 변수 전달 되는 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 다음 예제에서는 획득 하 고 독립 실행형 애플리케이션에서 명령줄 옵션을 처리 하는 방법을 보여 줍니다. 경우는 **/StartMinimized** 제공 된 명령줄 매개 변수, 애플리케이션 최소화 된 상태로 주 창을 엽니다.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 검색 및 사용 하 여 시작 되기 때문에 명령줄 인수를 처리할 수 없습니다 [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] 배포 (참조 [WPF 응용 프로그램 (WPF) 배포](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). 그러나 XBAP를 시작하는 데 사용되는 URL에서 쿼리 문자열 매개 변수를 검색하고 처리할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션이 시작될 때 자동으로 표시되는 UI를 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Uri" /> 참조 하는 응용 프로그램이 시작 될 때 자동으로 열리는 UI입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수 있습니다 <xref:System.Windows.Application.StartupUri%2A> 애플리케이션이 시작 될 때 UI 리소스를 자동으로 로드 하도록 합니다.  
  
 다음 표에서 로드 될 수 있는 UI 리소스 유형의 창에 열 형식 및으로 이러한 리소스를 설정할 수 있는 애플리케이션 종류는 <xref:System.Windows.Application.StartupUri%2A>합니다.  
  
|형식|창|애플리케이션 유형|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|독립 실행형만 해당|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형만 해당|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|독립 실행형/브라우저 호스팅|  
  
 일반적으로 설정 합니다 <xref:System.Windows.Application.StartupUri%2A> 속성에서 선언적으로 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]입니다. 설정할 수 있습니다 <xref:System.Windows.Application.StartupUri%2A> 프로그래밍 방식으로으로 <xref:System.Windows.Application.Startup> 이벤트 처리기는 런타임에 필요한 UI 리소스를 로드할 수 있는 애플리케이션에 있는 경우 유용 합니다. 예를 들어, 애플리케이션 UI 리소스의 이름을 구성 파일에 저장 된 경우 해당 리소스를 로드 하는 실행된 시간까지 기다릴 수 있습니다.  
  
 설정 여부 <xref:System.Windows.Application.StartupUri%2A> 선언적으로 또는 프로그래밍 방식으로 해당 UI 리소스까지 로드 되지 않은 후는 <xref:System.Windows.Application.Startup> 이벤트를 처리 합니다. 결과적으로 액세스할 수 없습니다를 결과 창에서 합니다 <xref:System.Windows.Application.Windows%2A> 속성 또는 <xref:System.Windows.Application.MainWindow%2A> 속성을 처리할 때 <xref:System.Windows.Application.Startup>합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" />가 null 값으로 설정된 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">요청된 앰비언트 속성의 이름입니다.</param>
        <summary>지정된 앰비언트 속성을 현재 범위에서 사용할 수 있는지 여부에 대한 쿼리입니다.</summary>
        <returns>요청된 앰비언트 속성을 사용할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.Application> 인스턴스가 <xref:System.Windows.Markup.IQueryAmbient> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스 이름입니다.</param>
        <summary>지정된 리소스를 검색합니다.</summary>
        <returns>요청된 리소스 개체입니다. 요청된 리소스가 없으면 null 참조가 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 지정된 된 리소스에 대 한 응용 프로그램 범위 리소스에서 먼저 살펴보겠습니다. 애플리케이션 범위 리소스를 관리 하 <xref:System.Windows.Application>에서 노출 되는 <xref:System.Windows.Application.Resources%2A> 속성입니다. 지정된 된 리소스는 애플리케이션 범위 리소스 집합에 없는 경우 <xref:System.Windows.Application.TryFindResource%2A> 옆에는 시스템 리소스를 검색 합니다. 시스템 리소스는 사용자가 정의한 shell 리소스 있으며 색, 글꼴 및 셸 구성을 포함 합니다. 노출 되는 이러한 합니다 <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, 및 <xref:System.Windows.SystemParameters> 형식을 각각 정적 속성입니다. 사용 하도록 <xref:System.Windows.Application.TryFindResource%2A> 을 얻으려면 이러한 형식은 또한 리소스 키 속성을 노출 전달할 수 있도록 만들어진 <xref:System.Windows.Application.TryFindResource%2A>예를 들어, <xref:System.Windows.SystemParameters.IconWidthKey%2A>합니다.  
  
 때문에 <xref:System.Windows.Application.TryFindResource%2A> 개체를 반환 합니다. 리소스가 발견 하는 경우 반환된 값을 적절 한 형식으로 캐스팅 해야 합니다.  
  
 이 메서드는 스레드로부터 안전 하 고 모든 스레드에서 호출할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 사용 하는 방법을 보여 줍니다 <xref:System.Windows.Application.TryFindResource%2A> 리소스를 가져오려고 합니다.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>애플리케이션의 인스턴스화된 창을 가져옵니다.</summary>
        <value>현재 <see cref="T:System.Windows.WindowCollection" />의 모든 창 개체에 대한 참조가 들어 있는 <see cref="T:System.AppDomain" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Window> 참조를 자동으로 추가 됩니다 <xref:System.Windows.Application.Windows%2A> 창에서 인스턴스화될 즉시는 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 스레드; 작업자 스레드는 추가에서 만든 windows. A <xref:System.Windows.Window> 참조 한 후 자동으로 제거 됩니다 해당 <xref:System.Windows.Window.Closing> 이벤트가 처리 되었는지 및 하기 전에 해당 <xref:System.Windows.Window.Closed> 이벤트가 발생 합니다.  
  
 기본적으로 첫 번째 항목을 추가 합니다 <xref:System.Windows.Application.Windows%2A> 속성은는 <xref:System.Windows.Application.MainWindow%2A>합니다.  
  
 이 속성을 만든 스레드에서 에서만 사용할 수는 <xref:System.Windows.Application> 개체입니다.  
  
   
  
## Examples  
 다음 예제에서는 열거 하는 방법에 설명 합니다 <xref:System.Windows.Application.Windows%2A> 빌드에 공통적으로 적용 되는 최상위 Windows 메뉴, 속성 [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] 와 같은 애플리케이션이 [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], 같은 다중 인스턴스 단일 문서 인터페이스 (SDI) 애플리케이션 또는 [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>