<Type Name="FrameworkCompatibilityPreferences" FullName="System.Windows.FrameworkCompatibilityPreferences">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eeed517dac3189f9a8422b1c6b47b621e0e100fe" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52596278" /></Metadata><TypeSignature Language="C#" Value="public static class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed FrameworkCompatibilityPreferences extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkCompatibilityPreferences" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkCompatibilityPreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkCompatibilityPreferences abstract sealed" />
  <TypeSignature Language="F#" Value="type FrameworkCompatibilityPreferences = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>PresentationFramework 어셈블리에 있는 WPF 기능을 기준으로 응용 프로그램의 동작을 지정하는 속성을 포함합니다.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AreInactiveSelectionHighlightBrushKeysSupported">
      <MemberSignature Language="C#" Value="public static bool AreInactiveSelectionHighlightBrushKeysSupported { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property AreInactiveSelectionHighlightBrushKeysSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AreInactiveSelectionHighlightBrushKeysSupported { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AreInactiveSelectionHighlightBrushKeysSupported : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>응용 프로그램에서 선택된 비활성 항목의 색상에 대해 <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> 및 <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" /> 속성을 사용해야 하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>응용 프로그램에서 비활성 선택 항목 색상에 대해 <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightBrush" /> 및 <see cref="P:System.Windows.SystemColors.InactiveSelectionHighlightTextBrush" /> 속성을 사용해야 하는 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 기본값은 WPF의 버전을 달라 집니다는 앱의 대상입니다.  앱이 대상으로 WPF 4.0 경우 기본값은 이전에 `false`입니다.  앱에서 WPF 4.5를 대상으로 하는 경우 기본값은 `true`합니다.  WPF의 동작을 변경 하려면이 속성을 사용 하는 경우 응용 프로그램에서 상속 된 클래스의 생성자에서 같은 앱의 수명 초기에 속성의 값을 변경 해야 합니다.  값을 읽은 후 다시 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepTextBoxDisplaySynchronizedWithTextProperty">
      <MemberSignature Language="C#" Value="public static bool KeepTextBoxDisplaySynchronizedWithTextProperty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property KeepTextBoxDisplaySynchronizedWithTextProperty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeepTextBoxDisplaySynchronizedWithTextProperty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepTextBoxDisplaySynchronizedWithTextProperty : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>데이터 바인딩된 <see cref="T:System.Windows.Controls.TextBox" />가 소스의 <see cref="P:System.Windows.Controls.TextBox.Text" /> 속성 값과 동일한 문자열을 표시해야 하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>데이터 바인딩된 <see cref="T:System.Windows.Controls.TextBox" />가 소스 값과 동일한 문자열을 표시해야 하는 경우 해당  <see cref="P:System.Windows.Controls.TextBox.Text" /> 속성은 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 기본값은 WPF의 버전을 달라 집니다는 앱의 대상입니다.  앱이 대상으로 WPF 4.0 경우 기본값은 이전에 `false`입니다.  앱에서 WPF 4.5를 대상으로 하는 경우 기본값은 `true`합니다.  WPF의 동작을 변경 하려면이 속성을 사용 하는 경우 응용 프로그램에서 상속 된 클래스의 생성자에서 같은 앱의 수명 초기에 속성의 값을 변경 해야 합니다.  값을 읽은 후 다시 변경할 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldThrowOnCopyOrCutFailure">
      <MemberSignature Language="C#" Value="public static bool ShouldThrowOnCopyOrCutFailure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ShouldThrowOnCopyOrCutFailure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool ShouldThrowOnCopyOrCutFailure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShouldThrowOnCopyOrCutFailure : bool with get, set" Usage="System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Controls.Primitives.TextBoxBase" /> 인스턴스의 실패한 복사 또는 잘라내기 작업으로 인해 <see cref="T:System.Runtime.InteropServices.ExternalException" />이 발생하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Controls.Primitives.TextBoxBase" /> 인스턴스의 실패한 복사 또는 잘라내기 작업으로 인해 <see cref="T:System.Runtime.InteropServices.ExternalException" />이 발생하면 <see langword="true" />이고, 발생하지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 클립보드 작업 실패와 같은 경우 사용 하 여는 **0x800401D0 (CLIPBRD_E_CANT_OPEN) HRESULT** 오류를 해당 <xref:System.Runtime.InteropServices.ExternalException> throw 됩니다 (형식인 ExternalException의).  
  
 때문에 Win32 `OpenClipboard` API는 전역으로 잘 작성 된 응용 프로그램 호출 해야 해당 `CloseClipboard` 클립보드 작업을 완료할 때 즉시 API. 이 고, 그렇지 동일한 세션에서 실행 중인 다른 응용 프로그램에 클립보드 기능에 액세스할 수 없습니다.  
  
 Wpf에서 클립보드에 대 한 액세스를 거부 하 이러한을 자동으로 무시 일반적으로 됩니다. 응용 프로그램 수신 하도록 선택할 수는 있지만 `ExternalException` 설정 하 여 실패 시 합니다 <xref:System.Windows.FrameworkCompatibilityPreferences.ShouldThrowOnCopyOrCutFailure%2A> 플래그를 `true`입니다. 그러나에 처리 하도록 응용 프로그램 예외를 수신 하도록 옵트인 해야 <xref:System.Windows.Input.ApplicationCommands.Cut%2A> 및 <xref:System.Windows.Input.ApplicationCommands.Copy%2A> 통해 RoutedUICommands는 <xref:System.Windows.Input.CommandBinding>, 한 다음 해당 바인딩을 모든 TextBoxBase 컨트롤에 적용 (<xref:System.Windows.Controls.TextBox> 및 <xref:System.Windows.Controls.RichTextBox>)에 응용 프로그램입니다. 응용 프로그램 ExternalExceptions CommandBinding의 실행 처리기에서 복사 및 잘라내기 작업의 결과 처리 하는 확인 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>