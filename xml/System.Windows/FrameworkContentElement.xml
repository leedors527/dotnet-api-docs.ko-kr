<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e289eb77e4ff85ab443d61345dc83cbcff35de7" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52733384" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" />는 <see cref="T:System.Windows.ContentElement" /> 기본 클래스의 WPF 프레임워크 수준 구현 및 확장입니다. <see cref="T:System.Windows.FrameworkContentElement" />는 데이터 바인딩, 스타일 지원 및 논리적 트리 도우미 API를 위한 데이터 컨텍스트, 스토리보드 및 추가 입력 API(도구 설명 및 상황에 맞는 메뉴 포함)에 대한 지원을 추가합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> 고유한 렌더링 동작을 아직 정의 하지 않습니다. 실제 인스턴스화 <xref:System.Windows.FrameworkContentElement> 코드나 마크업에서 클래스 인스턴스 수는 있지만에 아무 것도 표시 된 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 응용 프로그램 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]합니다. 사용 하는 클래스에서 렌더링 논리를 제공 되어야 합니다 <xref:System.Windows.FrameworkContentElement> 자식 요소 또는 해당 콘텐츠 모델의 일부로 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다.  
  
 <xref:System.Windows.FrameworkContentElement> 대부분의 동일한 의도적 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 으로 <xref:System.Windows.FrameworkElement>입니다. 특정 참고 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 에서 찾을 <xref:System.Windows.FrameworkElement> 것을 <xref:System.Windows.FrameworkContentElement> 해당. 몇 가지는 <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 기 하 도형 표현 또는 레이아웃 등의 기능에 대 한 적합 하지 않은 것을 <xref:System.Windows.FrameworkContentElement>입니다.  
  
 대부분의 기존 <xref:System.Windows.FrameworkContentElement> 파생된 클래스를 찾을 수는 <xref:System.Windows.Documents> 네임 스페이스입니다. 파생된 클래스는 대부분 흐름 문서 모델에 대 한 요소를 구현합니다. 와 같은 특정 파생된 클래스 <xref:System.Windows.Documents.Hyperlink> 일부 제어와 비슷한 기능을 갖지만에서 파생 된 <xref:System.Windows.FrameworkContentElement> 컨트롤과 비슷한 요소를 유동 문서 모델에 참가할 수 있도록 합니다.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkContentElement" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">추가될 자식 요소입니다.</param>
        <summary>이 요소의 자식으로 제공된 요소를 추가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 다른 프로세스에 의해 논리적 트리 반복 중일 때 한 번에 호출 되는 경우 예외를 throw 수 있습니다.  
  
 대부분 <xref:System.Windows.FrameworkContentElement> 포함 담당 하는 전용된 컬렉션을 노출 하는 파생된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스 <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스). 일반적으로 이러한 클래스에서 파생 하는 경우 논리적 트리를 직접 조작할 필요가 방지할 수 있습니다. 콘텐츠 요소에 대 한 논리적 트리를 사용 하 여 작업은 특수 한 파서 또는 특수화 된 필요할 수 있는 고급 시나리오 <xref:System.Windows.FrameworkElement> 의 부모 요소로 렌더링 (콘텐츠 호스트) 역할을 합니다.  
  
 사용 하는 방법에 대 한 자세한 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 하 고 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>를 참조 하세요 [WPF의 트리](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요소를 초기화하기 전에 호출됩니다.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>요소는 요소를 로드 프로세스 중 초기화 되기 전에 발생 되어야 하는 특수 한 처리를 제공 하려면이 메서드를 재정의 합니다.  
  
구현 (기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 기본 구현을 호출 해야 합니다.  
  
기본 구현 하는 경우 예외가 throw 됩니다 <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> 에 도달 하기 전에 동일한 요소에 한 번 이상 이라고 <see cref="M:System.Windows.FrameworkContentElement.EndInit" />합니다.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>제공된 된 storyboard에 포함 된 작업 시퀀스를 시작 합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 storyboard입니다.</param>
        <summary>제공된 된 storyboard에 포함 된 작업 시퀀스를 시작 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명에 대 한 합니다 `isControllable`, 매개 변수를 해당 매개 변수를 지정 하는 경우 또는 `false`, 연결 된 애니메이션 타임 라인 시계 "Fill" 기간에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. Note는 애니메이션 제어 수도 있어야 스토리 보드 이름이 나 코드에서 인스턴스로 액세스할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 storyboard입니다.</param>
        <param name="handoffBehavior">스토리 보드에 설명 된 속성에 이미 애니메이션이 적용 되는 경우 사용할 동작을 설명 하는 열거형의 값입니다.</param>
        <summary>속성에 이미 애니메이션이 적용 되는 경우 수행할 작업에 대 한 지정 된 옵션을 사용 하 여 제공된 된 storyboard에 포함 된 작업 시퀀스를 시작 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명에 대 한 합니다 `isControllable`, 매개 변수를 해당 매개 변수를 지정 하는 경우 또는 `false`, 연결 된 애니메이션 타임 라인 시계 "Fill" 기간에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. Note는 애니메이션 제어 수도 있어야 스토리 보드 이름이 나 코드에서 인스턴스로 액세스할 수 있습니다.  
  
## <a name="using-the-compose-handoffbehavior"></a>사용 하 여 Compose HandoffBehavior  
 적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>모든 <xref:System.Windows.Media.Animation.Clock> 개체 속성과 연관 된 이전에 시스템 리소스를 소비 계속; 타이밍 시스템에서 시계를 자동으로 제거 하지 않습니다.  
  
 사용 하 여 많은 수의 clock 적용 하는 경우 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 애니메이션된 속성에서 구성 중인 클록을 제거 해야 합니다. 클록을 제거 하는 방법은 여러 가지가 있습니다.  
  
-   속성에서 모든 클록을 제거 하려면 사용 합니다 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 개체의 메서드. 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 두 번째입니다. 이 속성에서 모든 애니메이션 클록을 제거합니다.  
  
-   특정 제거할 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 의 속성을 <xref:System.Windows.Media.Animation.AnimationClock> 검색할를 <xref:System.Windows.Media.Animation.ClockController>, 호출를 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 메서드의 <xref:System.Windows.Media.Animation.ClockController>합니다. 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다. 루트 클록만 하 여 제어 될 수는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다. 또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간 무제한 인 경우 이벤트가 발생 하지 않습니다.  이 경우 사용자 호출 시기를 결정 해야 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.  
  
 이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.  개체는 가비지 수집 되 면 해당 클록도 연결이 끊어집니다 및 가비지 수집 합니다.  
  
 클록 개체에 대 한 자세한 내용은 참조 하세요. [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">시작할 storyboard입니다.</param>
        <param name="handoffBehavior">스토리보드에 설명되어 있는 속성에 이미 애니메이션이 적용되어 있는 경우에 사용할 동작을 설명하는 열거형의 값입니다.</param>
        <param name="isControllable">애니메이션을 제어할 수 있는지 여부를 선언 (수 일시 중지 할) 시작 된 후입니다.</param>
        <summary>시작 된 후 애니메이션의 컨트롤에 대 한 지정 된 상태를 사용 하 여 제공된 된 storyboard에 포함 된 작업 시퀀스를 시작 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하지 않는 서명에 대 한 합니다 `isControllable`, 매개 변수를 해당 매개 변수를 지정 하는 경우 또는 `false`, 연결 된 애니메이션 타임 라인 시계 "Fill" 기간에 도달 하는 즉시 제거 됩니다. 따라서 애니메이션 번 실행 한 후 다시 시작할 수 없습니다. Note는 애니메이션 제어 수도 있어야 스토리 보드 이름이 나 코드에서 인스턴스로 액세스할 수 있습니다.  
  
## <a name="using-the-compose-handoffbehavior"></a>사용 하 여 Compose HandoffBehavior  
 적용 하는 경우는 <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, 또는 <xref:System.Windows.Media.Animation.AnimationClock> 사용 하 여 속성에는 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>모든 <xref:System.Windows.Media.Animation.Clock> 개체 속성과 연관 된 이전에 시스템 리소스를 소비 계속; 타이밍 시스템에서 자동으로 이러한 클록을 제거 하지 않습니다.  
  
 사용 하 여 많은 수의 clock 적용 하는 경우 성능 문제를 방지 하려면 <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>를 완성 한 후 애니메이션된 속성에서 구성 중인 클록을 제거 해야 합니다. 클록을 제거 하는 방법은 여러 가지가 있습니다.  
  
-   속성에서 모든 클록을 제거 하려면 사용 합니다 <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 또는 <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> 애니메이션된 개체의 메서드. 첫 번째 매개 변수로 애니메이션 효과가 적용 되는 속성을 지정 하 고 `null` 두 번째입니다. 이 속성에서 모든 애니메이션 클록을 제거합니다.  
  
-   특정 제거할 <xref:System.Windows.Media.Animation.AnimationClock> 클록 목록에서 사용 하 여는 <xref:System.Windows.Media.Animation.Clock.Controller%2A> 의 속성을 <xref:System.Windows.Media.Animation.AnimationClock> 검색할를 <xref:System.Windows.Media.Animation.ClockController>, 호출를 <xref:System.Windows.Media.Animation.ClockController.Remove%2A> 메서드의 <xref:System.Windows.Media.Animation.ClockController>합니다. 이 일반적으로 수행 된 <xref:System.Windows.Media.Animation.Clock.Completed> 클록에 대 한 이벤트 처리기입니다. 루트 클록만 하 여 제어 될 수는 <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> 자식 클록의 속성을 반환 `null`합니다. 또한는 <xref:System.Windows.Media.Animation.Clock.Completed> 클록의 유효 기간 무제한 인 경우 이벤트가 발생 하지 않습니다.  이 경우 사용자 호출 시기를 결정 해야 <xref:System.Windows.Media.Animation.ClockController.Remove%2A>합니다.  
  
 이것은 주로 수명이 긴 개체에 대한 애니메이션에서 문제가 됩니다.  개체는 가비지 수집 되 면 해당 클록도 연결이 끊어집니다 및 가비지 수집 합니다.  
  
 클록 개체에 대 한 자세한 내용은 참조 하세요. [애니메이션 및 타이밍 시스템 개요](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>가져오거나 설정 합니다 <see cref="T:System.Windows.Data.BindingGroup" /> 요소에 사용 되는 합니다.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> 요소에 사용 되는 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup> 개체의 여러 속성의 값 유효성 검사에 사용할 수 있습니다. 예를 들어 응용 프로그램 주소를 입력 하 라는 메시지를 다음 형식의 개체를 채웁니다 `Address`, 속성이 있는 `Street`, `City`, `ZipCode`, 및 `Country`, 값을 사용 하는 사용자 제공 합니다. 응용 프로그램에 4 개를 포함 하는 패널 <xref:System.Windows.Controls.TextBox> 개체의 속성 중 하나에 바인딩되는 컨트롤입니다. 사용할 수는 <xref:System.Windows.Controls.ValidationRule> 에 <xref:System.Windows.Data.BindingGroup> 유효성을 검사 하는 `Address` 개체. 예를 들어를 <xref:System.Windows.Controls.ValidationRule> 우편 주소의 국가 대 한 유효한 지 확인할 수 있습니다.  
  
 자식 요소에서 상속 된 <xref:System.Windows.Data.BindingGroup> 다른 상속 가능한 속성에서와 마찬가지로 해당 부모 요소에서.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 요소를 포함 된 스크롤 가능한 영역 내에서 뷰에 표시 하려고 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 호출 하면 호출 됩니다 <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 요소가 포함 된 부모 스크롤 가능한 영역에서 (부모 수 있을 것을 <xref:System.Windows.FrameworkElement>아니라는 <xref:System.Windows.FrameworkContentElement>). 이 요소는 스크롤 가능한 영역에 포함 되지 않은, 경우 이벤트가 계속 발생 하지만 효과가 있을 것입니다.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">방법: scrollviewer가 만들기</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>상황에 맞는 메뉴를 통해 요청 될 때마다 표시 되는 상황에 맞는 메뉴 요소를 가져오거나 설정 합니다. [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 에서이 요소 내에서.</summary>
        <value>이 요소를 사용 하는 상황에 맞는 메뉴입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 위치를 <xref:System.Windows.Controls.ContextMenu> 에 <xref:System.Windows.Documents.Paragraph>합니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소에 맞는 메뉴가 닫히기 바로 전에 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 닫히지 않도록 하려면 상황에 맞는 메뉴는 이벤트 처리기로 표시 해야 처리.  
  
 이 이벤트를 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (이 사용 되므로 필요한에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 는 노출 기본 서비스 이벤트를 올바르게 매핑되지를 <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> 트리거에 사용에 대 한 식별자)입니다.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 다음 예제에서는 명명 된 영역 위에 커서를 변경 하는 처리기 구현 `DisplayArea` (표시 되지 않음). 주석에서 힌트를 <xref:System.Windows.UIElement> 사용량 사실이 샘플은 동일 하지만 경우 `DisplayArea` 된를 <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소에 맞는 메뉴가 열릴 때 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 상황에 맞는 메뉴를 열고 수동으로, 처리 된 것으로 이벤트 처리기 관련 이벤트를 표시 해야 합니다. 이 고, 그렇지의 기존 값을 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 속성이 자동으로 상황에 맞는 메뉴를 열려면 사용 됩니다. 이벤트를 처리 된 기본 작업을 효과적으로 취소 하 고 수 값을 다시 설정할 수는 <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 속성 연 다음 새 <xref:System.Windows.Controls.ContextMenu>합니다. 그러나 고려해 야 타이밍 문제가 있습니다. 통해 상황에 맞는 메뉴를 완전히 바꾸기 위해는 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 처리기 초기 상황에 맞는 메뉴 아니어야 null 이거나 비어 있습니다. 또는 이벤트를 처리 하 여 수동으로 새 상황에 맞는 메뉴를 엽니다 해야 할 수 있습니다. 자세한 내용은 참조 하세요 [방법: ContextMenuOpening 이벤트 처리](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)합니다.  
  
 이 이벤트를 사용 하는 <xref:System.Windows.EventTrigger> 스타일에서 기본 서비스 이벤트 식별자를 참조 해야 합니다.  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (이 사용 되므로 필요한에서 이벤트를 구현 <xref:System.Windows.FrameworkContentElement> 는 노출 기본 서비스 이벤트를 올바르게 매핑되지를 <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> 트리거에 사용에 대 한 식별자)입니다.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|라우팅 전략|버블링|  
|대리자|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>마우스 포인터가 이 요소 위에 있을 때 표시되는 커서를 가져오거나 설정합니다.</summary>
        <value>표시할 커서입니다. 기본값은 이 종속성 속성마다 <see langword="null" />로 정의됩니다. 그러나 런타임 시 실제 기본값은 다양한 요소에서 비롯됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]의 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 프로세서에 대 한 형식 변환에 의존 합니다 <xref:System.Windows.Input.Cursor> 문자열을 평가 하는 클래스입니다. 제공된 된 문자열을 평가할지를 <xref:System.Windows.Input.CursorType> 값입니다. 자세한 내용은 <xref:System.Windows.Input.Cursor>를 참조하세요.  
  
 이 속성으로 설정 된 커서는 마우스 포인터가이 요소 위에 있을 때 표시 되지 것입니다 하는지 여부의 값에 따라 달라 집니다 이기도 합니다 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 속성입니다. 또한는 활성 끌기, 마우스 캡처, 컨트롤 및 등과 내의 텍스트 편집 모드와 같은 이벤트 관련 고려 사항을이 속성에 지정 된 값 보다 높은 우선 순위를 사용 하 여 커서를 적용도 됩니다.  
  
 로 설정, 최종 기본적으로이 속성을 설정 하는 동작으로 되돌리려면 `null` 다시 합니다.  
  
 `null` 기본값인은 실제 커서 값 결정 여기 지연 되 고이 다른 곳에서 가져와야 하는 의미입니다. 통해 모든 원본의 기본 커서를 프로그래밍 방식으로 값 없이 표시 되는 경우는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 응용 프로그램 화살표를 수 있습니다.  
  
 위에 마우스를 움직일 때마다를 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 발생을 <xref:System.Windows.ContentElement.QueryCursor> 이벤트입니다. 이 이벤트는 버블링, 및 경로 따라 모든 요소는 이벤트를 처리 하 고이 이벤트의 인수를 통해 커서의 값을 설정 합니다. 이런 경우, 이벤트 처리 하 고 인수에 변경 된 값 보다 우선 값을 <xref:System.Windows.FrameworkContentElement.Cursor%2A> 모든 수준에서 속성 하지 않는 한 <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 설정 됩니다.  
  
 사용자 지정 커서를 만들지, 일반적으로 설정한 경우이 속성의 정적 속성 값에는 <xref:System.Windows.Input.Cursors> 클래스입니다.  
  
 설정 된 <xref:System.Windows.Input.Cursor> 사용자 지정 값으로 설정 되지 않은 부분 신뢰 합니다. 사용자 지정 커서에 대 한 자세한 내용은 참조 하세요. [입력 개요](~/docs/framework/wpf/advanced/input-overview.md)합니다.  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 사용자 지정 값으로 커서를 설정 합니다.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>데이터 바인딩에 참여할 때 요소에 대한 데이터 컨텍스트를 가져오거나 설정합니다.</summary>
        <value>데이터 컨텍스트로 사용할 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *데이터 컨텍스트* 는 요소가 바인딩 뿐만 아니라 경로 같은 바인딩의 다른 특성에 사용 되는 바인딩 소스에 대 한 부모 요소 로부터 정보를 상속할 수 있도록 하는 개념입니다.  
  
 데이터 컨텍스트를 직접 설정할 수 있습니다는 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 바인딩 해당 개체의 속성을 사용 하 여 개체입니다. 데이터 컨텍스트 설정할 수 있습니다 또는 한 <xref:System.Windows.Data.DataSourceProvider> 개체입니다.  
  
 속성 값이 종속성 속성을 상속 합니다. 자식 요소에 대 한 다른 값이 없는 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정할 수는 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
 다음 속성 중 하나를 사용할 수는 또는 <xref:System.Windows.Data.Binding> 바인딩 소스를 명시적으로 지정 하는 클래스: <xref:System.Windows.Data.Binding.ElementName%2A>를 <xref:System.Windows.Data.Binding.Source%2A>, 또는 <xref:System.Windows.Data.Binding.RelativeSource%2A>합니다. 자세한 내용은 [방법: 바인딩 소스 지정](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)합니다.  
  
 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> 으로 설정 되어 가장 일반적으로 <xref:System.Windows.Data.Binding> 선언 합니다. 속성 요소 구문이 나 특성 구문을 사용할 수 있습니다. 특성 구문 예제에서는이 페이지에 표시 됩니다. 설정할 수도 있습니다 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 코드에서입니다.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 값  
 *dataContextObject*  
 부모 요소 내에서 모든 바인딩에 대 한 데이터 컨텍스트로 사용 되는 직접 포함 된 개체입니다. 이 개체는 일반적으로 <xref:System.Windows.Data.Binding> 또는 다른 <xref:System.Windows.Data.BindingBase> 하위 클래스입니다. 또는 모든 원시 데이터 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 개체 유형을 위해 나중에 정의 된 실제 바인딩은 바인딩 여기에 배치할 수 있습니다.  
  
 *bindingUsage*  
 적절 한 데이터 컨텍스트를으로 계산 되는 바인딩 사용 합니다. 자세한 내용은 [Binding 태그 확장](~/docs/framework/wpf/advanced/binding-markup-extension.md)을 참조하세요.  
  
 *resourceExtension*  
 다음 중 하나: `StaticResource`, 또는 `DynamicResource`합니다. 리소스에서 사용 되는 개체로 정의 하는 원시 데이터를 참조할 때 사용 됩니다. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *contextResourceKey*  
 내에서 요청 된 개체에 대 한 키 식별자는 <xref:System.Windows.ResourceDictionary>합니다.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 다음 예제에서 바인딩을 설정 합니다.는 <xref:System.Windows.Documents.Paragraph> 요소를 해당 개체로 설정 하 여 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 및 그 속성에 바인딩 경로 설정 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 데이터 컨텍스트가 변경 될 때 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 데이터 컨텍스트 및 데이터 바인딩에 설명은 참조 하세요. [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.  
  
> [!IMPORTANT]
>  요소의 경우 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 이 요소에 모든 데이터 바인딩된 속성 변경 내용을 잠재적으로 영향을 받는 합니다. 이 데이터 컨텍스트를 상속 하는 현재 요소의 하위 요소가 있는 모든 요소 및 현재 요소 자체에 적용 됩니다. 이러한 모든 바인딩을 다시 새 해석 <xref:System.Windows.FrameworkContentElement.DataContext%2A> 바인딩에서 새 값을 반영 하도록 합니다. 이러한 변경의 발생을 기준으로 순서 대로 수행 보장이 <xref:System.Windows.FrameworkContentElement.DataContextChanged> 이벤트입니다.  변경 내용을 조합 또는 이벤트 후 이벤트 전에 발생할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>테마에서이 컨트롤에 대 한 스타일 템플릿을 찾는 데 사용할 키를 가져오거나 설정 합니다.</summary>
        <value>스타일 키입니다. 테마 스타일 조회의 일부로 올바르게 작동 하려면이 값 이어야 하는데를 <see cref="T:System.Type" /> 스타일이 지정 되는 요소입니다. <see langword="null" /> 특정 사례에 대해 허용 된 값이입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 일반적으로 직접 setter 통해 설정 되지 않습니다. 대신 새 하위 클래스를 만들 때마다이 종속성 속성의 형식별 메타 데이터를 재정의 합니다. 때 있습니다 서브 클래스를 호출 합니다 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 에 대해 메서드를 <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> 컨트롤 하위 클래스의 정적 생성자 내에서 식별자.  
  
 예를 들어, 인라인 클래스와 같은 <xref:System.Windows.Documents.Bold> 재정의 초과 거의 구현이 실제로 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 메타 데이터에 해당 정적 생성자를 여러 인스턴스 생성자를 노출 합니다. 요소 둘러싸인 사실을 <xref:System.Windows.Documents.Bold> 향상 태그를 <xref:System.Windows.Documents.TextElement.FontWeight%2A> 속성을 <xref:System.Windows.FontWeights.Bold%2A> 의 기본값을 설정 하 여 참조 된 테마 스타일 내에서 구현 되 <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> 에 `typeof(Bold)`입니다.  
  
 테마 스타일을 사용 하지 않도록 의도적으로 컨트롤을 설정 합니다 <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> 속성을 `true`입니다.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>요소를 초기화한 후에 바로 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소를 로드 프로세스 동안 요소를 초기화 하는 경우 발생 되어야 하는 특수 한 처리를 제공 하려면이 메서드를 구현 합니다.  
  
 구현 (기본값) 기본 구현을 초기화를 추적 하기 위해 일부 내부 플래그를 설정 하기 때문에 기본 구현을 호출 해야 합니다.  
  
 하는 경우 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 이전에 호출 기본 구현 시킵니다는 <xref:System.Windows.FrameworkContentElement.Initialized> 이벤트입니다. 그렇지 않은 경우, <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 를 호출 하지 않았습니다 것일 수도 되었는지를 확인할 <xref:System.Windows.FrameworkContentElement.BeginInit%2A> 가 호출 되는 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">검색할 요소의 이름입니다.</param>
        <summary>제공된 식별자 이름의 요소를 찾습니다.</summary>
        <returns>요청한 요소입니다. 않을 <see langword="null" /> 가 일치 하는 요소가 없는 경우.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 요소에 자식 요소가 있으면 이러한 자식 요소는 요청 된 명명 된 요소에 대 한 모든 검색된을 재귀적으로 합니다.  
  
   
  
## Examples  
 참조 된 내에서 이름으로 검색 되는 요소에서 속성을 설정 하는 다음 예제에서는 <xref:System.Windows.Documents.FlowDocument> 페이지에 있습니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스의 키 식별자입니다.</param>
        <summary>지정된 키를 사용하여 리소스를 검색하고, 요청된 리소스가 없으면 예외를 발생시킵니다.</summary>
        <returns>찾은 리소스 또는 일치하는 리소스가 없는 경우 <see langword="null" />입니다(<see langword="null" />인 경우 예외도 발생함).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  찾을 수 없는 키에 대 한이 메서드를 호출 하면 예외가 throw 됩니다. 이 경우는 예외를 처리 하지 않으려면 대신 호출 해야 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>합니다. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 반환 `null` 리소스가 발견 되 면 시간과 예외를 throw 하지 않습니다.  
  
 리소스를 호출 하는 요소에 없는 논리적 트리를 사용 하 여 부모 트리를 검색 하는 경우 런타임에 키로 요청 된 리소스 검색된 경우 트리는 동일한 방식에서입니다.  
  
 일반적으로 즉시 캐스팅 반환 되는 리소스 값으로 설정 하 려 했던는 속성의 형식으로 반환 합니다.  
  
   
  
## Examples  
 다음 예제에서는 태그에 정의 된 대로 리소스를 찾습니다 및 라우트된 이벤트에 대 한 응답에 있는 요소의 특정 속성에 적용 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">요청된 리소스 키가 없는 경우</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" />가 <see langword="null" />인 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>키보드 포커스를 캡처할 때 이 요소에 적용되는 모양, 효과 또는 기타 스타일 특성을 사용자 지정할 수 있는 개체를 가져오거나 설정합니다.</summary>
        <value>포커스에 적용하려는 스타일입니다. 종속성 속성에 선언된 기본값은 빈 정적 <see cref="T:System.Windows.Style" />입니다. 그러나 런타임 시 유효 값은 대체로(항상 그렇지는 않음) 컨트롤에 대한 테마 지원에서 제공되는 스타일입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정할 때 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]스타일은 거의 항상 요소로 인라인 아닌 리소스 정의으로 참조 리소스는 일반적으로 <xref:System.Windows.StaticResourceExtension>합니다.  
  
 이 속성 시각적 모양에 영향을 줍니다 하지만 보고 하지 않습니다 있도록 메타 데이터에는 참고 합니다. 시각적 모양 변경 이벤트 구동 모든 시간에 적용 되지 않을 수 고 따라서은 일반적으로 보고 메타 데이터의 시각적 개체 또는 레이아웃 정보가 때문입니다.  
  
 개념상 컨트롤에 적용 되는 포커스의 시각적 동작 요소를 일관 된 있어야 합니다. 일관성을 적용 하는 가장 적절 한 방법은 전체 테마를 작성 하는 경우에 포커스 비주얼 스타일을 변경 하는 경우 테마의 일부가 아니라 개별 스타일에서이 속성을 설정할 수는 없습니다. 요소 관련 동작을 의도적으로 일관 된 테마를 하려는 경우 더 좋은 방법은 사용 하는 것 트리거 스타일의 개별 입력된 상태 속성에 대 한 같은 <xref:System.Windows.UIElement.IsFocused%2A> 또는 <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, 하지 않는 방식으로 작업을 수행 하 고 모든 기존 포커스 비주얼 스타일을 사용 하 여 시각적 방해 합니다. 디자인 의도 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> 및 대체 내용은 속성을 집중 [컨트롤 및 FocusVisualStyle의 포커스 스타일 지정](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)합니다.  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 값  
 *resourceExtension*  
 다음 중 하나:, 또는 합니다. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *styleResourceKey*  
 요청 되는 스타일을 식별 하는 키입니다. 키의 기존 리소스에 참조를 <xref:System.Windows.ResourceDictionary>입니다.  
  
> [!NOTE]
>  속성 요소 구문은 기술적으로 가능 하지만 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.  사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>나타내는 값을 가져오거나 여부를이 <see cref="T:System.Windows.FrameworkContentElement" /> 강제로 수행 해야 합니다 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 이 인스턴스에 의해 선언 된 커서를 렌더링 하 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 속성입니다.</summary>
        <value><see langword="true" /> (모든 자식 요소 포함); 커서에 대 한 설정의이 인스턴스를 사용 하려면이 요소 위에 있는 동안 커서가 표시 되도록 하려면 그렇지 않으면 <see langword="false" />합니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 `true` 자식 요소에서 설정한 커서 기본 설정이 재정의 됩니다. 이렇게 하면 응용 프로그램에서 일반적 이므로 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 자식 요소는 커서를 지정 하려는 경우에 특히 사용자에 대해 혼동 될 수 있습니다. 설정 <xref:System.Windows.FrameworkElement.ForceCursor%2A> 컨트롤 서브클래싱 또는 합성 시나리오에 더 적합 합니다.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 요소 위에 있는 동안 커서를 강제로 수행 합니다.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">대상 <see cref="T:System.Windows.DependencyProperty" /> 바인딩을 가져올입니다.</param>
        <summary>가져옵니다는 <see cref="T:System.Windows.Data.BindingExpression" /> 지정된 된 속성의 바인딩에 대 한 합니다.</summary>
        <returns>반환 된 <see cref="T:System.Windows.Data.BindingExpression" /> 대상이 데이터 바인딩되어 있으면 이면이 고, 그렇지 <see langword="null" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 속성을 쿼리하여 바인딩을 검색 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>시각적 부모가 없는 경우 이 요소에 대한 대체 논리 부모를 반환합니다. 이 경우 <see cref="T:System.Windows.FrameworkContentElement" /> 부모는 항상 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 속성과 동일한 값입니다.</summary>
        <returns>이 메서드의 WPF 프레임워크 수준 구현에 시각적 부모가 아닌 연결이 있을 때마다 <see langword="null" /> 이외의 값을 반환합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본 구현은 예상된 단일 시각적 부모를 반환합니다. 사용자 지정 구현을 대체 부모 관계를 반환할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>발생 하면이 <see cref="T:System.Windows.FrameworkContentElement" /> 초기화 됩니다. 사례와 일치 하는이 위치 값을 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 속성에서 변경 <see langword="false" /> (또는 undefined)를 <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 됩니다 될 때마다 발생 합니다 <xref:System.Windows.FrameworkContentElement.EndInit%2A> 또는 <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> 메서드를 호출 합니다. 이러한 메서드 호출 수 있는 의도적으로 코드를 사용 하거나는 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 프로세스를 로드 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />에서 사용되는 입력에 대한 컨텍스트를 가져오거나 설정합니다.</summary>
        <value>대체 입력 메서드에서 입력이 해석되는 방법을 수정하는 입력 범위입니다. 기본값은 <see langword="null" />(명령의 기본 처리 결과)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값이 종속성 속성을 상속 합니다. 자식 요소에 대 한 다른 값이 없는 경우 <xref:System.Windows.FrameworkElement.InputScope%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정할 수는 <xref:System.Windows.FrameworkElement.InputScope%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
 하지만 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문 사용은 나열 되 고 구문적으로,이 속성 설정 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 흔하지 않습니다.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소가 초기화 되었는지 하거나 여로 로드 여부를 나타내는 값을 가져옵니다 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]를 명시적으로 해당 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 메서드를 호출 합니다.</summary>
        <value><see langword="true" /> 요소는 앞서 언급 한 로드 또는 메서드 호출 마다 초기화 되 면 그렇지 않으면 <see langword="false" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 수도 `true` 경우이 요소에 옮겨졌습니다 요소 트리 내에서 새 부모 요소에 있고 따라서 요소가 다시 로드 되도록 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소를 프레젠테이션을 위해 로드 했는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value><see langword="true" /> 현재 요소가 요소 트리에 연결 되어 있으며 렌더링 되었으면 하는 경우 <see langword="false" /> 요소 로드 된 요소 트리에 연결 되지 않았으면 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 새로 생성 된 인스턴스에서이 속성 설정을 시작할 `false`를 그대로 유지 됩니다 `true` 로 설정 되 면 `true`이후에 코드에서 제거 하는 경우에 합니다.  
  
   
  
## Examples  
 다음 예제 코드를 사용 하 여 <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> 함수를 보증할 수 조건 검사 `displayData` (표시 되지 않음)는 유효한 요소를 로드 페이지의 요청 시 처리기의 일부로 작동할 수 있습니다. 동일한 논리에 대 한 이벤트 처리기로 실행 되는 <xref:System.Windows.FrameworkContentElement.Loaded>합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>개별 요소에 적용되는 지역화/전역화 언어 정보를 가져오거나 설정합니다.</summary>
        <value>이 요소에 대한 문화권 정보입니다. 기본값은 해당 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 값이 문자열 "en-US"로 설정된 <see cref="T:System.Windows.Markup.XmlLanguage" /> 인스턴스입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 RFC 3066 표준을 수행 하는 문자열 형식입니다. 예를 들어, 미국 영어는 "EN-US"입니다. 참조 <xref:System.Windows.Markup.XmlLanguage> 값 및 형식에 대 한 자세한 내용은 합니다.  
  
 속성 값이 종속성 속성을 상속 합니다. 자식 요소에 대 한 다른 값이 없는 경우 <xref:System.Windows.FrameworkElement.Language%2A> 를 통해 로컬 값 또는 스타일 설정 속성 시스템은 값을 설정할 수는 <xref:System.Windows.FrameworkElement.Language%2A> 이 값이 할당 된 가장 가까운 부모 요소의 값입니다.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.Language" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소를 배치하고 렌더링하여 상호 작용할 준비가 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 직접 라우트된 이벤트에 대 한 경로 따르지, 발생 하는 동일한 요소 내 에서만 처리 됩니다. 라우트된 이벤트는 라우트된 이벤트 동작은 다른 지원지 않습니다 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 논리적 자식에 대 한 열거자를 가져옵니다.</summary>
        <value>이 요소의 논리적 자식 요소에 대 한 열거자입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 방법에 대 한 자세한 내용은 <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> 하 고 <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>를 참조 하세요 [WPF의 트리](~/docs/framework/wpf/advanced/trees-in-wpf.md)합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">포커스가 열거형의 값으로 이동 하는 방향입니다.</param>
        <summary>이 요소에서 다른 요소에 키보드 포커스를 이동합니다.</summary>
        <returns>반환 <see langword="true" /> 포커스가 이동 되었으면 하는 경우 <see langword="false" /> 대상 요소 방향을 지정 하는 존재 하지 않는 경우.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소를 식별하는 이름을 가져오거나 설정합니다. 이름은 이벤트 처리기 코드와 같은 프로그래밍 코드 숨김에서 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문을 분석하는 동안 생성된 요소를 참조할 수 있도록 인스턴스 참조를 제공합니다.</summary>
        <value>요소의 이름을 나타내며</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 가장 일반적인 사용법은 지정 하는 경우는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 태그의 요소 이름입니다.  
  
 이 속성은 기본적으로 설정 하는 WPF 프레임 워크 수준 편의 속성을 제공 합니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 지시문](~/docs/framework/xaml-services/x-name-directive.md)합니다.  
  
 가져오기는 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 일반적이 지 이므로 코드에 적절 한 참조가 이미 있는 경우 메서드를 호출 하기만 하면 요소에서 속성 참조 및 수행 해야 일반적으로 <xref:System.Windows.FrameworkContentElement.Name%2A>합니다. 예외는 문자열에 있는 경우 일부 오버 로드 된 즉, 예를 들어에서 해당 이름을 표시 하는 데 유용 하다 면 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다. 설정 된 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 경우 원래 <xref:System.Windows.FrameworkContentElement.Name%2A> 된 태그에서 설정도 권장 되지 않습니다 및 속성을 변경 해도 개체 참조가 변경 되지 것입니다. 기본 이름 범위를 명시적으로 하는 동안 만든 경우에 이러한 개체 참조가 만들어집니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 로드 합니다.  
  
 명시적으로 호출 해야 합니다 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 에 대 한 효과적인 변경 되도록는 <xref:System.Windows.FrameworkContentElement.Name%2A> 이미 로드 된 요소의 속성입니다.  
  
 하나 주목할 만한에서는 설정 경우 <xref:System.Windows.FrameworkContentElement.Name%2A> 코드에서 명명 요소는 스토리 보드를 실행할입니다. 이름을 등록할 수 있습니다, 전에를 인스턴스화할 때 할당 해야 할 수는 <xref:System.Windows.NameScope> 인스턴스. 예제 섹션을 참조 하거나 [스토리 보드 개요](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다.  
  
 설정 <xref:System.Windows.FrameworkContentElement.Name%2A> 에서 코드를 응용 프로그램을 제한적 이지만 요소 이름별 조회 보다 일반적 위치 페이지 응용 프로그램에 로드 하 고 런타임에 코드를 반드시 않습니다의 코드 숨김 탐색 모델을 사용 중인 경우에 특히 해당 페이지입니다. 유틸리티 메서드 <xref:System.Windows.FrameworkContentElement.FindName%2A>에서 사용할 수 있는 <xref:System.Windows.FrameworkContentElement>, 모든 요소를 찾을 수 있습니다 <xref:System.Windows.FrameworkContentElement.Name%2A> 논리 트리를 재귀적으로 해당 요소에서. 사용할 수 있습니다는 <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> 의 정적 메서드 <xref:System.Windows.LogicalTreeHelper>도 적용 되는 <xref:System.Windows.FrameworkContentElement.Name%2A> 인수로 문자열입니다.  
  
 일반적으로 사용 되는 루트 요소 (<xref:System.Windows.Window>하십시오 <xref:System.Windows.Controls.Page> 예를 들어) 인터페이스를 구현 <xref:System.Windows.Markup.INameScope>합니다. 이 인터페이스의 구현은 이름이 해당 범위 내에서 명확 해야 하는 적용 되어야 합니다.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.Name" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 데이터를 제공합니다.</param>
        <summary>때마다 호출 된 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 이 메서드를 구현 하는 중간 클래스에서 상속 하는 경우에 기본 구현을 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 메서드: 파생 된 클래스는 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트는 라우트된 이벤트가입니다. 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 On * 메서드는 구현 패턴은 라우트된 이벤트에 대 한 다른 합니다. 따라서 구현을 고려해 야 할 이벤트 인수의 소스 속성을 갖습니다 (및 대부분의 경우에서에서는 이벤트가 다시 발생 하지 않아야). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 하나의 잠재적인 시나리오는 이벤트의 인수를 사용 하 고 경로 줄이기 위해 처리 된 것으로 의도적으로 이벤트를 표시 하는 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 이벤트 데이터입니다.</param>
        <summary>때마다 호출 된 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 이 메서드를 구현 하는 중간 클래스에서 상속 하는 경우에 여전히 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 메서드: 파생 된 클래스는 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트는 라우트된 이벤트가입니다. 이벤트 인수를 원본 되려면 구현 해야 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 On * 메서드는 구현 패턴은 라우트된 이벤트에 대 한 다른 계정에는 속성 (및 대부분의 경우에서에서는 이벤트가 다시 발생 하지 않아야). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 하나의 잠재적인 시나리오는 이벤트의 인수를 사용 하 고 경로 줄이기 위해 처리 된 것으로 의도적으로 이벤트를 표시 하는 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 이벤트 데이터입니다.</param>
        <summary>에 대 한 클래스 처리기는 <see cref="E:System.Windows.ContentElement.GotFocus" /> 이벤트입니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스 처리기는이 요소에서 이벤트가 시작 된 경우이 요소에 적절 한 포커스 동작을 설정 합니다. 이벤트의 원본에 트리의 다른 요소 되었으면 처리기 일은 없습니다.  
  
 이러한 기본 요소에 포커스 동작을 변경 하려면이 메서드를 재정의 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 이벤트를 발생시킵니다. 이 메서드가 호출 될 때마다 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 로 설정 된 <see langword="true" />합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 가상 메서드의 기본 구현은이 항목의 앞부분에 설명 된 대로 이벤트를 발생 시킵니다. 재정의이 동작을 유지 하려면 base ()를 호출 해야 합니다.  
  
 <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> 속성은 읽기 전용입니다. 따라서 이렇게 초기화 동작을 강제 적용 되도록 설정할 수 없습니다. 초기화 설정은 에서만 수행 해야 하는 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 프레임 워크입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">기존 값 및 새 값을 포함하여 변경된 속성을 설명하는 이벤트 데이터입니다.</param>
        <summary>이 <see cref="T:System.Windows.FrameworkContentElement" />에서 종속성 속성의 유효 값이 업데이트될 때마다 호출됩니다. 변경된 특정 종속성 속성이 인수 매개 변수에서 보고됩니다. <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />를 재정의합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일반적으로 속성 변경 내용 또는 무효화를 검색 하려면이 메서드를 사용 하는 것이 없습니다. 대신 것은 일반적인 무효화 패턴의 수정에 대 한 속성의 광범위 한 분류에 대 한 특정 정보가 알려져 있는 경우.  
  
 이 메서드 개체의 수명 동안 여러 번 호출 될 수도 있습니다. 따라서 특정 속성의 메타 데이터를 무시 하 고 다음 연결 성능을 높일 수 있습니다 <xref:System.Windows.CoerceValueCallback> 또는 <xref:System.Windows.PropertyChangedCallback> 개별 속성에 대 한 함수입니다. 하지만 경우이 메서드를 사용 하는를 <xref:System.Windows.FrameworkContentElement> 많은 값을 상호 연관 된 종속성 속성을 포함 하는 렌더링 동작을 다시 실행 해야 다양 한 관련 속성 무효화의 경우와 같은 논리를 포함 하는 경우 또는 합니다.  
  
 점이 동일 하 게 명명 된 `OnPropertyChanged` 다른 시그니처가 있는 메서드 (매개 변수 형식은 <xref:System.ComponentModel.PropertyChangedEventArgs>)는 다양 한 클래스에 나타날 수 있습니다. 있는지 `OnPropertyChanged` 데이터 개체 알림에 사용 되 고 계약의 일부인 <xref:System.ComponentModel.INotifyPropertyChanged>합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>구현에서 첫 번째 작업으로 기본 구현에서는 항상 호출 합니다. 이렇게 하지 않으면 전체 없게 되므로 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 속성 시스템에 잘못 된 값을 보고 합니다.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">이전 스타일입니다.</param>
        <param name="newStyle">새 스타일입니다.</param>
        <summary>이 요소를 변경에서 사용 하에서는 스타일 때 호출 됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 조건을 변경 하는 스타일을 나타내는 내부 플래그를 설정 하는 기본 구현입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>항상 기본 구현을 호출, 그렇지 않으면 스타일을 적용할 수 없습니다. 파생된 클래스에는 특수 한 스타일 선택기 또는 스타일 값을 캐시 하는 경우이 메서드를 재정의 하는 것에 대 한 시나리오 포함 될 수 있습니다. 테마 변경은 잠재적으로이 메서드를 호출 합니다.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 데이터를 제공합니다.</param>
        <summary>때마다 호출 된 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 이 메서드를 구현 하는 중간 클래스에서 상속 하는 경우에 여전히 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 메서드: 파생 된 클래스는 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트는 라우트된 이벤트가입니다. 이벤트 인수를 원본 되려면 구현 해야 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 On * 메서드는 구현 패턴은 라우트된 이벤트에 대 한 다른 계정에는 속성 (및 대부분의 경우에서에서는 이벤트가 다시 발생 하지 않아야). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 하나의 잠재적인 시나리오는 이벤트의 인수를 사용 하 고 경로 줄이기 위해 처리 된 것으로 의도적으로 이벤트를 표시 하는 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트에 대 한 데이터를 제공합니다.</param>
        <summary>때마다 호출 된 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 라우트된 이벤트가 해당 경로에서이 클래스에 도달 합니다. 이 이벤트에 대한 클래스 처리를 추가하려면 이 메서드를 구현합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 기본 구현이 없습니다. 이 메서드를 구현 하는 중간 클래스에서 상속 하는 경우에 여전히 base ()를 호출 해야 합니다.  
  
 이 메서드는 다소 비슷합니다 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 이벤트 패턴에서 * 메서드: 파생 된 클래스는 인스턴스 처리기 대신 클래스 처리기를 사용 하 여 일치 하는 이벤트를 처리 하는 방법을 제공 합니다. 이 경우 일치 하는 이벤트는 라우트된 이벤트가입니다. 이벤트 인수를 원본 되려면 구현 해야 하므로 처리기를 호출 하는 요소가 아닌 자식 요소에 의해 발생 했을 수 있으므로 On * 메서드는 구현 패턴은 라우트된 이벤트에 대 한 다른 계정에는 속성 (및 대부분의 경우에서에서는 이벤트가 다시 발생 하지 않아야). 서브 클래스 <xref:System.Windows.FrameworkContentElement> 경로 따라 이벤트를 받으면 전용 클래스 처리기 메서드를 호출할 수 있습니다. 하나의 잠재적인 시나리오는 이벤트의 인수를 사용 하 고 경로 줄이기 위해 처리 된 것으로 의도적으로 이벤트를 표시 하는 것입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소가 테마 스타일의 스타일 속성을 포함할지 여부를 나타내는 값을 가져오거나 설정 합니다.</summary>
        <value><see langword="true" /> 이 요소가 테마 스타일 속성을 사용 하지 않는 경우 로컬 응용 프로그램 스타일에서 제공 되는 모든 스타일 원래 속성 및 테마 스타일 속성이 적용 되지 않습니다. <see langword="false" /> 경우 응용 프로그램 스타일이 먼저 적용 하 고 응용 프로그램 스타일에 구체적으로 설정 되지 않은 속성에 대 한 테마 스타일을 적용 하는 합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 가장 일반적인 사용법은 테마가 지정 된 스타일을 제공 하는 스타일의 setter 내에서 간접적으로 사용 합니다.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>논리적 트리에서 이 요소의 부모를 가져옵니다.</summary>
        <value>이 요소의 논리적 부모입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 요소의 논리적 부모 응용 프로그램 기능에 따라 변경 될 수 있습니다 하 고이 속성의 값을 유지 하면 해당 변경 내용이 반영 되지 note 합니다. 필요한 직전에 일반적으로 값을 가져옵니다 해야 합니다.  
  
 참조 [WPF의 트리](~/docs/framework/wpf/advanced/trees-in-wpf.md) 요소 검색에이 방식을 사용 하는 것이 적절 한 시나리오 및 논리 트리 순회에 대 한 자세한 내용은 합니다.  
  
 속성 시스템에서는 다시 계산할 수 요소의 모든 속성 값, 부모가 때 일부 속성 논리 트리를 통해 값을 상속 하기 때문에 합니다. <xref:System.Windows.FrameworkContentElement.DataContext%2A> 적용 되는 바인딩 요소는 부모를 재지정할 경우 변경할 수도 있습니다에 대 한 합니다.  
  
 요소의 부모는 일반적으로을 통해 변경할 컬렉션 조작, 전용을 사용 하 여 추가 또는 제거 메서드 또는 요소의 콘텐츠 속성을 설정 합니다.  
  
 사용에 대 한 가장 일반적인 시나리오는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 참조를 가져온 다음 가져온 후 다양 한 속성이 <xref:System.Windows.FrameworkContentElement> 부모 개체에서 속성 값입니다. 템플릿에 대해서는 <xref:System.Windows.FrameworkContentElement.Parent%2A> 템플릿의 결국 됩니다 `null`합니다. 이 지점을 벗어나 템플릿을 실제로 적용 되는 논리 트리로 확장을 사용 하 여 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>입니다.  
  
   
  
## Examples  
 다음 예제에서는 확인 여부를 합니다 <xref:System.Windows.FrameworkContentElement.Parent%2A> 의 <xref:System.Windows.Documents.TextPointer> 특정 형식입니다.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">예상 포커스 변경을 결정할 방향입니다.</param>
        <summary>제공 된 포커스 이동 방향에 대해이 요소를 기준으로 포커스를 받을 하지만 실제로 포커스를 이동 하 고 하지 않습니다는 다음 요소를 결정 합니다. 이 메서드는 봉인 되어 있으며 재정의할 수 없습니다.</summary>
        <returns>포커스를 실제로 이동 하는 경우에 중점을 둔 다음 요소로 이동 합니다. 반환할 수 있습니다 <see langword="null" /> 제공된 방향에 대해이 요소를 기준으로 포커스를 이동할 수 없는 경우.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 실제로 포커스를 이동 하는 관련된 방법이입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">다음 지침 중 하나를 지정 합니다 <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />합니다. 다음이 지침에 적합 하지 않습니다 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (적합 하지만 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">지정 된 이름-개체 매핑에 사용할 이름입니다.</param>
        <param name="scopedElement">매핑에 대 한 개체입니다.</param>
        <summary>에 대 한 액세스를 간소화 하는 접근자를 제공 합니다 <see cref="T:System.Windows.NameScope" /> 등록 메서드.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편의 메서드 <xref:System.Windows.NameScope.RegisterName%2A>합니다. 구현은 해당 발견할 때까지 부모 요소로 라우트됩니다 확인 됩니다 <xref:System.Windows.NameScope> 를 구현 하는 요소를 검색 하 여 액세스할 수 있는 구현 <xref:System.Windows.Markup.INameScope>합니다. 이름 범위에 대 한 자세한 내용은 참조 하세요. [WPF XAML 이름 범위](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)합니다.  
  
 호출 <xref:System.Windows.FrameworkContentElement.RegisterName%2A> 코드에서 만들 때 응용 프로그램에 대 한 애니메이션 스토리 보드를 올바르게 연결 하기 위해 필요 합니다. Storyboard 속성 키 중 하나 이므로 <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, 런타임 이름 조회를 사용 하 여 대상 요소에 대 한 참조를 수행할 수 있게 되는 대신 합니다. 해당 요소는 코드에서 참조 하 여 액세스할 수 있는 경우에 마찬가지입니다. 스토리 보드 대상에 대 한 이름을 등록 해야 하는 이유는 무엇에 대 한 자세한 내용은 참조 하세요. [스토리 보드 개요](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)합니다. 콘텐츠 요소에 대 한 애니메이션은 애니메이션 컨트롤에 대해 보다는 덜 일반적인 합니다 [스토리 보드 개요](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) 제어 시나리오에 중점적으로 설명 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">제거할 요소입니다.</param>
        <summary>지정된 요소를 이 요소의 논리적 트리에서 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 자식 컬렉션에 대 한 지원을 추가 하는 경우 시나리오의 경우 파생 된 클래스에 대 한 주로 관련 된 내용을 다룹니다.  
  
 대부분 <xref:System.Windows.FrameworkContentElement> 포함 담당 하는 전용된 컬렉션을 노출 하는 파생된 클래스 (예를 들어 <xref:System.Windows.Documents.Span.Inlines%2A> 에 <xref:System.Windows.Documents.Span> 클래스 <xref:System.Windows.Documents.Section.Blocks%2A> 에 <xref:System.Windows.Documents.Section> 클래스). 일반적으로 이러한 클래스에서 파생 되는 논리적 트리를 직접 조작할 필요가 방지할 수 있습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 로컬로 정의 된 리소스 사전을 가져오거나 설정 합니다.</summary>
        <value>현재 로컬로 정의 된 리소스입니다. 이 사전은 리소스를 키로 사전 내에서 리소스에 액세스 하는 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 완전히 또는 부분적으로 정의할 수 있는 리소스가 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 속성 요소로 일반적으로 생성 되 고 개별 페이지 또는 응용 프로그램의 루트 요소에는 일반적으로 합니다. 이 수준에서 리소스 사전 배치 쉽게 페이지의 개별 자식 요소 (또는 응용 프로그램의 경우에는 페이지)를 찾을 수 있습니다. 대부분의 응용 프로그램 시나리오에서 스타일 리소스 사전 내의 개체 요소로 정의 되어 권장 또는 전체 스타일 리소스는 자체 포함 될 수 있도록 외부 리소스로 정의 됩니다 (이 통해 별도 디자이너 책임을 편집 해야 하는 물리적 파일을 구분 하 여 개발자의 책임).  
  
 이 속성 요소 내에서 직접 선언 된 리소스 사전만 반환 하는 참고 합니다. 이 자식 요소를 위쪽으로 재귀적으로 검색 각 부모 요소에 정의 된 리소스를 액세스할 수 있는 실제 리소스 조회 프로세스와 다릅니다.  
  
 리소스의 리소스 만들어졌는지 수 있지만 컬렉션 내에서 코드에 의해 참조 될 수도 있습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 확실 하 게 액세스할 수 없게 됩니다까지 후 <xref:System.Windows.FrameworkContentElement.Loaded> 사전을 선언 하는 요소에 의해 발생 합니다. 리소스의 비동기적으로 구문 분석 되 고 있지도 실제로 <xref:System.Windows.FrameworkContentElement.Loaded> 이벤트는 참조할 수 있는 보증을 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 리소스를 정의 합니다. 따라서 일반적으로 액세스 해야 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 정의의 일부로 런타임 코드 또는 다른 리소스 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 스타일 또는 특성 값에 대 한 리소스 확장 참조와 같은 기술입니다. 코드를 통해 리소스에 액세스 하는 경우 기본적으로 한 것과 동일에서 수행 하는 참조 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 기본 <xref:System.Windows.ResourceDictionary> 추가, 제거 또는 코드를 사용 하 여 컬렉션 내에서 리소스를 쿼리 하는 데 필요한 메서드를 지원 합니다. 합니다 <xref:System.Windows.FrameworkContentElement.Resources%2A> 속성을 완전히 새로운 또는 다른 요소의 리소스 컬렉션을 교체 하는 시나리오를 지원 하기 위해 설정할 수 <xref:System.Windows.ResourceDictionary>입니다.  
  
 에 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 표시 된 구문에 대 한 요소가 포함 되지 않습니다는 <xref:System.Windows.ResourceDictionary>합니다. 이 한 예로 암시적 컬렉션 구문을 사용 합니다. 컬렉션 요소를 나타내는 태그를 생략할 수 있습니다. 항목 컬렉션에 추가 된 요소 대신 지정 됩니다. 암시적 컬렉션에 대 한 자세한 내용은 및 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]를 참조 하세요 [XAML 구문 정보](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)합니다. 한 가지 경우 위치는 <xref:System.Windows.ResourceDictionary> 병합된 된 사전을 도입 하는 경우에서 많은 경우 일반적으로는 자식 요소가 없는 요소는 명시적으로 지정 되어 <xref:System.Windows.ResourceDictionary>입니다. 자세한 내용은 참조 하세요 [리소스 사전을 병합](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)입니다.  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 값  
 *oneOrMoreResourceElements*  
 하나 이상의 개체 요소를 각각 정의 하는 리소스입니다. 각 리소스 속성 요소에서 각 <xref:System.Windows.ResourceDictionary> 에 대 한 고유한 값을 가져야 합니다는 [X:key 지시문](~/docs/framework/xaml-services/x-key-directive.md)에서 값을 검색할 때 고유 키로 사용 되는 <xref:System.Windows.ResourceDictionary>합니다.  
  
   
  
## Examples  
 다음 예제에서는 설정 된 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소. <xref:System.Windows.Documents.FlowDocument> 일반적인 선택은 소수의 하나 이므로 <xref:System.Windows.FrameworkContentElement> 이해 되는 루트 요소 및 리소스 클래스는 페이지 루트 또는 응용 프로그램과 같이 이러한 더 높은 수준에서 일반적으로 저장 됩니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 종속성 속성에 대해 이 요소에 바인딩을 연결합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">바인딩된 속성을 식별합니다.</param>
        <param name="path">소스 속성 이름 또는 속성을 바인딩하는 데에 경로입니다.</param>
        <summary>데이터 원본에 대 한 경로 정규화로 제공 된 소스 속성 이름을 기반으로이 요소에 바인딩을 연결 합니다.</summary>
        <returns>바인딩 상태를 기록합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편의 메서드 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 합니다 <xref:System.Windows.DependencyObject>, 새 만들고 <xref:System.Windows.Data.Binding> 제공 된 기준 `path` 매개 변수. 이 서명은 간단한 기본 바인딩을 설정 하는 경우에 편리 합니다. 기본이 아닌 조건에 대 한 바인딩 속성을 지정 하거나 사용 하는 경우는 <xref:System.Windows.Data.MultiBinding> 또는 <xref:System.Windows.Data.PriorityBinding>를 사용 해야는 <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> 서명 합니다.  
  
   
  
## Examples  
 다음 예제에서 바인딩을 설정 합니다.는 <xref:System.Windows.Documents.Paragraph> 요소를 해당 개체로 설정 하 여 새 사용자 지정 데이터 개체를 만들어 <xref:System.Windows.FrameworkContentElement.DataContext%2A>, 및 그 속성에 바인딩 경로 설정 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">바인딩된 속성을 식별합니다.</param>
        <param name="binding">데이터 바인딩을 나타냅니다.</param>
        <summary>제공된 바인딩 개체를 기반으로 하여 이 요소에 바인딩을 연결합니다.</summary>
        <returns>바인딩 상태를 기록합니다. 이 반환 값은 오류 검사에 유용할 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 호출에 대 한 편의 메서드 <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>는 현재 인스턴스를 전달 하는 <xref:System.Windows.DependencyObject>합니다.  
  
   
  
## Examples  
 다음 예제에서 바인딩을 설정 합니다.는 <xref:System.Windows.Documents.Paragraph> 새 요소를 <xref:System.Windows.Data.Binding> 하 고 새로 빌드된 원본 설정 `DateTime` 개체입니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">리소스 바인딩되는 속성입니다.</param>
        <param name="name">리소스의 이름입니다.</param>
        <summary>지정 된 이름의 리소스를 검색 하 고 지정 된 속성에 리소스 참조를 설정 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리소스 참조를 사용 하 여 비슷합니다는 [DynamicResource 태그 확장](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) 태그에서입니다. 리소스 참조를 런타임에 지연 기준으로 지정된 된 속성의 값을 제공 하는 내부 식을 만듭니다. 리소스 사전 내부 이벤트를 통해 변경 된 값을 나타냅니다 때마다 또는 현재 요소의 부모를 재지정할 때마다 식을 다시 계산 됩니다 (부모 변경 사전 조회 경로 변경 됩니다).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialization 프로세스의 콘텐츠를 serialize 해야 하는지 여부를 반환 합니다 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 이 클래스 인스턴스의 속성입니다.</summary>
        <returns><see cref="P:System.Windows.FrameworkContentElement.Resources" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 돌아갑니다 `true` 으로 로컬에 키가 지정 된 리소스 중 적어도 하나가 <xref:System.Windows.FrameworkContentElement.Resources%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serialization 프로세스의 콘텐츠를 serialize 해야 하는지 여부를 반환 합니다 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 이 클래스 인스턴스의 속성입니다.</summary>
        <returns><see cref="P:System.Windows.FrameworkContentElement.Style" /> 속성 값을 serialize해야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 돌아갑니다 `true` 경우는 <xref:System.Windows.Style> 로컬로 설정 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소를 변경의 바인딩에 참여 하는 데이터 원본에 연결 된 경우 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 화면을 <xref:System.Windows.Data.Binding.SourceUpdated> 이벤트에 의해 발생 하는 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에서 사용할 스타일을 가져오거나 설정합니다.</summary>
        <value>있는 경우 요소에 대해 적용된 기본값이 아닌 스타일입니다. 그렇지 않으면 <see langword="null" />입니다. 기본 생성된 <see cref="T:System.Windows.FrameworkContentElement" />의 기본값은 <see langword="null" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 현재 스타일 리소스가 페이지나 응용 프로그램 수준 (암시적 스타일)에서 해당 형식의 개체에 일반적으로 적용 되는 스타일 또는 테마에서 기본 스타일에 의해 자주 제공 됩니다. 이 속성은 설정 하거나 반환 하지 기본 (테마) 스타일 않지만 암시적 스타일 또는 명시적 스타일을 반환 합니다. 암시적 또는 명시적 스타일의 경우 중요 하지 않습니다 스타일 리소스로 액세스 되는지 아니면 로컬로 정의 합니다.  
  
 스타일 정의는 몇 가지 제한 사항이 있습니다. 전체를 다시 설정할 수 있습니다 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성을 새 <xref:System.Windows.Style> 언제 든 지는 이렇게 하면 레이아웃이 다시 강제 됩니다. 그러나 가능한 한 즉시 로드 된 요소에 의해 해당 스타일 사용 하 게 되는 <xref:System.Windows.Style> 고려해 야 봉인 합니다. 사용 중인 스타일의 개별 속성을 변경 하는 동안 (컬렉션 내에서 아무 것도 같은 <xref:System.Windows.Style.Setters%2A>) 예외를 throw 합니다. 태그에 정의 된 스타일 (리소스)에 대 한 리소스 사전에서 로드 된 또는 인라인 스타일) (에 포함 된 페이지가 로드 되는 즉시 사용 중인 것으로 간주 됩니다.  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 특별 한 우선 순위를 사용 하 여 종속성 속성이입니다. 로컬에서 설정 스타일은 일반적으로 가장 높은 우선 순위로 속성 시스템으로 작동 합니다. 경우는 <xref:System.Windows.FrameworkContentElement.Style%2A> 이 시점에서 해당 형식을 지정 하는 다시 사용할 수 있는 리소스로 정의 된 암시적 스타일에 대 한 속성 시스템을 확인 하는 로드 하는 동안 null입니다. 이 단계를 수행 하면 스타일은 여전히 null 이라면 기본 (테마) 스타일에서 스타일을 가져옵니다 이지만 기본 스타일에 반환 되지 않습니다는 <xref:System.Windows.FrameworkContentElement.Style%2A> 속성 값입니다. 참조 [종속성 속성 값 우선 순위](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)합니다.  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 값  
 *resourceExtension*  
 다음 중 하나:, 또는 합니다. 참조 [XAML 리소스](~/docs/framework/wpf/advanced/xaml-resources.md)합니다.  
  
 *styleResourceKey*  
 요청 되는 스타일을 식별 하는 키입니다. 키의 기존 리소스에 참조를 <xref:System.Windows.ResourceDictionary>입니다.  
  
> [!NOTE]
>  속성 요소 구문은 기술적으로 가능 하지만 권장 하지는 않습니다. 참조 [인라인 스타일 및 템플릿](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)합니다.  사용 하 여 바인딩 참조 또는 <xref:System.Windows.Data.Binding> 가능 하지만 일반적이 지 않은 이기도 합니다.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 다음 예제에서는 설정를 <xref:System.Windows.FrameworkContentElement.Resources%2A> 컬렉션에는 <xref:System.Windows.Documents.FlowDocument> 루트 요소에 대 한 특정 스타일으로 리소스로 참조 하 고는 <xref:System.Windows.Documents.Paragraph>합니다.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.Style" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">요청된 된 앰비언트 속성의 이름입니다.</param>
        <summary>이 멤버에 대한 설명을 보려면 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 메서드를 참조하세요.</summary>
        <returns><see langword="true" /> 하는 경우 <paramref name="propertyName" /> 이 고, 그렇지 않으면 <see langword="false" />합니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 멤버는 명시적 인터페이스 멤버 구현이며, <xref:System.Windows.FrameworkContentElement> 인스턴스가 <xref:System.Windows.Markup.IQueryAmbient> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에 대 한 사용자 지정 정보를 저장 하는 데 사용할 수 있는 임의의 개체 값을 가져오거나 설정 합니다.</summary>
        <value>의도 한 값입니다. 이 속성에는 기본값이 없습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 다른 Microsoft 프로그래밍 모델에서 응용 프로그램 또는 Windows Forms에 대 한 Visual Basic과 같은 태그 속성과 비슷합니다. 기존 응용 프로그램 개발자는 서브 클래스를 시작 하지 않고 모든 요소에 대 한 일부 기본 사용자 지정 정보를 저장할 위치를 제공 하는 것이 것입니다.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML 값  
 속성 요소 사용 설정 하기 위해 사용 해야 하는 개체를 사용 하는이 속성을 하기 때문에 <xref:System.Windows.FrameworkContentElement.Tag%2A> , 문자열 등의 알려진된 기본 제공 형식 변환기를 사용 하 여 개체 이외의 값으로 XAML의 속성입니다. 이러한 방식으로 사용 되는 개체 일반적으로 표준 WPF 네임 스페이스에 포함 되지 않은 하 고 따라서 XAML 요소로 소개 하기 위해 외부 네임 스페이스에 네임 스페이스 매핑을 필요할 수 있습니다.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.Tag" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 바인딩에 참여하는 연결된 대상 속성이 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트 화면을 <xref:System.Windows.Data.Binding.TargetUpdated> 이벤트에 의해 발생 하는 <xref:System.Windows.Data.Binding> 이 요소와 연결 합니다. 이 일반적으로 해당 바인딩이 양방향 바인딩으로 바인딩된 종속성 속성은 유효성 검사 또는 속성을 지 원하는 캐싱 구성표 마다 이전 속성 값의 무효화 함을 의미 합니다.  
  
 이 이벤트의 이벤트 인수를 어떤 바인딩된 속성이 변경 된 것을 알려줍니다.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소의 템플릿 부모에 대한 참조를 가져옵니다. 요소가 템플릿을 통해 만들어지지 않은 경우에는 이 속성이 관련이 없습니다.</summary>
        <value>요소입니다 <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> 이 요소를 만들 수 있습니다. 이 값은 대개 <see langword="null" />합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 템플릿은 실제로 공유 개체를 서식 파일의 내용을 한 번만 생성 됩니다. 따라서 템플릿에서 생성 된 요소에 대 한 개체 참조를 가져온 경우 명확한 논리 트리의 페이지 루트까지 도달 하지 않습니다를 알 수 있습니다. 이러한 템플릿 참조 페이지의 논리 트리에 연결 하려면 가져와야는 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 값 및 계속를 원하는 대로 해당 요소 트리를 탐색 합니다.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 자주 `null` 공통 개체에 대 한 만들어지지 않았기 때문에 일반적인 수단을 통해 응용 프로그램에서 페이지 푸시된 개체 참조를 얻은 경우 해당 요소 아마도 된 템플릿에서 합니다. 인 사례 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 아닐 `null` 이벤트 적중 테스트, 특정 하위 수준 입력 이벤트를 처리 하거나 템플릿에서 생성 되는 요소를 반환 있을 수 있는 열거자를 사용 하 여 작업 등의 작업에 포함 됩니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 요소에 대해 표시 되는 도구 설명 개체를 가져오거나 설정 합니다.는 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]합니다.</summary>
        <value>도구 설명 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 값 형식인 경우 <xref:System.Windows.Controls.ToolTip>에서 사용할 도구 설명 됩니다는 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]합니다.  다른 형식의 값이 있으면 해당 값으로 사용할 합니다 *콘텐츠* 에 대 한는 <xref:System.Windows.Controls.ToolTip> 제공 (생성 된) 시스템에서. 자세한 내용은 <xref:System.Windows.Controls.ToolTipService>을 참조하세요. 서비스 클래스는 추가로 도구 설명을 사용자 지정할 수 있는 연결 된 속성을 제공 합니다.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 특성 사용  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 속성 요소 사용  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 값  
 *toolTipContent*  
 에 대 한 표시 텍스트를가 하는 문자열을 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>입니다.  
  
 *toolTipObjectContent*  
 에 대 한 내용으로 사용 해야 하는 개체 요소 형식에 제공 된 일부 개체는 <xref:System.Windows.FrameworkContentElement> 합니다. 일반적을 <xref:System.Windows.FrameworkElement> 또는 다른 요소에 대 한 레이아웃 합성을 만드는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, 최종적으로 합치기 내에 텍스트 콘텐츠를 포함 합니다. 이 사용법에서 합니다 <xref:System.Windows.Controls.ToolTip> 요소가 만들어집니다 구문 분석 된에서 암시적으로 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], 및 *toolTipObjectContent* 내용으로 설정 되어 해당 <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> 속성.  
  
 <`ToolTip` .../>  
 <xref:System.Windows.Controls.ToolTip>을 참조하세요.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 값을 설정 하는 다음 예제는 <xref:System.Windows.FrameworkElement.ToolTip%2A> 속성 문자열을 직접.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소에 도구 설명이 닫히기 바로 전에 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도구 설명 닫기 사용 하지 않으려면 이벤트의 처리기로 표시 해야 처리.  
  
 이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다. 이 이벤트의 식별자 필드 다시 사용 하 여 이벤트에 대 한 추가/제거 메서드를 노출 하지 않는 서비스에서 구현 때문입니다.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소에 도구 설명이 열릴 때 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 도구 설명을 수동으로 열려면, 처리 된 것으로 이벤트 처리기 관련 이벤트를 표시 해야 합니다. 이 고, 그렇지의 값을 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 속성이 자동으로 상황에 맞는 메뉴를 열려면 사용 됩니다. 이벤트를 처리 된 기본 작업을 효과적으로 취소 하 고 수 값을 다시 설정할 수는 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 속성 연 다음 새 <xref:System.Windows.Controls.ContextMenu>합니다. 확인 하는 경우이 이벤트가 발생 하지 것입니다 <xref:System.Windows.FrameworkContentElement.ToolTip%2A> 가 null 참조 또는 기타 수단을 설정 합니다.  
  
 이 이벤트는 <xref:System.Windows.EventTrigger> 스타일에서입니다. 이 이벤트의 식별자 필드 다시 사용 하 여 이벤트에 대 한 추가/제거 메서드를 노출 하지 않는 서비스에서 구현 때문입니다.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">찾을 리소스의 키 식별자입니다.</param>
        <summary>지정된 키를 사용하여 리소스를 검색하고 해당 리소스를 반환합니다(있는 경우).</summary>
        <returns>찾은 리소스입니다. 리소스가 없으면 <see langword="null" />이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 리소스를 호출 하는 요소에 없는 경우 부모 트리를 검색 하는 논리적 트리를 사용 하 여 트리는 동일한 방식에서 런타임에 키로 동적 리소스 참조를 요청 하는 경우를 검색 합니다.  
  
 일반적으로 즉시 캐스팅 반환 되는 리소스 값으로 설정 하 려 했던는 속성의 형식으로 반환 합니다.  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A> 메서드가 비슷한 동작을 제외 하 고 제공 된 키를 사용 하 여 리소스를 찾지 못하는 경우 예외가 throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 태그에 정의 된 대로 리소스를 찾습니다 및 라우트된 이벤트에 대 한 응답에 있는 요소의 특정 속성에 적용 합니다.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>로드 된 요소의 요소 트리에서 요소를 제거할 때 발생 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 직접 라우트된 이벤트에 대 한 경로 따르지, 발생 하는 동일한 요소 내 에서만 처리 됩니다. 라우트된 이벤트는 라우트된 이벤트 동작은 다른 지원지 않습니다 직접: 액세스할 수 있는 처리기 컬렉션을 지원 하며으로 사용할 수는 <xref:System.Windows.EventTrigger> 스타일에서입니다.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>라우팅 이벤트 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|라우팅 전략|직접|  
|대리자|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [라우트된 이벤트 개요](~/docs/framework/wpf/advanced/routed-events-overview.md)를 식별합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이벤트 식별자 개체는 라우트된 이벤트가 등록 될 때 만들어집니다 (참조 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) 클래스 처리기를 추가 하려면 사용할 수 있습니다 (참조 <xref:System.Windows.EventManager.RegisterClassHandler%2A>). 식별자 개체는 식별 이름, 소유자 유형, 처리기 형식, 라우팅 전략 및 이벤트에 대 한 소유자를 추가 하기 위한 유틸리티 메서드를 포함 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">현재 범위에서 제거할 이름-개체 쌍의 이름입니다.</param>
        <summary>에 대 한 액세스를 간소화는 <see cref="T:System.Windows.NameScope" /> 메서드를 등록 취소 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만 하면 등록을 취소할 이름을 다시 동일한 이름 가진 다른 요소를 등록 하려는 경우.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>현재 기본 스타일을 다시 적용 <see cref="T:System.Windows.FrameworkContentElement" />합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>