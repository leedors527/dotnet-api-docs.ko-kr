<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474426" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>프레임워크별 속성 시스템 특성을 구체적으로 추가하여 종속성 속성에 대한 메타데이터를 보고하거나 적용합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 클래스에서 파생 됩니다 <xref:System.Windows.PropertyMetadata> (통해 <xref:System.Windows.UIPropertyMetadata>). 대부분의 WPF 프레임 워크 수준 애플리케이션 개발을 위해 <xref:System.Windows.FrameworkPropertyMetadata> 는 기본 메타 데이터 형식인 것이 아니라 종속성 속성 메타 데이터에 사용 된 형식과 <xref:System.Windows.PropertyMetadata> 또는 <xref:System.Windows.UIPropertyMetadata>합니다. 기존 종속성 속성 및 대부분의 사용자 지정 종속성 속성 시나리오에도 마찬가지입니다.  
  
 이 선언 된 멤버 보완 하는 클래스는 <xref:System.Windows.PropertyMetadata> 속성 상속, 데이터 바인딩 및 레이아웃과 같은 WPF 프레임 워크 수준 속성 시스템 동작을 보고 하거나 지정 하는 다양 한 부울 속성을 포함 하는 기본 클래스입니다.  
  
 만들기 위한 몇 가지 생성자 시그니처를 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 사용을 <xref:System.Windows.FrameworkPropertyMetadataOptions> 매개 변수입니다. 합니다 <xref:System.Windows.FrameworkPropertyMetadataOptions> 열거형 생성자에서 초기 동작을 지정 하기 위해서만 사용 되 고 후 노출 되지 않는 <xref:System.Windows.FrameworkPropertyMetadata> 생성 됩니다. 생성된 된 인스턴스를 가져올 수도 있고 생성자 호출에서 사용 되는 열거형 값의 이름을 공유 하는 다양 한 속성을 통해 해당 정보를 설정 키를 누릅니다.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스는 일반적으로 사용 되지 않습니다 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 종속성 속성 메타 데이터를 특정 소유자의 초기도 기본 <xref:System.Windows.PropertyMetadata> 형식입니다. 해당 메타 데이터는 <xref:System.Windows.FrameworkPropertyMetadata>합니다. 유효한 반환 되 면 <xref:System.Windows.FrameworkPropertyMetadata>, 다음 다양 한 <xref:System.Windows.FrameworkPropertyMetadata> 속성 값 (표시 되지 않음) 간단한 UI를 통해 보고 됩니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 모든 값을 초기화 하는이 서명을 <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> 속성 기본값으로 합니다. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 됩니다 `null`, 및 다양 한 <xref:System.Windows.FrameworkPropertyMetadata> Boolean 속성 `false`합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <summary>지정된 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <summary>제공된 기본값과 프레임워크 수준 메타데이터 옵션을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
 값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다. 이후에 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" />의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현은 기본 이니셜라이저를 호출 하 고 다음 추가 `coerceValueCallback` 기본 인스턴스에서 속성을 설정 합니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식의 값으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 콜백을 사용하여 <see cref="T:System.Windows.PropertyChangedCallback" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
 값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다. 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션 및 지정된 콜백을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
 값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다. 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 종속성 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <param name="isAnimationProhibited">속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다. 이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다. 속성에 애니메이션을 적용할 수 있게 하려면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백 및 속성 애니메이션을 금지할 수 있는 부울 값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
 합니다 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수를 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 즉시 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.  
  
 값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다. 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 생성자 시그니처를 호출합니다.  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">종속성 속성의 기본값이며, 일반적으로 특정 형식으로 제공됩니다.</param>
        <param name="flags">메타데이터 옵션 플래그(<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 값의 조합)입니다. 이러한 옵션은 레이아웃이나 데이터 바인딩과 같이 시스템과 상호 작용하는 종속성 속성의 특성을 지정합니다.</param>
        <param name="propertyChangedCallback">속성의 유효 값이 변경될 때마다 속성 시스템에서 호출할 처리기 구현에 대한 참조입니다.</param>
        <param name="coerceValueCallback">속성 시스템에서 이 속성에 대해 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />를 호출할 때마다 호출되는 처리기 구현에 대한 참조입니다.</param>
        <param name="isAnimationProhibited">속성 시스템에서 이 메타데이터가 적용되는 속성에 애니메이션을 사용하지 않게 하려면 <see langword="true" />입니다. 이러한 속성에 애니메이션을 적용하려고 하면 속성 시스템에서 런타임 예외가 발생합니다. 기본값은 <see langword="false" />입니다.</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 속성에 대한 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />입니다.</param>
        <summary>제공된 기본값, 프레임워크 메타데이터 옵션, 지정된 콜백, 속성 애니메이션을 금지할 수 있는 부울 값 및 데이터 바인딩 업데이트 트리거 기본값을 사용하여 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제공 된 값 형식의 `defaultValue` 일치 하거나이 메타 데이터에 적용 될 종속성 속성의 원래 등록에서 지정 된 형식과 관련 됩니다. 컴파일하는 동안 불일치를 감지할 수 없기 때문에 메타 데이터의 기본 값 형식과 메타 데이터에 적용 되는 종속성 속성의 형식 불일치를 디버깅 하려면 어려울 수 있습니다. 속성 시스템의 기본 값 형식/속성 형식이 일치 하지 않기 런타임 오류 때문에 속성의 유효 값 런타임까지 평가 되지 않습니다.  
  
 값 <xref:System.Windows.DependencyProperty.UnsetValue> 속성 시스템에 대 한 특별 한 의미가 및 종속성 속성이 기본 값으로 사용할 수 없습니다.  
  
 합니다 `isAnimationProhibited` 의 초기 값을 설정 하는 매개 변수를 <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 즉시 기본 속성 선언 <xref:System.Windows.UIPropertyMetadata> 클래스입니다.  
  
 바인딩 소스 업데이트 동작에 대 한 자세한 내용은 참조 하세요. [데이터 바인딩 개요](~/docs/framework/wpf/data/data-binding-overview.md)합니다.  
  
 값 집합 flags에서 플래그로 표시 된 `flags` 매개 변수는 부울 값을 설정 <xref:System.Windows.FrameworkPropertyMetadata> 일치 하는 속성 <xref:System.Windows.FrameworkPropertyMetadataOptions> 플래그의 이름을 `true`입니다. 특정 속성 시스템 작업에 적용 된 메타 데이터에서 속성의 값을 여전히 변경할 수 있습니다.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" />이 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />로 설정됩니다.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 있는 종속성 속성이 정렬 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다. 논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 로 설정 `true` 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다 (호출 <xref:System.Windows.UIElement.InvalidateArrange%2A>). 이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 는 `true`합니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버는 일반적으로 없습니다에서 사용 하거나 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 있는 종속성 속성이 측정 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 영향을 주지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다. 논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 로 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. 이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 는 `true`합니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 정렬 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 있는 종속성 속성이 부모 요소의 정렬 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 영향을 주지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다. 논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 로 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다.  
  
 일반적으로 않아도의 변경 내용을 보고 하는 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 요소 자체는 이미 있으므로 자체 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 으로 `true`합니다. 일반적으로 이것으로 충분, 해당 하는 경우 부모 정렬 하므로 변경 된 자식 요소에 일반적으로 시작 합니다. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 에 사용 되기도 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다. 이 경우 속성, 하지만 자식 요소 집합 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다. 렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다. 예를 들어 값으로 변경 합니다 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 자식 요소에서 연결 된 속성 무효화 부모에서 자식 위치를 변경 해야 하기 때문에 부모를 정렬 합니다. 따라서 합니다 <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> 연결 된 속성 메타 데이터에 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 는 `true`합니다. 또 다른 예로 <xref:System.Windows.Controls.Control.Padding%2A>이 속성 변경 내용을 상위 변경 될 수 있습니다 사용 가능한 공간에 따라 자식 위치를 지정 하는 경우.  
  
 이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 는 `true`합니다.  
  
 에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>레이아웃 엔진 작업 중 종속성 속성이 부모 요소 레이아웃의 측정 단계에 잠재적으로 영향을 주는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 있는 종속성 속성이 부모 요소의 측정 단계에 잠재적으로 영향을 주면 <see langword="true" />이고, 영향을 주지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다. 논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 로 `true` 부모 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. 이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 일반적으로 않아도의 변경 내용을 보고 하는 <xref:System.Windows.FrameworkElement> 속성을 사용 하 여 부모 요소 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 요소 자체는 이미 있으므로 자체 <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> 으로 `true`합니다. 변경 된 자식 요소에 일반적으로 해당 하는 경우 부모 측정 단계를 시작 하기 때문에 이것이 충분입니다. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 에 사용 되기도 <xref:System.Windows.FrameworkContentElement> 클래스를 파생 합니다. 이 경우 속성, 하지만 자식 요소 집합 <xref:System.Windows.FrameworkContentElement> 파생된 클래스는 자체 렌더링을 제어 하지 않습니다. 렌더링 하 여 처리 되는 <xref:System.Windows.FrameworkElement> 콘텐츠 호스트 역할을 하는 부모 요소입니다. 예를 들어 값으로 변경 합니다 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 단락의 상대 간격 수 변경 될 수 있습니다 늘리거나 콘텐츠 호스트 크기 때문에 속성 자식 요소에서 부모의 측정을 무효화 합니다. 따라서 합니다 <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> 속성이 메타 데이터 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`합니다.  
  
 종속성 속성의 변경에 대 한 콘텐츠 호스트 요소 에서도 자주 표시 위치 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`, 콘텐츠 호스트 렌더링 논리의 일부로. 예를 들어를 <xref:System.Windows.Controls.TextBox> 의 경계 상자 요소는 필요할 수 있는 텍스트 내에서 특정 변경에 응답 해야 합니다는 <xref:System.Windows.Controls.TextBox> 자체를 변경할 수 있습니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 는 `true`합니다.  
  
 에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성은 정렬이나 측정에 특별히 영향을 주지 않는 어떤 방식으로 일반 레이아웃에 잠재적으로 영향을 주는지 여부를 나타내지만 다시 그리기를 필요로 하는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 존재하는 종속성 속성이 렌더링에 영향을 주면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 및 <xref:System.Windows.FrameworkContentElement> 의 구현이 포함 <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> 요소에 있는 모든 종속성 속성 유효 값 변경 내용을 모니터링 하는 합니다. 논리의 일부로, 적용을 변경 하는 종속성 속성 값 및 사용 하 여 메타 데이터를 가져야 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 로 `true` 해당 요소에 대 한 시각적 개체를 무효화 하는 지연 된 요청이 시작 됩니다. 이 WPF 프레임 워크 수준 구현 되어에서 이미 이기 때문에 일반적으로 필요가 없습니다 사용 하 여 종속성 속성에 대 한 검색할 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 대체로 대체 또는 WPF 프레임 워크 수준 레이아웃 동작을 수정 하는 경우가 아니면 합니다.  
  
 사용자 지정 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 구현이 종속성 속성 변경에 대 한 비슷한 동작을 선택할 수 있는 <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 는 `true`합니다.  
  
 에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>속성이 기본적으로 양방향으로 바인드하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 존재하는 종속성 속성이 기본적으로 양방향으로 바인드하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 없을 경우이 속성의 `true`, 바인딩 업데이트는 기본적으로의 기본 동작에 따라 단방향 합니다 <xref:System.Windows.Data.Binding> 생성자 또는 이와 동등한 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 구문입니다.  
  
 기존 요소를 찾을 수 있습니다 일반적으로이 속성을 설정 `true` 상태를 보고 하 고는 예를 들어 사용자 작업을 통해 수정할 수는 종속성 속성에 대 한 메타 데이터에서 <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>합니다.  
  
 이 속성 보고할 종속성 속성의 기본 바인딩 업데이트 특징을 뿐 일반적입니다. 인스턴스에서이 속성을 설정 하는 모든 바인딩 로컬로 설정할 수는 <xref:System.Windows.Data.Binding.Mode%2A> 바인딩의 속성이이 기본값을 변경 합니다.  
  
 에 대 한 속성의 파생 클래스인 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Data.UpdateSourceTrigger" />가 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />로 설정된 경우 이 메타데이터가 있는 속성에 바인딩이 적용될 때 사용할 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />의 기본값을 가져오거나 설정합니다.</summary>
        <value><see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />를 제외한 열거형 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이 속성이 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />로 설정된 경우. 이 속성에 설정하는 값은 바인딩에서 요청할 때 기본값이 되어야 합니다.</exception>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성의 값이 상속되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>속성 값이 상속 가능하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 속성 값 상속의 기능은 합니다 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 가능해 집니다 특정 종속성 속성을 설정할 수 있습니다 로컬로 끝났거나 곧의 루트 요소에 WPF 프레임 워크 수준 속성 시스템을 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 요소 트리와 연결한 다음 해당 값에서 상속 또한 해당 속성을 소유 하는 자식 요소의 논리 트리 내에서 모든 요소입니다. 기본적으로 속성 값 상속 가능 하지 없고 있도록 몇 가지 성능에 미치는 영향입니다. 자세한 내용은 [속성 값 상속](~/docs/framework/wpf/advanced/property-value-inheritance.md)을 참조하십시오.  
  
> [!NOTE]
>  속성 값 상속은 연결 되지 않은 종속성 속성에 대 한 작업에 표시 될 수 있지만 런타임 트리의 특정-개체 부분을 통해 연결 되지 않은 속성에 대 한 상속 동작은 정의 되지 않습니다. 항상 사용 하 여 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 지정 하는 속성을 등록 하려면 <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 메타 데이터에서입니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성에 대한 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>이 메타데이터가 적용되는 종속성 속성에 대한 데이터 바인딩이 지원되면 <see langword="true" />이고, 지원되지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 보고 `false` 두 상황 중 하나에 대해: 종속성 속성에 데이터 바인딩 중 하나 (보고 되는 종속성 속성 식별자 메타 데이터가 아니라에), 읽기 전용 종속성 속성 이므로 되지 또는 값 다른 메타 데이터 속성 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>로 설정 된 `true` 이 메타 데이터입니다. 이 속성은 편의 위해 호출자가 모두 선택 하지 않아도 되도록 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 고 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>입니다.  
  
 그렇지 않은 경우 읽기/쓰기 속성을 데이터 바인딩을 지원 하지 않도록 지정 하는 메타 데이터를 생성 하려는 경우이 플래그를 지정 <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (및 약간의 명명 규칙 차이가 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
   
  
## Examples  
 다음 예제에서는 속성 필드 다양 한 종속성에서 기본 메타 데이터를 가져오고, 다양 한 값을 쿼리 <xref:System.Windows.FrameworkPropertyMetadata> 속성에서 "메타 데이터 브라우저"를 구현 하는 테이블을 채우기 위한 정보를 사용 합니다.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성이 데이터 바인딩을 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>속성이 데이터 바인딩을 지원하면 <see langword="true" />이고, 그러지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메타 데이터 속성에 `true` 특히 읽기 / 쓰기 속성 불구 하 고 데이터 바인딩을 지원 하지 않아야 하는 속성에 대 한 합니다. 예상이는 종속성 속성이 선언 되어 있는 대부분의 경우에서 데이터 바인딩, 데이터 바인딩 종속성 속성을 유용 하는 주요 시나리오 중 하나 이므로 합니다. 와 달리 <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, 단순히 특정 바인딩에서 이후에 변경 될 수 있는 기본값을 변경 되지 않습니다. 이 속성을 설정할 `true` 종속성 속성에 대 한 메타 데이터의 메타 데이터는 종속성 속성에 식을 통해 값을 적용 하는 모든 바인딩에서 비활성화 됩니다.  
  
 읽기 전용 종속성 속성 데이터 바인딩 (있기 때문에 변경 된 값을 적용할 수 있는 setter) 지원 하지 않지만 보고서는 여전히 `false` 에 대 한 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>합니다. 이므로이에 해당 하는 속성을 <xref:System.Windows.FrameworkPropertyMetadataOptions> 값 메타 데이터를 실제로 설정 방법, 항상 의미 하는 속성의 이름을 지정 하는 최종 결과 동작을 보고 하는 대신 사용 하 여 패리티를 보고 합니다. 지정 된 종속성 속성이 데이터 바인딩을 허용 하는지 여부를 확인, 일반적으로 확인 해야 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 대신 합니다. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 둘 다 검사 편리 <xref:System.Windows.DependencyProperty.ReadOnly%2A> 및 <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 를 단일 작업으로 예상 되는 결과 생성 합니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 속성이 애플리케이션에서 저널링 구현의 일부로 저장할 수 있거나 저장해야 하는 저널링 정보를 포함하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>이 메타데이터가 적용되는 종속성 속성에 저널링이 수행되어야 하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">병합할 기본 메타데이터입니다.</param>
        <param name="dp">이 메타데이터가 적용되는 종속성 속성입니다.</param>
        <summary>기본 메타데이터와 원본 메타 데이터의 병합을 사용하도록 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 메타 데이터 재정의 될 때 내부적으로 사용 됩니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>파생 된 클래스 <see cref="T:System.Windows.PropertyMetadata" /> (또는이 특히 클래스)는 구현에 추가한 모든 메타 데이터 속성에 대 한 계정에이 메서드를 재정의 해야 합니다. 예를 들어, 구현 추가 했을 수는 새 플래그 열거형 값 및 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 구현 이러한 플래그를 올바르게 결합 수 있어야 합니다.  
  
이전 형식 계층 구조에 이미 정의 된 모든 속성을 병합의 기본 구현을 담당 하기 때문에 항상 기본 구현을 개발자 고유의 구현 하기 전에 호출 합니다.  
  
하 여 추가 동작을 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 에서 구현 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 특정 WPF 프레임 워크 수준 속성은와 같은 메타 데이터에 <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> 비트 결합 됩니다 또는 작업 합니다.  
  
합니다 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> 동작 구현 동작을 호출 하 여 기존 종속성 속성의 속성 메타 데이터를 재정의 하는 경우 <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, 재정의 메타 데이터를 사용 하 여 <see cref="T:System.Windows.FrameworkPropertyMetadata" />입니다.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">메타데이터를 적용한 종속성 속성입니다.</param>
        <param name="targetType">형식별 메타데이터인 경우 이 메타데이터에 연결된 형식입니다. 기본 메타데이터인 경우에는 이 값이 <see langword="null" />일 수 있습니다.</param>
        <summary>이 메타데이터가 속성에 적용되어 메타데이터가 봉인될 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 어떠한 방법으로의 데이터 구조를 <xref:System.Windows.FrameworkPropertyMetadata> 인스턴스 표시 해야 변경할 수 없는 것이 메서드가 호출 되 면 합니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkPropertyMetadata" /> 이 메서드의 구현에서는 기본 구현을 호출 하기만 합니다.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>속성 값 상속 평가가 요소의 논리적 트리에서 특정 콘텐츠 경계를 넘을지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>속성 값 상속이 특정 콘텐츠 경계를 넘으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메타 데이터에서 특수 부모 요소 자식 요소의 경계를 넘어 속성 값 상속 동작은 거의 적용 수정을 보고합니다. 이러한 경계 방식의 전형적인 예는 내용의 <xref:System.Windows.Controls.Frame>여기서는 <xref:System.Windows.Controls.Frame> 의 존재 여부와 독립적으로 콘텐츠를 다시 로드 가져올 수 있습니다는 <xref:System.Windows.Controls.Frame>합니다. Desired 속성 시스템 동작은의 내용을 속성 값 상속을 트래버스 하지 해야는 <xref:System.Windows.Controls.Frame>이므로 이러한 콘텐츠 요소일 수도 프레임을 호스팅하는 애플리케이션을 소유 하거나 제어 하지 않습니다. 메타 데이터를 지정 하 <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> 로 설정 `true`지정, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> 으로 `true`, 에서도 상속할 수에 적용 되는 메타 데이터는 속성을 <xref:System.Windows.Controls.Frame> 경계 또는 이와 유사한 경계입니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>종속성 속성의 하위 속성이 포함하는 개체의 렌더링에 영향을 주지 않는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>하위 속성 값이 변경되어도 렌더링에 영향을 주지 않으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메타 데이터 옵션은 해당 형식 자체의 속성 값에 있는 참조 형식에는 종속성 속성에 대 한 관련 됩니다. 일반적으로 레이아웃 시스템 논리 하위 속성을 사용 하 여 모든 종속성 속성은 영향을 줄 레이아웃에 변경 내용에 대 한 모든 하위 속성을 확인 하는 것은 실제로 실행 중인 것 보다 더 많은 시간이 소요 되므로 다른 렌더링 패스를 가정 하는 것입니다. 이 옵션을 설정 `true` WPF 프레임 워크 수준 레이아웃 시스템 구현은의 성능을 최적화 하는 데 유용 합니다.  
  
 파생된 클래스에서 속성 <xref:System.Windows.PropertyMetadata> 읽기 / 쓰기 가능으로 개체 모델에서 일반적으로 정의 됩니다. 이므로 인스턴스를 초기화 한 후 조정할 수 있습니다. 그러나 메타 데이터에 대 한 호출의 일부로 사용 되 면 <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, 또는 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, 속성 시스템에는 해당 메타 데이터 인스턴스가 봉인 됩니다 및 속성 메타 데이터의 세부 정보를 전달 하는 이제 변경할 수 없는 것으로 간주 됩니다. 후이 속성을 설정 하려고 <xref:System.Windows.PropertyMetadata.IsSealed%2A> 는 `true` 인스턴스가 메타이 데이터에서 예외가 발생 합니다.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 텍스트 사용  
 이 클래스의 멤버에 일반적으로 사용 되지 않는 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">메타데이터는 종속성 속성 작업에 이미 적용되었으므로 메타데이터가 봉인되어 메타데이터의 속성을 설정할 수 없습니다.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>