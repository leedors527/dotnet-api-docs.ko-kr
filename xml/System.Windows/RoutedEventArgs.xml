<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48756033" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="36ba8-101">라우트된 이벤트와 연결된 상태 정보 및 이벤트 데이터를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-102">다른 <xref:System.Windows.RoutedEventArgs> 사용 하 여 단일 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="36ba8-103">이 클래스는 이벤트 데이터를 패키지 하는 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>추가 이벤트 상태 정보를 제공 하 고 이벤트 시스템에서 사용 되는 라우트된 이벤트와 연결 된 처리기를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="36ba8-104"><see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="36ba8-105"><see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-106">이 매개 변수가 없는 생성자, new의 모든 공용 속성을 사용 하는 경우 <xref:System.Windows.RoutedEventArgs> 인스턴스는 다음과 같은 기본값 가정:</span><span class="sxs-lookup"><span data-stu-id="36ba8-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="36ba8-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="36ba8-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> 기본값은 `false`</span><span class="sxs-lookup"><span data-stu-id="36ba8-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="36ba8-109"><xref:System.Windows.RoutedEventArgs.Source%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="36ba8-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="36ba8-111">Null 값에 대 한 <xref:System.Windows.RoutedEventArgs.Source%2A> 및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 만 의미를 <xref:System.Windows.RoutedEventArgs> 데이터에서는 소스를 지정 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="36ba8-112">에 대 한 호출에서이 인스턴스를 사용 하는 경우 <xref:System.Windows.UIElement.RaiseEvent%2A>서 <xref:System.Windows.RoutedEventArgs.Source%2A> 및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 이벤트를 발생 시킨 및 라우팅을 통해 수신기에 전달 되는 요소에 따라 값이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="36ba8-113"><see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 이 인스턴스에 대한 라우트된 이벤트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="36ba8-114">제공된 라우트된 이벤트 식별자를 사용하여 <see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-115">이 오버 로드 된 생성자를 사용 하는 경우 새 속성을 지정 하지 않으면 <xref:System.Windows.RoutedEventArgs> 인스턴스는 다음과 같은 기본값 가정:</span><span class="sxs-lookup"><span data-stu-id="36ba8-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="36ba8-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> 기본값은 `false`</span><span class="sxs-lookup"><span data-stu-id="36ba8-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="36ba8-117"><xref:System.Windows.RoutedEventArgs.Source%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="36ba8-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="36ba8-119">Null 값에 대 한 <xref:System.Windows.RoutedEventArgs.Source%2A> 하 고 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 의미는이 <xref:System.Windows.RoutedEventArgs> 원본을 지정 하려고 하지 않으므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="36ba8-120">에 대 한 호출에서이 인스턴스를 사용 하는 경우 <xref:System.Windows.UIElement.RaiseEvent%2A>서 <xref:System.Windows.RoutedEventArgs.Source%2A> 및 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 이벤트를 발생 시킨 및 라우팅을 통해 수신기에 전달 되는 요소에 따라 값이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36ba8-121">다음 예제에서는 새 구문을 <xref:System.Windows.RoutedEventArgs> 에 대 한 호출에서 사용 하기 위해 <xref:System.Windows.UIElement.RaiseEvent%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="36ba8-122"><see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 이 인스턴스에 대한 라우트된 이벤트 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="36ba8-123">이벤트가 처리되면 보고될 대체 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="36ba8-124">이 소스는 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 속성을 미리 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="36ba8-125">제공된 라우트된 이벤트 식별자를 사용하여 <see cref="T:System.Windows.RoutedEventArgs" /> 클래스의 새 인스턴스를 초기화하고 이벤트에 대해 다른 소스를 선언할 수 있는 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-126">이 오버 로드 된 생성자를 사용 하는 경우 새 속성을 지정 하지 않으면 <xref:System.Windows.RoutedEventArgs> 인스턴스는 다음과 같은 기본값 가정:</span><span class="sxs-lookup"><span data-stu-id="36ba8-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="36ba8-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> 기본값은 `false`</span><span class="sxs-lookup"><span data-stu-id="36ba8-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="36ba8-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="36ba8-129">Null 값에 대 한 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 이벤트를 발생 하 고는 라우팅을 통해 전달 하는 요소에 따라 채워집니다 하지만 읽기는 `null` 호출 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="36ba8-130">전달 하는 경우이 서명을 사용 하 여 <xref:System.Windows.RoutedEventArgs> 와 같은 가상 메서드를 <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>호출에 인수를 사용 되는 위치, <xref:System.Windows.UIElement.RaiseEvent%2A> 내부적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36ba8-131">경로를 따라 이동할 때 라우트된 이벤트의 현재 이벤트 처리 상태를 나타내는 값을 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="36ba8-132">을 설정 하는 경우로 <see langword="true" /> 이벤트를 처리 하지 않으면 표시할 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="36ba8-133">이 값을 읽을 때 <see langword="true" /> 는 클래스 처리기 또는 경로의 일부 인스턴스 처리기가 이미 표시 나타냅니다이 이벤트를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="36ba8-134"><see langword="false" />는 이러한 처리기가 이벤트를 처리한 것으로 표시하지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
<span data-ttu-id="36ba8-135">기본값은 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-136">이벤트를 처리 된 이벤트 경로 따라 수신기 라우트된 이벤트의 표시 유형을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="36ba8-137">이벤트 경로의 나머지 부분을 계속 이동지 않습니다 하지만 유일한 처리기는 특히 사용 하 여 추가 `HandledEventsToo` `true` 에 <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> 메서드 호출 응답에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="36ba8-138">기본 인스턴스 수신기 처리기 (로 표현 되는 같은 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 호출 되지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="36ba8-139">일반적인 시나리오가 아닙니다 처리 표시 되는 이벤트를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="36ba8-140">컨트롤 작성자는 사용자 고유의 이벤트를 결정 하는 사항을 정의 처리 클래스 수준에서 컨트롤의 사용자와 파생 된 컨트롤의 모든 사용자 이벤트에 대 한 영향 및 컨트롤에서 다른 요소를 포함 하는 잠재적으로 또는 컨트롤을 포함 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="36ba8-141">자세한 내용은 [라우트된 이벤트를 처리된 것으로 표시 및 클래스 처리](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="36ba8-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="36ba8-142">매우 드문 경우에서 적절 한 이벤트를 처리 하는 위치 <xref:System.Windows.RoutedEventArgs.Handled%2A> 표시 됩니다 `true`, 및 이벤트 인수를 변경 하 여 수정 <xref:System.Windows.RoutedEventArgs.Handled%2A> 를 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="36ba8-143">이 키 처리 등의 컨트롤 입력된 이벤트의 특정 영역에 필요할 수 있습니다 <xref:System.Windows.UIElement.KeyDown> 비교 <xref:System.Windows.UIElement.TextInput> 는 낮은 수준 높은 수준의 입력된 이벤트 처리를 위해 경쟁 하 고 각각 서로 다른 라우팅 방법을 사용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36ba8-144">다음 예제에서는 이벤트를 처리를 표시 하는 이벤트 처리기를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="36ba8-145">호출할 제네릭 처리기/대리자 구현입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="36ba8-146">지정된 처리기가 호출되어야 하는 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="36ba8-147">파생 클래스에서 재정의된 경우 기본 구현 이상으로 효율성을 높일 수 있는 형식별 방법으로 이벤트 처리기를 호출하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-148">리플렉션을 처리기 있지 않은 말 그대로 모든 사례에 대 한 적절 한 처리기를 통합 하는 기본 구현을 <xref:System.Windows.RoutedEventHandler>, 성능은 저하 없고이 리플렉션 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="36ba8-149">호출 가능 효율적 리플렉션에 의존 하지 않고 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="36ba8-150">이렇게 하면이 메서드를 재정의 하는 모든 라우트된 이벤트 인수 클래스에 사용할 수 있는 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="36ba8-151">구현은 구현 형식이 안전한 처리기를 호출 하는 일을 담당 있어야 하기 때문에이 메서드에 대 한 기본을 호출 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36ba8-152">다음은 구현에 사용할 수 있는 기본 패턴을 보여 주는 의사 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="36ba8-153">이때 `MyRoutedEventHandler` 서브 클래스입니다 <xref:System.Windows.RoutedEventHandler>합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="36ba8-154">이 메서드는 보다 효율적으로 해당 대리자 호출을 제공 하는 파생 된 이벤트 데이터 클래스에서 재정의 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="36ba8-155">구현에서는 제공 된 캐스팅 해야 <paramref name="genericHandler" /> 형식별 대리자를 다음 해당 처리기를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
<span data-ttu-id="36ba8-156">기본 구현으로 캐스팅 하려고 합니다. 제공된 된 처리기를 호출 하려고 <see cref="T:System.Windows.RoutedEventHandler" />합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="36ba8-157">이면 <paramref name="genericHandler" /> 또는 <paramref name="genericTarget" /> 로 제공 됩니다 <see langword="null" />, 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="36ba8-158"><see cref="P:System.Windows.RoutedEventArgs.Source" />가 설정되는 새 값입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="36ba8-159">파생된 클래스에서 재정의되는 경우 인스턴스의 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 속성 값이 변경될 때마다 알림 콜백 진입점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="36ba8-160">이벤트의 보고 된 소스를 프로그래밍 방식으로 변경 이벤트 내의 형식별 데이터를 업데이트 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="36ba8-161">이러한 이유로 합니다 <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> 은 보호 된 가상 메서드와의 서브 클래스에서 재정의 될 <see cref="T:System.Windows.RoutedEventArgs" />합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
<span data-ttu-id="36ba8-162">이 메서드는 기본 구현이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-162">This method has no default implementation.</span></span></para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36ba8-163">부모 클래스에 의한 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 조정 앞에 순수 적중 횟수 테스트에서 결정한 원본 보고 원본을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="36ba8-164">클래스 처리에 의한 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 조정 앞에 있는 원본 보고 소스로서, 합성 요소 트리를 평면화하기 위해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-165">이 속성이 면 클래스 하기 전에 이벤트 처리기 나 인스턴스 처리기 호출 되 고이 지점 이후의 조정 되지 않습니다 해당 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="36ba8-166">원래 원본 정보는 이벤트 데이터에서 보고 됩니다 처럼 클래스 처리기 또는 클래스 구현에 읽기 전용입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="36ba8-167">컨트롤에 대 한 콘텐츠 모델 내의 콘텐츠 요소를 포함 하는 일반적인 사례는 소스를 조정할 수 있습니다 (예를 들어, 목록 항목의 내용을으로 목록 항목 요소에서 보고를 <xref:System.Windows.RoutedEventArgs.Source%2A> 목록 항목 내에서 실제 요소 수를 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="36ba8-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="36ba8-168">다양 한 요소 및 콘텐츠 모델에서 원본 조정 클래스에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="36ba8-169">이벤트 소스를 조정 하는 각 클래스는 원본이 클래스를 위한, 시나리오 및 대부분의 입력된 시나리오에 대 한 보고 하는 가장 유용한 예상 하 고 다음 집합을 원본으로 <xref:System.Windows.RoutedEventArgs.Source%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="36ba8-170">이벤트의 처리와 관련 된 것이이 원본이 없는 경우를 확인해 보세요 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 대신 더욱 적합 한 다른 소스 경우 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="36ba8-171">입력된 이벤트에 대 한 자세한 내용은 참조 하세요. [입력 개요](~/docs/framework/wpf/advanced/input-overview.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36ba8-172">이 <see cref="T:System.Windows.RoutedEventArgs" /> 인스턴스와 연결된 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="36ba8-173">호출된 이벤트의 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-174">이 값을 설정할 수 없습니다는 <xref:System.Windows.RoutedEventArgs> 는 이미 회람 된 (예를 들어 획득 한 경우 처리기를 통해 인수).</span><span class="sxs-lookup"><span data-stu-id="36ba8-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="36ba8-175">이렇게 하려고 하면 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="36ba8-176">이벤트의 호출을 생성 하는 아직 사용 되지 않은 인스턴스에 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="36ba8-177">변수의 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 일 수 없습니다 `null` 언제 든 지 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="36ba8-178">다음 예제에서는 초기 생성자를 사용 하 여 새 라우트된 이벤트 데이터를 만들고 설정 하는 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 후속 작업으로 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="36ba8-179">있어야 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 라우트된 이벤트가 발생 하기 전에 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="36ba8-180">이벤트가 라우트되는 동안 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 값을 변경하려고 시도했습니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="36ba8-181">이벤트를 발생시킨 개체에 대한 참조를 가져오거나 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="36ba8-182">이벤트를 발생시킨 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="36ba8-183">이벤트를 발생 시킨 요소 경로가 짧아 지도록 실제로는 라우팅된 모든 버블링 및 터널링 모든 라우트된 이벤트 하지 않는지 아직를 발생 시킨 값 요소까지 아래로 터널링에 대 한 <xref:System.Windows.RoutedEventArgs.Source%2A> 합니다 의값과다를수 `sender` 이벤트 인수 클래스의 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="36ba8-184">두 요소는 이벤트와 관련 된 것이 가장 중요 모든 지정 된 처리기에서 (<xref:System.Windows.RoutedEventArgs.Source%2A>를 발생 시킨 요소 또는 `sender`, 현재이 처리 하는 요소) 처리기는 응용 프로그램 논리에 따라 달라 집니다 주소를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="36ba8-185">이 속성을 설정할는 일반적으로 경우에 수행 재정의 하거나 구현 하는 다른 [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] 경우와 같이 이벤트 소스를 조정 하는 클래스는 이벤트를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="36ba8-186">인스턴스 처리기에서 명백한 이벤트 소스를 다시 설정 하는 권장 되지 처리 처리기 이벤트를 표시 하지 않는 경우에 특히.</span><span class="sxs-lookup"><span data-stu-id="36ba8-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="36ba8-187">다시 설정 해도 <xref:System.Windows.RoutedEventArgs.Source%2A> 다른 이벤트 소스를 보고 하 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 보고서를 시작 하 여 발생 하는 첫 번째 소스 계속 <xref:System.Windows.UIElement.RaiseEvent%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="36ba8-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>