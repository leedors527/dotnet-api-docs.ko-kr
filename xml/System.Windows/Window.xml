<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9d43e1669777630039410a6a9e7e3d24852c6ad1" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57937124" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>창과 대화 상자의 수명을 생성, 구성, 표시 및 관리하는 기능을 제공합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용자와 독립 실행형 응용 프로그램 간의 상호 작용 지점 창입니다. [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 창 두 고유 영역으로 구성 됩니다.  
  
-   아이콘, 제목, 시스템 메뉴를 포함 하 여 windows 도구 영역을 호스트 하는 비클라이언트 영역을 최소화 단추, 단추, 복원 단추, 닫기 단추 및 테두리를 최대화 합니다.  
  
-   응용 프로그램별 콘텐츠를 호스트 하는 클라이언트 영역입니다.  
  
 표준 창 다음 그림에 표시 됩니다.  
  
 ![창 요소](~/add/media/windowoverviewfigure1.PNG "창 요소")  
  
 <xref:System.Windows.Window> 만들기, 구성, 표시 및 창과 대화 상자 모두의 수명을 관리 하는 기능을 캡슐화 하 고 다음과 같은 핵심 서비스를 제공 합니다.  
  
 **수명 관리**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>를 <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>를 <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>를 <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>합니다.  
  
 **창 관리**: <xref:System.Windows.Window.GetWindow%2A>하십시오 <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>합니다.  
  
 **모양 및 동작**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>를 <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>를 <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>를 <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **대화 상자**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 또한 <xref:System.Windows.Application> 모든 응용 프로그램의 창 관리에 대 한 특별 한 지원을 노출 합니다.  
  
-   응용 프로그램에는 현재 응용 프로그램에서 인스턴스화되는 모든 windows의 목록을 유지 관리 합니다. 이 목록에 의해 노출 되는 <xref:System.Windows.Application.Windows%2A> 속성입니다.  
  
-   기본적으로 <xref:System.Windows.Application.MainWindow%2A> 첫 번째에 대 한 참조를 사용 하 여 자동으로 설정 됩니다 <xref:System.Windows.Window> 는 응용 프로그램에서 인스턴스화됩니다. 따라서이 창의 기본 응용 프로그램 창입니다.  
  
 <xref:System.Windows.Window> 태그, 태그 및 코드 숨김 또는 코드를 사용 하 여 구현할 수 있습니다.  
  
 <xref:System.Windows.Window> windows 및 독립 실행형 응용 프로그램에 대 한 대화 상자를 표시할 주로 사용 됩니다. 그러나 탐색 마법사와 같은 창 수준에서 필요한 응용 프로그램을 사용할 수 있습니다 <xref:System.Windows.Navigation.NavigationWindow> 대신; <xref:System.Windows.Navigation.NavigationWindow> 에서 파생 <xref:System.Windows.Window> 브라우저 스타일 탐색 지원을 통해 확장 하 고 있습니다.  
  
> [!NOTE]
>  탐색 가능한 콘텐츠를 사용 하 여 다른 콘텐츠 및 콘텐츠 컨테이너에 통합할 수 <xref:System.Windows.Controls.Frame>입니다.  
  
 <xref:System.Windows.Window> 필요한 `UnmanagedCode` 보안 권한을 인스턴스화해야 합니다. 이 다음과 같은 결과가 발생 합니다.  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-배포 된 독립 실행형 응용 프로그램은 인터넷 또는 로컬 인트라넷 영역에서 시작 하는 경우 권한 상승을 요청 합니다.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] 보다 낮은 권한을 요청 전체 사용 권한 창 또는 대화 상자를 인스턴스화할 수 없습니다.  
  
 독립 실행형 응용 프로그램 배포 및 보안 고려 사항에 대 한 자세한 내용은 [WPF 보안 전략-플랫폼 보안](~/docs/framework/wpf/wpf-security-strategy-platform-security.md)합니다.  
  
 A <xref:System.Windows.Window> 는 <xref:System.Windows.Controls.ContentControl>, 즉, 모든 형식 (예: 문자열, 이미지 또는 패널)의 단일 개체가 포함 될 수 있습니다. 자세한 내용은 <xref:System.Windows.Controls.ContentControl> 클래스를 참조하세요. 또한 <xref:System.Windows.Window> 루트 요소 이며, 따라서 다른 요소의 콘텐츠가 포함 될 수 없습니다.  
  
> [!NOTE]
>  합니다 <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A> 에 설정 된 속성을 <xref:System.Windows.Window> 스타일을 통해 적용 되지 것입니다 런타임 시.  
  
## <a name="customizing-the-window-control"></a>창 컨트롤을 사용자 지정  
 여러 동일한 속성 설정에 적용할 <xref:System.Windows.Window> 컨트롤을 사용 하 여는 <xref:System.Windows.FrameworkElement.Style%2A> 속성입니다. 기본값을 수정할 수 있습니다 <xref:System.Windows.Controls.ControlTemplate> 고유한 모양을 제어할 수 있습니다. 만들기에 대 한 자세한 내용은 <xref:System.Windows.Controls.ControlTemplate>를 참조 하세요 [ControlTemplate을 만들어 기존 컨트롤의 모양 사용자 지정](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md)합니다.  부분과 관련 된 상태를 보려면 합니다 <xref:System.Windows.Window>를 참조 하세요 [Window 스타일 및 템플릿](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 이 컨트롤에 대 한 종속성 속성은 컨트롤의 기본 스타일으로 설정할 수 있습니다.  속성이 설정 된 기본 스타일을 컨트롤 응용 프로그램에 표시 되 면 속성 값이 기본값에서 변경 될 수 있습니다. 기본 스타일은 응용 프로그램 실행 중일 때 사용 되는 바탕 화면 테마에서 결정 됩니다.  자세한 내용은 [기본 WPF 테마](https://go.microsoft.com/fwlink/?LinkID=158252)합니다.  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 다음 예제에서는 표준 창의 성은 태그를 사용 하 여 정의 합니다.  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 다음 예제에서는 표준 창을 사용 하 여 정의 하는 방법만 코드:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 다음 예제에서는 표준 창의 성은 태그 및 코드 숨김의 조합을 사용 하 여 정의 합니다.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Window" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 생성자가 초기화 하는 <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>를 <xref:System.Windows.Window.Top%2A>, 및 <xref:System.Windows.Window.Left%2A> 속성을 기본 <xref:System.Windows.Window> 값입니다.  
  
 창 내에서 만들어지는 경우는 <xref:System.AppDomain> 있는 <xref:System.Windows.Application> 개체를 추가 하는 생성자를 <xref:System.Windows.Window> 개체 집합에 <xref:System.Windows.Application>-를 통해 windows 관리를 <xref:System.Windows.Application.Windows%2A> 의 속성을 <xref:System.Windows.Application> 개체.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">안전 하지 않은 네이티브 메서드를 호출 하 여이 개체에 대해 필요한 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 전경으로 가져오고 활성화하려고 합니다.</summary>
        <returns><see cref="T:System.Windows.Window" />가 활성화된 경우 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창 활성화 되는지 여부를 결정 하는 규칙에서 사용 하는 것과 동일 합니다 [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` 함수 (User32.dll).  
  
 창이 전경 응용 프로그램이 사용자의 Windows Presentation Foundation 응용 프로그램에서 활성화 된 경우 <xref:System.Windows.Application.Activated> 이벤트가 발생 합니다.  
  
> [!NOTE]
>  창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 활성화할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 전경 창이 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창이 활성화 됩니다 (전경 창이 되) 때:  
  
-   먼저 창이 열려 있습니다.  
  
-   ALT + TAB을 눌러 마우스를 사용 하 여 또는 작업 관리자에서 선택 하 여 사용자를 창으로 전환 합니다.  
  
-   사용자가 창의 작업 표시줄 단추를 클릭 합니다.  
  
 활성화 되는 경우를 감지 해야 하는 Windows를 처리할 수는 <xref:System.Windows.Window.Activated> 이벤트입니다.  
  
 창이 처음 활성화 한 후 비활성화 하 고 해당 수명 동안 여러 번 다시 활성화 될 수 있습니다. 응용 프로그램의 동작 또는 상태 정품 인증 상태에 의존 하는 경우 검사 수 <xref:System.Windows.Window.IsActive%2A> 있는 정품 인증 상태를 확인 하려면.  
  
 응용 프로그램 일 수도 있습니다 <xref:System.Windows.Application.Activated>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 클라이언트 영역에서 투명도를 지원하는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창에서 투명도를 지원하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Controls.Control.Background%2A> 창의 속성을 투명 한 색을 사용 하 여 <xref:System.Windows.Media.Brushes.Transparent%2A> 예를 들어 창을 불투명 하 게 유지 합니다. 즉, 데스크톱 및 "beneath" 창의 실행 중인 응용 프로그램을 볼 수 없습니다. 이 형식의 투명도 사용할 수 있도록 <xref:System.Windows.Window.AllowsTransparency%2A> 으로 설정 되어 있어야 `true`합니다.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> 사각형이 아닌 창 만들기를 용이 하 게 존재 때 <xref:System.Windows.Window.AllowsTransparency%2A> 로 설정 된 `true`, 창의 <xref:System.Windows.Window.WindowStyle%2A> 속성으로 설정 되어 있어야 <xref:System.Windows.WindowStyle.None>합니다.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">창의 <see cref="P:System.Windows.Window.WindowStyle" /> 값이 <see cref="F:System.Windows.WindowStyle.None" />이 아닌 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.AllowsTransparency" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">창이 해당 창과 자식을 정렬하는 데 사용해야 하는 최종 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</param>
        <summary>이 메서드를 재정의하여 창과 자식 요소를 정렬하고 크기를 조정합니다.</summary>
        <returns>사용된 실제 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> 경우 라고 합니다 <xref:System.Windows.UIElement.Visibility%2A> 속성의 값이 <xref:System.Windows.Visibility.Collapsed>합니다. 하는 경우의 값을 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden> 또는 <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> 라고 합니다.  
  
> [!NOTE]
>  경우 중 하나 <xref:System.Windows.Window.Show%2A> 또는 <xref:System.Windows.Window.ShowDialog%2A> 호출 되는 <xref:System.Windows.UIElement.Visibility%2A> 의 속성을 <xref:System.Windows.Window> 로 설정 된 <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>수동으로 <see cref="T:System.Windows.Window" />를 닫습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window> , 여러 가지 방법 중 하나를 사용 하 여 닫아야 바 포함 하 여 제목에 있는 잘 알려진 시스템 제공 메커니즘:  
  
-   ALT+F4입니다.  
  
-   시스템 메뉴 &#124; **닫습니다**합니다.  
  
-   **닫기** 단추입니다.  
  
 <xref:System.Windows.Window> 클라이언트 영역 내에서 개발자에 게 제공 되는 몇 가지 잘 알려진 메커니즘 중 하나를 사용 하 여 닫을 수도 있습니다.  
  
-   **파일** &#124; **끝내기** 주 창에 있습니다.  
  
-   **파일** &#124; **닫습니다** 또는 **닫습니다** 자식 창에는 단추입니다.  
  
> [!NOTE]
>  **확인** 및 **취소** 대화 상자의 단추 개발자 제공한도 있지만 설정할 가능성이 <xref:System.Windows.Window.DialogResult%2A>를 호출 하 여 열려 있는 창을 자동으로 닫는 <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 이러한 메커니즘을 사용 하면 명시적으로 호출 해야 <xref:System.Windows.Window.Close%2A> 는 창을 닫습니다.  
  
> [!NOTE]
>  호출로 열린 창, 하는 경우 <xref:System.Windows.Window.ShowDialog%2A>, 및는 <xref:System.Windows.Controls.Button> 사용 하 여 해당 <xref:System.Windows.Controls.Button.IsCancel%2A> 단추를 클릭 하거나, 또는 esc 키를 누를 때에 자동으로 속성을 true로 설정할 닫힙니다. 창을 사용 하 여 열렸으면 <xref:System.Windows.Window.Show%2A>그러나 <xref:System.Windows.Window.Close%2A> 에서 같이 명시적으로 호출 해야 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 에 대 한 이벤트 처리기는 <xref:System.Windows.Controls.Button>합니다.  
  
 창을 닫으면는 <xref:System.Windows.Window.Closing> 이벤트가 발생 합니다. 경우는 <xref:System.Windows.Window.Closing> 이벤트 취소 하지 않으면 다음이 발생 합니다.  
  
-   합니다 <xref:System.Windows.Window> 에서 제거 됩니다 <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (하는 경우는 <xref:System.Windows.Application> 개체가).  
  
-   <xref:System.Windows.Window> 소유자에서 제거 됩니다 <xref:System.Windows.Window> 소유자 소유 관계가 설정 된 경우를 소유 하기 전에 <xref:System.Windows.Window> 표시 된 소유자 후 <xref:System.Windows.Window> 열렸습니다.  
  
-   <xref:System.Windows.Window.Closed> 이벤트가 발생합니다.  
  
-   만든 리소스를 관리 되지 않는 <xref:System.Windows.Window> 삭제 됩니다.  
  
-   경우 <xref:System.Windows.Window.ShowDialog%2A> 표시할 호출한 합니다 <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> 반환 합니다.  
  
 닫기는 <xref:System.Windows.Window> 닫아야 소유 하는 모든 창이 있습니다. 또한 닫기는 <xref:System.Windows.Window> 방법에 따라 실행을 중지 하려면 응용 프로그램에 발생할 수 있습니다 <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> 속성을 설정 합니다.  
  
> [!NOTE]
>  창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 에서는 다음 예제는 **파일** &#124; **종료** 명시적으로 호출 하도록 처리 되는 메뉴 <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 닫히려고 할 때 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트가 발생 되 면 창 닫기를 방지할 수 없습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">창이 닫히는 동안 <see cref="P:System.Windows.UIElement.Visibility" />, <see cref="M:System.Windows.Window.Show" /> 또는 <see cref="M:System.Windows.Window.ShowDialog" />가 호출되거나 <see cref="M:System.Windows.Window.Hide" />가 설정된 경우</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Window.Close" />가 호출된 직후에 발생하며 창 닫기를 취소하도록 처리할 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> 창의 닫을 때를 감지 하도록 처리할 수 있습니다 (경우에 예를 들어 <xref:System.Windows.Window.Close%2A> 라고). 또한 <xref:System.Windows.Window.Closing> 창 닫기를 방지 하기 위해 사용할 수 있습니다. 창 닫기를 방지 하려면 설정할 수 있습니다는 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> 의 속성을 <xref:System.ComponentModel.CancelEventArgs> 인수를 `true`입니다.  
  
 합니다 <xref:System.Windows.Window.Closing> 이벤트가 발생할 때 <xref:System.Windows.Window.Close%2A> 창 닫기 단추를 클릭 하거나 alt+f4를 누를 경우 호출 됩니다.  
  
 소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 소유자 및 소유한 창의 창이 닫힌 <xref:System.Windows.Window.Closing> 이벤트가 발생 하지 않습니다. 창의 소유자 닫히면 (참조 <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> 소유 된 창에서 발생 하지 않습니다.  
  
 하는 경우 <xref:System.Windows.Application.Shutdown%2A> 호출 되는 <xref:System.Windows.Window.Closing> 각 창에 대 한 이벤트가 발생 합니다. 그러나 경우 <xref:System.Windows.Window.Closing> 는 취소, 취소 무시 됩니다.  
  
 사용자가 로그 오프 하거나 종료 하기 때문에 세션을 종료 하는 경우 <xref:System.Windows.Window.Closing> 발생 하지 않으면 처리 <xref:System.Windows.Application.SessionEnding> 응용 프로그램을 닫지는 코드를 구현 합니다.  
  
 응용 프로그램의 수명 동안 여러 번 창 숨기기 및 표시 하 고 창 될 때마다 다시 인스턴스화하는 데 않을 경우 표시할 때마다 처리할 수 있습니다 합니다 <xref:System.Windows.Window.Closing> 이벤트를 취소 하 고 호출 된 <xref:System.Windows.Window.Hide%2A> 메서드. 그런 다음 호출할 수 있습니다 <xref:System.Windows.Window.Show%2A> 닫았다가 동일한 인스턴스에서 합니다.  
  
   
  
## Examples  
 다음 예제는 <xref:System.Windows.Window> 닫기 위해 사용자 개입이 필요한 지 여부를 결정 하는 합니다.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">창이 닫히는 동안 <see cref="P:System.Windows.UIElement.Visibility" />, <see cref="M:System.Windows.Window.Show" /> 또는 <see cref="M:System.Windows.Window.ShowDialog" />가 호출되거나 <see cref="M:System.Windows.Window.Close" />가 설정된 경우</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 콘텐츠가 렌더링된 후에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창에 내용이 없는 경우이 이벤트가 발생 하지 않습니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 배경 창이 되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창이 비활성화 되었을 (배경 창이 되) 때:  
  
-   사용자는 현재 응용 프로그램의 다른 창으로 전환합니다.  
  
-   사용자가 ALT + TAB을 사용 하 여 또는 작업 관리자를 사용 하 여 다른 응용 프로그램의 창으로 전환 합니다.  
  
-   사용자가 다른 응용 프로그램의 창에 대 한 작업 표시줄 단추를 클릭 합니다.  
  
 처리 하 여 비활성화 되는 경우를 감지 해야 하는 Windows를 <xref:System.Windows.Window.Deactivated> 이벤트입니다.  
  
 창이 먼저 비활성화 되 면 다시 활성화 하 고 해당 수명 동안 여러 번 비활성화 될 수 있습니다. 응용 프로그램의 동작 또는 상태 정품 인증 상태에 의존 하는 경우 검사 수 <xref:System.Windows.Window.IsActive%2A> 있는 정품 인증 상태를 확인 하려면.  
  
 응용 프로그램 일 수도 있습니다 <xref:System.Windows.Application.Deactivated>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Window.ShowDialog" /> 메서드에서 반환된 값인 대화 상자 결과 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Nullable`1" /> 형식의 <see cref="T:System.Boolean" /> 값입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> 사용자의 수락 여부를 결정 하는 대화 상자를 표시 한 코드에서 사용할 수 있습니다 (`true`) 하거나 취소 (`false`) 대화 상자. 대화 상자를 수락 하는 경우이 사용자에 의해 수집 된 데이터를 검색 하 고 처리 하는 대화 상자를 연 코드를 나타냅니다. 그러나 대화 상자를 취소 된 경우 것을 의미 합니다는 코드를 호출 해야 처리를 중지 합니다.  
  
 기본적으로 사용자는 다음 중 하나를 수행 하는 경우 대화 상자 취소 됩니다.  
  
-   PressesALT+F4.  
  
-   클릭 합니다 **닫기** 단추입니다.  
  
-   선택 **닫기** 시스템 메뉴에서.  
  
 이러한 경우 모든 <xref:System.Windows.Window.DialogResult%2A> 는 `false` 기본적으로 합니다.  
  
 대화 상자에 단추가 있는 대화 상자를 취소 하는 특수 단추 일반적으로 제공 된 <xref:System.Windows.Controls.Button.IsCancel%2A> 속성이 `true`합니다. 이 방식으로 구성 된 단추를 자동으로 닫힙니다 창 누를 하거나 때나 ESC 키를 누를 때. 이러한 경우 중 하나로 <xref:System.Windows.Window.DialogResult%2A> 남아 `false`합니다.  
  
 대화 상자에는 일반적으로 단추의 적용 단추를 제공 된 <xref:System.Windows.Controls.Button.IsDefault%2A> 속성이 `true`합니다. 이러한 방식으로 구성 된 단추에서 발생 하는 해당 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 것 또는 ENTER 키를 누르면 이벤트입니다. 그러나 대화 상자를 자동으로 닫히지 되거나 해당 설정이 <xref:System.Windows.Window.DialogResult%2A> 에 `true`입니다. 수동으로이 코드에서 일반적으로 작성 해야 합니다 <xref:System.Windows.Controls.Primitives.ButtonBase.Click> 기본 단추에 대 한 이벤트 처리기입니다.  
  
 <xref:System.Windows.Window.DialogResult%2A> `null` 대화 상자를 표시 하는 경우 하지만 모두 허용 되거나 취소 합니다.  
  
 대화 상자를 닫으면 반환 하는 값에서 대화 상자 결과 가져올 수 있습니다 <xref:System.Windows.Window.ShowDialog%2A> 메서드를 검사 하 여 또는 <xref:System.Windows.Window.DialogResult%2A> 속성입니다.  
  
 <xref:System.Windows.Window.DialogResult%2A> 만 설정할 수 있습니다 시기를 <xref:System.Windows.Window> 호출 하 여 해당 <xref:System.Windows.Window.ShowDialog%2A> 메서드.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 확인 단추와 적절 한 반환할 취소 단추를 구성 하는 방법을 보여 줍니다 <xref:System.Windows.Window.DialogResult%2A>합니다.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" />는 <see cref="M:System.Windows.Window.ShowDialog" />를 호출하여 창이 열리기 전에 설정됩니다.  
  
또는 
 <see cref="P:System.Windows.Window.DialogResult" />는 <see cref="M:System.Windows.Window.Show" />를 호출하여 창이 열릴 때 설정됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 표시되는 화면 DPI가 변경된 후에 발생합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 화면 DPI가 변경 중일 때의 <see cref="T:System.Windows.RoutedEvent" />입니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>마우스 왼쪽 단추를 누른 상태로 창 클라이언트 영역의 노출된 영역에서 창을 끌 수 있게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 마우스 왼쪽된 단추를 누른 상태로 해야 <xref:System.Windows.Window.DragMove%2A> 라고 합니다. 마우스 왼쪽된 단추를 누를 때 검색 하는 한 가지 방법은 처리 하는 것은 <xref:System.Windows.UIElement.MouseLeftButtonDown> 이벤트입니다.  
  
 때 <xref:System.Windows.Window.DragMove%2A> 라고, 왼쪽 마우스 단추를 누른 창의 클라이언트 영역의 노출 된 영역입니다.  
  
> [!NOTE]
>  창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 재정의 하는 방법을 보여 줍니다 <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> 호출할 <xref:System.Windows.Window.DragMove%2A>합니다.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">왼쪽 마우스 단추를 누르지 않은 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 끌 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">종속성 개체입니다.</param>
        <summary>종속성 개체가 위치한 콘텐츠 트리를 호스팅하는 <see cref="T:System.Windows.Window" /> 개체에 대한 참조를 반환합니다.</summary>
        <returns>호스트 창에 대한 <see cref="T:System.Windows.Window" /> 참조입니다.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" />가 null입니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창이 표시되지 않게 합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 를 숨긴 경우 창이 닫힐 모두를 <xref:System.Windows.Window.Closing> 나 <xref:System.Windows.Window.Closed> 이벤트가 발생 합니다. 대신 창의 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>합니다.  
  
 창에 응용 프로그램의 경우 <xref:System.Windows.Application.MainWindow%2A> 및 응용 프로그램의 <xref:System.Windows.Application.ShutdownMode%2A> 는 <xref:System.Windows.ShutdownMode.OnMainWindowClose>, 응용 프로그램 종료 되지 않습니다. 마찬가지로, 응용 프로그램 종료 되지 않으면 창을 유일한 창이 이며 응용 프로그램의 종료 모드 경우 <xref:System.Windows.ShutdownMode.OnLastWindowClose>합니다.  
  
 응용 프로그램의 수명 동안 여러 번 창 숨기기 및 표시 하 고 다시 창을 인스턴스화할 때마다 하지 않을 경우 표시할 때마다 처리할 수 있습니다 합니다 <xref:System.Windows.Window.Closing> 이벤트를 취소 하 고 호출 된 <xref:System.Windows.Window.Hide%2A> 메서드. 그런 다음 호출할 수 있습니다 <xref:System.Windows.Window.Show%2A> 에 다시 열고 동일한 인스턴스에 있습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">닫히고 있는 창(<see cref="M:System.Windows.Window.Hide" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 아이콘을 가져오거나 설정합니다.</summary>
        <value>아이콘을 나타내는 <see cref="T:System.Windows.Media.ImageSource" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows Presentation Foundation (WPF) 독립 실행형 응용 프로그램에는 두 가지 유형의 아이콘이 있습니다.  
  
-   사용 하 여 지정 된 어셈블리 아이콘을 `<ApplicationIcon>` 응용 프로그램의 프로젝트 속성 파일을 빌드합니다. 이 아이콘은 어셈블리에 대 한 바탕 화면 아이콘으로 사용 됩니다.  
  
    > [!NOTE]
    >  Visual Studio에서 디버깅 아이콘 호스팅 프로세스로 인해 나타나지 않을 수 있습니다. 실행 파일을 실행 하는 경우에 아이콘이 표시 됩니다. 자세한 내용은 [호스팅 프로세스(vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b)를 참조하세요.  
  
-   설정 하 여 지정 된 기간당 한 아이콘만 <xref:System.Windows.Window.Icon%2A>합니다. 각 창에 대 한 해당 ALT + TAB 응용 프로그램 선택 목록 항목의 작업 표시줄 단추가 제목 표시줄에이 아이콘이 사용 됩니다.  
  
 항상 WPF 창 아이콘을 표시합니다. 때 설정 하 여 제공 하지 않은 <xref:System.Windows.Window.Icon%2A>, WPF는 다음 규칙을 기준으로 표시할 아이콘을 선택 합니다.  
  
1.  지정 된 경우에 어셈블리 아이콘을 사용 합니다.  
  
2.  어셈블리 아이콘을 지정 하지 않으면 기본 Microsoft Windows 아이콘을 사용 합니다.  
  
 사용 하는 경우 <xref:System.Windows.Window.Icon%2A> 사용자 지정 창 아이콘을 지정 하려면 기본 응용 프로그램 아이콘을 설정 하 여 복원할 수 있습니다 <xref:System.Windows.Window.Icon%2A> 에 `null`입니다.  
  
 Windows, ALT + TAB 파일 선택 목록 창의 작업 표시줄 창의 제목 표시줄에 표시 하는 등의 다양 한 아이콘을 사용할 수 있습니다. 이러한 각을 다른 크기로; 아이콘을 표시 ALT + TAB 파일 선택 목록에 표시 되는 32 x 32 픽셀 아이콘 동안 16 x 16 픽셀 아이콘을 작업 표시줄 및 창의 제목 표시줄에 표시 됩니다. 같은 일부 응용 프로그램 [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], 제공을 **보기** 보려는 원하는 아이콘의 크기를 선택할 수 있는 메뉴.  
  
 아이콘 파일에 다양 한 디스플레이 크기에는 각각 특정 크기 및 색 농도 대상으로 하는 아이콘의 버전을 나타내는 하나 이상의 실제 아이콘으로 구성 됩니다. 예를 들어, 하나의 아이콘 16 색 및 256 색을 사용 하 여 32 x 32 픽셀 아이콘과 16 x 16 픽셀을 포함할 수 있습니다 다른 하는 동안에 16 색을 사용 하 여 단일 16 x 16 픽셀 아이콘이 있을 수 있습니다.  
  
 모든 가능한 크기 및 색에 대 한 아이콘 아이콘 파일 내에 존재 하는 경우 <xref:System.Windows.Window> 해당 아이콘을 사용 합니다. 아이콘 파일에 가능한 모든 아이콘의 하위 집합만 포함 되어 있으면 <xref:System.Windows.Window> 크기 및 색 농도 감소의 순서로 다음 가장 적합 한 아이콘을 사용 합니다.  
  
 결과 아이콘에서 항상 사용 됩니다 <xref:System.Windows.Window>사용 되는 아이콘 크기 및 색 깊이 필요한 대상 하지 않더라도, 합니다. 예를 들어, 256 색을 사용 하 여 32 x 32 픽셀 아이콘으로 표시를 16 색 16 x 16 픽셀 아이콘을 사용할 수 있습니다. 이 픽셀화가, 같은 바람직하지 않은 시각 효과가 발생할 수 있지만 모든 대상된 크기와 색상에 대 한 아이콘을 만들어 방지할 수 있습니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.IconProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 창 아이콘을 설정 하는 방법을 보여 줍니다.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">아이콘을 설정할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Icon" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 활성 상태인지 여부를 나타내는 값을 가져옵니다.</summary>
        <value>창이 활성 상태이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 활성화 된 창의 사용자의 현재 전경 창을 이며 포커스가 있는 제목 표시줄의 현재 모양을 표시 됩니다. 활성 창도 명시적으로 설정 하지 않는 모든 최상위 창의 최상위 됩니다는 <xref:System.Windows.Window.Topmost%2A> 속성입니다.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.IsActiveProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.IsActive" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>바탕 화면과 관련해서 창의 왼쪽 가장자리 위치를 가져오거나 설정합니다.</summary>
        <value>논리 단위(1인치의 1/96)로 지정된 창의 왼쪽 가장자리 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 최대화 되거나 최소화, 복원의 왼쪽된 가장자리에 대 한 지점 값 나타냅니다가는 <xref:System.Windows.Window>합니다.  
  
 스타일을 통해이 속성을 설정할 수 없습니다.  
  
 값을 지정 하지 않으면 경우 <xref:System.Windows.Window.Left%2A> 시스템 기본값으로 설정 됩니다. 설정 하 여 시스템 기본값을 지정할 수도 있습니다 <xref:System.Windows.Window.Left%2A> 에 <xref:System.Double.NaN>입니다. 모두 <xref:System.Double.NegativeInfinity> 나 <xref:System.Double.PositiveInfinity> 에 대 한 유효한 값인지 <xref:System.Windows.Window.Left%2A>합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.LeftProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Left" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 위치가 변경되면 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창의 위치를 변경 하는 경우:  
  
-   사용자는 창의 제목 표시줄을 사용 하 여 끌어 창을 이동 합니다.  
  
-   창이 이동 하는 후 <xref:System.Windows.Window.DragMove%2A> 라고 합니다.  
  
-   중 하나는 <xref:System.Windows.Window.Left%2A> 또는 <xref:System.Windows.Window.Top%2A> 속성을 프로그래밍 방식으로 설정 합니다.  
  
-   합니다 **이동** 창의 시스템 메뉴의 메뉴 항목을 선택 합니다.  
  
-   <xref:System.Windows.Window.WindowState%2A> 속성이 변경 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 논리적 자식 요소에 대한 열거자를 가져옵니다.</summary>
        <value>창의 논리적 자식 요소에 대한 <see cref="T:System.Collections.IEnumerator" />입니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">이 창에서 자식에 사용할 수 있는 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다. 창의 크기를 사용할 수 있는 콘텐츠에 맞게 조정할 수 있음을 나타내려면 값을 무한대로 지정할 수 있습니다.</param>
        <summary>이 메서드를 재정의하여 창의 크기를 측정합니다.</summary>
        <returns>이 창에서 자식의 크기 계산을 기반으로 레이아웃 중에 필요한 것으로 확인된 크기를 반영하는 <see cref="T:System.Windows.Size" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> 경우 라고 합니다 <xref:System.Windows.UIElement.Visibility%2A> 속성의 값이 <xref:System.Windows.Visibility.Collapsed>합니다. 하는 경우의 값을 <xref:System.Windows.UIElement.Visibility%2A> 속성이 <xref:System.Windows.Visibility.Hidden> 또는 <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> 라고 합니다.  
  
> [!NOTE]
>  경우 중 하나 <xref:System.Windows.Window.Show%2A> 또는 <xref:System.Windows.Window.ShowDialog%2A> 호출 되는 <xref:System.Windows.UIElement.Visibility%2A> 의 속성을 <xref:System.Windows.Window> 로 설정 된 <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.Activated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A>는 <xref:System.Windows.Window.Activated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnActivated%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnActivated%2A> 기본 클래스의 경우 <xref:System.Windows.Window.Activated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.Closed" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A>는 <xref:System.Windows.Window.Closed> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnClosed%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnClosed%2A> 기본 클래스의 경우 <xref:System.Windows.Window.Closed> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.ComponentModel.CancelEventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.Closing" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A>는 <xref:System.Windows.Window.Closing> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnClosing%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnClosing%2A> 기본 클래스의 경우 <xref:System.Windows.Window.Closing> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">이전 콘텐츠 트리의 루트에 대한 참조입니다.</param>
        <param name="newContent">새 콘텐츠 트리의 루트에 대한 참조입니다.</param>
        <summary><see cref="P:System.Windows.Controls.ContentControl.Content" /> 속성이 변경되면 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.ContentRendered" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A>는 <xref:System.Windows.Window.ContentRendered> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnContentRendered%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnContentRendered%2A> 기본 클래스의 경우 <xref:System.Windows.Window.ContentRendered> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />에 대한 <see cref="T:System.Windows.Window" /> 개체를 만들어 반환합니다.</summary>
        <returns>이 <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" />에 대한 <see cref="T:System.Windows.Window" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>를 재정의합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.Deactivated" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A>는 <xref:System.Windows.Window.Deactivated> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnDeactivated%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnDeactivated%2A> 기본 클래스의 경우 <xref:System.Windows.Window.Deactivated> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">이전 DPI 배율 설정입니다.</param>
        <param name="newDpi">새 DPI 배율 설정입니다.</param>
        <summary>이 창이 렌더링되는 DPI가 변경될 때 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.LocationChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A>는 <xref:System.Windows.Window.LocationChanged> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnLocationChanged%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnLocationChanged%2A> 기본 클래스의 경우 <xref:System.Windows.Window.LocationChanged> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터입니다.</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> 이벤트가 발생할 때 호출됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 구현은 처리 상태를 변경 하지 않습니다 (합니다 <xref:System.Windows.RoutedEventArgs.Handled%2A> 속성)의 <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> 이벤트 데이터입니다.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>재정의 하는 경우 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, 항상 기본 구현을 호출 하면 <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> 구현 합니다. 최종 클래스의 런타임 동작을 변경할 수는 이벤트 처리에서 기본 클래스를 방지 하는 기본 구현을 호출 하지 못했습니다. 기본 구현은 앞 이나 뒤에 특수 한 처리 요구 사항에 따라 호출할 수 있습니다.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.SourceInitialized" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A>는 <xref:System.Windows.Window.SourceInitialized> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnSourceInitialized%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnSourceInitialized%2A> 기본 클래스의 경우 <xref:System.Windows.Window.SourceInitialized> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">이벤트 데이터를 포함하는 <see cref="T:System.EventArgs" />입니다.</param>
        <summary><see cref="E:System.Windows.Window.StateChanged" /> 이벤트를 발생시킵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A>는 <xref:System.Windows.Window.StateChanged> 이벤트를 발생시킵니다.  
  
 파생 되는 형식을 <xref:System.Windows.Window> 재정의할 수 있습니다 <xref:System.Windows.Window.OnStateChanged%2A>합니다. 재정의 된 메서드를 호출 해야 합니다 <xref:System.Windows.Window.OnStateChanged%2A> 기본 클래스의 경우 <xref:System.Windows.Window.StateChanged> 발생 해야 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="visualAdded">컬렉션에 추가된 <see cref="T:System.Windows.Media.Visual" />입니다.</param>
        <param name="visualRemoved">컬렉션에서 제거된 <see cref="T:System.Windows.Media.Visual" />입니다.</param>
        <summary>이 <see cref="T:System.Windows.Window" /> 개체의 <see cref="T:System.Windows.Media.VisualCollection" />이 수정될 때 호출됩니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">이전 부모입니다. <see cref="T:System.Windows.DependencyObject" />에 이전 부모가 없는 경우 null로 설정됩니다.</param>
        <summary>창의 부모가 변경될 때 호출됩니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 창이 소유자인 창의 컬렉션을 가져옵니다.</summary>
        <value>이 창이 소유자인 창에 대한 참조가 들어 있는 <see cref="T:System.Windows.WindowCollection" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소유 된 창을 하나인 인 <xref:System.Windows.Window.Owner%2A> 소유자 창 이라고 하는 다른 창에 대 한 참조를 사용 하 여 속성을 설정 합니다. 열거할 수는 소유자 창이 소유한 모든 windows를 찾으려면 <xref:System.Windows.WindowCollection> 에서 반환 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다.  
  
   
  
## Examples  
 다음 예제에서는 열거 하는 방법을 보여 줍니다 <xref:System.Windows.Window.OwnedWindows%2A>합니다.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Windows.Window" />를 소유하는<see cref="T:System.Windows.Window" />를 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Windows.Window" />의 소유자를 나타내는 <see cref="T:System.Windows.Window" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 호출 하 여 자식 창을 부모 창으로 열릴 때 <xref:System.Windows.Window.ShowDialog%2A>, 부모 및 자식 창 사이 암시적 관계가 설정 됩니다. 이 관계는 최소화, 최대화 및 복원 관련 하 여 포함 하 여 특정 동작을 적용 합니다.  
  
 그러나 호출 하 여 자식 창을 부모 창에서 만들 때 <xref:System.Windows.Window.Show%2A>, 자식 창에는 관계가 없는 부모 창 사용 하 여 합니다. 이는 다음을 의미합니다.  
  
-   자식 창의 부모 창에 대 한 참조가 없습니다.  
  
-   자식 창의 동작은 부모 창;의 동작에 종속 되지 않습니다. 창이 나 다른 처리할 수 있습니다 하거나 최소화, 최대화 및 서로 독립적으로 복원 합니다.  
  
 부모 창의 자식 창 사이의 관계를 만들 수 있도록 <xref:System.Windows.Window> 소유권의 개념을 지원 합니다. 소유권이 설정 된 경우는 <xref:System.Windows.Window.Owner%2A> 다른 창 (소유자 창)에 대 한 참조를 사용 하 여 속성 창 (소유한 창)을 설정 합니다.  
  
 이 관계 설정 되 면 다음 동작이 표시 됩니다.  
  
-   소유자 창이 최소화 되 면 모든 소유 된 창도 최소화 됩니다.  
  
-   소유 된 창을 최소화 하면 소유자 최소화 되지 않습니다.  
  
-   소유자 창 최대화 되 면 소유자 창 및 소유 된 창 복원 됩니다.  
  
-   소유자 창은 소유 된 창은 덮을 수 있습니다.  
  
-   사용 하 여 열려 있지 않은 windows 소유 <xref:System.Windows.Window.ShowDialog%2A> 는 모달 대화 상자가 있습니다. 여전히 사용자 소유자 창 상호 작용할 수 있습니다.  
  
-   소유자 창을 닫은 경우 소유 된 창도 닫힙니다.  
  
-   소유 된 창을 사용 하 여 해당 소유자 창에서 열린 경우 <xref:System.Windows.Window.Show%2A>, 소유자 및 소유한 창의 창이 닫힌 <xref:System.Windows.Window.Closing> 이벤트가 발생 하지 않습니다.  
  
 호출 하 여 자식 창을 열면 <xref:System.Windows.Window.ShowDialog%2A>를 설정 해야 합니다 <xref:System.Windows.Window.Owner%2A> 자식 창의 속성입니다. 그렇지 않으면 사용자가 작업 표시줄 단추를 눌러 자식 창 및 부모 창을 모두 복원 하는 일을 할 수 없습니다. 대신, 작업 표시줄 단추를 누르면를 생성 하 여 select, 자식 및 부모 창 등의 windows 목록 선택한 기간에만 복원 됩니다.  
  
> [!IMPORTANT]
>  설정 해야 합니다 <xref:System.Windows.Window.Owner%2A> 를 호출 하 여 열려 있는 창에 속성 <xref:System.Windows.Window.ShowDialog%2A> 올바른 동작을 보장 하려면.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 다음 예제에는 소유자 소유 관계를 설정 하는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">창이 자신을 소유하려고 하는 경우 
또는 
두 개의 창이 서로를 소유하려고 하는 경우</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.Owner" />를 사용하여 표시된 창에서 <see cref="M:System.Windows.Window.ShowDialog" /> 속성이 설정된 경우  
  
또는 
이전에 표시되지 않은 창에서 <see cref="P:System.Windows.Window.Owner" /> 속성이 설정된 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">모든 창과 사용자 입력된 이벤트를 제한 없이 사용할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>크기 조정 모드를 가져오거나 설정합니다.</summary>
        <value>크기 조정 모드를 지정하는 <see cref="T:System.Windows.ResizeMode" /> 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네 가지 옵션이 있습니다.  
  
-   **NoResize**합니다. 사용자 창의 크기를 조정할 수 없습니다. 최대화, 최소화 상자 표시 되지 않습니다.  
  
-   **CanMinimize**합니다. 만 사용자 창을 최소화 하 고 작업 표시줄에서 복원할 수 있습니다. 최소화 및 최대화 상자 모두 표시 되지만 최소화 상자만 사용 하도록 설정 합니다.  
  
-   **CanResize**합니다. 사용자가 창 주변의 최소화 및 최대화 상자 및 draggable 개요를 사용 하 여 창의 크기를 조정할 수 있습니다. 최소화 및 최대화 상자를 표시 하 고 사용 하도록 설정 됩니다. (기본값)입니다.  
  
-   **CanResizeWithGrip**. 이 옵션은 동일한 기능을 <xref:System.Windows.ResizeMode.CanResize>, 있지만 "크기 조정 그립" 창의 오른쪽 아래 모서리에 추가 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ResizeModeProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ResizeMode" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>최소화 또는 최대화하기 전의 창의 크기와 위치를 가져옵니다.</summary>
        <value>최소화 또는 최대화하기 전의 창의 크기와 위치를 지정하는 <see cref="T:System.Windows.Rect" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 복원 사각형은 최소화 또는 최대화 전에 창에서 사용 된 영역입니다. 사용할 수 있습니다 <xref:System.Windows.Window.RestoreBounds%2A> 응용 프로그램을 닫기 전에 마지막 크기 및 창 위치를 저장 및 다음 사용자를 생략 하는 방식과 창을 복원 하려면 응용 프로그램을 시작할 때 이러한 값을 검색 합니다.  
  
 쿼리하면 <xref:System.Windows.Window.RestoreBounds%2A> 창이 표시 된 전이나 이미 종료 된 후 <xref:System.Windows.Rect.Empty%2A> 반환 됩니다.  
  
> [!NOTE]
>  창이 브라우저에 호스팅되는 경우에이 속성을 가져올 수 없습니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Windows.Window.RestoreBounds%2A> 및 격리 된 저장소 크기 및 창 위치와 동일한 것은 창이 표시 되기 이전 시간을 확인 합니다.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">크기와 창 위치를 쿼리 하는 권한에 대 한 경계 사각형입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 연 후 새로 열린 창이 닫힐 때까지 기다리지 않고 반환됩니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다. <xref:System.Windows.Window.Show%2A> 창을 표시 하 고 창이 닫힐 때까지 기다리지 않고 즉시 반환 합니다. 결과적으로 열린된 창이 사용자 응용 프로그램에서 다른 windows와 상호 작용을 방지 하지는 않습니다. 이 유형의 창 호출 되는 *모덜리스* 창입니다. 모덜리스 windows의 일반적인 예에는 속성 창과 도구 상자의 색상표는 합니다. 특정 창 상호 작용 하는 사용자를 제한 하려면 창을 열어야 호출 하 여 <xref:System.Windows.Window.ShowDialog%2A>입니다.  
  
 호출 하 여 열려 있는 창을 <xref:System.Windows.Window.Show%2A> 않습니다이 열려 있는 창 사용 하 여 관계가 자동으로, 특히 열린된 창 알지 창을 연 합니다. 사용 하 여이 관계를 설정할 수 있습니다는 <xref:System.Windows.Window.Owner%2A> 속성 및 관리를 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다.  
  
 호출 <xref:System.Windows.Window.Show%2A> 설정으로 동일한 최종 결과 달성 <xref:System.Windows.UIElement.Visibility%2A> 의 속성을 <xref:System.Windows.Window> 개체를 <xref:System.Windows.Visibility.Visible>입니다. 그러나 타이밍 관점에서 둘 간의 차이가 있습니다.  
  
 호출 <xref:System.Windows.Window.Show%2A> 후에 반환 하는 동기 작업이 <xref:System.Windows.FrameworkElement.Loaded> 자식 창에 이벤트가 발생 합니다.  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 그러나 설정 <xref:System.Windows.UIElement.Visibility%2A>,는 즉시 반환 하는 비동기 작업:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 설정 하는 경우 <xref:System.Windows.UIElement.Visibility%2A>를 설정 하기 전에 등록할 창 이벤트 <xref:System.Windows.UIElement.Visibility%2A> 설정 하는 방법을 수행한 후 될 때까지 발생할 수 있습니다 <xref:System.Windows.UIElement.Visibility%2A> 실행을 완료 합니다.  
  
   
  
## Examples  
 다음 샘플에는 모덜리스 창을 여는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">닫히고 있는 창(<see cref="M:System.Windows.Window.Show" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창이 처음 표시될 때 활성화되는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창이 처음 표시될 때 활성화되면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="true" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창을 해당 <xref:System.Windows.Window.ShowActivated%2A> 속성으로 설정 `false` 는 열린 창 활성화 되지 않았습니다 고 <xref:System.Windows.Window.Activated> 선택 하 여 창을 수동으로 활성화 될 때까지 이벤트가 발생 하지 않습니다. 창을 선택한 후 활성화 및 비활성화 하 고 일반적으로 합니다.  
  
 창이 열릴 때 활성화 되 고 하지 못하도록 합니다 <xref:System.Windows.Window.ShowActivated%2A> 속성으로 설정 되어 있어야 `false` 창이 표시 되기 전에 (호출 하 여 <xref:System.Windows.Window.Show%2A>) 설정 <xref:System.Windows.Window.ShowActivated%2A> 를 `false` 후 영향을 주지 않습니다 창이 표시 됩니다.  
  
 설정 <xref:System.Windows.Window.ShowActivated%2A> 하 `false` 모달 형식으로 호출 하 여 열려 있는 창에 <xref:System.Windows.Window.ShowDialog%2A>, 실제 영향을 주지 않습니다. 모달 창 활성화 되지 것입니다, 하지만 모달 창 사용자가 다른 응용 프로그램 열기 창을 활성화할 수 없게 됩니다.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ShowActivatedProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 태그를 사용 하 여 창을 활성화 되지 않고 열 수를 구성 하는 방법을 보여 줍니다.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 다음 예제에서는 코드를 사용 하 여 활성화 되지 않고 열려는 기간을 구성 하는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ShowActivated" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>창을 연 후 새로 열린 창이 닫힌 경우에만 반환됩니다.</summary>
        <returns>작업이 받아들여졌는지(<see langword="true" /> 또는 취소되었는지(<see langword="false" />) 여부를 지정하는 <see cref="T:System.Nullable`1" /> 유형의 <see cref="T:System.Boolean" /> 값입니다. 반환 값은 창이 닫히기 전의 <see cref="P:System.Windows.Window.DialogResult" /> 속성 값입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 클래스가 인스턴스화되면, 기본적으로 표시 되지 않습니다. <xref:System.Windows.Window.ShowDialog%2A> 창을 보여 줍니다, 그리고 응용 프로그램에서 다른 모든 windows를 사용 하지 않도록 설정 하 고 창이 닫혀 있는 경우에를 반환 합니다. 이 유형의 창 이라고는 *모달* 창입니다.  
  
 모달 창은 주로 대화 상자로 사용 됩니다. 대화 상자는 특수 한 유형의 응용 프로그램 파일을 열거나 문서 인쇄와 같은 작업을 완료 하는 사용자와 상호 작용 하는 데 사용할 수 있는 창입니다. 대화 상자에는 일반적으로 적용 하거나는 표시 된 대화 상자를 닫기 전에 작업을 취소할 수가 있습니다. <xref:System.Windows.Window.ShowDialog%2A> 반환 된 <xref:System.Nullable%601> <xref:System.Boolean> 활동 수락 되었거나 취소 여부를 지정 하는 값입니다. 반환 값은 창이 닫히기 전의 <xref:System.Windows.Window.DialogResult%2A> 속성 값입니다. 자세한 내용은 <xref:System.Windows.Window.DialogResult%2A>를 참조하십시오.  
  
 호출 하 여 열려 있는 창을 <xref:System.Windows.Window.ShowDialog%2A> 메서드에 자동으로 열이 있는 창 사용 하 여 관계가 없는; 특히 열린된 창 알지 창을 연 합니다. 사용 하 여이 관계를 설정할 수 있습니다는 <xref:System.Windows.Window.Owner%2A> 속성 및 관리를 사용 하는 <xref:System.Windows.Window.OwnedWindows%2A> 속성입니다. 지원 하기 위해 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 자동화 (참조 [UI 자동화 개요](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> 호출 하 여 연 창에 대 한 설정 해야 합니다 <xref:System.Windows.Window.ShowDialog%2A>합니다.  
  
 모달 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 창 (호출로 열린 창 <xref:System.Windows.Window.ShowDialog%2A>) 닫혀 이전에 활성화 된 창이 다시 활성화 됩니다. 경우 모달 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 창에 소유자 (참조 <xref:System.Windows.Window.Owner%2A>), 소유자 창이 다시 활성화 될 때 모달 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 이전에 활성화 된 창 않은 경우 창이 닫힙니다.  
  
> [!NOTE]
>  창이 브라우저에서 호스팅될 때이 메서드를 호출할 수 없습니다.  
  
   
  
## Examples  
 다음 샘플에는 모달 창을 여는 방법을 보여 줍니다.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">닫히고 있는 창(<see cref="M:System.Windows.Window.ShowDialog" />) 또는 닫힌 창(<see cref="E:System.Windows.Window.Closing" />)에서 <see cref="E:System.Windows.Window.Closed" />가 호출된 경우</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">창을 활성화할 수 있는 권한입니다. 연결 된 열거형: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창에 작업 표시줄 단추가 있는지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창에 작업 표시줄 단추가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 창이 브라우저에서 호스팅될 때는 적용하지 마십시오.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하는 경우 <xref:System.Windows.Window.ShowInTaskbar%2A> 로 설정 된 `true`, ALT + TAB 응용 프로그램 선택 목록의 창도 나타납니다.  
  
 작업 표시줄 단추 및 ALT + TAB 응용 프로그램 선택 목록에 사용 되는 아이콘의 값인는 <xref:System.Windows.Window.Icon%2A> 속성입니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.ShowInTaskbar" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>콘텐츠 크기에 맞게 창의 크기를 자동으로 조정할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.SizeToContent" /> 값입니다. 기본값은 <see cref="F:System.Windows.SizeToContent.Manual" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.WidthAndHeight>를 설정 하거나 <xref:System.Windows.FrameworkElement.Height%2A> 또는 <xref:System.Windows.FrameworkElement.Width%2A> 영향을 주지 않습니다; 속성을 모두 설정할 수 있지만 사용 하 여 설정 값 창에 적용 되지 않습니다.  
  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.Height>설정, <xref:System.Windows.FrameworkElement.Height%2A> 창의 높이 변경 되지 않습니다.  
  
 때 <xref:System.Windows.Window.SizeToContent%2A> 로 설정 된 <xref:System.Windows.SizeToContent.Width>설정, <xref:System.Windows.FrameworkElement.Width%2A> 창의 너비를 변경 되지 않습니다.  
  
 하는 경우 <xref:System.Windows.Window.SizeToContent%2A> 이외의 값을 가지 <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> 자동으로 설정 됩니다 <xref:System.Windows.SizeToContent.Manual> 크기 조정 그립을 사용 하거나 테두리를 끌어 창의 크기를 조정 사용자 경우.  
  
-   창에 자체의 크기를 조정 하는 방식으로 콘텐츠의 크기를 변경할 경우 <xref:System.Windows.FrameworkElement.SizeChanged> 발생 합니다.  
  
 창이 투명 하 게 된 경우 (참조 <xref:System.Windows.Window.AllowsTransparency%2A>), 설정 되지 않는 것이 좋습니다 <xref:System.Windows.Window.SizeToContent%2A> 에 <xref:System.Windows.SizeToContent.WidthAndHeight> 기간은 해당 표시 콘텐츠 이하의 되도록 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.SizeToContentProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
   
  
## Examples  
 다음 예제에서는 설정 하는 방법의 <xref:System.Windows.Window.SizeToContent%2A> 콘텐츠에 맞게 창의 크기 조정 하는 방법을 지정 하는 코드에서 속성입니다.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.SizeToContent" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 이벤트는 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]와의 상호 운용성을 지원하기 위해 발생합니다. <see cref="T:System.Windows.Interop.HwndSource" />을 참조하세요.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 <see cref="P:System.Windows.Window.WindowState" /> 속성이 변경될 때 발생합니다.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Window" />에 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄 썸네일을 가져오거나 설정합니다.</summary>
        <value><see cref="T:System.Windows.Window" />의 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄 축소판 그림입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하는 방법에 대 한 자세한 내용은 합니다 [!INCLUDE[win7](~/includes/win7-md.md)] 작업 표시줄 축소판 그림을 참조 하십시오는 <xref:System.Windows.Shell.TaskbarItemInfo> 클래스.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.TaskbarItemInfo" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 제목을 가져오거나 설정합니다.</summary>
        <value>창의 제목이 들어 있는 <see cref="T:System.String" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 제목의 <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, 또는 [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]를 사용 하 여 설정할 수도 있습니다 <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>합니다.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TitleProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Title" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>바탕 화면과 관련해서 창의 맨 위 가장자리 위치를 가져오거나 설정합니다.</summary>
        <value>논리 단위(1/96인치)로 지정된 창의 맨 위 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우는 <xref:System.Windows.Window> 최대화 되거나 최소화, 복원의 위쪽 가장자리에 대 한 지점 값 나타냅니다가는 <xref:System.Windows.Window>합니다.  
  
 스타일을 통해이 속성을 설정할 수 없습니다.  
  
 값을 지정 하지 않으면 경우 <xref:System.Windows.Window.Top%2A> 시스템 기본값으로 설정 됩니다. 설정 하 여 시스템 기본값을 지정할 수도 있습니다 <xref:System.Windows.Window.Top%2A> 에 <xref:System.Double.NaN>입니다. 모두 <xref:System.Double.NegativeInfinity> 나 <xref:System.Double.PositiveInfinity> 에 대 한 유효한 값인지 <xref:System.Windows.Window.Top%2A>합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TopProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창을 맨 위 z 순서에 표시할지 여부를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창이 맨 위에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 창입니다 <xref:System.Windows.Window.Topmost%2A> 속성이 `true` 갖는 모든 창 위에 표시 <xref:System.Windows.Window.Topmost%2A> 속성으로 설정 됩니다 `false`합니다.  
  
 이 있는 windows 그룹에 있는 <xref:System.Windows.Window.Topmost%2A> 속성이 `true`, 현재 활성화 되는 최상위 창입니다. 이 있는 windows 그룹에도 마찬가지 <xref:System.Windows.Window.Topmost%2A> 속성이 `false`합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.TopmostProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Topmost" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.Top" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>처음 표시될 때 창의 위치를 가져오거나 설정합니다.</summary>
        <value>처음 표시될 때의 창의 맨 위/왼쪽 위치를 지정하는 <see cref="T:System.Windows.WindowStartupLocation" /> 값입니다. 기본값은 <see cref="F:System.Windows.WindowStartupLocation.Manual" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 설정 합니다 `WindowStartupLocation` 속성을 <xref:System.Windows.WindowStartupLocation.Manual> 에 따라 배치 하는 창을 사용 하면 해당 <xref:System.Windows.Window.Left%2A> 및 <xref:System.Windows.Window.Top%2A> 속성 값입니다. 경우는 <xref:System.Windows.Window.Left%2A> 또는 <xref:System.Windows.Window.Top%2A> 속성을 지정 하지, 해당 값은 Windows에서 결정 됩니다.  
  
 설정 된 `WindowStartupLocation` 속성을 <xref:System.Windows.WindowStartupLocation.CenterScreen> 가 설정 된 창은 마우스 커서를 포함 하는 화면 가운데에 위치 하 게 합니다.  
  
 설정 된 `WindowStartupLocation` 속성을 <xref:System.Windows.WindowStartupLocation.CenterOwner> 해당 소유자 창의 가운데에 위치 하 게 창 (참조 <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>), 지정 된 경우. 소유자 창에는 다른 WPF 창 또는 비 WPF 창 수 있습니다.

> [!NOTE]   
>  비 WPF windows 사용 하 여 WPF windows에 대 한 자세한 내용은 참조 하세요. [WPF 및 Win32 상호 운용성](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) 고 <xref:System.Windows.Interop.WindowInteropHelper>입니다. 

 창의 위치가 동일한 방식으로 결정 됩니다 소유자 창 지정 하지 않으면 처럼를 `WindowStartupLocation` 속성이 <xref:System.Windows.WindowStartupLocation.Manual>합니다.

> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성의 값을 가져올 수 없습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창을 복원, 최소화 또는 최대화할지 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>창을 복원, 최소화 또는 최대화할지 결정하는 <see cref="T:System.Windows.WindowState" />입니다. 기본값은 <see cref="F:System.Windows.WindowState.Normal" />(복원됨)입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 크기와 위치에 저장 됩니다 창을 최소화 또는 최대화 전에 <xref:System.Windows.Window.RestoreBounds%2A>입니다. 창을 복원, 이후에 해당 크기와 위치 값의 값으로 복원 됩니다 <xref:System.Windows.Window.RestoreBounds%2A>합니다.  
  
 경우는 <xref:System.Windows.Window.WindowState%2A> 속성이 변경 되 면 <xref:System.Windows.Window.StateChanged> 발생 합니다.  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.WindowStateProperty>|  
|메타 데이터 속성 설정 `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.WindowState" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>창의 테두리 스타일을 가져오거나 설정합니다.</summary>
        <value>창의 테두리 스타일을 지정하는 <see cref="T:System.Windows.WindowStyle" />입니다. 기본값은 <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> 중 하나일 수 있습니다 합니다 <xref:System.Windows.WindowStyle> 열거형 값을 포함 하 여 <xref:System.Windows.WindowStyle.None>를 <xref:System.Windows.WindowStyle.ToolWindow>를 <xref:System.Windows.WindowStyle.SingleBorderWindow> (기본값) 및 <xref:System.Windows.WindowStyle.ThreeDBorderWindow>합니다.  
  
 다음 그림에서는 창 스타일에 [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (사용 하도록 설정 하는 투명 효과 사용 하 여 Windows Vista Aero 테마):  
  
 ![창 스타일](~/add/media/windowoverviewfigure6.PNG "창 스타일")  
  
> [!NOTE]
>  설정 하거나 창을 브라우저에 호스팅되는 경우이 속성을 가져올 수 없습니다.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>종속성 속성 정보  
  
|||  
|-|-|  
|식별자 필드|<xref:System.Windows.Window.WindowStyleProperty>|  
|메타 데이터 속성 설정 `true`|없음|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Window.WindowStyle" /> 종속성 속성을 식별합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>