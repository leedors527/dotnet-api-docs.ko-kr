<Type Name="Extensions" FullName="System.Xml.Linq.Extensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4604dada4a431c37edce3f5da499518e280f312b" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53222202" /></Metadata><TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>LINQ to XML 확장명 메서드를 포함합니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 대부분의 합니다 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 확장 메서드는에서 사용 되는 축 메서드 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 쿼리 합니다. 이 클래스의 메서드는 컬렉션에 대해 작동 하 고 컬렉션을 반환 합니다. 이러한 메서드는 소스 컬렉션을 열거, 컬렉션의 각 항목에 적절 한 축 메서드를 호출 및 결과 연결 합니다.  
  
 하지만 두 <xref:System.Xml.Linq.Extensions.Remove%2A> 확장 메서드는 축 메서드가 아닙니다. 이러한 메서드는 XML 트리에서 노드 또는 특성을 제거합니다.  
  
 축 메서드를 구현 하는 다른 범주는 합니다 <xref:System.Xml.Linq.XElement>, <xref:System.Xml.Linq.XDocument>, 및 <xref:System.Xml.Linq.XNode> 클래스입니다. 이러한 다른 축 메서드는 단일 개체에 대해 작동 하 고 컬렉션을 반환 <xref:System.Xml.Linq.XElement>하십시오 <xref:System.Xml.Linq.XAttribute>, 또는 <xref:System.Xml.Linq.XNode> 개체입니다.  
  
 모든 축 확장 메서드는 지연 된 실행을 사용합니다.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
    <related type="Article" href="https://msdn.microsoft.com/library/86ff2c9f-2ea1-43fc-bea3-6a9cc85f41ef">LINQ to XML 축</related>
    <related type="Article" href="https://msdn.microsoft.com/library/7c9b5ad2-dffc-47c4-a76f-a39815ecc7ec">XML 트리에서 요소, 특성 및 노드 제거</related>
    <related type="Article" href="https://msdn.microsoft.com/library/175ce3ff-9bbf-4e64-8421-faeb81a0bb51">확장명 메서드(C# 프로그래밍 가이드)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Ancestors&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션에 있는 모든 노드의 상위 항목이 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션의 여러 노드에서 동일한 상위에 있는 경우 상위 결과 컬렉션에 여러 번 포함 됩니다. 이 문제를 방지 하려면 사용 된 <xref:System.Linq.Enumerable.Distinct%2A> 메서드.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XNode;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors&lt;(class System.Xml.Linq.XNode) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Ancestors(Of T As XNode) (source As IEnumerable(Of T)) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XNode[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Ancestors : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XNode)&gt; -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XNode)" Usage="System.Xml.Linq.Extensions.Ancestors source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XNode" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 노드의 상위 항목이 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 노드의 상위 항목이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션의 여러 노드에서 동일한 상위에 있는 경우 상위 결과 컬렉션에 여러 번 포함 됩니다. 이 문제를 방지 하려면 사용 된 <xref:System.Linq.Enumerable.Distinct%2A> 메서드.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 유용한 손자 요소 컬렉션을 검색 합니다. 그런 다음이 축 메서드를 사용 하 여 컬렉션에 있는 모든 요소의 모든 상위 항목을 검색 합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1",  
            new XElement("GreatGrandChild1", "content")  
        )  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild2",  
            new XElement("GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.Ancestors().Distinct()  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>  
            <GrandChild1>  
                <GreatGrandChild1>content</GreatGrandChild1>  
            </GrandChild1>  
        </Child1>  
        <Child2>  
            <GrandChild2>  
                <GreatGrandChild2>content</GreatGrandChild2>  
            </GrandChild2>  
        </Child2>  
    </Root>  
  
Dim greatGrandChildren = From el In xmlTree.Descendants _  
                         Where el.Name.LocalName.StartsWith("Great") _  
                         Select el  
  
Console.WriteLine("Great Grand Children Elements")  
Console.WriteLine("----")  
  
For Each de As XElement In greatGrandChildren  
    Console.WriteLine(de.Name)  
Next  
  
Dim allAncestors = From el In greatGrandChildren.Ancestors.Distinct _  
                   Select el  
  
Console.WriteLine("")  
Console.WriteLine("Ancestors")  
Console.WriteLine("----")  
  
For Each de As XElement In allAncestors  
    Console.WriteLine(de.Name)  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
GreatGrandChild1  
GreatGrandChild2  
  
Ancestors  
----  
GrandChild1  
Child1  
Root  
GrandChild2  
Child2  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Child1",  
        new XElement(aw + "GrandChild1",  
            new XElement(aw + "GreatGrandChild1", "content")  
        )  
    ),  
    new XElement(aw + "Child2",  
        new XElement(aw + "GrandChild2",  
            new XElement(aw + "GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.Ancestors().Distinct()  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Child1>  
                    <GrandChild1>  
                        <GreatGrandChild1>content</GreatGrandChild1>  
                    </GrandChild1>  
                </Child1>  
                <Child2>  
                    <GrandChild2>  
                        <GreatGrandChild2>content</GreatGrandChild2>  
                    </GrandChild2>  
                </Child2>  
            </Root>  
  
        Dim greatGrandChildren = From el In xmlTree.Descendants _  
                                 Where el.Name.LocalName.StartsWith("Great") _  
                                 Select el  
  
        Console.WriteLine("Great Grand Children Elements")  
        Console.WriteLine("----")  
  
        For Each de As XElement In greatGrandChildren  
            Console.WriteLine(de.Name)  
        Next  
  
        Dim allAncestors = From el In greatGrandChildren.Ancestors.Distinct _  
                           Select el  
  
        Console.WriteLine("")  
        Console.WriteLine("Ancestors")  
        Console.WriteLine("----")  
  
        For Each de As XElement In allAncestors  
            Console.WriteLine(de.Name)  
        Next  
    End Sub  
End Module  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
{http://www.adventure-works.com}GreatGrandChild1  
{http://www.adventure-works.com}GreatGrandChild2  
  
Ancestors  
----  
{http://www.adventure-works.com}GrandChild1  
{http://www.adventure-works.com}Child1  
{http://www.adventure-works.com}Root  
{http://www.adventure-works.com}GrandChild2  
{http://www.adventure-works.com}Child2  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Ancestors&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source, System.Xml.Linq.XName name) where T : System.Xml.Linq.XNode;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors&lt;(class System.Xml.Linq.XNode) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Ancestors(Of T As XNode) (source As IEnumerable(Of T), name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XNode[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member Ancestors : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XNode)&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XNode)" Usage="System.Xml.Linq.Extensions.Ancestors (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XNode" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 노드의 상위 항목이 들어 있는 필터링된 요소 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션에 있는 모든 노드의 상위 항목이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션에 있는 여러 노드의 상위 항목이 같은 일치 하는 경우 <xref:System.Xml.Linq.XName>, 상위 결과 컬렉션에 여러 번 포함 될 됩니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 유용한 손자 요소 컬렉션을 검색 합니다. 그런 다음 모든 상위 항목 컬렉션의 지정 된 일치 하는 모든 요소를 검색 하려면이 축 메서드를 사용 <xref:System.Xml.Linq.XName>합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1",  
            new XElement("GreatGrandChild1", "content")  
        )  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild2",  
            new XElement("GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.Ancestors("Child1")  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>  
            <GrandChild1>  
                <GreatGrandChild1>content</GreatGrandChild1>  
            </GrandChild1>  
        </Child1>  
        <Child2>  
            <GrandChild2>  
                <GreatGrandChild2>content</GreatGrandChild2>  
            </GrandChild2>  
        </Child2>  
    </Root>  
  
Dim greatGrandChildren = From el In xmlTree.Descendants _  
                         Where el.Name.LocalName.StartsWith("Great") _  
                         Select el  
  
Console.WriteLine("Great Grand Children Elements")  
Console.WriteLine("----")  
  
For Each de As XElement In greatGrandChildren  
    Console.WriteLine(de.Name)  
Next  
  
Dim allAncestors = From el In greatGrandChildren.Ancestors("Child1") _  
                   Select el  
  
Console.WriteLine("")  
Console.WriteLine("Ancestors")  
Console.WriteLine("----")  
  
For Each de As XElement In allAncestors  
    Console.WriteLine(de.Name)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
GreatGrandChild1  
GreatGrandChild2  
  
Ancestors  
----  
Child1  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Child1",  
        new XElement(aw + "GrandChild1",  
            new XElement(aw + "GreatGrandChild1", "content")  
        )  
    ),  
    new XElement(aw + "Child2",  
        new XElement(aw + "GrandChild2",  
            new XElement(aw + "GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.Ancestors(aw + "Child1")  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Child1>  
                    <GrandChild1>  
                        <GreatGrandChild1>content</GreatGrandChild1>  
                    </GrandChild1>  
                </Child1>  
                <Child2>  
                    <GrandChild2>  
                        <GreatGrandChild2>content</GreatGrandChild2>  
                    </GrandChild2>  
                </Child2>  
            </Root>  
  
        Dim greatGrandChildren = From el In xmlTree.Descendants _  
                                 Where el.Name.LocalName.StartsWith("Great") _  
                                 Select el  
  
        Console.WriteLine("Great Grand Children Elements")  
        Console.WriteLine("----")  
  
        For Each de As XElement In greatGrandChildren  
            Console.WriteLine(de.Name)  
        Next  
  
        Dim allAncestors = From el In greatGrandChildren.Ancestors(GetXmlNamespace() + "Child1") _  
                           Select el  
  
        Console.WriteLine("")  
        Console.WriteLine("Ancestors")  
        Console.WriteLine("----")  
  
        For Each de As XElement In allAncestors  
            Console.WriteLine(de.Name)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
{http://www.adventure-works.com}GreatGrandChild1  
{http://www.adventure-works.com}GreatGrandChild2  
  
Ancestors  
----  
{http://www.adventure-works.com}Child1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AncestorsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 상위 항목이 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션의 여러 노드에서 동일한 상위에 있는 경우 상위 결과 컬렉션에 여러 번 포함 됩니다. 이 문제를 방지 하려면 사용 된 <xref:System.Linq.Enumerable.Distinct%2A> 메서드.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Ancestors" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.AncestorsAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AncestorsAndSelf (source As IEnumerable(Of XElement)) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ AncestorsAndSelf(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AncestorsAndSelf : seq&lt;System.Xml.Linq.XElement&gt; -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.Extensions.AncestorsAndSelf source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 상위 항목이 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 상위 항목이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션의 여러 노드에서 동일한 상위에 있는 경우 상위 결과 컬렉션에 여러 번 포함 됩니다. 이 문제를 방지 하려면 사용 된 <xref:System.Linq.Enumerable.Distinct%2A> 메서드.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 유용한 손자 요소 컬렉션을 검색 합니다. 그런 다음이 축 메서드를 사용 하 여 모든 상위 항목 및 자체는 컬렉션의 모든 요소를 검색 합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1",  
            new XElement("GreatGrandChild1", "content")  
        )  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild2",  
            new XElement("GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.AncestorsAndSelf().Distinct()  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors and Self");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
    <Root>  
        <Child1>  
            <GrandChild1>  
                <GreatGrandChild1>content</GreatGrandChild1>  
            </GrandChild1>  
        </Child1>  
        <Child2>  
            <GrandChild2>  
                <GreatGrandChild2>content</GreatGrandChild2>  
            </GrandChild2>  
        </Child2>  
    </Root>  
  
Dim greatGrandChildren = From el In xmlTree.Descendants _  
                         Where el.Name.LocalName.StartsWith("Great") _  
                         Select el  
  
Console.WriteLine("Great Grand Children Elements")  
Console.WriteLine("----")  
  
For Each de As XElement In greatGrandChildren  
    Console.WriteLine(de.Name)  
Next  
  
Dim allAncestors = From el In greatGrandChildren.AncestorsAndSelf.Distinct _  
                   Select el  
  
Console.WriteLine("")  
Console.WriteLine("Ancestors and Self")  
Console.WriteLine("----")  
  
For Each de As XElement In allAncestors  
    Console.WriteLine(de.Name)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
GreatGrandChild1  
GreatGrandChild2  
  
Ancestors and Self  
----  
GreatGrandChild1  
GrandChild1  
Child1  
Root  
GreatGrandChild2  
GrandChild2  
Child2  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Child1",  
        new XElement(aw + "GrandChild1",  
            new XElement(aw + "GreatGrandChild1", "content")  
        )  
    ),  
    new XElement(aw + "Child2",  
        new XElement(aw + "GrandChild2",  
            new XElement(aw + "GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.AncestorsAndSelf().Distinct()  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors and Self");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Child1>  
                    <GrandChild1>  
                        <GreatGrandChild1>content</GreatGrandChild1>  
                    </GrandChild1>  
                </Child1>  
                <Child2>  
                    <GrandChild2>  
                        <GreatGrandChild2>content</GreatGrandChild2>  
                    </GrandChild2>  
                </Child2>  
            </Root>  
  
        Dim greatGrandChildren = From el In xmlTree.Descendants _  
                                 Where el.Name.LocalName.StartsWith("Great") _  
                                 Select el  
  
        Console.WriteLine("Great Grand Children Elements")  
        Console.WriteLine("----")  
  
        For Each de As XElement In greatGrandChildren  
            Console.WriteLine(de.Name)  
        Next  
  
        Dim allAncestors = From el In greatGrandChildren.AncestorsAndSelf.Distinct _  
                           Select el  
  
        Console.WriteLine("")  
        Console.WriteLine("Ancestors and Self")  
        Console.WriteLine("----")  
  
        For Each de As XElement In allAncestors  
            Console.WriteLine(de.Name)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
{http://www.adventure-works.com}GreatGrandChild1  
{http://www.adventure-works.com}GreatGrandChild2  
  
Ancestors and Self  
----  
{http://www.adventure-works.com}GreatGrandChild1  
{http://www.adventure-works.com}GrandChild1  
{http://www.adventure-works.com}Child1  
{http://www.adventure-works.com}Root  
{http://www.adventure-works.com}GreatGrandChild2  
{http://www.adventure-works.com}GrandChild2  
{http://www.adventure-works.com}Child2  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Ancestors" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="AncestorsAndSelf">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; AncestorsAndSelf (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source, System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; AncestorsAndSelf(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.AncestorsAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AncestorsAndSelf (source As IEnumerable(Of XElement), name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ AncestorsAndSelf(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member AncestorsAndSelf : seq&lt;System.Xml.Linq.XElement&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.Extensions.AncestorsAndSelf (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 상위 항목이 들어 있는 필터링된 요소 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 상위 항목이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 컬렉션에 있는 여러 노드의 상위 항목이 같은 일치 하는 경우 <xref:System.Xml.Linq.XName>, 상위 결과 컬렉션에 여러 번 포함 될 됩니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 유용한 손자 요소 컬렉션을 검색 합니다. 그런 다음 모든 자체를 검색 하려면이 축 메서드를 사용 하 고 지정 된 일치 하는 컬렉션의 모든 요소 <xref:System.Xml.Linq.XName>합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1",  
            new XElement("GreatGrandChild1", "content")  
        )  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild2",  
            new XElement("GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.AncestorsAndSelf("GreatGrandChild1")  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors and Self");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>  
            <GrandChild1>  
                <GreatGrandChild1>content</GreatGrandChild1>  
            </GrandChild1>  
        </Child1>  
        <Child2>  
            <GrandChild2>  
                <GreatGrandChild2>content</GreatGrandChild2>  
            </GrandChild2>  
        </Child2>  
    </Root>  
  
Dim greatGrandChildren = From el In xmlTree.Descendants _  
                         Where el.Name.LocalName.StartsWith("Great") _  
                         Select el  
  
Console.WriteLine("Great Grand Children Elements")  
Console.WriteLine("----")  
  
For Each de As XElement In greatGrandChildren  
    Console.WriteLine(de.Name)  
Next  
  
Dim allAncestors = From el In greatGrandChildren.AncestorsAndSelf("GreatGrandChild1") _  
                   Select el  
  
Console.WriteLine("")  
Console.WriteLine("Ancestors and Self")  
Console.WriteLine("----")  
  
For Each de As XElement In allAncestors  
    Console.WriteLine(de.Name)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
GreatGrandChild1  
GreatGrandChild2  
  
Ancestors and Self  
----  
GreatGrandChild1  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Child1",  
        new XElement(aw + "GrandChild1",  
            new XElement(aw + "GreatGrandChild1", "content")  
        )  
    ),  
    new XElement(aw + "Child2",  
        new XElement(aw + "GrandChild2",  
            new XElement(aw + "GreatGrandChild2", "content")  
        )  
    )  
);  
IEnumerable<XElement> greatGrandChildren =  
    from el in xmlTree.Descendants()  
    where el.Name.LocalName.StartsWith("Great")  
    select el;  
  
Console.WriteLine("Great Grand Children Elements");  
Console.WriteLine("----");  
foreach (XElement de in greatGrandChildren)  
    Console.WriteLine(de.Name);  
  
IEnumerable<XElement> allAncestors =  
    from el in greatGrandChildren.AncestorsAndSelf(aw + "GreatGrandChild1")  
    select el;  
  
Console.WriteLine("");  
Console.WriteLine("Ancestors and Self");  
Console.WriteLine("----");  
foreach (XElement de in allAncestors)  
    Console.WriteLine(de.Name);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Child1>  
                    <GrandChild1>  
                        <GreatGrandChild1>content</GreatGrandChild1>  
                    </GrandChild1>  
                </Child1>  
                <Child2>  
                    <GrandChild2>  
                        <GreatGrandChild2>content</GreatGrandChild2>  
                    </GrandChild2>  
                </Child2>  
            </Root>  
  
        Dim greatGrandChildren = From el In xmlTree.Descendants _  
                                 Where el.Name.LocalName.StartsWith("Great") _  
                                 Select el  
  
        Console.WriteLine("Great Grand Children Elements")  
        Console.WriteLine("----")  
  
        For Each de As XElement In greatGrandChildren  
            Console.WriteLine(de.Name)  
        Next  
  
        Dim allAncestors = From el In greatGrandChildren.AncestorsAndSelf(GetXmlNamespace() + "GreatGrandChild1") _  
                           Select el  
  
        Console.WriteLine("")  
        Console.WriteLine("Ancestors and Self")  
        Console.WriteLine("----")  
  
        For Each de As XElement In allAncestors  
            Console.WriteLine(de.Name)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Great Grand Children Elements  
----  
{http://www.adventure-works.com}GreatGrandChild1  
{http://www.adventure-works.com}GreatGrandChild2  
  
Ancestors and Self  
----  
{http://www.adventure-works.com}GreatGrandChild1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XNode.Ancestors" />
        <altmember cref="M:System.Xml.Linq.XElement.AncestorsAndSelf" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Ancestors" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attributes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션에 있는 모든 요소의 특성 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic 사용자 통합된 특성 축을 사용 하 여 요소 컬렉션에서 특정 이름 가진 특성을 검색할 수 있습니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.Attributes" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Elements" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Attributes(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Attributes (source As IEnumerable(Of XElement)) As IEnumerable(Of XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ Attributes(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Attributes : seq&lt;System.Xml.Linq.XElement&gt; -&gt; seq&lt;System.Xml.Linq.XAttribute&gt;" Usage="System.Xml.Linq.Extensions.Attributes source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소의 특성 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소의 특성이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 다른 XML 달리 프로그래밍 인터페이스에 확인 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], 네임 스페이스 특성으로 표시 됩니다.  
  
 Visual Basic 사용자를 사용할 수 있지만 통합된 특성 축 요소 컬렉션에서 지정한 이름 가진 특성을 검색할 수 없는 통합된 Visual Basic 축 컬렉션에 있는 모든 요소의 모든 특성을 검색할 수 있습니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 요소의 컬렉션을 검색 한 다음 컬렉션에 있는 모든 요소의 모든 특성의 컬렉션을 검색 합니다. 결과 컬렉션의 특성에만 포함 됩니다는 `Child1` 하 고 `Child2` 요소 및 특성이 아닌는 `Root` 요소입니다.  
  
 네임 스페이스 특성은이 메서드에서 반환 되는 참고 합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2"),  
    new XElement("Child1",  
        new XAttribute("Att1", "content3"),  
        new XAttribute("Att2", "content4")  
    ),  
    new XElement("Child2",  
        new XAttribute("Att1", "content5"),  
        new XAttribute("Att2", "content6")  
    )  
);  
Console.WriteLine(xmlTree);  
Console.WriteLine("-----");  
  
IEnumerable<XAttribute> attList =  
    from att in xmlTree.DescendantsAndSelf().Attributes()  
    select att;  
  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root xmlns:aw="http://www.adventure-works.com" Att1="content1" Att2="content2">  
        <Child1 Att1="content3" Att2="content4"/>  
        <Child2 Att1="content5" Att2="content6"/>  
    </Root>  
  
Dim attList = _  
    From att In xmlTree.DescendantsAndSelf.Attributes _  
    Select att  
  
Console.WriteLine(xmlTree)  
Console.WriteLine("-----")  
  
For Each att As XAttribute In attList  
    Console.WriteLine(att)  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<Root xmlns:aw="http://www.adventure-works.com" Att1="content1" Att2="content2">  
  <Child1 Att1="content3" Att2="content4" />  
  <Child2 Att1="content5" Att2="content6" />  
</Root>  
-----  
xmlns:aw="http://www.adventure-works.com"  
Att1="content1"  
Att2="content2"  
Att1="content3"  
Att2="content4"  
Att1="content5"  
Att2="content6"  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다. 네임 스페이스 특성이 반환 되는 컬렉션에 포함 되어 있는지를 참고 합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att1", "content1"),  
    new XAttribute(aw + "Att2", "content2"),  
    new XElement(aw + "Child1",  
        new XAttribute(aw + "Att1", "content3"),  
        new XAttribute(aw + "Att2", "content4")  
    ),  
    new XElement(aw + "Child2",  
        new XAttribute(aw + "Att1", "content5"),  
        new XAttribute(aw + "Att2", "content6")  
    )  
);  
Console.WriteLine(xmlTree);  
Console.WriteLine("-----");  
  
IEnumerable<XAttribute> attList =  
    from att in xmlTree.DescendantsAndSelf().Attributes()  
    select att;  
  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <aw:Root xmlns:aw="http://www.adventure-works.com" aw:Att1="content1" aw:Att2="content2">  
                <aw:Child1 aw:Att1="content3" aw:Att2="content4"/>  
                <aw:Child2 aw:Att1="content5" aw:Att2="content6"/>  
            </aw:Root>  
  
        Dim attList = _  
            From att In xmlTree.DescendantsAndSelf.Attributes _  
            Select att  
  
        Console.WriteLine(xmlTree)  
        Console.WriteLine("-----")  
  
        For Each att As XAttribute In attList  
            Console.WriteLine(att)  
        Next  
    End Sub  
End Module  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aw:Root xmlns:aw="http://www.adventure-works.com" aw:Att1="content1" aw:Att2="content2">  
  <aw:Child1 aw:Att1="content3" aw:Att2="content4" />  
  <aw:Child2 aw:Att1="content5" aw:Att2="content6" />  
</aw:Root>  
-----  
xmlns:aw="http://www.adventure-works.com"  
aw:Att1="content1"  
aw:Att2="content2"  
aw:Att1="content3"  
aw:Att2="content4"  
aw:Att1="content5"  
aw:Att2="content6"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.Attributes" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Elements" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; Attributes (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source, System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; Attributes(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Attributes(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Attributes (source As IEnumerable(Of XElement), name As XName) As IEnumerable(Of XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ Attributes(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member Attributes : seq&lt;System.Xml.Linq.XElement&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XAttribute&gt;" Usage="System.Xml.Linq.Extensions.Attributes (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소의 필터링된 특성 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소의 필터링된 특성 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XAttribute" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 일부 다른 XML 달리 프로그래밍 인터페이스에 확인 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], 네임 스페이스 특성으로 표시 됩니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 경우에 요소의 컬렉션을 검색 합니다 `Child1` 고 `Child2` 요소입니다. 그런 다음 해당 자식 컬렉션의 모든 특성의 이름으로 검색 `Att1`합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2"),  
    new XElement("Child1",  
        new XAttribute("Att1", "content3"),  
        new XAttribute("Att2", "content4")  
    ),  
    new XElement("Child2",  
        new XAttribute("Att1", "content5"),  
        new XAttribute("Att2", "content6")  
    )  
);  
  
IEnumerable<XAttribute> attList = from att in xmlTree.Elements().Attributes("Att1")  
                                  select att;  
  
foreach (XAttribute att in attList)  
    Console.WriteLine(att);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root Att1="content1" Att2="content2">  
        <Child1 Att1="content3" Att2="content4">  
        </Child1>  
        <Child2 Att1="content5" Att2="content6">  
        </Child2>  
    </Root>  
  
Dim attList = From att In xmlTree.Elements.Attributes("Att1") _  
                          Select att  
  
For Each att As XAttribute In attList  
    Console.WriteLine(att)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Att1="content3"  
Att1="content5"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.Attributes" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Elements" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodes&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodes&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DescendantNodes(Of T As XContainer) (source As IEnumerable(Of T)) As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ DescendantNodes(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DescendantNodes : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; -&gt; seq&lt;System.Xml.Linq.XNode&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.DescendantNodes source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XContainer" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 문서 및 요소의 하위 노드 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 문서 및 요소의 하위 노드에 대한 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 축을 확장 메서드를 사용할 경우 <xref:System.Xml.Linq.XDocument> 고 <xref:System.Xml.Linq.XElement> 개체입니다. 이러한 형식에서 파생 <xref:System.Xml.Linq.XContainer>이므로이 메서드가 작동을 <xref:System.Collections.Generic.IEnumerable%601> 의 <xref:System.Xml.Linq.XContainer> 소스 컬렉션을 포함 하는 합니다.  
  
 Visual Basic XML 하위 요소에 대 한 통합된 축에는 있지만 하위 노드에 대 한 통합된 축 없음 하므로 Visual Basic 사용자는 명시적으로이 축 메서드를 사용 해야 합니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 요소의 컬렉션을 검색 한 다음 소스 컬렉션에 있는 모든 요소에 대 한 모든 하위 노드의 컬렉션을 검색 합니다. 특성을 `GrandChild` 노드로 요소를 노출 하지 않습니다.  
  
```csharp  
XElement xmlTree = XElement.Parse(  
@"<Root>  
    <Child>aaa<GrandChild anAttribute='xyz'>Text</GrandChild>  
        <!--a comment-->  
        <?xml-stylesheet type='text/xsl' href='test.xsl'?>  
    </Child>  
    <Child>ccc<GrandChild>Text</GrandChild>ddd</Child>  
</Root>");  
IEnumerable<XNode> nodes =  
    from node in xmlTree.Elements("Child").DescendantNodes()  
    select node;  
  
foreach (XNode node in nodes)  
{  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Element:  
            Console.WriteLine("Element: {0}", ((XElement)node).Name);  
            break;  
        case XmlNodeType.Text:  
            Console.WriteLine("Text: {0}", ((XText)node).Value);  
            break;  
        case XmlNodeType.Comment:  
            Console.WriteLine("Comment: {0}", ((XComment)node).Value);  
            break;  
        case XmlNodeType.ProcessingInstruction:  
            Console.WriteLine("PI: {0}", ((XProcessingInstruction)node).Data);  
            break;  
    }  
}  
```  
  
```vb  
Dim xmlTree As XElement = _  
<Root>  
    <Child>aaa<GrandChild anAttribute='xyz'>Text</GrandChild>  
        <!--a comment-->  
        <?xml-stylesheet type='text/xsl' href='test.xsl'?>  
    </Child>  
    <Child>ccc<GrandChild>Text</GrandChild>ddd</Child>  
</Root>  
  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In xmlTree.<Child>.DescendantNodes _  
    Select node  
  
For Each node As XNode In nodes  
    Select Case node.NodeType  
        Case XmlNodeType.Element  
            Console.WriteLine("Element: {0}", DirectCast(node, XElement).Name)  
        Case XmlNodeType.Text  
            Console.WriteLine("Text: {0}", DirectCast(node, XText).Value)  
        Case XmlNodeType.Comment  
            Console.WriteLine("Comment: {0}", DirectCast(node, XComment).Value)  
        Case XmlNodeType.ProcessingInstruction  
            Console.WriteLine("PI: {0}", DirectCast(node, XProcessingInstruction).Data)  
    End Select  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Text: aaa  
Element: GrandChild  
Text: Text  
Comment: a comment  
PI: type='text/xsl' href='test.xsl'  
Text: ccc  
Element: GrandChild  
Text: Text  
Text: ddd  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = XElement.Parse(  
@"<Root xmlns='http://www.adventure-works.com'>  
    <Child>aaa<GrandChild anAttribute='xyz'>Text</GrandChild>  
        <!--a comment-->  
        <?xml-stylesheet type='text/xsl' href='test.xsl'?>  
    </Child>  
    <Child>ccc<GrandChild>Text</GrandChild>ddd</Child>  
</Root>");  
IEnumerable<XNode> nodes =  
    from node in xmlTree.Elements(aw + "Child").DescendantNodes()  
    select node;  
  
foreach (XNode node in nodes)  
{  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Element:  
            Console.WriteLine("Element: {0}", ((XElement)node).Name);  
            break;  
        case XmlNodeType.Text:  
            Console.WriteLine("Text: {0}", ((XText)node).Value);  
            break;  
        case XmlNodeType.Comment:  
            Console.WriteLine("Comment: {0}", ((XComment)node).Value);  
            break;  
        case XmlNodeType.ProcessingInstruction:  
            Console.WriteLine("PI: {0}", ((XProcessingInstruction)node).Data);  
            break;  
    }  
}  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
        <Root>  
            <Child>aaa<GrandChild anAttribute='xyz'>Text</GrandChild>  
                <!--a comment-->  
                <?xml-stylesheet type='text/xsl' href='test.xsl'?>  
            </Child>  
            <Child>ccc<GrandChild>Text</GrandChild>ddd</Child>  
        </Root>  
  
        Dim nodes As IEnumerable(Of XNode) = _  
            From node In xmlTree.<Child>.DescendantNodes _  
            Select node  
  
        For Each node As XNode In nodes  
            Select Case node.NodeType  
                Case XmlNodeType.Element  
                    Console.WriteLine("Element: {0}", DirectCast(node, XElement).Name)  
                Case XmlNodeType.Text  
                    Console.WriteLine("Text: {0}", DirectCast(node, XText).Value)  
                Case XmlNodeType.Comment  
                    Console.WriteLine("Comment: {0}", DirectCast(node, XComment).Value)  
                Case XmlNodeType.ProcessingInstruction  
                    Console.WriteLine("PI: {0}", DirectCast(node, XProcessingInstruction).Data)  
            End Select  
        Next  
    End Sub  
End Module  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Text: aaa  
Element: {http://www.adventure-works.com}GrandChild  
Text: Text  
Comment: a comment  
PI: type='text/xsl' href='test.xsl'  
Text: ccc  
Element: {http://www.adventure-works.com}GrandChild  
Text: Text  
Text: ddd  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodesAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement})" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodesAndSelf">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodesAndSelf (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodesAndSelf(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.DescendantNodesAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DescendantNodesAndSelf (source As IEnumerable(Of XElement)) As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ DescendantNodesAndSelf(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DescendantNodesAndSelf : seq&lt;System.Xml.Linq.XElement&gt; -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="System.Xml.Linq.Extensions.DescendantNodesAndSelf source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 노드가 들어 있는 노드 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 노드가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic XML 하위 요소에 대 한 통합된 축에는 있지만 하위 노드에 대 한 통합된 축 없음 하므로 Visual Basic 사용자는 명시적으로이 축 메서드를 사용 해야 합니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Descendants&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 하위 요소가 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic 사용자 통합된 XML descendant 축을 사용 하 여 하위 요소의 컬렉션을 검색할 수 있습니다. 그러나 통합된 축 지정된 된 이름 가진 하위만 검색합니다. Visual Basic 사용자를 모든 하위 항목을 검색 하려면 다음 사용 해야이 축 메서드를 명시적으로.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Descendants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Descendants(Of T As XContainer) (source As IEnumerable(Of T)) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Descendants : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.Descendants source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XContainer" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 하위 요소가 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소 및 문서의 하위 요소가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic 사용자 통합된 XML descendant 축을 사용 하 여 하위 요소의 컬렉션을 검색할 수 있습니다. 그러나 통합된 축 지정된 된 이름 가진 하위만 검색합니다. Visual Basic 사용자를 모든 하위 항목을 검색 하려면 다음 사용 해야이 축 메서드를 명시적으로.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 요소의 컬렉션을 검색 한 다음이 축 메서드를 사용 하 여 요소 컬렉션에 있는 모든 항목의 모든 하위 요소를 검색 합니다.  
  
```csharp  
XElement xmlTree = XElement.Parse(  
@"<Root>  
    <Para>  
        <t>This is some text </t>  
        <b>  
            <t>where</t>  
        </b>  
        <t> all of the nodes must be concatenated. </t>  
    </Para>  
    <Para>  
        <t>This is a second sentence.</t>  
    </Para>  
</Root>");  
  
IEnumerable<XElement> elList =  
    from el in xmlTree.Elements("Para").Descendants()  
    select el;  
  
foreach (XElement el in elList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Para>  
            <t>This is some text </t>  
            <b>  
                <t>where</t>  
            </b>  
            <t> all of the nodes must be concatenated. </t>  
        </Para>  
  
        <Para>  
            <t>This is a second sentence.</t>  
        </Para>  
    </Root>  
  
Dim elList = From el In xmlTree.<Para>.Descendants _  
                        Select el  
  
For Each el As XElement In elList  
    Console.WriteLine(el)  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<t>This is some text </t>  
<b>  
  <t>where</t>  
</b>  
<t>where</t>  
<t> all of the nodes must be concatenated. </t>  
<t>This is a second sentence.</t>  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = XElement.Parse(  
@"<Root xmlns='http://www.adventure-works.com'>  
    <Para>  
        <t>This is some text </t>  
        <b>  
            <t>where</t>  
        </b>  
        <t> all of the nodes must be concatenated. </t>  
    </Para>  
    <Para>  
        <t>This is a second sentence.</t>  
    </Para>  
</Root>");  
  
IEnumerable<XElement> elList =  
    from el in xmlTree.Elements(aw + "Para").Descendants()  
    select el;  
  
foreach (XElement el in elList)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Para>  
                    <t>This is some text </t>  
                    <b>  
                        <t>where</t>  
                    </b>  
                    <t> all of the nodes must be concatenated. </t>  
                </Para>  
  
                <Para>  
                    <t>This is a second sentence.</t>  
                </Para>  
            </Root>  
  
        Dim elList = From el In xmlTree.<Para>.Descendants _  
                                Select el  
  
        For Each el As XElement In elList  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<t xmlns="http://www.adventure-works.com">This is some text </t>  
<b xmlns="http://www.adventure-works.com">  
  <t>where</t>  
</b>  
<t xmlns="http://www.adventure-works.com">where</t>  
<t xmlns="http://www.adventure-works.com"> all of the nodes must be concatenated. </t>  
<t xmlns="http://www.adventure-works.com">This is a second sentence.</t>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Descendants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source, System.Xml.Linq.XName name) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Descendants(Of T As XContainer) (source As IEnumerable(Of T), name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member Descendants : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.Descendants (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XContainer" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 하위 요소가 들어 있는 필터링된 요소 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소 및 문서의 하위 요소가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic 사용자가 사용할 수는 [Visual Basic (LINQ to XML)의 Language-Integrated 축](https://msdn.microsoft.com/library/4143c385-eb50-4286-a7fd-a50f466c7af0) 이 축 메서드를 명시적으로 사용 하는 대신 합니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 두 요소의 컬렉션을 검색 한 다음 지정 된 요소 이름을 가진 두 요소의 모든 하위 항목의 컬렉션을 검색 합니다.  
  
```csharp  
XElement xmlTree = XElement.Parse(  
@"<Root>  
    <Para>  
        <t>This is some text </t>  
        <b>  
            <t>where</t>  
        </b>  
        <t> all of the text nodes must be concatenated. </t>  
    </Para>  
    <Para>  
        <t>This is a second sentence.</t>  
    </Para>  
</Root>");  
  
string str =  
    (from el in xmlTree.Elements("Para").Descendants("t")  
    select (string)el)  
    .Aggregate(new StringBuilder(),  
        (sb, i) => sb.Append(i),  
        sb => sb.ToString());  
  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Para>  
            <t>This is some text </t>  
            <b>  
                <t>where</t>  
            </b>  
            <t> all of the text nodes must be concatenated. </t>  
        </Para>  
        <Para>  
            <t>This is a second sentence.</t>  
        </Para>  
    </Root>  
  
Dim str As String = _  
    ( _  
        From el In xmlTree.<Para>...<t> _  
        Select CStr(el) _  
    ) _  
    .Aggregate(New StringBuilder(), _  
               Function(ByVal sb, ByVal i) sb.Append(i), _  
               Function(ByVal sb) sb.ToString())  
  
Console.WriteLine(str)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
This is some text where all of the text nodes must be concatenated. This is a second sentence.  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = XElement.Parse(  
@"<Root xmlns='http://www.adventure-works.com'>  
    <Para>  
        <t>This is some text </t>  
        <b>  
            <t>where</t>  
        </b>  
        <t> all of the text nodes must be concatenated. </t>  
    </Para>  
    <Para>  
        <t>This is a second sentence.</t>  
    </Para>  
</Root>");  
  
string str =  
    (from el in xmlTree.Elements(aw + "Para").Descendants(aw + "t")  
     select (string)el)  
    .Aggregate(new StringBuilder(),  
        (sb, i) => sb.Append(i),  
        sb => sb.ToString());  
  
Console.WriteLine(str);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Para>  
                    <t>This is some text </t>  
                    <b>  
                        <t>where</t>  
                    </b>  
                    <t> all of the text nodes must be concatenated. </t>  
                </Para>  
                <Para>  
                    <t>This is a second sentence.</t>  
                </Para>  
            </Root>  
  
        Dim str As String = _  
            ( _  
                From el In xmlTree.<Para>...<t> _  
                Select CStr(el) _  
            ) _  
            .Aggregate(New StringBuilder(), _  
                       Function(sb, i) sb.Append(i), _  
                       Function(sb) sb.ToString())  
  
        Console.WriteLine(str)  
    End Sub  
End Module  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
This is some text where all of the text nodes must be concatenated. This is a second sentence.  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DescendantsAndSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 모든 하위 요소가 들어 있는 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic XML 하위 요소에 대 한 통합된 축에는 있지만이 메서드의 의미 체계는 통합된 축 없음.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.DescendantsAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DescendantsAndSelf (source As IEnumerable(Of XElement)) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ DescendantsAndSelf(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DescendantsAndSelf : seq&lt;System.Xml.Linq.XElement&gt; -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.Extensions.DescendantsAndSelf source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 요소가 들어 있는 요소 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 요소가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic XML 하위 요소에 대 한 통합된 축에는 있지만이 메서드의 의미 체계가 있으므로 Visual Basic 사용자는 명시적으로이 축 메서드를 사용 해야 하는 통합된 축 없음.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="DescendantsAndSelf">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; DescendantsAndSelf (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; source, System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; DescendantsAndSelf(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.DescendantsAndSelf(System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DescendantsAndSelf (source As IEnumerable(Of XElement), name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ DescendantsAndSelf(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member DescendantsAndSelf : seq&lt;System.Xml.Linq.XElement&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.Linq.Extensions.DescendantsAndSelf (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 항목이 들어 있는 필터링된 요소 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션의 모든 요소와 소스 컬렉션에 있는 모든 요소의 하위 항목이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic XML 하위 요소에 대 한 통합된 축에는 있지만이 메서드의 의미 체계가 있으므로 Visual Basic 사용자는 명시적으로이 축 메서드를 사용 해야 하는 통합된 축 없음.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.DescendantNodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Descendants" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Elements&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 자식 요소 컬렉션을 반환합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic에 지정 된 모든 자식 요소를 찾을 수 있는 통합된 요소 축을 <xref:System.Xml.Linq.XName> 소스 컬렉션에 있는 모든 요소에 대 한 합니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.Extensions.Attributes" />
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Elements&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Elements``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Elements(Of T As XContainer) (source As IEnumerable(Of T)) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Elements : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.Elements source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 자식 요소 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소 또는 문서의 자식 요소에 대한 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic에는 지정 된 모든 자식 요소를 찾을 수 있는 통합된 요소 축을 포함 되어 있지만 <xref:System.Xml.Linq.XName> 에 소스 컬렉션에 있는 모든 요소의 컬렉션을 검색할 수 있는 통합된 요소 축 없음가 모든 소스 컬렉션에 있는 모든 요소에 대 한 자식 요소입니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 요소 이름의 요소의 컬렉션을 검색 하는 다음 예제에서는 `Child`합니다. 그런 다음이 축 메서드를 사용 하 여 컬렉션의 모든 자식 요소를 검색 합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2)  
    ),  
    new XElement("Child",  
        new XElement("GrandChild3", 3),  
        new XElement("GrandChild4", 4)  
    ),  
    new XElement("Child",  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
  
IEnumerable<XElement> allGrandChildren =  
    from el in xmlTree.Elements("Child").Elements()  
    select el;  
  
foreach (XElement el in allGrandChildren)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
     <Root>  
          <Child>  
              <GrandChild1>1</GrandChild1>  
              <GrandChild2>2</GrandChild2>  
          </Child>  
  
          <Child>  
              <GrandChild3>3</GrandChild3>  
              <GrandChild4>4</GrandChild4>  
          </Child>  
  
          <Child>  
              <GrandChild5>5</GrandChild5>  
              <GrandChild6>6</GrandChild6>  
          </Child>  
      </Root>  
  
Dim allGrandChildren = From el In xmlTree.<Child>.Elements _  
                       Select el  
  
For Each el As XElement In allGrandChildren  
    Console.WriteLine(el)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<GrandChild1>1</GrandChild1>  
<GrandChild2>2</GrandChild2>  
<GrandChild3>3</GrandChild3>  
<GrandChild4>4</GrandChild4>  
<GrandChild5>5</GrandChild5>  
<GrandChild6>6</GrandChild6>  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Child",  
        new XElement(aw + "GrandChild1", 1),  
        new XElement(aw + "GrandChild2", 2)  
    ),  
    new XElement(aw + "Child",  
        new XElement(aw + "GrandChild3", 3),  
        new XElement(aw + "GrandChild4", 4)  
    ),  
    new XElement(aw + "Child",  
        new XElement(aw + "GrandChild5", 5),  
        new XElement(aw + "GrandChild6", 6)  
    )  
);  
  
IEnumerable<XElement> allGrandChildren =  
    from el in xmlTree.Elements(aw + "Child").Elements()  
    select el;  
  
foreach (XElement el in allGrandChildren)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
             <Root>  
                 <Child>  
                     <GrandChild1>1</GrandChild1>  
                     <GrandChild2>2</GrandChild2>  
                 </Child>  
  
                 <Child>  
                     <GrandChild3>3</GrandChild3>  
                     <GrandChild4>4</GrandChild4>  
                 </Child>  
  
                 <Child>  
                     <GrandChild5>5</GrandChild5>  
                     <GrandChild6>6</GrandChild6>  
                 </Child>  
             </Root>  
  
        Dim allGrandChildren = From el In xmlTree.<Child>.Elements _  
                               Select el  
  
        For Each el As XElement In allGrandChildren  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<GrandChild1 xmlns="http://www.adventure-works.com">1</GrandChild1>  
<GrandChild2 xmlns="http://www.adventure-works.com">2</GrandChild2>  
<GrandChild3 xmlns="http://www.adventure-works.com">3</GrandChild3>  
<GrandChild4 xmlns="http://www.adventure-works.com">4</GrandChild4>  
<GrandChild5 xmlns="http://www.adventure-works.com">5</GrandChild5>  
<GrandChild6 xmlns="http://www.adventure-works.com">6</GrandChild6>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Attributes" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Elements&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source, System.Xml.Linq.XName name) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Elements``1(System.Collections.Generic.IEnumerable{``0},System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Elements(Of T As XContainer) (source As IEnumerable(Of T), name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source, System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="static member Elements : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; * System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.Elements (source, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="name">일치시킬 <see cref="T:System.Xml.Linq.XName" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 요소 및 문서의 필터링된 자식 요소 컬렉션을 반환합니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</summary>
        <returns>소스 컬렉션에 있는 모든 요소 및 문서의 자식 요소에 대한 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다. 일치하는 <see cref="T:System.Xml.Linq.XName" />이 있는 요소만 컬렉션에 포함됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Basic 사용자 컬렉션에 있는 모든 요소의 자식 요소를 검색 하는 통합된 요소 축을 사용할 수 있습니다.  
  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 이 확장 메서드는 특정 깊이에서 지정 된 이름의 모든 요소를 검색 하려고 할 때 유용 합니다. 이 문서는 매우 일반적인 경우 문서를 일반 없는 경우 좀 더 어려울 수 있습니다 쉽습니다. 다음 예제에서는 모든 검색 하고자 `aaa` 자식 요소 `Item` 요소입니다. 지정 된 `Item` 요소가 포함 되거나 포함 되지 않을 수 있습니다는 `aaa` 요소입니다. 이 검사는 다음과 같이이 확장 메서드를 사용 하 여 쉽게 수행 됩니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Item",  
        new XElement("aaa", 1),  
        new XElement("bbb", 2)  
    ),  
    new XElement("Item",  
        new XElement("ccc", 3),  
        new XElement("aaa", 4)  
    ),  
    new XElement("Item",  
        new XElement("ddd", 5),  
        new XElement("eee", 6)  
    )  
);  
  
IEnumerable<XElement> allGrandChildren =  
    from el in xmlTree.Elements("Item").Elements("aaa")  
    select el;  
  
foreach (XElement el in allGrandChildren)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Item>  
            <aaa>1</aaa>  
            <bbb>2</bbb>  
        </Item>  
  
        <Item>  
            <ccc>3</ccc>  
            <aaa>4</aaa>  
        </Item>  
  
        <Item>  
            <ddd>5</ddd>  
            <eee>6</eee>  
        </Item>  
    </Root>  
  
Dim allGrandChildren = From el In xmlTree.<Item>.<aaa> _  
                       Select el  
  
For Each el As XElement In allGrandChildren  
    Console.WriteLine(el)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aaa>1</aaa>  
<aaa>4</aaa>  
```  
  
 다음은 동일한 예에서 이지만 경우 XML 네임 스페이스에 있습니다. 자세한 내용은 [XML 네임 스페이스 작업](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430)합니다.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XElement(aw + "Item",  
        new XElement(aw + "aaa", 1),  
        new XElement(aw + "bbb", 2)  
    ),  
    new XElement(aw + "Item",  
        new XElement(aw + "ccc", 3),  
        new XElement(aw + "aaa", 4)  
    ),  
    new XElement(aw + "Item",  
        new XElement(aw + "ddd", 5),  
        new XElement(aw + "eee", 6)  
    )  
);  
  
IEnumerable<XElement> allGrandChildren =  
    from el in xmlTree.Elements(aw + "Item").Elements(aw + "aaa")  
    select el;  
  
foreach (XElement el in allGrandChildren)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <Root>  
                <Item>  
                    <aaa>1</aaa>  
                    <bbb>2</bbb>  
                </Item>  
  
                <Item>  
                    <ccc>3</ccc>  
                    <aaa>4</aaa>  
                </Item>  
  
                <Item>  
                    <ddd>5</ddd>  
                    <eee>6</eee>  
                </Item>  
            </Root>  
  
        Dim allGrandChildren = From el In xmlTree.<Item>.<aaa> _  
                               Select el  
  
        For Each el As XElement In allGrandChildren  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aaa xmlns="http://www.adventure-works.com">1</aaa>  
<aaa xmlns="http://www.adventure-works.com">4</aaa>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantNodesAndSelf" />
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="M:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Attributes" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="InDocumentOrder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; InDocumentOrder&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XNode;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; InDocumentOrder&lt;(class System.Xml.Linq.XNode) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.InDocumentOrder``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function InDocumentOrder(Of T As XNode) (source As IEnumerable(Of T)) As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XNode[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;T&gt; ^ InDocumentOrder(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member InDocumentOrder : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XNode)&gt; -&gt; seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XNode)&gt; (requires 'T :&gt; System.Xml.Linq.XNode)" Usage="System.Xml.Linq.Extensions.InDocumentOrder source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XNode" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <summary>소스 컬렉션의 모든 노드가 문서 순으로 정렬되어 들어 있는 노드 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션의 모든 노드가 문서 순으로 정렬되어 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 축 메서드는 지연 된 실행을 사용 합니다. 그러나 먼저 해당 소스 컬렉션을 문서 순서로 노드 종류를 열거 하 고 결과 생성 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서 순서에 있지 않은 노드 컬렉션 만들고이 축을 사용 하 여이 새 컬렉션을 만드는 문서 순서에 노드가 있는 합니다.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Item",  
        new XElement("aaa", 1),  
        new XElement("bbb", 2)  
    ),  
    new XElement("Item",  
        new XElement("ccc", 3),  
        new XElement("aaa", 4)  
    ),  
    new XElement("Item",  
        new XElement("ddd", 5),  
        new XElement("eee", 6)  
    )  
);  
  
XElement[] elementList = {  
    xmlTree.Descendants("ddd").First(),  
    xmlTree.Descendants("ccc").First(),  
    xmlTree.Descendants("aaa").First()  
};  
  
IEnumerable<XElement> inDocOrder = elementList.InDocumentOrder();  
  
foreach (XElement el in inDocOrder)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Item>  
            <aaa>1</aaa>  
            <bbb>2</bbb>  
        </Item>  
  
        <Item>  
            <ccc>3</ccc>  
            <aaa>4</aaa>  
        </Item>  
  
        <Item>  
            <ddd>5</ddd>  
            <eee>6</eee>  
        </Item>  
    </Root>  
  
Dim elementList() As XElement = _  
    { _  
        xmlTree...<ddd>(0), _  
        xmlTree...<ccc>(0), _  
        xmlTree...<aaa>(0) _  
    }  
  
Dim inDocOrder = elementList.InDocumentOrder  
  
For Each el As XElement In inDocOrder  
    Console.WriteLine(el)  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aaa>1</aaa>  
<ccc>3</ccc>  
<ddd>5</ddd>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Nodes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; Nodes&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XContainer;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; Nodes&lt;(class System.Xml.Linq.XContainer) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Nodes``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Nodes(Of T As XContainer) (source As IEnumerable(Of T)) As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XContainer[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ Nodes(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Nodes : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XContainer)&gt; -&gt; seq&lt;System.Xml.Linq.XNode&gt; (requires 'T :&gt; System.Xml.Linq.XContainer)" Usage="System.Xml.Linq.Extensions.Nodes source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.Extensions/&lt;Nodes&gt;d__1`1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.Extensions/&lt;Nodes&gt;d__6`1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XContainer" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <summary>소스 컬렉션에 있는 모든 문서 및 요소의 자식 노드 컬렉션을 반환합니다.</summary>
        <returns>소스 컬렉션에 있는 모든 문서 및 요소의 자식 노드에 대한 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 지연된 실행을 사용합니다.  
  
   
  
## Examples  
 다음 예제에서는 검색의 모든 자식 노드 이름의 요소가 컬렉션의 모든 노드에 대해 `Child`합니다.  
  
```csharp  
XElement xmlTree = XElement.Parse(  
    @"<Root><Child>aaa<GrandChild>Text</GrandChild>bbb</Child>" +  
    @"<Child>ccc<GrandChild>Text</GrandChild>ddd</Child></Root>");  
IEnumerable<XNode> nodes = xmlTree.Elements("Child").Nodes();  
  
foreach (XNode node in nodes)  
{  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Element:  
            Console.WriteLine("Element: {0}", ((XElement)node).Name);  
            break;  
        case XmlNodeType.Text:  
            Console.WriteLine("Text: {0}", ((XText)node).Value);  
            break;  
    }  
}  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child>aaa<GrandChild>Text</GrandChild>bbb</Child>  
        <Child>ccc<GrandChild>Text</GrandChild>ddd</Child>  
    </Root>  
  
Dim nodes = xmlTree.<Child>.Nodes()  
  
' Note that XNode uses XmlNodeType, which is in the System.Xml namespace.  
For Each node As XNode In nodes  
    Select Case node.NodeType  
        Case XmlNodeType.Element  
            Console.WriteLine("Element: {0}", DirectCast(node, XElement).Name)  
        Case XmlNodeType.Text  
            Console.WriteLine("Text: {0}", DirectCast(node, XText).Value)  
    End Select  
Next  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Text: aaa  
Element: GrandChild  
Text: bbb  
Text: ccc  
Element: GrandChild  
Text: ddd  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Nodes" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Elements" />
        <altmember cref="M:System.Xml.Linq.Extensions.InDocumentOrder``1(System.Collections.Generic.IEnumerable{``0})" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static void Remove (this System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remove(class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Remove(System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Remove (source As IEnumerable(Of XAttribute))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Remove(System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Remove : seq&lt;System.Xml.Linq.XAttribute&gt; -&gt; unit" Usage="System.Xml.Linq.Extensions.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</param>
        <summary>부모 요소에서 소스 컬렉션의 모든 특성을 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특성을 소스 컬렉션에 있는 복사,-스냅숏 의미 체계를 사용 하는이 메서드는 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> 부모 로부터 분리 하기 전에 합니다. 이 선언적/명령적 코드가 혼합된 된 문제를 방지 해야 합니다. 자세한 내용은 [혼합 된 선언적 코드/명령적 코드 버그 (LINQ to XML)](https://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)합니다.  
  
   
  
## Examples  
 다음 예제에서는 특성의 컬렉션을 검색 한 다음 해당 부모 요소에서 제거 하려면이 메서드를 호출 합니다.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XAttribute("Att4", 4),  
    new XAttribute("Att5", 5)  
);  
  
IEnumerable<XAttribute> atList =  
    from at in root.Attributes()  
    where (int)at >= 3  
    select at;  
  
atList.Remove();  
  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3" Att4="4" Att5="5"/>  
  
Dim atList = From at In root.Attributes _  
             Where at.Value >= 3 _  
             Select at  
  
atList.Remove()  
  
Console.WriteLine(root)  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<Root Att1="1" Att2="2" />  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAttributes" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Attributes" />
        <altmember cref="M:System.Xml.Linq.XAttribute.Remove" />
        <altmember cref="M:System.Xml.Linq.XNode.Remove" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Remove&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Remove&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; source) where T : System.Xml.Linq.XNode;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remove&lt;(class System.Xml.Linq.XNode) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.Extensions.Remove``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub Remove(Of T As XNode) (source As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Xml::Linq::XNode[System::Runtime::CompilerServices::Extension]&#xA; static void Remove(System::Collections::Generic::IEnumerable&lt;T&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Remove : seq&lt;'T (requires 'T :&gt; System.Xml.Linq.XNode)&gt; -&gt; unit (requires 'T :&gt; System.Xml.Linq.XNode)" Usage="System.Xml.Linq.Extensions.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T"><see cref="T:System.Xml.Linq.XNode" />로 제한된 <paramref name="source" />의 개체 형식입니다.</typeparam>
        <param name="source">소스 컬렉션이 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <summary>부모 노드에서 소스 컬렉션의 모든 노드를 제거합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특성을 소스 컬렉션에 있는 복사,-스냅숏 의미 체계를 사용 하는이 메서드는 `List<T>` 부모 로부터 분리 하기 전에 합니다. 이 선언적/명령적 코드가 혼합된 된 문제를 방지 해야 합니다. 자세한 내용은 [혼합 된 선언적 코드/명령적 코드 버그 (LINQ to XML)](https://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094)합니다.  
  
   
  
## Examples  
 다음 예제에서는 요소의 컬렉션을 검색 합니다. 그런 다음 해당 부모 요소에서 요소를 제거 하려면이 메서드를 호출 합니다.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Data", 1),  
    new XElement("Data", 2),  
    new XElement("Data", 3),  
    new XElement("Data", 4),  
    new XElement("Data", 5)  
);  
  
IEnumerable<XElement> elList =  
    from el in root.Elements()  
    where (int)el >= 3  
    select el;  
  
elList.Remove();  
  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _  
    <Root>  
        <Data>1</Data>  
        <Data>2</Data>  
        <Data>3</Data>  
        <Data>4</Data>  
        <Data>5</Data>  
    </Root>  
  
Dim elList = From el In root.Elements _  
             Where el.Value >= 3 _  
             Select el  
  
elList.Remove()  
  
Console.WriteLine(root)  
  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<Root>  
  <Data>1</Data>  
  <Data>2</Data>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.RemoveAll" />
        <altmember cref="Overload:System.Xml.Linq.Extensions.Attributes" />
        <altmember cref="M:System.Xml.Linq.XAttribute.Remove" />
        <altmember cref="M:System.Xml.Linq.XNode.Remove" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
  </Members>
</Type>