<Type Name="XDocument" FullName="System.Xml.Linq.XDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df1f540d20dfb2381c7aac4e3b942195bf81c6c5" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39797172" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XDocument : System.Xml.Linq.XContainer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XDocument extends System.Xml.Linq.XContainer" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XDocument&#xA;Inherits XContainer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XDocument : System::Xml::Linq::XContainer" />
  <TypeSignature Language="F#" Value="type XDocument = class&#xA;    inherit XContainer" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XContainer</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>XML 문서를 나타냅니다. <see cref="T:System.Xml.Linq.XDocument" /> 개체의 구성 요소 및 사용에 대한 자세한 내용은 <see href="http://msdn.microsoft.com/library/90f78331-1be8-42fb-93e7-bd1325826467">XDocument 클래스 개요</see>를 참조하세요.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효한 콘텐츠에 대 한 자세한 내용은 <xref:System.Xml.Linq.XDocument>를 참조 하세요 [유효한 콘텐츠 XElement 및 XDocument 개체](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서를 만들고 메모와 요소를 추가 합니다. 그런 다음 쿼리의 결과 사용 하 여 다른 문서를 작성 합니다.  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XNamespace" />
    <altmember cref="T:System.Xml.Linq.XDeclaration" />
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XNode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 오버 로드 된 생성자를 사용 하면 비어 있는 새를 만들 수 <xref:System.Xml.Linq.XDocument>; 만들기를 <xref:System.Xml.Linq.XDocument> 만듭니다 및 지정 된 초기 내용을;과 <xref:System.Xml.Linq.XDocument> 의 다른 복사본으로 <xref:System.Xml.Linq.XDocument> 개체입니다.  
  
 <xref:System.Xml.Linq.XDocument>를 만들어야 하는 경우는 많지 않습니다. @FSHO3@대신 일반적으로 <xref:System.Xml.Linq.XElement> 루트 노드를 사용하여 XML 트리를 만들 수 있습니다. 문서를 만들어야 하는 특정 요구 사항(예를 들어, 최상위 수준에서 처리 명령과 주석을 만들어야 하거나 문서 형식을 지원해야 하는 경우)이 없는 한 <xref:System.Xml.Linq.XElement>를 루트 노드로 사용하는 것이 더 편리한 경우가 많습니다.  
  
 유효한 콘텐츠에 대 한 자세한 내용은 <xref:System.Xml.Linq.XDocument>를 참조 하세요 [유효한 콘텐츠 XElement 및 XDocument 개체](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서를 만들고 메모와 요소를 추가 합니다. 그런 다음 쿼리의 결과 사용 하 여 다른 문서를 작성 합니다.  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XDocument>를 만들어야 하는 경우는 많지 않습니다. @FSHO3@대신 일반적으로 <xref:System.Xml.Linq.XElement> 루트 노드를 사용하여 XML 트리를 만들 수 있습니다. 문서를 만들어야 하는 특정 요구 사항(예를 들어, 최상위 수준에서 처리 명령과 주석을 만들어야 하거나 문서 형식을 지원해야 하는 경우)이 없는 한 <xref:System.Xml.Linq.XElement>를 루트 노드로 사용하는 것이 더 편리한 경우가 많습니다.  
  
 유효한 콘텐츠에 대 한 자세한 내용은 <xref:System.Xml.Linq.XDocument>를 참조 하세요 [유효한 콘텐츠 XElement 및 XDocument 개체](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 새 문서를 만들고 메모와 요소를 추가 합니다.  
  
```csharp  
XDocument doc = new XDocument();  
doc.Add(new XComment("This is a comment"));  
doc.Add(new XElement("Root", "content"));  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = New XDocument()  
doc.Add(<!--This is a comment-->)  
doc.Add(<Root>content</Root>)  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!--This is a comment-->  
<Root>content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument content" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">이 문서에 추가할 콘텐츠 개체의 매개 변수 목록입니다.</param>
        <summary>지정된 콘텐츠를 사용하여 <see cref="T:System.Xml.Linq.XDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XDocument>를 만들어야 하는 경우는 많지 않습니다. @FSHO3@대신 일반적으로 <xref:System.Xml.Linq.XElement> 루트 노드를 사용하여 XML 트리를 만들 수 있습니다. 문서를 만들어야 하는 특정 요구 사항(예를 들어, 최상위 수준에서 처리 명령과 주석을 만들어야 하거나 문서 형식을 지원해야 하는 경우)이 없는 한 <xref:System.Xml.Linq.XElement>를 루트 노드로 사용하는 것이 더 편리한 경우가 많습니다.  
  
 유효한 콘텐츠에 대 한 자세한 내용은 <xref:System.Xml.Linq.XDocument>를 참조 하세요 [유효한 콘텐츠 XElement 및 XDocument 개체](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서를 만들고 메모와 요소를 추가 합니다. 그런 다음 쿼리의 결과 사용 하 여 다른 문서를 작성 합니다.  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim srcTree As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!--This is a comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDocument other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDocument other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XDocument)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDocument ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDocument -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XDocument" />
      </Parameters>
      <Docs>
        <param name="other">복사할 <see cref="T:System.Xml.Linq.XDocument" /> 개체입니다.</param>
        <summary>기존 <see cref="T:System.Xml.Linq.XDocument" /> 개체를 사용하여 <see cref="T:System.Xml.Linq.XDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 생성자를 사용 하 여의 전체 복사본을 만들기는 <xref:System.Xml.Linq.XDocument>합니다.  
  
 모든 노드 및 특성에 지정 된 문서에서이 생성자를 통과 합니다 `other` 매개 변수를 새로 초기화를 조합 하는 대로 모든 노드의 복사본을 만듭니다 <xref:System.Xml.Linq.XDocument>합니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XDocument (System.Xml.Linq.XDeclaration declaration, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XDeclaration declaration, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.#ctor(System.Xml.Linq.XDeclaration,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (declaration As XDeclaration, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XDocument(System::Xml::Linq::XDeclaration ^ declaration, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XDocument : System.Xml.Linq.XDeclaration * obj[] -&gt; System.Xml.Linq.XDocument" Usage="new System.Xml.Linq.XDocument (declaration, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="declaration" Type="System.Xml.Linq.XDeclaration" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="declaration">문서의 <see cref="T:System.Xml.Linq.XDeclaration" />입니다.</param>
        <param name="content">문서의 콘텐츠입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.Linq.XDocument" /> 및 콘텐츠를 사용하여 <see cref="T:System.Xml.Linq.XDeclaration" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XDocument>를 만들어야 하는 경우는 많지 않습니다. @FSHO3@대신 일반적으로 <xref:System.Xml.Linq.XElement> 루트 노드를 사용하여 XML 트리를 만들 수 있습니다. 문서를 만들어야 하는 특정 요구 사항(예를 들어, 최상위 수준에서 처리 명령과 주석을 만들어야 하거나 문서 형식을 지원해야 하는 경우)이 없는 한 <xref:System.Xml.Linq.XElement>를 루트 노드로 사용하는 것이 더 편리한 경우가 많습니다.  
  
 유효한 콘텐츠에 대 한 자세한 내용은 <xref:System.Xml.Linq.XDocument>를 참조 하세요 [유효한 콘텐츠 XElement 및 XDocument 개체](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae)합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서를 만들려면이 생성자를 사용 합니다.  
  
```csharp  
XDocument srcTree = new XDocument(  
    new XComment("This is a comment"),  
    new XElement("Root",  
        new XElement("Child1", "data1"),  
        new XElement("Child2", "data2"),  
        new XElement("Child3", "data3"),  
        new XElement("Child2", "data4"),  
        new XElement("Info5", "info5"),  
        new XElement("Info6", "info6"),  
        new XElement("Info7", "info7"),  
        new XElement("Info8", "info8")  
    )  
);  
  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a new comment"),  
    new XElement("Root",  
        from el in srcTree.Element("Root").Elements()  
        where ((string)el).StartsWith("data")  
        select el  
    )  
);  
doc.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>  
            <Child1>data1</Child1>  
            <Child2>data2</Child2>  
            <Child3>data3</Child3>  
            <Child2>data4</Child2>  
            <Info5>info5</Info5>  
            <Info6>info6</Info6>  
            <Info7>info7</Info7>  
            <Info8>info8</Info8>  
        </Root>  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a new comment-->  
        <Root>  
            <%= From el In srcTree.<Root>.Elements _  
                Where CStr(el).StartsWith("data") _  
                Select el %>  
        </Root>  
doc.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
<!--This is a new comment-->  
<Root>  
  <Child1>data1</Child1>  
  <Child2>data2</Child2>  
  <Child3>data3</Child3>  
  <Child2>data4</Child2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
      </Docs>
    </Member>
    <Member MemberName="Declaration">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDeclaration Declaration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDeclaration Declaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Declaration" />
      <MemberSignature Language="VB.NET" Value="Public Property Declaration As XDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDeclaration ^ Declaration { System::Xml::Linq::XDeclaration ^ get(); void set(System::Xml::Linq::XDeclaration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Declaration : System.Xml.Linq.XDeclaration with get, set" Usage="System.Xml.Linq.XDocument.Declaration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDeclaration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서의 XML 선언을 가져오거나 설정합니다.</summary>
        <value>이 문서의 XML 선언이 들어 있는 <see cref="T:System.Xml.Linq.XDeclaration" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 따라 XML 선언이 문서에 대 한 만들기 해야 합니다. 독립 실행형 문서 임을 나타내려면 하려는 경우이 속성을 사용 해야 합니다. Utf-8 이외의 인코딩을 사용 하 여 문서를 인코드 하려는 경우 통해 인코딩을 지정할 수 있습니다는 <xref:System.Xml.Linq.XDeclaration>합니다. 문서 인코딩에 대 한 다른 방법은 인코딩을 지정 하는 것을 <xref:System.Xml.XmlWriter> 작성 하기 위한 LINQ to XML 전달 합니다.  
  
   
  
## Examples  
 다음 예제에서는이 속성을 사용 하 여 XML 선언의 문서를 검색 합니다.  
  
```csharp  
XDocument doc = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XComment("This is a comment"),  
    new XElement("Root", "content")  
);  
  
Console.WriteLine(doc.Declaration);  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <!--This is a comment-->  
        <Root>content</Root>  
  
Console.WriteLine(doc.Declaration)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<?xml version="1.0" encoding="utf-8" standalone="yes"?>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentType As XDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocumentType ^ DocumentType { System::Xml::Linq::XDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.Linq.XDocumentType" Usage="System.Xml.Linq.XDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서의 DTD(문서 종류 정의)를 가져옵니다.</summary>
        <value>이 문서의 DTD가 들어 있는 <see cref="T:System.Xml.Linq.XDocumentType" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Dtd에 대 한 제한 된 지원을 제공합니다.  
  
 Dtd가 포함 된 XML 문서를 사용 하 여 XML 트리를 채울 수 있습니다. 다음 사용 될 XML 트리를 <xref:System.Xml.Linq.XDocument.DocumentType%2A> 노드. 으로 serialize 하거나 트리를 저장 하는 경우 DTD도 serialize 됩니다. [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] DTD에 엔터티를 확장 됩니다. 를 serialize 하거나 XML 트리를 저장할 때 엔터티 참조 저장 되지 않습니다. 대신 노드 엔터티의 텍스트로 대체 엔터티 참조를 사용 하 여 저장 됩니다.  
  
 DTD가 기본 특성에 있으면 특성이 일반 특성으로 XML 트리의 생성 됩니다.  
  
 기본적으로 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 해당 DTD에 따라 문서의 유효성을 검사 하지 않습니다. DTD에 따라 문서의 유효성을 검사 하려면 만듭니다는 <xref:System.Xml.XmlReader> 은 유효성을 검사 하는 DTD에 기반을 만든 다음에서 XML 트리를 <xref:System.Xml.XmlReader>입니다.  
  
   
  
## Examples  
 다음 예제에서는 포함 된 문서는 <xref:System.Xml.Linq.XDocumentType>합니다.  
  
 Visual Basic XML 리터럴 내에서 문서 유형을 지원 하지 않습니다. 그러나 것 먼저 XML 리터럴을 사용 하 여 문서를 작성 하 고 다음 만들고 추가 하 여 문서 유형을 포함 하는 문서를 만들 수는 <xref:System.Xml.Linq.XDocumentType> 노드 XML 트리에서 해당 위치에 있습니다.  
  
```csharp  
string internalSubset = @"<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>";  
  
string target = "xml-stylesheet";  
string data = "href='mystyle.css' title='Compact' type='text/css'";  
  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XProcessingInstruction(target, data),  
    new XDocumentType("Pubs", null, null, internalSubset),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
doc.Declaration = new XDeclaration("1.0", "utf-8", "true");  
Console.WriteLine(doc);  
  
doc.Save("test.xml");  
```  
  
```vb  
Dim internalSubset = _  
        "<!ELEMENT Pubs (Book+)>" & Environment.NewLine & _  
        "<!ELEMENT Book (Title, Author)>" & Environment.NewLine & _  
        "<!ELEMENT Title (#PCDATA)>" & Environment.NewLine & _  
        "<!ELEMENT Author (#PCDATA)>"  
  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
    </Pubs>  
    <!--This is another comment.-->  
  
doc.Nodes().Skip(1).First().AddAfterSelf(New XDocumentType("Pubs", Nothing, Nothing, internalSubset))  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!--This is a comment.-->  
<?xml-stylesheet href='mystyle.css' title='Compact' type='text/css'?>  
<!DOCTYPE Pubs [<!ELEMENT Pubs (Book+)>  
<!ELEMENT Book (Title, Author)>  
<!ELEMENT Title (#PCDATA)>  
<!ELEMENT Author (#PCDATA)>]>  
<Pubs>  
  <Book>  
    <Title>Artifacts of Roman Civilization</Title>  
    <Author>Moreno, Jordao</Author>  
  </Book>  
  <Book>  
    <Title>Midieval Tools and Implements</Title>  
    <Author>Gazit, Inbar</Author>  
  </Book>  
</Pubs>  
<!--This is another comment.-->  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XDocumentType" />
        <altmember cref="P:System.Xml.Linq.XDocument.NodeType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>URI로 지정된 파일, <see cref="T:System.Xml.Linq.XDocument" /> 또는 <see cref="T:System.IO.TextReader" />를 사용하여 새 <see cref="T:System.Xml.XmlReader" />를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로드할 수 있습니다이 메서드의 오버 로드 중 하나를 사용 하는 <xref:System.Xml.Linq.XDocument> 파일에서 한 <xref:System.IO.TextReader>, 또는 <xref:System.Xml.XmlReader>합니다.  
  
 만들려는 프로그램 <xref:System.Xml.Linq.XDocument> XML이 포함 된 문자열에서 사용 하 여 <xref:System.Xml.Linq.XDocument.Parse%2A>입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XML 데이터가 포함된 스트림입니다.</param>
        <summary>지정된 스트림을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" /> 인스턴스를 만듭니다.</summary>
        <returns>스트림에 들어 있는 데이터를 읽는 <see cref="T:System.Xml.Linq.XDocument" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 로드 옵션을 제어 하려는 경우 사용 합니다 <xref:System.Xml.Linq.XDocument.Load%2A> 오버 로드를 <xref:System.Xml.Linq.LoadOptions> 매개 변수로 합니다.  
  
 Linq to XML 로드 기능을 기반으로 구축 되어 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
 수정 해야 할 경우 <xref:System.Xml.XmlReaderSettings>, 다음이 단계를 수행 합니다.  
  
1.  만들기는 <xref:System.Xml.XmlReader> 중 하나를 호출 하 여 합니다 <xref:System.Xml.XmlReader.Create%2A> 오버 <xref:System.Xml.XmlReaderSettings> 매개 변수로 합니다.  
  
2.  전달 된 <xref:System.Xml.XmlReader> 중 하나에 <xref:System.Xml.Linq.XDocument.Load%2A> 오버 로드 <xref:System.Xml.Linq.XDocument> 를 사용 하는 <xref:System.Xml.XmlReader> 매개 변수로.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load textReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <see cref="T:System.IO.TextReader" />의 콘텐츠가 들어 있는 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" />에서 새 <see cref="T:System.IO.TextReader" />를 만듭니다.</summary>
        <returns>지정된 <see cref="T:System.Xml.Linq.XDocument" />의 콘텐츠가 들어 있는 <see cref="T:System.IO.TextReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는에서 문서를 <xref:System.IO.StringReader>입니다.  
  
```csharp  
TextReader tr = new StringReader("<Root>Content</Root>");  
XDocument doc = XDocument.Load(tr);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim tr As TextReader = New StringReader("<Root>Content</Root>")  
Dim doc As XDocument = XDocument.Load(tr)  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<Root>Content</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">새 <see cref="T:System.Xml.Linq.XDocument" />에 로드할 파일을 참조하는 URI 문자열입니다.</param>
        <summary>파일을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" />를 만듭니다.</summary>
        <returns>지정된 파일의 내용이 들어 있는 <see cref="T:System.Xml.Linq.XDocument" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 내부 <xref:System.Xml.XmlReader> XML 트리로 XML을 읽을 수 있습니다.  
  
 사용 하 여 <xref:System.Xml.Linq.XDocument.Parse%2A> 만들려면는 <xref:System.Xml.Linq.XDocument> XML이 포함 된 문자열에서 합니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 로드 하는 방법을 보여 줍니다는 <xref:System.Xml.Linq.XDocument> 파일에서 합니다.  
  
 이 예제에서는 XML 문서로 을 사용합니다.  
  
 [샘플 XML 파일: 일반적인 구매 주문(LINQ to XML)](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc = XDocument.Load("PurchaseOrder.xml");  
Console.WriteLine(doc);  
```  
  
```vb  
Dim doc As XDocument = XDocument.Load("PurchaseOrder.xml")  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<PurchaseOrder PurchaseOrderNumber="99503" OrderDate="1999-10-20">  
  <Address Type="Shipping">  
    <Name>Ellen Adams</Name>  
    <Street>123 Maple Street</Street>  
    <City>Mill Valley</City>  
    <State>CA</State>  
    <Zip>10999</Zip>  
    <Country>USA</Country>  
  </Address>  
  <Address Type="Billing">  
    <Name>Tai Yee</Name>  
    <Street>8 Oak Avenue</Street>  
    <City>Old Town</City>  
    <State>PA</State>  
    <Zip>95819</Zip>  
    <Country>USA</Country>  
  </Address>  
  <DeliveryNotes>Please leave packages in shed by driveway.</DeliveryNotes>  
  <Items>  
    <Item PartNumber="872-AA">  
      <ProductName>Lawnmower</ProductName>  
      <Quantity>1</Quantity>  
      <USPrice>148.95</USPrice>  
      <Comment>Confirm this is electric</Comment>  
    </Item>  
    <Item PartNumber="926-AA">  
      <ProductName>Baby Monitor</ProductName>  
      <Quantity>2</Quantity>  
      <USPrice>39.98</USPrice>  
      <ShipDate>1999-05-21</ShipDate>  
    </Item>  
  </Items>  
</PurchaseOrder>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />의 콘텐츠가 들어 있는 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" />를 사용하여 새 <see cref="T:System.Xml.XmlReader" />를 만듭니다.</summary>
        <returns>지정된 <see cref="T:System.Xml.Linq.XDocument" />의 콘텐츠가 들어 있는 <see cref="T:System.Xml.XmlReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드에 대 한 한 가지 가능한 용도에서 LINQ to XML 트리를 DOM 문서 복사본을 만드는 것입니다. 만든이 위해는 <xref:System.Xml.XmlNodeReader> DOM 문서를 사용 하 여 합니다 <xref:System.Xml.XmlNodeReader> 만들려는 <xref:System.Xml.Linq.XDocument>합니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 DOM 문서를 만들어 만듭니다는 <xref:System.Xml.XmlNodeReader> DOM 문서에서 만들고는 <xref:System.Xml.Linq.XDocument> 를 사용 하 여는 <xref:System.Xml.XmlNodeReader>.  
  
```csharp  
// Create a DOM document with some content.  
XmlDocument doc = new XmlDocument();  
XmlElement child = doc.CreateElement("Child");  
child.InnerText = "child contents";  
XmlElement root = doc.CreateElement("Root");  
root.AppendChild(child);  
doc.AppendChild(root);  
  
// create a reader and move to the content  
using (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {  
    // the reader must be in the Interactive state in order to  
    // create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader);  
    Console.WriteLine(xRoot);  
}  
```  
  
```vb  
' Create a DOM document with some content.  
Dim doc As XmlDocument = New XmlDocument()  
Dim child As XmlElement = doc.CreateElement("Child")  
child.InnerText = "child contents"  
Dim root As XmlElement = doc.CreateElement("Root")  
root.AppendChild(child)  
doc.AppendChild(root)  
  
' create a reader and move to the content  
Using nodeReader = New XmlNodeReader(doc)  
    ' the reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader)  
    Console.WriteLine(xRoot)  
End Using  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<Root>  
  <Child>child contents</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.Stream stream, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="stream">XML 데이터가 포함된 스트림입니다.</param>
        <param name="options">기본 URI 및 줄 정보의 로드 여부를 지정하는 <see cref="T:System.Xml.Linq.LoadOptions" />입니다.</param>
        <summary>지정된 스트림을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" /> 인스턴스를 만들고, 선택적으로 공백 및 줄 정보를 유지하고 기본 URI를 설정합니다.</summary>
        <returns>스트림에 들어 있는 데이터를 읽는 <see cref="T:System.Xml.Linq.XDocument" /> 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Linq to XML 로드 기능을 기반으로 구축 되어 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
 수정 해야 할 경우 <xref:System.Xml.XmlReaderSettings>, 다음이 단계를 수행 합니다.  
  
1.  만들기는 <xref:System.Xml.XmlReader> 중 하나를 호출 하 여 합니다 <xref:System.Xml.XmlReader.Create%2A> 는 오버 로드 <xref:System.Xml.XmlReaderSettings> 매개 변수로 합니다.  
  
2.  전달 된 <xref:System.Xml.XmlReader> 중 하나에 <xref:System.Xml.Linq.XDocument.Load%2A> 오버 로드 <xref:System.Xml.Linq.XDocument> 를 사용 하는 <xref:System.Xml.XmlReader> 매개 변수로.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.TextReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (textReader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="textReader">
          <see cref="T:System.IO.TextReader" />의 콘텐츠가 들어 있는 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <param name="options">기본 URI와 줄 정보의 로드 여부 및 공백 동작을 지정하는 <see cref="T:System.Xml.Linq.LoadOptions" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" />를 사용하여 새 <see cref="T:System.IO.TextReader" />를 만들고, 선택적으로 공백 및 줄 정보를 유지하고 기본 URI를 설정합니다.</summary>
        <returns>지정된 <see cref="T:System.Xml.Linq.XDocument" />에서 읽은 XML이 들어 있는 <see cref="T:System.IO.TextReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 소스 XML에서에서 모든 공백이 읽을 판독기입니다. 노드 형식의 <xref:System.Xml.Linq.XText> 중요 하 고 불필요 한 공백에 대 한 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 하지 않으면 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 판독기의 소스 XML에서에서 불필요 한 공백을 모두 무시 합니다. XML 트리에서 무효 공백에 대 한 텍스트 노드 없이 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 영향을 주지 않습니다. 유효 공백 문자는 계속 유지 되며 자세한 공백 텍스트 노드가 생성 될 수 있는 불필요 한 공백이 없는 범위.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
 사용 하 여 <xref:System.Xml.Linq.XDocument.Parse%2A> 만들려면는 <xref:System.Xml.Linq.XElement> XML이 포함 된 문자열에서 합니다.  
  
 설정 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 에서 로드할 때 유효 하지 않은 한 <xref:System.IO.TextReader>합니다.  
  
 설정한 경우 성능 저하가 발생 합니다 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 플래그입니다.  
  
 XML 문서를 로드 한 직후 줄 정보는 정확 하 게 됩니다. 문서를 로드 한 후 XML 트리를 수정 하는 경우 줄 정보가 무의미해 질 수 있습니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는에서 문서를 <xref:System.IO.StringReader>입니다.  
  
```csharp  
TextReader sr;  
int whiteSpaceNodes;  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree1 = XDocument.Load(sr, LoadOptions.None);  
sr.Close();  
whiteSpaceNodes = xmlTree1  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes);  
  
sr = new StringReader("<Root> <Child> </Child> </Root>");  
XDocument xmlTree2 = XDocument.Load(sr, LoadOptions.PreserveWhitespace);  
sr.Close();  
whiteSpaceNodes = xmlTree2  
    .Element("Root")  
    .DescendantNodesAndSelf()  
    .OfType<XText>()  
    .Where(tNode => tNode.ToString().Trim().Length == 0)  
    .Count();  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes);  
```  
  
```vb  
Dim sr As TextReader  
Dim whiteSpaceNodes As Integer  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree1 As XDocument = XDocument.Load(sr, LoadOptions.None)  
sr.Close()  
whiteSpaceNodes = xmlTree1 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (not preserving whitespace): {0}", whiteSpaceNodes)  
  
sr = New StringReader("<Root> <Child> </Child> </Root>")  
Dim xmlTree2 As XDocument = XDocument.Load(sr, LoadOptions.PreserveWhitespace)  
sr.Close()  
whiteSpaceNodes = xmlTree2 _  
              .Element("Root") _  
              .DescendantNodesAndSelf() _  
              .OfType(Of XText)() _  
              .Where(Function(ByVal tNode As XNode) tNode. _  
                  ToString().Trim().Length = 0).Count()  
Console.WriteLine("Count of white space nodes (preserving whitespace): {0}", whiteSpaceNodes)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Count of white space nodes (not preserving whitespace): 0  
Count of white space nodes (preserving whitespace): 3  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (string uri, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(string uri, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (uri As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::String ^ uri, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (uri, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="uri">새 <see cref="T:System.Xml.Linq.XDocument" />에 로드할 파일을 참조하는 URI 문자열입니다.</param>
        <param name="options">기본 URI와 줄 정보의 로드 여부 및 공백 동작을 지정하는 <see cref="T:System.Xml.Linq.LoadOptions" />입니다.</param>
        <summary>파일을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" />를 만들고, 선택적으로 공백 및 줄 정보를 유지하고 기본 URI를 설정합니다.</summary>
        <returns>지정된 파일의 내용이 들어 있는 <see cref="T:System.Xml.Linq.XDocument" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 소스 XML에서에서 모든 공백이 읽을 판독기입니다. 노드 형식의 <xref:System.Xml.Linq.XText> 중요 하 고 불필요 한 공백에 대 한 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 하지 않으면 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 판독기의 소스 XML에서에서 불필요 한 공백을 모두 무시 합니다. XML 트리에서 무효 공백에 대 한 텍스트 노드 없이 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 영향을 주지 않습니다. 유효 공백 문자는 계속 유지 되며 자세한 공백 텍스트 노드가 생성 될 수 있는 불필요 한 공백이 없는 범위.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
 사용 하 여 <xref:System.Xml.Linq.XDocument.Parse%2A> 만들려면는 <xref:System.Xml.Linq.XDocument> XML이 포함 된 문자열에서 합니다.  
  
 설정한 경우 성능 저하가 발생 합니다 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 하며 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 플래그입니다.  
  
 기본 URI 및 줄 정보를 정확 하 게 XML 문서를 로드 한 직후입니다. 문서를 로드 한 후 XML 트리를 수정 하는 경우 기본 URI 및 줄 정보의 무의미해 질 수 있습니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 로드 하는 방법을 보여 줍니다는 <xref:System.Xml.Linq.XDocument> 파일에서 합니다.  
  
 이 예제에서는 XML 문서로 을 사용합니다.  
  
 [샘플 XML 파일: 일반적인 구매 주문(LINQ to XML)](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)  
  
```csharp  
XDocument doc1 = XDocument.Load("PurchaseOrder.xml", LoadOptions.None);  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count());  
  
XDocument doc2 = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim doc1 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.None)  
Console.WriteLine("nodes if not preserving whitespace: {0}", doc1.DescendantNodes().Count())  
  
Dim doc2 As XDocument = XDocument.Load("PurchaseOrder.xml", LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes if preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
nodes if not preserving whitespace: 48  
nodes if preserving whitespace: 82  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Load (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Load(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Load(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Load (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" />의 콘텐츠를 읽어올 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <param name="options">기본 URI 및 줄 정보의 로드 여부를 지정하는 <see cref="T:System.Xml.Linq.LoadOptions" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.Linq.XDocument" />에서 <see cref="T:System.Xml.XmlReader" />를 로드하고, 선택적으로 기본 URI를 설정하고 줄 정보를 유지합니다.</summary>
        <returns>지정된 <see cref="T:System.Xml.Linq.XDocument" />에서 읽은 XML이 들어 있는 <see cref="T:System.Xml.XmlReader" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 만들어를 <xref:System.Xml.XmlNodeReader> DOM 문서를 사용 하 여 다음에서 합니다 <xref:System.Xml.XmlNodeReader> 만들려면는 <xref:System.Xml.Linq.XElement>, LINQ to XML 트리를에서 DOM 문서 복사본을 만들려면이 메서드를 사용할 수 있습니다.  
  
 사용 하 여 <xref:System.Xml.Linq.XDocument.Parse%2A> 만들려면는 <xref:System.Xml.Linq.XDocument> XML이 포함 된 문자열에서 합니다.  
  
 설정 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 에서 로드할 때 유효 하지 않은 한 <xref:System.Xml.XmlReader>합니다. <xref:System.Xml.XmlReader> 여부 하거나 읽기 공백을 구성 됩니다. 공백 노드를 사용 하 여 LINQ to XML 트리를 채울 수는 있는 판독기 화면. 여부에 관계 없이 동작이 됩니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 설정 여부입니다.  
  
 <xref:System.Xml.XmlReader> 여부 유효한 기본 URI가 될 수 있습니다. 설정 하는 경우 <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, 기본 URI가 보고 되는 기본 URI에서 XML 트리의 설정 됩니다는 <xref:System.Xml.XmlReader>합니다.  
  
 <xref:System.Xml.XmlReader> 여부 유효한 줄 정보가 있을 수 있습니다. 설정 하는 경우 <xref:System.Xml.Linq.LoadOptions.SetLineInfo>, 줄 정보를 설정할 XML 트리의 보고 된 줄 정보를 <xref:System.Xml.XmlReader>입니다.  
  
 설정한 경우 성능 저하가 발생 합니다 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 플래그입니다.  
  
 XML 문서를 로드 한 직후 줄 정보는 정확 하 게 됩니다. 문서를 로드 한 후 XML 트리를 수정 하는 경우 줄 정보가 무의미해 질 수 있습니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서 로드 하는 줄 정보를 로드 합니다 <xref:System.Xml.XmlReader>합니다. 다음 줄 정보를 인쇄합니다.  
  
```csharp  
string markup =  
@"<Root>  
    <Child>  
        <GrandChild/>  
    </Child>  
</Root>";  
  
// Create a reader and move to the content.  
using (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))  
{  
    // the reader must be in the Interactive state in order to  
    // Create a LINQ to XML tree from it.  
    nodeReader.MoveToContent();  
  
    XDocument xRoot = XDocument.Load(nodeReader, LoadOptions.SetLineInfo);  
    Console.WriteLine("{0}{1}{2}",  
        "Element Name".PadRight(20),  
        "Line".PadRight(5),  
        "Position");  
    Console.WriteLine("{0}{1}{2}",  
        "------------".PadRight(20),  
        "----".PadRight(5),  
        "--------");  
    foreach (XElement e in xRoot.Elements("Root").DescendantsAndSelf())  
        Console.WriteLine("{0}{1}{2}",  
            ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
            ((IXmlLineInfo)e).LinePosition);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child>" & Environment.NewLine & _  
    "        <GrandChild/>" & Environment.NewLine & _  
    "    </Child>" & Environment.NewLine & _  
    "</Root>"  
  
' Create a reader and move to the content.  
Using nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))  
  
    ' The reader must be in the Interactive state in order to  
    ' create a LINQ to XML tree from it.  
    nodeReader.MoveToContent()  
  
    Dim xRoot As XDocument = XDocument.Load(nodeReader, LoadOptions.SetLineInfo)  
    Console.WriteLine("{0}{1}{2}", _  
        "Element Name".PadRight(20), _  
        "Line".PadRight(5), _  
        "Position")  
    Console.WriteLine("{0}{1}{2}", _  
        "------------".PadRight(20), _  
        "----".PadRight(5), _  
        "--------")  
    For Each e As XElement In xRoot.Elements("Root").DescendantsAndSelf()  
        Console.WriteLine("{0}{1}{2}", _  
            ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _  
            (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _  
            (DirectCast(e, IXmlLineInfo)).LinePosition)  
    Next  
End Using  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child             2    6  
    GrandChild      3    10  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.Stream stream, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.Stream,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::Stream ^ stream, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.Stream * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.IO.TextReader textReader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.IO.TextReader textReader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.IO.TextReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::IO::TextReader ^ textReader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.IO.TextReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (textReader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textReader" Type="System.IO.TextReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textReader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt; LoadAsync (System.Xml.XmlReader reader, System.Xml.Linq.LoadOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XDocument&gt; LoadAsync(class System.Xml.XmlReader reader, valuetype System.Xml.Linq.LoadOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.LoadAsync(System.Xml.XmlReader,System.Xml.Linq.LoadOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XDocument ^&gt; ^ LoadAsync(System::Xml::XmlReader ^ reader, System::Xml::Linq::LoadOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member LoadAsync : System.Xml.XmlReader * System.Xml.Linq.LoadOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;" Usage="System.Xml.Linq.XDocument.LoadAsync (reader, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XDocument&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 노드에 대한 노드 형식을 가져옵니다.</summary>
        <value>노드 형식입니다. <see cref="T:System.Xml.Linq.XDocument" /> 개체의 경우 이 값은 <see cref="F:System.Xml.XmlNodeType.Document" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 파생 하는 모든 클래스 <xref:System.Xml.Linq.XObject> 포함 된 <xref:System.Xml.Linq.XObject.NodeType%2A> 속성 컬렉션 개체를 각 유형의의 서브 클래스에 대해 작동 하는 코드를 작성할 수 있습니다 <xref:System.Xml.Linq.XObject>. 컬렉션의 각 개체의 노드 형식에 대 한 코드 테스트할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는이 속성의 사용을 보여 줍니다.  
  
```csharp  
// Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XDeclaration("1.0", "utf-8", "yes"),  
    new XElement("Root", "content")  
);  
Console.WriteLine(xmlTree.NodeType);  
```  
  
```vb  
' Note that this property uses XmlNodeType, which is in the System.Xml namespace.  
Dim xmlTree As XDocument = _  
    <?xml version='1.0' encoding='utf-8' standalone='yes'?>  
        <Root>content</Root>  
Console.WriteLine("{0}", xmlTree.NodeType)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Document  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="P:System.Xml.Linq.XDocument.DocumentType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>문자열을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" />를 만들고, 선택적으로 공백 및 줄 정보를 유지하고 기본 URI를 설정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문자열을 구문 분석 하 고 XML 트리를 만듭니다.  
  
   
  
## Examples  
 다음 예제에서는 XML이 포함 된 문자열을 만듭니다. 그런 다음 문자열을 구문 분석을 <xref:System.Xml.Linq.XDocument>입니다.  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">XML이 포함된 문자열입니다.</param>
        <summary>문자열을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" />를 만듭니다.</summary>
        <returns>XML이 들어 있는 문자열을 사용하여 채운 <see cref="T:System.Xml.Linq.XDocument" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 공백을 유지 하지 않습니다. 오버 로드를 사용 하 여 XML 트리의 공백을 유지 하려는 경우 <xref:System.Xml.Linq.XDocument.Parse%2A> 를 사용 하는 <xref:System.Xml.Linq.LoadOptions> 매개 변수로 합니다.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 XML이 포함 된 문자열을 만듭니다. 그런 다음 문자열을 구문 분석을 <xref:System.Xml.Linq.XDocument>입니다.  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc = XDocument.Parse(str);  
Console.WriteLine(doc);  
```  
  
```vb  
Dim str As String = _  
    "<?xml version= '1.0'?>" & _  
    "<!-- comment at the root level -->" & _  
    "<Root>" & _  
    "  <Child>Content</Child>" & _  
    "</Root>"  
  
Dim doc As XDocument = XDocument.Parse(str)  
Console.WriteLine(doc)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<!-- comment at the root level -->  
<Root>  
  <Child>Content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XDocument Parse (string text, System.Xml.Linq.LoadOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XDocument Parse(string text, valuetype System.Xml.Linq.LoadOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Parse(System.String,System.Xml.Linq.LoadOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (text As String, options As LoadOptions) As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XDocument ^ Parse(System::String ^ text, System::Xml::Linq::LoadOptions options);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Xml.Linq.LoadOptions -&gt; System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XDocument.Parse (text, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.LoadOptions" />
      </Parameters>
      <Docs>
        <param name="text">XML이 포함된 문자열입니다.</param>
        <param name="options">기본 URI와 줄 정보의 로드 여부 및 공백 동작을 지정하는 <see cref="T:System.Xml.Linq.LoadOptions" />입니다.</param>
        <summary>문자열을 사용하여 새 <see cref="T:System.Xml.Linq.XDocument" />를 만들고, 선택적으로 공백 및 줄 정보를 유지하고 기본 URI를 설정합니다.</summary>
        <returns>XML이 들어 있는 문자열을 사용하여 채운 <see cref="T:System.Xml.Linq.XDocument" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 소스 XML에서에서 모든 공백이 읽을 판독기입니다. 노드 형식의 <xref:System.Xml.Linq.XText> 중요 하 고 불필요 한 공백에 대 한 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 하지 않으면 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 하면 판독기의 소스 XML에서에서 불필요 한 공백을 모두 무시 합니다. XML 트리에서 무효 공백에 대 한 텍스트 노드 없이 생성 됩니다.  
  
 소스 XML 들여쓰기 없는 경우 설정 합니다 <xref:System.Xml.Linq.LoadOptions.PreserveWhitespace> 플래그 `options` 영향을 주지 않습니다. 유효 공백 문자는 계속 유지 되며 자세한 공백 텍스트 노드가 생성 될 수 있는 불필요 한 공백이 없는 범위.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
 설정 <xref:System.Xml.Linq.LoadOptions.SetBaseUri> 에서 구문 분석할 때 유효 하지 않은 한 <xref:System.String>합니다.  
  
 설정한 경우 성능 저하가 발생 합니다 <xref:System.Xml.Linq.LoadOptions.SetLineInfo> 플래그입니다.  
  
 XML 문서를 로드 한 직후 줄 정보는 정확 하 게 됩니다. 문서를 로드 한 후 XML 트리를 수정 하는 경우 줄 정보가 무의미해 질 수 있습니다.  
  
 XML의 로드 기능에는 LINQ 기반 <xref:System.Xml.XmlReader>입니다. throw 된 예외를 catch 될 수 있습니다 따라서 합니다 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 메서드 오버 로드 및 <xref:System.Xml.XmlReader> 읽기 및 문서를 구문 분석 하는 메서드.  
  
   
  
## Examples  
 다음 예제에서는 문자열을 구문 분석 하는 <xref:System.Xml.Linq.XDocument>합니다.  
  
```csharp  
string str =  
@"<?xml version=""1.0""?>  
<!-- comment at the root level -->  
<Root>  
    <Child>Content</Child>  
</Root>";  
XDocument doc1 = XDocument.Parse(str, LoadOptions.PreserveWhitespace);  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count());  
XDocument doc2 = XDocument.Parse(str, LoadOptions.None);  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count());  
```  
  
```vb  
Dim str As String = _  
"<?xml version= '1.0'?>" & Environment.NewLine & _  
"<!-- comment at the root level -->" & Environment.NewLine & _  
"<Root>" & Environment.NewLine & _  
"    <Child>Content</Child>"  & Environment.NewLine & _  
"</Root>"  
  
Dim doc1 As XDocument = XDocument.Parse(str, LoadOptions.PreserveWhitespace)  
Console.WriteLine("nodes when preserving whitespace: {0}", doc1.DescendantNodes().Count())  
Dim doc2 As XDocument = XDocument.Parse(str, LoadOptions.None)  
Console.WriteLine("nodes when not preserving whitespace: {0}", doc2.DescendantNodes().Count())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
nodes when preserving whitespace: 8  
nodes when not preserving whitespace: 4  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Root" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XDocument.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Root { System::Xml::Linq::XElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.Xml.Linq.XElement" Usage="System.Xml.Linq.XDocument.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 대한 XML 트리의 루트 요소를 가져옵니다.</summary>
        <value>XML 트리의 루트 <see cref="T:System.Xml.Linq.XElement" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성은 작성 하려는 경우에 유용 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 경우에서 루 팅 트리에 대 한 구성으로 동일한 컨텍스트에서 쿼리 <xref:System.Xml.Linq.XElement>합니다. 참조 [XDocument 쿼리와 합니다. XElement 쿼리 비교](http://msdn.microsoft.com/library/d266f58d-f2f3-4668-b661-e716e658d13a) 대 한 자세한 내용은 합니다.  
  
   
  
## Examples  
 다음 예제에서는이 속성을 사용 하 여 문서의 루트 요소를 가져옵니다.  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("This is a comment."),  
    new XElement("Pubs",   
        new XElement("Book",  
            new XElement("Title", "Artifacts of Roman Civilization"),  
            new XElement("Author", "Moreno, Jordao")  
        ),  
        new XElement("Book",  
            new XElement("Title", "Midieval Tools and Implements"),  
            new XElement("Author", "Gazit, Inbar")  
        )  
    ),  
    new XComment("This is another comment.")  
);  
Console.WriteLine(doc.Root.Name.ToString());  
```  
  
```vb  
Dim doc As XDocument = _  
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
    <!--This is a comment.-->  
    <Pubs>  
        <Book>  
            <Title>Artifacts of Roman Civilization</Title>  
            <Author>Moreno, Jordao</Author>  
        </Book>  
        <Book>  
            <Title>Midieval Tools and Implements</Title>  
            <Author>Gazit, Inbar</Author>  
        </Book>  
        <!--This is another comment.-->  
    </Pubs>  
  
Console.WriteLine(doc.Root.Name.ToString())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Pubs  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 파일, <see cref="T:System.IO.TextWriter" /> 또는 <see cref="T:System.Xml.XmlWriter" />로 serialize합니다.</summary>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xDocument.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">이 <see cref="T:System.Xml.Linq.XDocument" />를 출력할 스트림입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 지정된 <see cref="T:System.IO.Stream" />에 출력합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialize 된 XML은 들여씁니다. 모든 무효 공백이 제거할 수 있으며, XML을 올바르게 들여쓰기 됩니다 있도록 추가 공백이 추가 됩니다. 이 메서드의 동작은 불필요 한 공백이 유지 되지 것입니다.  
  
 오버 로드를 사용 하 여 공백 제어 하려는 경우 <xref:System.Xml.Linq.XDocument.Save%2A> 를 사용 하는 <xref:System.Xml.Linq.SaveOptions> 매개 변수로 합니다. 사용 된 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 된 들여쓰지 않은 XML을 저장 하는 옵션입니다. 이렇게 하면 모든 공백이 XML 트리에 표시 된 대로 정확 하 게 작성할 작성기입니다.  
  
 사용 하 여 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> 중복 된 네임 스페이스 선언을 제거 하려는 경우 옵션입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xDocument.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <see cref="T:System.IO.TextWriter" />를 쓸 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 <see cref="T:System.IO.TextWriter" />로 serialize합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialize 된 XML은 들여씁니다. 모든 무효 공백이 제거할 수 있으며, XML을 올바르게 들여쓰기 됩니다 있도록 추가 공백이 추가 됩니다. 이 메서드의 동작은 불필요 한 공백이 유지 되지 것입니다.  
  
 오버 로드를 사용 하 여 공백 제어 하려는 경우 <xref:System.Xml.Linq.XDocument.Save%2A> 를 사용 하는 <xref:System.Xml.Linq.SaveOptions> 매개 변수로 합니다. 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Xml.Linq.XDocument>, 문서를 저장을 <xref:System.IO.StringWriter>, 한 다음 콘솔에 문자열을 출력 합니다.  
  
```csharp  
StringBuilder sb = new StringBuilder();  
  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
TextWriter tr = new StringWriter(sb);  
doc.Save(tr);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim tr As TextWriter = New StringWriter(sb)  
doc.Save(tr)  
Console.WriteLine(sb.ToString())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xDocument.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">파일 이름이 포함된 문자열입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 파일로 serialize하여 기존 파일이 있는 경우 덮어씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serialize 된 XML은 들여씁니다. 모든 무효 공백이 제거할 수 있으며, XML을 올바르게 들여쓰기 됩니다 있도록 추가 공백이 추가 됩니다. 이 메서드의 동작은 불필요 한 공백이 유지 되지 것입니다.  
  
 오버 로드를 사용 하 여 공백 제어 하려는 경우 <xref:System.Xml.Linq.XDocument.Save%2A> 를 사용 하는 <xref:System.Xml.Linq.SaveOptions> 매개 변수로 합니다. 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Xml.Linq.XDocument>, 문서 파일에 저장 한 다음 콘솔 파일을 출력 합니다.  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root.xml");  
Console.WriteLine(File.ReadAllText("Root.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root.xml")  
Console.WriteLine(File.ReadAllText("Root.xml"))  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" />를 쓸 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 <see cref="T:System.Xml.XmlWriter" />로 serialize합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 <xref:System.Xml.Linq.XDocument>를 <xref:System.Xml.XmlWriter>에 저장하는 방법을 보여 줍니다.  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.Save(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.Save(xw)  
  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">이 <see cref="T:System.Xml.Linq.XDocument" />를 출력할 스트림입니다.</param>
        <param name="options">형식 지정 동작을 지정하는 <see cref="T:System.Xml.Linq.SaveOptions" />입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 지정된 <see cref="T:System.IO.Stream" />에 출력하고 선택적으로 형식 지정 동작을 지정합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 `options` 로 설정 되어 <xref:System.Xml.Linq.SaveOptions.None>입니다. 이 옵션은 모든 불필요 한 공백이 제거 하 고 XML이 제대로 들여쓰는 지 수 있도록 적절 한 무효 공백을 추가 합니다.  
  
 지정 된 들여쓰지 않은 XML을 저장 하려는 경우는 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 플래그 `options`합니다. 이렇게 하면 모든 공백이 XML 트리에 표시 된 대로 정확 하 게 작성할 작성기입니다.  
  
 사용 하 여 <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> 중복 된 네임 스페이스 선언을 제거 하려는 경우 옵션입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">XML을 출력할 <see cref="T:System.IO.TextWriter" />입니다.</param>
        <param name="options">형식 지정 동작을 지정하는 <see cref="T:System.Xml.Linq.SaveOptions" />입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 <see cref="T:System.IO.TextWriter" />로 serialize하고, 선택적으로 형식 지정을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 들여쓰지 않은 XML을 저장 하려는 경우는 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 플래그 `options`합니다. 이렇게 하면 모든 공백이 XML 트리에 표시 된 대로 정확 하 게 작성할 작성기입니다.  
  
 들여쓰기 된 XML을 저장 하려는 경우를 지정 하지 않으면 합니다 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 플래그 `options`합니다. 모든 불필요 한 공백이 제거 되 고 XML이 제대로 들여쓰는 지 수 있도록 적절 한 불필요 한 공백이 추가 됩니다. 이 기본 동작을 오버 로드의 동작을 <xref:System.Xml.Linq.XDocument.Save%2A> 사용 하지 않는 메서드 `options` 매개 변수로 합니다.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드의 두 가지 용도 보여 줍니다. 첫 번째 사용에서는 serialize 된 <xref:System.Xml.Linq.XDocument> 서식을 사용 하 여 합니다. 두 번째 공백을 유지합니다. 문서에는 공백이 없습니다 생성, 때문에 들여쓰기 되지 않고 XML 출력 공백 유지 합니다.  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
StringBuilder sb1 = new StringBuilder();  
using (StringWriter sr1 = new StringWriter(sb1)) {  
    doc.Save(sr1, SaveOptions.None);  
    Console.WriteLine(sb1.ToString());  
}  
  
StringBuilder sb2 = new StringBuilder();  
using (StringWriter sr2 = new StringWriter(sb2)) {  
    doc.Save(sr2, SaveOptions.DisableFormatting);  
    Console.WriteLine(sb2.ToString());  
}  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
Dim sb1 As StringBuilder = New StringBuilder()  
  
Using sr1 = New StringWriter(sb1)  
    doc.Save(sr1, SaveOptions.None)  
    Console.WriteLine(sb1.ToString())  
End Using  
  
Dim sb2 As StringBuilder = New StringBuilder()  
  
Using sr2 = New StringWriter(sb2)  
    doc.Save(sr2, SaveOptions.DisableFormatting)  
    Console.WriteLine(sb2.ToString())  
End Using  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<?xml version="1.0" encoding="utf-16"?>  
<Root>  
  <Child>content</Child>  
</Root>  
<?xml version="1.0" encoding="utf-16"?><Root><Child>content</Child></Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xDocument.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">파일 이름이 포함된 문자열입니다.</param>
        <param name="options">형식 지정 동작을 지정하는 <see cref="T:System.Xml.Linq.SaveOptions" />입니다.</param>
        <summary>이 <see cref="T:System.Xml.Linq.XDocument" />를 파일로 serialize하고, 선택적으로 형식 지정을 해제합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 지정 된 들여쓰지 않은 XML을 저장 하려는 경우는 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 플래그 `options`합니다. 이렇게 하면 모든 공백이 XML 트리에 표시 된 대로 정확 하 게 작성할 작성기입니다.  
  
 들여쓰기 된 XML을 저장 하려는 경우를 지정 하지 않으면 합니다 <xref:System.Xml.Linq.SaveOptions.DisableFormatting> 플래그 `options`합니다. 모든 불필요 한 공백이 제거 되 고 XML이 제대로 들여쓰는 지 수 있도록 적절 한 불필요 한 공백이 추가 됩니다. 이 기본 동작을 오버 로드의 동작을 <xref:System.Xml.Linq.XDocument.Save%2A> 사용 하지 않는 메서드 `options` 매개 변수로 합니다.  
  
 자세한 내용은 [로드 하거나 XML 구문 분석 하는 동안 공백을 유지](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) 하 고 [유지 공백 하는 동안 직렬화](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939)합니다.  
  
   
  
## Examples  
 다음 예제에서는이 메서드의 두 가지 용도 보여 줍니다. 첫 번째 사용에서는 공백을 유지합니다. 두 번째 serialize 된 <xref:System.Xml.Linq.XDocument> 들여쓰기와 합니다.  
  
```csharp  
XDocument doc = new XDocument(  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
doc.Save("Root1.xml", SaveOptions.DisableFormatting);  
Console.WriteLine(File.ReadAllText("Root1.xml"));  
doc.Save("Root2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Root2.xml"));  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
        <Root><Child>content</Child></Root>  
  
doc.Save("Root1.xml", SaveOptions.DisableFormatting)  
Console.WriteLine(File.ReadAllText("Root1.xml"))  
doc.Save("Root2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Root2.xml"))  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<?xml version="1.0" encoding="utf-8"?><Root><Child>content</Child></Root>  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Child>content</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.Stream stream, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.Stream,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.Stream * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (stream, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="stream">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task SaveAsync (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task SaveAsync(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.SaveAsync(System.IO.TextWriter,System.Xml.Linq.SaveOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ SaveAsync(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.SaveAsync : System.IO.TextWriter * System.Xml.Linq.SaveOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.SaveAsync (textWriter, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="textWriter">To be added.</param>
        <param name="options">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xDocument.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">이 메서드가 쓸 <see cref="T:System.Xml.XmlWriter" />입니다.</param>
        <summary>이 문서를 <see cref="T:System.Xml.XmlWriter" />에 씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 쓰는 방법을 보여 줍니다.는 <xref:System.Xml.Linq.XDocument> 에 <xref:System.Xml.XmlWriter>합니다. 이 예제에서는 XML 선언을 작성 하지 않은 참고 합니다.  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XDocument doc = new XDocument(  
        new XElement("Child",  
            new XElement("GrandChild", "some content")  
        )  
    );  
    doc.WriteTo(xw);  
}  
  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    Dim doc As XDocument = New XDocument(<Child><GrandChild>some content</GrandChild></Child>)  
    doc.WriteTo(xw)  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
<Child>  
  <GrandChild>some content</GrandChild>  
</Child>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XDocument.Save" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Load" />
        <altmember cref="Overload:System.Xml.Linq.XDocument.Parse" />
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XDocument.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xDocument.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>