<Type Name="Extensions" FullName="System.Xml.Schema.Extensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8d2c8239fcc407f8953d07a9771bf66edb9113c8" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58746145" /></Metadata><TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Schema.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>이 클래스에는 XSD 유효성 검사에 대한 LINQ to XML 확장 메서드가 포함됩니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 또한이 클래스는 유효성이 검사 된 XML 노드의 스키마 유효성 검사 이후 정보 PSVI ()를 가져오는 메서드를 포함 합니다.  
  
 유효성을 검사할 때 프로그램 <xref:System.Xml.Linq.XDocument>, <xref:System.Xml.Linq.XElement>, 또는 <xref:System.Xml.Linq.XAttribute>, 스키마 유효성 검사 이후 정보 집합을 사용 하 여 XML 트리를 채울 수도 있습니다. PSVI 정보가 형식의 주석으로 추가 됩니다 <xref:System.Xml.Schema.XmlSchemaInfo?displayProperty=nameWithType>합니다.  
  
   
  
## Examples  
 XSD [샘플 XSD 파일: Customers 및 Orders](https://msdn.microsoft.com/library/8b05efe3-cc5e-4c7b-b322-892dbda41687) XML 문서 유효성 검사에 사용할 수 있는 스키마가 들어 [샘플 XML 파일: Customers 및 Orders(LINQ to XML)](https://msdn.microsoft.com/library/26790c41-5976-4558-a096-d0f67bfc4d92). 다음 예제에서는 스키마 및 문서 로드 된 문서의 유효성을 검사, 문서를 변경 하는 `xs:key` 및 `xs:keyref` 관계 유효 하지 않은 한 다음 유효성 검사를 다시 시도 합니다.  
  
```csharp  
  
                XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", "CustomersOrders.xsd");  
  
XDocument custOrd = XDocument.Load("CustomersOrders.xml");  
  
Console.WriteLine("Validating custOrd");  
bool errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
  
// Modify the custOrd tree so that it is no longer valid.  
custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA";  
  
Console.WriteLine();  
Console.WriteLine("Validating custOrd");  
errors = false;  
custOrd.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("custOrd {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", "CustomersOrders.xsd")  
  
    Console.WriteLine("Validating custOrd")  
    Dim custOrd As XDocument = XDocument.Load("CustomersOrders.xml")  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating custOrd")  
    ' Modify the source document so that it will not validate.  
    custOrd.Root.Element("Orders").Element("Order").Element("CustomerID").Value = "AAAAA"  
    errors = False  
    custOrd.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("custOrd {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating custOrd  
custOrd validated  
  
Validating custOrd  
The key sequence 'AAAAA' in Keyref fails to refer to some key.  
custOrd did not validate  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetSchemaInfo">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>유효성이 검사된 노드의 PSVI(스키마 유효성 검사 이후 정보 집합)를 가져옵니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 유효성을 검사 한 후는 <xref:System.Xml.Linq.XDocument>에 스키마 유효성 검사 이후 정보 집합에 대 한 검색할 수 있습니다는 <xref:System.Xml.Linq.XElement> 또는 <xref:System.Xml.Linq.XAttribute> 문서에 포함 된 합니다.  
  
 검색 한 후 합니다 <xref:System.Xml.Schema.IXmlSchemaInfo> 개체를 사용할 수는 <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> 또는 <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> 부분 유효성 검사 형식을 가져올 속성 (<xref:System.Xml.Schema.XmlSchemaElement> 또는 <xref:System.Xml.Schema.XmlSchemaAttribute>). 부분 유효성 검사 형식 특성 또는 하위 트리의 유효성 검사에 사용할 수 있습니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XAttribute source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XAttribute source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XAttribute)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XAttribute) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XAttribute ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XAttribute -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">이전에 유효성을 검사한 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</param>
        <summary>유효성이 검사된 특성의 PSVI(스키마 유효성 검사 이후 정보 집합)를 가져옵니다.</summary>
        <returns><see cref="T:System.Xml.Schema.IXmlSchemaInfo" />에 대한 스키마 유효성 검사 이후 정보 집합이 포함된 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Xml.Schema.IXmlSchemaInfo> 유효성이 검사 된 특성의 특정 특성을 결정이 메서드에서 반환 합니다. 예를 들어 XSD의 기본 특성 값에서 가져왔는지 확인할 수 있습니다.  
  
 사용 된 <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaAttribute%2A> 부분 유효성 검사 유형을 가져올 속성 (<xref:System.Xml.Schema.XmlSchemaAttribute>). 전체 문서 유효성 검사 하지 않고 특성을 유효성 검사를 사용할 수 있습니다.  
  
 이 속성의 예제를 참조 하세요. <xref:System.Xml.Schema.Extensions.Validate%2A>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaInfo">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo (this System.Xml.Linq.XElement source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.IXmlSchemaInfo GetSchemaInfo(class System.Xml.Linq.XElement source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.GetSchemaInfo(System.Xml.Linq.XElement)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetSchemaInfo (source As XElement) As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Schema::IXmlSchemaInfo ^ GetSchemaInfo(System::Xml::Linq::XElement ^ source);" />
      <MemberSignature Language="F#" Value="static member GetSchemaInfo : System.Xml.Linq.XElement -&gt; System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.Schema.Extensions.GetSchemaInfo source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">이전에 유효성을 검사한 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <summary>유효성이 검사된 요소의 PSVI(스키마 유효성 검사 이후 정보 집합)를 가져옵니다.</summary>
        <returns><see cref="T:System.Xml.Schema.IXmlSchemaInfo" />에 대한 PSVI(스키마 유효성 검사 이후 정보 집합)가 포함된 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용할 수는 <xref:System.Xml.Schema.IXmlSchemaInfo> 유효성이 검사 된 요소의 특정 특성을 확인 하려면이 메서드에서 반환 합니다. 예를 들어, 요소의 동적 스키마 형식을 확인할 수 있습니다.  
  
 사용 된 <xref:System.Xml.Schema.IXmlSchemaInfo.SchemaElement%2A> 부분 유효성 검사 유형을 가져올 속성 (<xref:System.Xml.Schema.XmlSchemaElement>). 하위 트리의 루트 요소를 사용 하 여 전체 문서 유효성 검사 하지 않고 유효성 검사를 사용할 수 있습니다.  
  
 이 속성의 예제를 참조 하세요. <xref:System.Xml.Schema.Extensions.Validate%2A>합니다.  
  
   
  
## Examples  
 다음 예제에서는 PSVI 사용 하 여 트리를 채웁니다. 유효성 검사 후 모든 특성과 해당 요소 트리의 PSVI에 따라 유효 하지 않은 출력 합니다.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
         @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
   <xsd:simpleType name='GCType'>  
    <xsd:restriction base='xsd:token'>  
     <xsd:enumeration value='AAA'/>  
     <xsd:enumeration value='BBB'/>  
    </xsd:restriction>  
   </xsd:simpleType>  
   <xsd:element name='Root'>  
    <xsd:complexType>  
     <xsd:sequence>  
      <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
       <xsd:complexType>  
        <xsd:sequence>  
         <xsd:element name='GrandChild1' type='GCType'/>  
         <xsd:element name='GrandChild2' type='GCType'/>  
         <xsd:element name='GrandChild3' type='GCType'/>  
        </xsd:sequence>  
       </xsd:complexType>  
      </xsd:element>  
     </xsd:sequence>  
    </xsd:complexType>  
   </xsd:element>  
  </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
                <xsd:enumeration value='AAA'/>  
                <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
        </xsd:simpleType>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:sequence>  
                                <xsd:element name='GrandChild1' type='GCType'/>  
                                <xsd:element name='GrandChild2' type='GCType'/>  
                                <xsd:element name='GrandChild3' type='GCType'/>  
                            </xsd:sequence>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>  
            <GrandChild1>AAA</GrandChild1>  
            <GrandChild2>ZZZ</GrandChild2>  
            <GrandChild3>ZZZ</GrandChild3>  
        </Child1>  
    </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xml.Linq.XDocument" />, <see cref="T:System.Xml.Linq.XElement" /> 또는 <see cref="T:System.Xml.Linq.XAttribute" />가 <see cref="T:System.Xml.Schema.XmlSchemaSet" />에서 XSD를 준수하는지 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 메서드는 내부 사용 <xref:System.Xml.XmlReader> XSD에 대해 XML 트리의 유효성을 검사할 합니다.  
  
 유효성 검사 오류 및 경고 메시지를 사용 하 여 처리 되는 <xref:System.Xml.Schema.ValidationEventHandler> 위임 합니다. 유효성 검사 오류도 노출 된 이벤트 처리기를 이러한 메서드에 제공 하는 경우는 <xref:System.Xml.Schema.XmlSchemaValidationException>합니다. 유효성 검사 경고 발생 하지는 <xref:System.Xml.Schema.XmlSchemaValidationException> throw 됩니다.  
  
 이러한 확장 메서드 중 일부는 필요에 따라 스키마 유효성 검사 이후 정보 집합 (PSVI)의 채우기를 허용합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <summary>이 메서드는 <see cref="T:System.Xml.Linq.XDocument" />가 <see cref="T:System.Xml.Schema.XmlSchemaSet" />에서 XSD를 준수하는지 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 확장 메서드는 유효성을 검사 합니다 <xref:System.Xml.Linq.XDocument> 스키마 콘텐츠 모델에 대 한 준수 <xref:System.Xml.Schema.XmlSchemaSet>합니다.  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Xml.Schema.XmlSchemaSet>을 만든 다음 스키마 집합에 대해 두 <xref:System.Xml.Linq.XDocument> 개체의 유효성을 검사합니다. 문서 중 하나는 유효하고 다른 하나는 유효하지 않습니다.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child2", "content1")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     });  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'/>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child2>content2</Child2>  
    </Root>  
  
    Dim doc2 As XDocument = _  
    <?xml version='1.0'?>  
    <Root>  
        <Child1>content1</Child1>  
        <Child3>content1</Child3>  
    </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</param>
        <param name="partialValidationType">유효성을 검사할 하위 트리를 지정하는 <see cref="T:System.Xml.Schema.XmlSchemaObject" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <summary>이 메서드는 <see cref="T:System.Xml.Linq.XAttribute" />가 지정된 <see cref="T:System.Xml.Schema.XmlSchemaObject" /> 및 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 준수하는지 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 유효성을 검사 하는 <xref:System.Xml.Linq.XAttribute> 스키마를 준수 합니다. 일반적으로 특성을 수정 하 고 여전히 해당 스키마를 준수 하는지 확인 하려는 경우이 메서드를 사용 합니다. 전체 문서를 유효성을 검사할 수 있지만 특성만 유효성을 검사 하는 처리 시간이 적게 걸립니다.  
  
 전달 하는 경우 `null` 에 대 한 `validationEventHandler`,이 메서드는 유효성 검사 오류 시 예외가 발생 합니다. 유효성 검사 경고에는 예외가 발생 하지 않습니다.  
  
 인스턴스를 사용 하면 특성의 유효성을 검사할 <xref:System.Xml.Schema.XmlSchemaObject>합니다. 다양 한 방법으로이 인스턴스를 가져올 수 있습니다. 쉬운 아래와 같습니다.  
  
1.  문서 스키마를 준수 하는지 확인 합니다.  
  
2.  스키마 유효성 검사 이후 정보 집합 (PSVI) 호출 하 여 추가 된 <xref:System.Xml.Schema.Extensions.Validate%2A> 확장 메서드.  
  
3.  호출 된 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 확장 메서드를 구현 하는 개체 검색 <xref:System.Xml.Schema.IXmlSchemaInfo>합니다. 검색된 된 개체에서 가져올 수 있습니다는 <xref:System.Xml.Schema.XmlSchemaObject>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XElement>, 형식은 <xref:System.Xml.Schema.XmlSchemaElement>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XAttribute>, 형식은 <xref:System.Xml.Schema.XmlSchemaAttribute>합니다.  
  
 인스턴스를 만든 후는 <xref:System.Xml.Schema.XmlSchemaObject>, 특성의 유효성을 검사 하려면이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XAttribute("Lang", "C#")  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
XAttribute lang = doc1.Root.Attribute("Lang");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Lang attribute invalid according to the schema  
lang.Value = "VC";  
  
Console.WriteLine();  
Console.WriteLine("Validating Lang attribute ...");  
  
errors = false;  
lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
      <?xml version='1.0'?>  
      <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
          <xsd:element name='Root'>  
              <xsd:complexType>  
                  <xsd:simpleContent>  
                      <xsd:extension base='xsd:string'>  
                          <xsd:attribute name='Lang' use='required'>  
                              <xsd:simpleType>  
                                  <xsd:restriction base='xsd:token'>  
                                      <xsd:enumeration value='C#'/>  
                                      <xsd:enumeration value='VB'/>  
                                  </xsd:restriction>  
                              </xsd:simpleType>  
                          </xsd:attribute>  
                      </xsd:extension>  
                  </xsd:simpleContent>  
              </xsd:complexType>  
          </xsd:element>  
      </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Root.Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XDocument source, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XDocument source, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XDocument,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XDocument ^ source, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XDocument * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XDocument" RefType="this" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XDocument" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <param name="addSchemaInfo">PSVI(스키마 유효성 검사 이후 정보 집합)를 채울지 여부를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <summary><see cref="T:System.Xml.Linq.XDocument" />가 <see cref="T:System.Xml.Schema.XmlSchemaSet" />에서 XSD를 준수하는지 확인하고, 선택적으로 XML 트리를 PSVI(스키마 유효성 검사 이후 정보 집합)로 채울 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 확장 메서드는 유효성을 검사 합니다 <xref:System.Xml.Linq.XDocument> 스키마 콘텐츠 모델에 대 한 준수 <xref:System.Xml.Schema.XmlSchemaSet>합니다.  
  
 하는 경우 `addSchemaInfo` 는 `true`,이 메서드는 스키마 유효성 검사 이후 정보 집합 (PSVI)를 사용 하 여 XML 트리를 채웁니다.  
  
 XML 트리를 PSVI에는 다음과 같은 두 단계가 있습니다.  
  
1.  첫째, 주석의 호출할 수 있도록 트리의 모든 노드에 추가 됩니다 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> 또는 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> 요소 또는 트리에서 특성입니다.  
  
2.  둘째, 기본 요소 및 XSD에 정의 된 특성을 XML 트리에 추가 됩니다. 중 하나를 호출 하 여는 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 메서드 경우 특정 요소 또는 특성으로 추가 된 XSD에서 기본 요소 또는 특성을 확인할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에 정의 하는 XSD의 `Child2` 요소는 `Att1` 기본값을 사용 하 여 특성입니다. 문서의 유효성을 검사 한 후 기본값을 사용 하 여 특성을 XML 트리에 추가 됩니다. 기본 특성이 없는 참고 추가할 `doc2`, 스키마에 대해 유효성을 검사 하지 않습니다.  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                           {  
                               Console.WriteLine("{0}", e.Message);  
                               errors = true;  
                           }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
        <xsd:element name='Root'>  
            <xsd:complexType>  
                <xsd:sequence>  
                    <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                    <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                        <xsd:complexType>  
                            <xsd:simpleContent>  
                                <xsd:extension base='xsd:string'>  
                                    <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                </xsd:extension>  
                            </xsd:simpleContent>  
                        </xsd:complexType>  
                    </xsd:element>  
                </xsd:sequence>  
            </xsd:complexType>  
        </xsd:element>  
    </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>c1</Child1>  
                                <Child2>c2</Child2>  
                            </Root>  
    Dim doc2 As XDocument = <?xml version='1.0'?>  
                            <Root>  
                                <Child1>content1</Child1>  
                                <Child3>content1</Child3>  
                            </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 다음 예제에서는 트리를 채웁니다. 유효성 검사 후 모든 특성과 해당 요소 트리의 PSVI에 따라 유효 하지 않은 출력 합니다.  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
   string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
           <xsd:simpleType name='GCType'>  
            <xsd:restriction base='xsd:token'>  
             <xsd:enumeration value='AAA'/>  
             <xsd:enumeration value='BBB'/>  
            </xsd:restriction>  
           </xsd:simpleType>  
           <xsd:element name='Root'>  
            <xsd:complexType>  
             <xsd:sequence>  
              <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
               <xsd:complexType>  
                <xsd:sequence>  
                 <xsd:element name='GrandChild1' type='GCType'/>  
                 <xsd:element name='GrandChild2' type='GCType'/>  
                 <xsd:element name='GrandChild3' type='GCType'/>  
                </xsd:sequence>  
               </xsd:complexType>  
              </xsd:element>  
             </xsd:sequence>  
            </xsd:complexType>  
           </xsd:element>  
          </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XElement("Child1",  
                new XElement("GrandChild1", "AAA"),  
                new XElement("GrandChild2", "ZZZ"),  
                new XElement("GrandChild3", "ZZZ")  
            )  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
        {  
            Console.WriteLine(e.Message);  
            errors = true;  
        }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:simpleType name='GCType'>  
                <xsd:restriction base='xsd:token'>  
                    <xsd:enumeration value='AAA'/>  
                    <xsd:enumeration value='BBB'/>  
                </xsd:restriction>  
            </xsd:simpleType>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' type='GCType'/>  
                                    <xsd:element name='GrandChild2' type='GCType'/>  
                                    <xsd:element name='GrandChild3' type='GCType'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>AAA</GrandChild1>  
                <GrandChild2>ZZZ</GrandChild2>  
                <GrandChild3>ZZZ</GrandChild3>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1 ...  
The 'GrandChild2' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
The 'GrandChild3' element is invalid - The value 'ZZZ' is invalid according to its datatype 'GCType' - The Enumeration constraint failed.  
doc1 did not validate  
Invalid Element /Root  
Invalid Element /Root/Child1  
Invalid Element /Root/Child1/GrandChild2  
Invalid Element /Root/Child1/GrandChild3  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="partialValidationType">유효성을 검사할 하위 트리를 지정하는 <see cref="T:System.Xml.Schema.XmlSchemaObject" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <summary>이 메서드는 <see cref="T:System.Xml.Linq.XElement" /> 하위 트리가 지정된 <see cref="T:System.Xml.Schema.XmlSchemaObject" /> 및 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 준수하는지 확인합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하위 트리의 유효성을 검사 하는이 메서드를 사용할 수 있습니다 (사용 하 여는 <xref:System.Xml.Linq.XElement> 루트) 스키마를 준수 합니다. 일반적으로 하위 트리를 수정 하 고 여전히 해당 스키마를 준수 하는지 확인 하려는 경우이 메서드를 사용 합니다. 전체 문서를 유효성을 검사할 수 있지만에 처리 시간이 적게 걸립니다 하위 트리.  
  
 전달 하는 경우 `null` 에 대 한 `validationEventHandler`,이 메서드를 유효성 검사 오류에 예외를 발생 시킵니다. 유효성 검사 경고에는 예외가 발생 하지 않습니다.  
  
 인스턴스를 사용 하면 하위 트리의 유효성을 검사할 <xref:System.Xml.Schema.XmlSchemaObject>합니다. 다양 한 방법으로이 인스턴스를 가져올 수 있습니다. 쉬운 아래와 같습니다.  
  
1.  문서 스키마를 준수 하는지 확인 합니다.  
  
2.  스키마 유효성 검사 이후 정보 집합 (PSVI) 호출 하 여 추가 된 <xref:System.Xml.Schema.Extensions.Validate%2A> 확장 메서드.  
  
3.  호출 된 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 확장 메서드를 구현 하는 개체 검색 <xref:System.Xml.Schema.IXmlSchemaInfo>합니다. 검색된 된 개체에서 가져올 수 있습니다는 <xref:System.Xml.Schema.XmlSchemaObject>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XElement>, 형식은 <xref:System.Xml.Schema.XmlSchemaElement>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XAttribute>, 형식은 <xref:System.Xml.Schema.XmlSchemaAttribute>합니다.  
  
 인스턴스를 만든 후는 <xref:System.Xml.Schema.XmlSchemaObject>에 하위 트리의 유효성을 검사할이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:sequence>  
             <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
             <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
            </xsd:sequence>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1",  
            new XElement("GrandChild1", "gc"),  
            new XElement("GrandChild2", "gc")  
        )  
    )  
);  
  
Console.WriteLine("Validating doc1 ...");  
bool errors = false;  
doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after first edit ...");  
XElement child1 = doc1.Element("Root").Element("Child1");  
child1.Add(new XElement("GrandChild2", "gc"));  
errors = false;  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
  
// the following makes the Child1 element invalid according to the schema  
child1.Add(new XElement("GrandChild3", "gc"));  
Console.WriteLine();  
Console.WriteLine("Validating Child1 after second edit ...");  
child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    });  
Console.WriteLine("child1 {0}", errors ? "did not validate" : "validated");  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:sequence>  
                                    <xsd:element name='GrandChild1' minOccurs='1' maxOccurs='1'/>  
                                    <xsd:element name='GrandChild2' minOccurs='1' maxOccurs='2'/>  
                                </xsd:sequence>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>  
                <GrandChild1>gc</GrandChild1>  
                <GrandChild2>gc</GrandChild2>  
            </Child1>  
        </Root>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after first edit ...")  
    Dim child1 As XElement = doc1.Element("Root").Element("Child1")  
    child1.Add(<GrandChild2>gc</GrandChild2>)  
    errors = False  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
  
    ' the following makes the Child1 element invalid according to the schema  
    child1.Add(<GrandChild3>gc</GrandChild3>)  
    Console.WriteLine()  
    Console.WriteLine("Validating Child1 after second edit ...")  
    child1.Validate(child1.GetSchemaInfo().SchemaElement, schemas, AddressOf XSDErrors)  
    Console.WriteLine("child1 {0}", IIf(errors, "did not validate", "validated"))  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Child1 after first edit ...  
child1 validated  
  
Validating Child1 after second edit ...  
The element 'Child1' has invalid child element 'GrandChild3'.  
child1 did not validate  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XAttribute source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XAttribute source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XAttribute,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XAttribute ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XAttribute * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XAttribute" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XAttribute" />입니다.</param>
        <param name="partialValidationType">유효성을 검사할 하위 트리를 지정하는 <see cref="T:System.Xml.Schema.XmlSchemaObject" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <param name="addSchemaInfo">PSVI(스키마 유효성 검사 이후 정보 집합)를 채울지 여부를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <summary><see cref="T:System.Xml.Linq.XAttribute" />가 지정된 <see cref="T:System.Xml.Schema.XmlSchemaObject" /> 및 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 준수하는지 확인하고, 선택적으로 XML 트리를 PSVI(스키마 유효성 검사 이후 정보 집합)로 채울 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드를 사용 하 여 유효성을 검사 하는 <xref:System.Xml.Linq.XAttribute> 스키마를 준수 합니다. 일반적으로 특성을 수정 하 고 여전히 해당 스키마를 준수 하는지 확인 하려는 경우이 메서드를 사용 합니다. 전체 문서를 유효성을 검사할 수 있지만 특성만 유효성을 검사 하는 처리 시간이 적게 걸립니다.  
  
 하는 경우 `addSchemaInfo` 는 `true`,이 메서드는 스키마 유효성 검사 이후 정보 집합 (PSVI)를 사용 하 여 특성을 채웁니다. PSVI 사용 하 여 XML 트리를 채운 후 호출할 수 있습니다 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A?displayProperty=nameWithType> 유효성이 검사 된 특성입니다. 반환 된 데이터를 사용 하는 코드를 작성 하는 경우에 유용 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A>합니다.  
  
 전달 하는 경우 `null` 에 대 한 `validationEventHandler`,이 메서드를 유효성 검사 오류에 예외를 발생 시킵니다. 유효성 검사 경고에는 예외가 발생 하지 않습니다.  
  
 인스턴스를 사용 하면 특성의 유효성을 검사할 <xref:System.Xml.Schema.XmlSchemaObject>합니다. 다양 한 방법으로이 인스턴스를 가져올 수 있습니다. 쉬운 아래와 같습니다.  
  
1.  문서 스키마를 준수 하는지 확인 합니다.  
  
2.  스키마 유효성 검사 이후 정보 집합 (PSVI) 호출 하 여 추가 된 <xref:System.Xml.Schema.Extensions.Validate%2A> 확장 메서드.  
  
3.  호출 된 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 확장 메서드를 구현 하는 개체 검색 <xref:System.Xml.Schema.IXmlSchemaInfo>합니다. 검색된 된 개체에서 가져올 수 있습니다는 <xref:System.Xml.Schema.XmlSchemaObject>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XElement>, 형식은 <xref:System.Xml.Schema.XmlSchemaElement>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XAttribute>, 형식은 <xref:System.Xml.Schema.XmlSchemaAttribute>합니다.  
  
 인스턴스를 만든 후는 <xref:System.Xml.Schema.XmlSchemaObject>, 특성의 유효성을 검사 하려면이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
  
```csharp  
  
                static void DumpInvalidNodes(XElement el)  
{  
    if (el.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
        Console.WriteLine("Invalid Element {0}",  
            el.AncestorsAndSelf()  
            .InDocumentOrder()  
            .Aggregate("", (s, i) => s + "/" + i.Name.ToString()));  
    foreach (XAttribute att in el.Attributes())  
        if (att.GetSchemaInfo().Validity != XmlSchemaValidity.Valid)  
            Console.WriteLine("Invalid Attribute {0}",  
                att  
                .Parent  
                .AncestorsAndSelf()  
                .InDocumentOrder()  
                .Aggregate("",  
                    (s, i) => s + "/" + i.Name.ToString()) + "/@" + att.Name.ToString()  
                );  
    foreach (XElement child in el.Elements())  
        DumpInvalidNodes(child);  
}  
  
static void Main(string[] args)  
{  
    string xsdMarkup =  
        @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:simpleContent>  
          <xsd:extension base='xsd:string'>  
           <xsd:attribute name='Lang' use='required'>  
            <xsd:simpleType>  
             <xsd:restriction base='xsd:token'>  
              <xsd:enumeration value='C#'/>  
              <xsd:enumeration value='VB'/>  
             </xsd:restriction>  
            </xsd:simpleType>  
           </xsd:attribute>  
          </xsd:extension>  
         </xsd:simpleContent>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
  
    XmlSchemaSet schemas = new XmlSchemaSet();  
    schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
    XDocument doc1 = new XDocument(  
        new XElement("Root",  
            new XAttribute("Lang", "C#")  
        )  
    );  
  
    Console.WriteLine("Validating doc1 ...");  
    bool errors = false;  
    doc1.Validate(schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
    XAttribute lang = doc1.Element("Root").Attribute("Lang");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
  
    // the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC";  
  
    Console.WriteLine();  
    Console.WriteLine("Validating Lang attribute ...");  
  
    errors = false;  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, (sender, e) =>  
    {  
        Console.WriteLine(e.Message);  
        errors = true;  
    }, true);  
    Console.WriteLine("lang {0}", errors ? "did not validate" : "validated");  
    DumpInvalidNodes(doc1.Root);  
}  
```  
  
```vb  
  
                Private Sub DumpInvalidNodes(ByVal el As XElement)  
    If el.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
        Console.WriteLine("Invalid Element {0}", _  
            el _  
            .AncestorsAndSelf _  
            .InDocumentOrder() _  
            .Aggregate("", _  
                Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()))  
    End If  
    For Each att As XAttribute In el.Attributes()  
        If att.GetSchemaInfo.Validity <> XmlSchemaValidity.Valid Then  
            Console.WriteLine("Invalid Attribute {0}", _  
                att _  
                .Parent _  
                .AncestorsAndSelf() _  
                .InDocumentOrder() _  
                .Aggregate("", _  
                    Function(ByVal s, ByVal i) s + "/" + i.Name.ToString()) + _  
                    "/@" + att.Name.ToString())  
        End If  
    Next  
    For Each child As XElement In el.Elements()  
        DumpInvalidNodes(child)  
    Next  
End Sub  
  
Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:simpleContent>  
                        <xsd:extension base='xsd:string'>  
                            <xsd:attribute name='Lang' use='required'>  
                                <xsd:simpleType>  
                                    <xsd:restriction base='xsd:token'>  
                                        <xsd:enumeration value='C#'/>  
                                        <xsd:enumeration value='VB'/>  
                                    </xsd:restriction>  
                                </xsd:simpleType>  
                            </xsd:attribute>  
                        </xsd:extension>  
                    </xsd:simpleContent>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = <?xml version='1.0'?>  
                            <Root Lang='C#'/>  
  
    Console.WriteLine("Validating doc1 ...")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
    Dim lang As XAttribute = doc1.Element("Root").Attribute("Lang")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
  
    ' the following makes the Lang attribute invalid according to the schema  
    lang.Value = "VC"  
  
    Console.WriteLine()  
    Console.WriteLine("Validating Lang attribute ...")  
  
    errors = False  
    lang.Validate(lang.GetSchemaInfo().SchemaAttribute, schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("lang {0}", IIf(errors, "did not validate", "validated"))  
    DumpInvalidNodes(doc1.Root)  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1 ...  
doc1 validated  
  
Validating Lang attribute ...  
lang validated  
  
Validating Lang attribute ...  
The 'Lang' attribute is invalid - The value 'VC' is invalid according to its datatype 'Token' - The Enumeration constraint failed.  
lang did not validate  
Invalid Attribute /Root/@Lang  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public static void Validate (this System.Xml.Linq.XElement source, System.Xml.Schema.XmlSchemaObject partialValidationType, System.Xml.Schema.XmlSchemaSet schemas, System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Validate(class System.Xml.Linq.XElement source, class System.Xml.Schema.XmlSchemaObject partialValidationType, class System.Xml.Schema.XmlSchemaSet schemas, class System.Xml.Schema.ValidationEventHandler validationEventHandler, bool addSchemaInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Schema.Extensions.Validate(System.Xml.Linq.XElement,System.Xml.Schema.XmlSchemaObject,System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void Validate(System::Xml::Linq::XElement ^ source, System::Xml::Schema::XmlSchemaObject ^ partialValidationType, System::Xml::Schema::XmlSchemaSet ^ schemas, System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, bool addSchemaInfo);" />
      <MemberSignature Language="F#" Value="static member Validate : System.Xml.Linq.XElement * System.Xml.Schema.XmlSchemaObject * System.Xml.Schema.XmlSchemaSet * System.Xml.Schema.ValidationEventHandler * bool -&gt; unit" Usage="System.Xml.Schema.Extensions.Validate (source, partialValidationType, schemas, validationEventHandler, addSchemaInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Xml.Linq.XElement" RefType="this" />
        <Parameter Name="partialValidationType" Type="System.Xml.Schema.XmlSchemaObject" />
        <Parameter Name="schemas" Type="System.Xml.Schema.XmlSchemaSet" />
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="addSchemaInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">유효성을 검사할 <see cref="T:System.Xml.Linq.XElement" />입니다.</param>
        <param name="partialValidationType">유효성을 검사할 하위 트리를 지정하는 <see cref="T:System.Xml.Schema.XmlSchemaObject" />입니다.</param>
        <param name="schemas">유효성을 검사할 <see cref="T:System.Xml.Schema.XmlSchemaSet" />입니다.</param>
        <param name="validationEventHandler">판독기에서 유효성 검사 오류를 발견했을 때 수행되는 이벤트의 <see cref="T:System.Xml.Schema.ValidationEventHandler" />입니다. <see langword="null" />인 경우 유효성 검사 오류가 있을 때 예외가 throw됩니다.</param>
        <param name="addSchemaInfo">PSVI(스키마 유효성 검사 이후 정보 집합)를 채울지 여부를 나타내는 <see cref="T:System.Boolean" />입니다.</param>
        <summary><see cref="T:System.Xml.Linq.XElement" /> 하위 트리가 지정된 <see cref="T:System.Xml.Schema.XmlSchemaObject" /> 및 <see cref="T:System.Xml.Schema.XmlSchemaSet" />을 준수하는지 확인하고, 선택적으로 XML 트리를 PSVI(스키마 유효성 검사 이후 정보 집합)로 채울 수 있습니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하위 트리의 유효성을 검사 하는이 메서드를 사용할 수 있습니다 (사용 하 여는 <xref:System.Xml.Linq.XElement> 하위 트리의 루트로) 스키마를 준수 합니다. 일반적으로 하위 트리를 수정 하 고 여전히 해당 스키마를 준수 하는지 확인 하려는 경우이 메서드를 사용 합니다. 전체 문서를 유효성을 검사할 수 있지만에 처리 시간이 적게 걸립니다 하위 트리.  
  
 하는 경우 `addSchemaInfo` 는 `true`, 다음이 메서드는 스키마 유효성 검사 이후 정보 집합 (PSVI)를 사용 하 여 XML 트리를 채웁니다.  
  
 PSVI 사용 하 여 XML 트리를 채우는 방법은 두 가지 측면이 있습니다.  
  
 먼저 주석을 추가할 트리의 모든 노드는 이제 호출할 수 있습니다 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 요소 또는 트리에서 특성입니다.  
  
 둘째, 기본 요소 및 XSD에 정의 된 특성을 XML 트리에 추가 됩니다. 중 하나를 호출 하 여는 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 메서드 경우 특정 요소 또는 특성으로 추가 된 XSD에서 기본 요소 또는 특성을 확인할 수 있습니다.  
  
 전달 하는 경우 `null` 에 대 한 `validationEventHandler`,이 메서드를 유효성 검사 오류에 예외를 발생 시킵니다. 유효성 검사 경고에는 예외가 발생 하지 않습니다.  
  
 인스턴스를 사용 하면 하위 트리의 유효성을 검사할 <xref:System.Xml.Schema.XmlSchemaObject>합니다. 다양 한 방법으로이 인스턴스를 가져올 수 있습니다. 쉬운 아래와 같습니다.  
  
1.  문서 스키마를 준수 하는지 확인 합니다.  
  
2.  스키마 유효성 검사 이후 정보 집합 (PSVI) 호출 하 여 추가 된 <xref:System.Xml.Schema.Extensions.Validate%2A> 확장 메서드.  
  
3.  호출 된 <xref:System.Xml.Schema.Extensions.GetSchemaInfo%2A> 확장 메서드를 구현 하는 개체 검색 <xref:System.Xml.Schema.IXmlSchemaInfo>합니다. 검색된 된 개체에서 가져올 수 있습니다는 <xref:System.Xml.Schema.XmlSchemaObject>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XElement>, 형식은 <xref:System.Xml.Schema.XmlSchemaElement>합니다.  
  
    -   표시 되 면를 <xref:System.Xml.Schema.XmlSchemaObject> 에 대 한는 <xref:System.Xml.Linq.XAttribute>, 형식은 <xref:System.Xml.Schema.XmlSchemaAttribute>합니다.  
  
 인스턴스를 만든 후는 <xref:System.Xml.Schema.XmlSchemaObject>,이 메서드를 사용 하 여 하위 트리의 유효성을 검사할 수 있습니다...  
  
   
  
## Examples  
  
```csharp  
  
                string xsdMarkup =  
    @"<xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
       <xsd:element name='Root'>  
        <xsd:complexType>  
         <xsd:sequence>  
          <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
          <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
           <xsd:complexType>  
            <xsd:simpleContent>  
             <xsd:extension base='xsd:string'>  
              <xsd:attribute name='Att1' default='Att1 Default Value'/>  
             </xsd:extension>  
            </xsd:simpleContent>  
           </xsd:complexType>  
          </xsd:element>  
         </xsd:sequence>  
        </xsd:complexType>  
       </xsd:element>  
      </xsd:schema>";  
XmlSchemaSet schemas = new XmlSchemaSet();  
schemas.Add("", XmlReader.Create(new StringReader(xsdMarkup)));  
  
XDocument doc1 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "c1"),  
        new XElement("Child2", "c2")  
    )  
);  
  
XDocument doc2 = new XDocument(  
    new XElement("Root",  
        new XElement("Child1", "content1"),  
        new XElement("Child3", "content1")  
    )  
);  
  
Console.WriteLine("Validating doc1");  
bool errors = false;  
doc1.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc1 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Validating doc2");  
errors = false;  
doc2.Validate(schemas, (o, e) =>  
                     {  
                         Console.WriteLine("{0}", e.Message);  
                         errors = true;  
                     }, true);  
Console.WriteLine("doc2 {0}", errors ? "did not validate" : "validated");  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc1:");  
Console.WriteLine(doc1);  
  
Console.WriteLine();  
Console.WriteLine("Contents of doc2:");  
Console.WriteLine(doc2);  
```  
  
```vb  
  
                Dim errors As Boolean = False  
  
Private Sub XSDErrors(ByVal o As Object, ByVal e As ValidationEventArgs)  
    Console.WriteLine("{0}", e.Message)  
    errors = True  
End Sub  
  
Sub Main()  
    Dim xsdMarkup As XDocument = _  
        <?xml version='1.0'?>  
        <xsd:schema xmlns:xsd='http://www.w3.org/2001/XMLSchema'>  
            <xsd:element name='Root'>  
                <xsd:complexType>  
                    <xsd:sequence>  
                        <xsd:element name='Child1' minOccurs='1' maxOccurs='1'/>  
                        <xsd:element name='Child2' minOccurs='1' maxOccurs='1'>  
                            <xsd:complexType>  
                                <xsd:simpleContent>  
                                    <xsd:extension base='xsd:string'>  
                                        <xsd:attribute name='Att1' default='Att1 Default Value'/>  
                                    </xsd:extension>  
                                </xsd:simpleContent>  
                            </xsd:complexType>  
                        </xsd:element>  
                    </xsd:sequence>  
                </xsd:complexType>  
            </xsd:element>  
        </xsd:schema>  
    Dim schemas As XmlSchemaSet = New XmlSchemaSet()  
    schemas.Add("", xsdMarkup.CreateReader)  
  
    Dim doc1 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>c1</Child1>  
            <Child2>c2</Child2>  
        </Root>  
  
    Dim doc2 As XDocument = _  
        <?xml version='1.0'?>  
        <Root>  
            <Child1>content1</Child1>  
            <Child3>content1</Child3>  
        </Root>  
  
    Console.WriteLine("Validating doc1")  
    errors = False  
    doc1.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc1 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Validating doc2")  
    errors = False  
    doc2.Validate(schemas, AddressOf XSDErrors, True)  
    Console.WriteLine("doc2 {0}", IIf(errors, "did not validate", "validated"))  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc1:")  
    Console.WriteLine(doc1)  
  
    Console.WriteLine()  
    Console.WriteLine("Contents of doc2:")  
    Console.WriteLine(doc2)  
End Sub  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
Validating doc1  
doc1 validated  
  
Validating doc2  
The element 'Root' has invalid child element 'Child3'. List of possible elements expected: 'Child2'.  
doc2 did not validate  
  
Contents of doc1:  
<Root>  
  <Child1>c1</Child1>  
  <Child2 Att1="Att1 Default Value">c2</Child2>  
</Root>  
  
Contents of doc2:  
<Root>  
  <Child1>content1</Child1>  
  <Child3>content1</Child3>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">XSD(XML 스키마 정의) 언어 유효성 검사 오류가 발생한 경우 throw됩니다.</exception>
      </Docs>
    </Member>
  </Members>
</Type>