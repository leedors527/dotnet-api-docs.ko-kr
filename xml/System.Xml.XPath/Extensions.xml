<Type Name="Extensions" FullName="System.Xml.XPath.Extensions">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b79063567bf75ecfa5cc60673943bcdae45fe703" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ko-KR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36438712" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XPath.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>이 클래스에는 XPath 식을 평가할 수 있는 LINQ to XML 확장 메서드가 들어 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이러한 메서드를 사용 하기 위한 몇 가지 성능 저하가 됩니다. 사용 하 여 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] 쿼리 하면 성능이 향상 됩니다.  
  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Xml.XPath.XPathNavigator" />에 대해 <see cref="T:System.Xml.Linq.XNode" />를 만듭니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 XML 트리를 편집할 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 이 메서드가 반환 됩니다. <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 속성이 `false`를 반환합니다.  
  
 만들 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 에 대 한는 <xref:System.Xml.Linq.XDocumentType> 노드. 문서 형식을 XPath 데이터 모델에 참여 하지 않습니다.  
  
 Namespace 선언 왼쪽에서 오른쪽으로 보고 됩니다. 반대로 <xref:System.Xml.XmlDocument> 네임 스페이스는 오른쪽에서 왼쪽으로 보고 됩니다. 네임 스페이스 선언을 XPath 데이터 모델에서 정렬 되어 있지 않으므로 이것이 준수 동작입니다.  
  
 메서드가 <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> 이 메서드에 의해 반환 되는 탐색기에 지원 되지 않습니다.  
  
 XSLT 변환을 수행 하려면이 메서드를 사용할 수 있습니다. XML 트리를 만들고, 만들 수 있습니다는 <xref:System.Xml.XPath.XPathNavigator> XML 트리를 만든 다음 새 문서를 만들고는 <xref:System.Xml.XmlWriter> 새 문서에 쓸입니다. 그런 다음 <xref:System.Xml.XPath.XPathNavigator> 및 <xref:System.Xml.XmlWriter>를 변환에 전달하여 XSLT 변환을 호출할 수 있습니다. 변환이 성공적으로 완료된 후 새 XML 트리가 변환의 결과로 채워집니다.  
  
 XSLT 변환을 수행 하려면 사용할 수 있습니다는 <xref:System.Xml.XmlReader> 또는 <xref:System.Xml.XPath.XPathNavigator>합니다. 방법은 다음 두 가지 서로 다른 성능 특징을 갖습니다. 사용 하는 경우 일부 변환 더 빠르게 실행 됩니다는 <xref:System.Xml.XmlReader>를 사용할 때 더 빠르게 실행 됩니다 다른 사용자는 <xref:System.Xml.XPath.XPathNavigator>합니다. 성능이 중요 하지 않은 경우에 사용자 환경에서 더 잘 수행 되는 확인 하려면 각 접근 방식으로 실험 하는 것이 좋습니다.  
  
```csharp  
  
            string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
            Dim xslMarkup As XDocument = <?xml version='1.0'?>  
                             <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
                                 <xsl:template match='/Parent'>  
                                     <Root>  
                                         <C1><xsl:value-of select='Child1'/></C1>  
                                         <C2><xsl:value-of select='Child2'/></C2>  
                                     </Root>  
                                 </xsl:template>  
                             </xsl:stylesheet>  
  
Dim xmlTree As XDocument = <?xml version='1.0'?>  
                           <Parent>  
                               <Child1>Child1 data</Child1>  
                               <Child2>Child2 data</Child2>  
                           </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
  
            <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node">XPath 쿼리를 처리할 수 있는 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.XPath.XPathNavigator" />에 대해 <see cref="T:System.Xml.Linq.XNode" />를 만듭니다.</summary>
        <returns>XPath 쿼리를 처리할 수 있는 <see cref="T:System.Xml.XPath.XPathNavigator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 XML 트리를 편집할 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 이 메서드가 반환 됩니다. <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 속성이 `false`를 반환합니다.  
  
 만들 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 에 대 한는 <xref:System.Xml.Linq.XDocumentType> 노드. 문서 형식을 XPath 데이터 모델에 참여 하지 않습니다.  
  
 Namespace 선언 왼쪽에서 오른쪽으로 보고 됩니다. 반대로 <xref:System.Xml.XmlDocument> 네임 스페이스는 오른쪽에서 왼쪽으로 보고 됩니다. 네임 스페이스 선언을 XPath 데이터 모델에서 정렬 되어 있지 않으므로 이것이 준수 동작입니다.  
  
 메서드가 <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> 이 메서드에 의해 반환 되는 탐색기에 지원 되지 않습니다.  
  
 XSLT 변환을 수행 하려면이 메서드를 사용할 수 있습니다. XML 트리를 만들고, 만들 수 있습니다는 <xref:System.Xml.XPath.XPathNavigator> XML 트리를 만든 다음 새 문서를 만들고는 <xref:System.Xml.XmlWriter> 새 문서에 쓸입니다. 그런 다음 전달 하 여 XSLT 변형을 호출할 수 있습니다는 <xref:System.Xml.XPath.XPathNavigator> 및 <xref:System.Xml.XmlWriter> 변환 합니다. 변환이 성공적으로 완료된 후 새 XML 트리가 변환의 결과로 채워집니다.  
  
 XSLT 변환을 수행 하려면 사용할 수 있습니다는 <xref:System.Xml.XmlReader> 또는 <xref:System.Xml.XPath.XPathNavigator>합니다. 방법은 다음 두 가지 서로 다른 성능 특징을 갖습니다. 사용 하는 경우 일부 변환 더 빠르게 실행 됩니다는 <xref:System.Xml.XmlReader>를 사용할 때 더 빠르게 실행 됩니다 다른 사용자는 <xref:System.Xml.XPath.XPathNavigator>합니다. 성능이 중요 하지 않은 경우에 사용자 환경에서 더 잘 수행 되는 확인 하려면 각 접근 방식으로 실험 하는 것이 좋습니다.  
  
   
  
## Examples  
  
```csharp  
  
                string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
                Dim xslMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XDocument = _  
    <?xml version='1.0'?>  
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```xml  
  
                <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node, System.Xml.XmlNameTable nameTable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node, class System.Xml.XmlNameTable nameTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode, nameTable As XmlNameTable) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node, System::Xml::XmlNameTable ^ nameTable);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode * System.Xml.XmlNameTable -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator (node, nameTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="nameTable" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="node">XPath 쿼리를 처리할 수 있는 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="nameTable">
          <see cref="T:System.Xml.XmlNameTable" />에 사용할 <see cref="T:System.Xml.XPath.XPathNavigator" />입니다.</param>
        <summary>
          <see cref="T:System.Xml.XPath.XPathNavigator" />에 대해 <see cref="T:System.Xml.Linq.XNode" />를 만듭니다. <see cref="T:System.Xml.XmlNameTable" />을 사용하면 보다 효율적으로 XPath 식을 처리할 수 있습니다.</summary>
        <returns>XPath 쿼리를 처리할 수 있는 <see cref="T:System.Xml.XPath.XPathNavigator" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 사용 하 여 XML 트리를 편집할 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 이 메서드가 반환 됩니다. <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> 속성이 `false`를 반환합니다.  
  
 만들 수 없습니다는 <xref:System.Xml.XPath.XPathNavigator> 에 대 한는 <xref:System.Xml.Linq.XDocumentType> 노드. 문서 형식을 XPath 데이터 모델에 참여 하지 않습니다.  
  
 Namespace 선언 왼쪽에서 오른쪽으로 보고 됩니다. 반대로 <xref:System.Xml.XmlDocument> 네임 스페이스는 오른쪽에서 왼쪽으로 보고 됩니다. 네임 스페이스 선언을 XPath 데이터 모델에서 정렬 되어 있지 않으므로 이것이 준수 동작입니다.  
  
 메서드가 <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> 이 메서드에 의해 반환 되는 탐색기에 지원 되지 않습니다.  
  
 사용 하는 경우는 <xref:System.Xml.XmlNameTable> 를 만들려면이 메서드로 <xref:System.Xml.XPath.XPathNavigator>, 더 나은 성능을 XPath 식을 계산할 때 발생 합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathEvaluate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XPath 식을 평가합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <summary>XPath 식을 평가합니다.</summary>
        <returns>
          <see langword="bool" />, <see langword="double" />, <see langword="string" /> 또는 <see cref="T:System.Collections.Generic.IEnumerable`1" />을 포함할 수 있는 개체입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 컬렉션의 요소 또는 특성의 열거형 인 경우 사용할 수 있습니다는 `Cast` 연산자 컬렉션을 가져오는 <xref:System.Xml.Linq.XElement> 또는 <xref:System.Xml.Linq.XAttribute>합니다.  
  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
   
  
## Examples  
 다음 예제에서는 특성을 작은 XML 트리를 만든 다음 사용 하 여는 <xref:System.Xml.XPath.Extensions.XPathEvaluate%2A> 특성을 검색 하는 메서드.  
  
```csharp  
  
                String xml = "<root a='value'/>";  
XDocument d = XDocument.Parse(xml);  
IEnumerable att = (IEnumerable)d.XPathEvaluate("/root/@a");  
Console.WriteLine(att.Cast<XAttribute>().FirstOrDefault());  
```  
  
```vb  
  
                Dim d As XDocument = _  
    <?xml version='1.0'?>  
    <root a='value'/>  
Dim att As IEnumerable = CType(d.XPathEvaluate("/root/@a"), IEnumerable)  
Console.WriteLine(att.Cast(Of XAttribute)().FirstOrDefault())  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
a="value"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <param name="resolver">XPath 식의 네임스페이스 접두사에 대한 <see cref="T:System.Xml.IXmlNamespaceResolver" />입니다.</param>
        <summary>XPath 식을 평가하고 지정된 <see cref="T:System.Xml.IXmlNamespaceResolver" />를 사용하여 네임스페이스 접두사를 확인합니다.</summary>
        <returns>식 평가 결과가 들어 있는 개체입니다. 이 개체는 <see langword="bool" />, <see langword="double" />, <see langword="string" /> 또는 <see cref="T:System.Collections.Generic.IEnumerable`1" />일 수 있습니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네임 스페이스 접두사가 포함 된 XPath 식을 평가 하려면이 메서드를 사용할 수 있습니다.  
  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
   
  
## Examples  
 다음 예제에서는 네임 스페이스를 포함 하는 XML 트리를 만듭니다. 여기에서는 <xref:System.Xml.XmlReader>를 사용하여 XML 문서를 읽습니다. 그런 다음 <xref:System.Xml.XmlNameTable>에서 <xref:System.Xml.XmlReader>을 가져오고 <xref:System.Xml.XmlNamespaceManager>에서 <xref:System.Xml.XmlNameTable>를 가져옵니다. 사용 하 여는 <xref:System.Xml.XmlNamespaceManager> 요소를 선택할 때.  
  
```csharp  
  
                string markup =  
@"<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable atts = (IEnumerable)root.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager);  
IEnumerable<XAttribute> attList = atts.Cast<XAttribute>();  
XAttribute att = attList.First();  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim atts As IEnumerable = CType(markup.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager), IEnumerable)  
Dim attList As IEnumerable(Of XAttribute) = atts.Cast(Of XAttribute)()  
Dim att As XAttribute = attList.First()  
Console.WriteLine(att)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
aw:Att="attdata"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XPath 식을 사용하여 <see cref="T:System.Xml.Linq.XElement" />를 선택합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <summary>XPath 식을 사용하여 <see cref="T:System.Xml.Linq.XElement" />를 선택합니다.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" />이거나 null입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 작은 XML 트리를 만들고 사용 하 여 <xref:System.Xml.XPath.Extensions.XPathSelectElement%2A> 단일 요소를 선택 합니다.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
XElement el = root.XPathSelectElement("./Child4");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
        <Child6>6</Child6>  
    </Root>  
Dim el As XElement = root.XPathSelectElement("./Child4")  
Console.WriteLine(el)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<Child4>4</Child4>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <param name="resolver">XPath 식의 네임스페이스 접두사에 대한 <see cref="T:System.Xml.IXmlNamespaceResolver" />입니다.</param>
        <summary>XPath 식을 사용하여 <see cref="T:System.Xml.Linq.XElement" />를 선택하고 지정된 <see cref="T:System.Xml.IXmlNamespaceResolver" />를 사용하여 네임스페이스 접두사를 확인합니다.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" />이거나 null입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네임 스페이스 접두사가 포함 된 XPath 식을 평가 하려면이 메서드를 사용할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 네임 스페이스를 포함 하는 XML 트리를 만듭니다. 여기에서는 <xref:System.Xml.XmlReader>를 사용하여 XML 문서를 읽습니다. 그런 다음 <xref:System.Xml.XmlNameTable>에서 <xref:System.Xml.XmlReader>을 가져오고 <xref:System.Xml.XmlNamespaceManager>에서 <xref:System.Xml.XmlNameTable>를 가져옵니다. 사용 하 여는 <xref:System.Xml.XmlNamespaceManager> 요소를 선택할 때.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data</aw:Child1>  
    <aw:Child2>child two data</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
XElement child1 = root.XPathSelectElement("./aw:Child1", namespaceManager);  
Console.WriteLine(child1);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1>child one data</aw:Child1>  
        <aw:Child2>child two data</aw:Child2>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim child1 As XElement = markup.XPathSelectElement("./aw:Child1", namespaceManager)  
Console.WriteLine(child1)  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XPath 식을 사용하여 요소 컬렉션을 선택합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <summary>XPath 식을 사용하여 요소 컬렉션을 선택합니다.</summary>
        <returns>선택된 요소가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
   
  
## Examples  
 다음 예제에서는 작은 XML 트리를 만들고 <xref:System.Xml.XPath.Extensions.XPathSelectElements%2A>를 사용하여 요소 집합을 선택합니다.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child1", 2),  
    new XElement("Child1", 3),  
    new XElement("Child2", 4),  
    new XElement("Child2", 5),  
    new XElement("Child2", 6)  
);  
IEnumerable<XElement> list = root.XPathSelectElements("./Child2");  
foreach (XElement el in list)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child1>2</Child1>  
        <Child1>3</Child1>  
        <Child2>4</Child2>  
        <Child2>5</Child2>  
        <Child2>6</Child2>  
    </Root>  
Dim list As IEnumerable(Of XElement) = root.XPathSelectElements("./Child2")  
For Each el As XElement In list  
    Console.WriteLine(el)  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<Child2>4</Child2>  
<Child2>5</Child2>  
<Child2>6</Child2>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node">@FSHO3@XPath 식을 평가할 <see cref="T:System.Xml.Linq.XNode" />입니다.</param>
        <param name="expression">@FSHO3@XPath 식이 들어 있는 <see cref="T:System.String" />입니다.</param>
        <param name="resolver">XPath 식의 네임스페이스 접두사에 대한 <see cref="T:System.Xml.IXmlNamespaceResolver" />입니다.</param>
        <summary>XPath 식을 사용하여 요소 컬렉션을 선택하고 지정된 <see cref="T:System.Xml.IXmlNamespaceResolver" />를 사용하여 네임스페이스 접두사를 확인합니다.</summary>
        <returns>선택된 요소가 들어 있는 <see cref="T:System.Collections.Generic.IEnumerable`1" />의 <see cref="T:System.Xml.Linq.XElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네임 스페이스 접두사가 포함 된 XPath 식을 평가 하려면이 메서드를 사용할 수 있습니다.  
  
 반환 된 컬렉션의 순서를 지정 하지 않으면 XML XPath 언어 1.0 권장 사항에 있지만이 확장 메서드는 문서 순서로 노드를 반환 합니다.  
  
 와 같은 역방향 축의 사용 하는 경우에 노드가 문서 순서로 반환 되도록 참고 `preceding-sibling` 또는 `ancestor-or-self`합니다.  
  
   
  
## Examples  
 이 예제에서는 네임 스페이스를 포함 하는 XML 트리를 만듭니다. 여기에서는 <xref:System.Xml.XmlReader>를 사용하여 XML 문서를 읽습니다. 그런 다음 <xref:System.Xml.XmlNameTable>에서 <xref:System.Xml.XmlReader>을 가져오고 <xref:System.Xml.XmlNamespaceManager>에서 <xref:System.Xml.XmlNameTable>를 가져옵니다. 사용 하 여는 <xref:System.Xml.XmlNamespaceManager> 요소의 목록을 선택 하는 경우.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable<XElement> elements = root.XPathSelectElements("./aw:Child1", namespaceManager);  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim markup As XElement = _  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim elements As IEnumerable(Of XElement) = markup.XPathSelectElements("./aw:Child1", namespaceManager)  
For Each el As XElement In elements  
    Console.WriteLine(el)  
Next  
```  
  
 이 예제는 다음과 같은 출력을 생성합니다.  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 1</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 2</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 3</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>