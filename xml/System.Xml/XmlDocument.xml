<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d3c1618ebd2745957f4a16a9a3d5fbe6c44b3b32" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59349640" /></Metadata><TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <TypeSignature Language="F#" Value="type XmlDocument = class&#xA;    inherit XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>XML 문서를 나타냅니다. 이 클래스를 사용하여 문서에서 XML 로드, 유효성 검사, 편집, 추가 및 위치 지정을 수행할 수 있습니다.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a> <xref:System.Xml.XmlDocument> 클래스는 XML 문서의 메모리 내 표현입니다. W3C 구현 [XML 문서 개체 모델 (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md) Level 1 Core 및 DOM Level 2 Core.  
  
 *DOM* 의미 *문서 개체 모델*합니다. 자세한 정보를 참조 하세요 [XML 문서 개체 모델 (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md)합니다.  
  
 사용 하 여 XML DOM에 로드할 수 있습니다는 <xref:System.Xml.XmlDocument> 클래스 및 다음 프로그래밍 방식으로 읽기, 수정 및 XML 문서에서 제거 합니다.  
  
 들어 올릴 엽니다는 <xref:System.Xml.XmlDocument> 클래스 및 구현 하는 방법을 참조 하십시오 합니다 [참조 소스](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12)합니다.  
  
<a name="Common"></a>   
## <a name="tasks"></a>작업  
  
-   [XML 문서 개체 모델에 로드](#Load)  
  
-   [스키마에 대해 유효성 검사](#Validation)  
  
-   [문서 트리를 이동 합니다.](#Navigate)  
  
-   [노드 찾기](#Find)  
  
-   [노드를 편집 합니다.](#Edit)  
  
-   [노드 추가](#Add)  
  
-   [노드 제거](#Remove)  
  
-   [위치 노드](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>XML 문서 개체 모델에 로드  
 다음과 같은 XML 문서를 사용 하 여 시작 합니다. 컬렉션에 속하는 책의 몇 가지는 것입니다. 하지만 모든 XML 문서에서 찾을 수 있는 기본 사항 포함지 않습니다. 네임 스페이스, 데이터를 나타내는 요소 및 데이터를 설명 하는 특성입니다.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 다음으로, 메모리에서 작업할 수 있도록 DOM에이 데이터를 로드 합니다. 이 작업을 수행 하는 가장 인기 있는 방법은 아니지만 네트워크 또는 로컬 컴퓨터에 파일을 참조 하십시오입니다.  
  
 이 예제에서는 파일에서 XML을 로드 합니다. 파일이 없으면 바로 일부 XML을 생성 하 고이 로드 하 합니다.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **자세한 정보:** [DOM에 XML 문서 읽어오기](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>스키마에 대해 유효성 검사  
 이와 같은 XML 스키마를 사용 하 여 시작 합니다. 이 스키마는 XML 데이터 형식을 정의 하 고 필요한 특성을 합니다.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 만들기는 <xref:System.Xml.XmlReader> 스키마를 사용 하 여 개체 및 DOM 개체 로드 한 다음 코드는 스키마의 규칙을 위반 하는 방법으로 XML 파일을 수정 하려고 할 때 실행 하는 이벤트 처리기를 만듭니다.  
  
 이러한 코드 블록을이 모든 작업을 수행 하는 도우미 메서드를 보여 줍니다.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **자세한 정보:** [DOM에서의 XML 문서 유효성 검사](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>문서 트리를 이동 합니다.  
 XML 문서를 탐색 하려면 속성을 사용할 수 있습니다. 하지만 그 중 하나를 사용 하기 전에 신속 하 게 살펴보겠습니다 몇 가지 용어입니다. 문서 노드의 구성 됩니다. 각 노드에 단일 *부모* 바로 위의 노드. 부모 노드에 없는 유일한 노드이거나 문서 루트는 최상위 노드입니다. 대부분의 노드 수 *자식* 노드인, 노드 바로 아래에 있습니다. 동일한 수준에 있는 노드가 *형제*합니다.  
  
 다음 예제에서는 루트 노드를 가져올, 루트 노드의 첫 번째 자식 노드로 이동, 해당 자식 노드 중 하나를 액세스, 돌아갈 부모 노드를 이동한 다음 형제 노드에서 방법을 보여 줍니다.  
  
 **루트 노드를 사용 하 여 시작**  
  
 이 예제에서는 루트 노드를 가져오고 해당 노드를 사용 하 여 콘솔에 문서의 내용을 출력 하려면.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **자식 노드 가져오기**  
  
 이 예제에서는 루트 노드의 첫 번째 자식 노드로 이동 하 고 있는 경우 해당 노드의 자식 노드를 반복 합니다.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **부모 노드를 다시 가져오기**  
  
 <xref:System.Xml.XmlDocument.ParentNode%2A> 속성을 사용합니다.  
  
 **마지막 자식 노드를 참조 하세요**  
  
 이 예제에서는 콘솔 (즉, 책 노드의 마지막 자식 노드)에 책의 가격을 씁니다.  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **형제 간 탐색**  
  
 이 예제에서는 책 책에서 앞으로 이동 합니다. 책 노드는 서로 형제 관계입니다.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **형제에서 뒤로 이동**  
  
 이 예제에서는 이전 버전과에서 책을 책을 이동합니다.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>노드 찾기  
 데이터의 하나 이상의 노드를 찾기 위해 가장 인기 있는 방법은 XPath 쿼리 문자열을 사용 하려면 이지만 하나 필요 하지 않은 메서드도 있습니다.  
  
 **단일 노드 가져오기**  
  
 이 예제에서는 ISBN 번호를 사용 하 여 책을 찾습니다.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 이 예제에서 사용 하는 문자열은 Xpath 쿼리입니다. 여기의 더 많은 예제를 찾을 수 있습니다.   [XPath 예제](https://msdn.microsoft.com/library/ms256086.aspx)합니다.  
  
 사용할 수도 있습니다는 <xref:System.Xml.XmlDocument.GetElementById%2A> 노드를 검색 하려고 합니다. 이 방법을 사용 하려면 정의 해야 XML 파일의 문서 형식 정의 선언에서 ID입니다.  
  
 노드를 가져온 후 자식 노드 또는 특성 값을 가져옵니다. 이 예제는는 book 노드를 사용 하 여 수행합니다.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **노드의 컬렉션을 가져옵니다.**  
  
 저자의 성과 인 모든 책을 선택 하는이 예제 **Austen**, 다음의 해당 책 가격을 변경 합니다.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 또한 노드 이름을 사용 하 여 노드의 컬렉션을 가져올 수 있습니다. 예를 들어이 예제에서는 모든 책 제목의 컬렉션을 가져옵니다.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **자세한 정보:** [XPath 탐색을 사용하여 노드 선택](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>노드를 편집 합니다.  
 이 예제에서는 책 노드 및 해당 특성을 편집합니다.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **자세한 정보:** [XML 문서에서 노드, 내용 및 값 수정](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>노드 추가  
 노드를 추가 하려면 사용 합니다 <xref:System.Xml.XmlDocument.CreateElement%2A> 메서드 또는 <xref:System.Xml.XmlDocument.CreateNode%2A> 메서드.  
  
 책 같은 데이터 노드를 추가 하려면 사용 된 <xref:System.Xml.XmlDocument.CreateElement%2A> 메서드.  
  
 다른 유형의 주석, 공백 노드 또는 CDATA 노드를 사용 하는 같은 노드를 <xref:System.Xml.XmlDocument.CreateNode%2A> 메서드.  
  
 책 노드를 만들고 해당 노드로 특성을 추가 합니다. 다음 문서에 해당 노드를 추가 하는이 예제입니다.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **자세한 정보:** [XML 문서에 노드 삽입](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>노드 제거  
 노드를 제거 하려면 사용 된 <xref:System.Xml.XmlNode.RemoveChild%2A> 메서드.  
  
 이 예제에서는 책 노드 바로 앞에 나타나는 모든 공백 및 문서에서 책을 제거 합니다.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **자세한 정보:** [XML 문서에서 노드, 내용 및 값 제거](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>위치 노드  
 노드를 사용 하 여 문서에 표시 하려는 선택할 수 있습니다 합니다 <xref:System.Xml.XmlNode.InsertBefore%2A> 고 <xref:System.Xml.XmlNode.InsertAfter%2A> 메서드.  
  
 이 예제에서는 두 가지 도우미 메서드를 보여 줍니다. 그 중 하나를 목록에서 상위 노드를 이동합니다. 다른 하위 노드를 이동합니다.  
  
 이러한 메서드는 책 목록에서 책을 위나 아래로 이동할 수 있도록 하는 응용 프로그램에서 사용할 수 있습니다. 사용자는 책을 선택 하 고 위쪽을 누를 때 또는 아래로 단추를 코드 다른 책 노드 전후 해당 책 노드를 배치 하려면 이러한 메서드를 호출할 수 없습니다.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **전체 샘플의 경우:** [XmlDocument 클래스 및 기타 관련된 형식을 사용 하 여 메모리에서 XML 조작](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xml.XmlDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Xml.XmlDocument" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음은 로드할 때 유효성 검사의 예입니다. 문서 유형 정의 (DTD) 유효성 <xref:System.Xml.XmlReader> 에 전달 되는 <xref:System.Xml.XmlDocument.Load%2A> 메서드 및 <xref:System.Xml.Schema.ValidationEventHandler> 유효성 검사 오류가 발생 하는 사용자에 게 제공 됩니다. 이 예제의 유효성 검사 오류가 발견 되 이지만 문서 계속 로드 합니다. 유효성 검사를 정의할 수 있습니다 또는 <xref:System.Xml.XmlReader> 예외를 throw 하지를 지정 하 여 유효성 검사 오류가 발견 되 면 로드 프로세스를 중지 하는 <xref:System.Xml.Schema.ValidationEventHandler>합니다. XML 데이터 유효성 검사에 대한 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 이 예제에서는 `bookDTD.xml` 파일을 입력으로 사용합니다.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlImplementation -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument imp" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">사용할 <see langword="XmlImplementation" />입니다.</param>
        <summary>지정된 <see langword="XmlDocument" />를 사용하여 <see cref="T:System.Xml.XmlImplementation" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlNameTable -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">사용할 <see langword="XmlNameTable" />입니다.</param>
        <summary>지정된 <see langword="XmlDocument" />를 사용하여 <see cref="T:System.Xml.XmlNameTable" /> 클래스의 새 인스턴스를 초기화합니다.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 노드의 기본 URI를 가져옵니다.</summary>
        <value>노드를 로드한 위치입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 네트워크에 연결 된 XML 문서를 다양 한 W3C 표준 포함 메커니즘을 사용 하 여 집계 데이터의 청크 이루어집니다 및 서로 다른 위치에서 제공 되는 노드를 포함 합니다. `BaseURI` 이러한 노드가 출처를 보여 줍니다.  
  
 문서 노드의 경우 `BaseURI` XML 문서의 위치를 반환 합니다. 예를 들어 경우는 `XmlDocument` 다음 호출 문서를 사용 하 여 로드 되었습니다. 부하 ("http://server/mydata.xml"), `BaseURI` 노드는 문서의 http://server/mydata.xml합니다. 그러나 경우 합니다 <xref:System.Xml.XmlDocument.Load%2A> 메서드는 다른 URI로 서버를 통해 리디렉션되 `BaseURI` 에 전달 된 원래 URI를 반환 합니다 `Load` 메서드.  
  
 이 속성은 DOM(문서 개체 모델)에 대한 Microsoft 확장입니다. 에 대 한 자세한 `BaseURI` 및 다른 노드 형식에서 작동 하는 방법 참조 <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>합니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">지정된 노드 아래의 하위 트리를 재귀적으로 복제하려면 <see langword="true" />이고, 노드 자체만 복제하려면 <see langword="false" />입니다.</param>
        <summary>이 노드의 복제본을 만듭니다.</summary>
        <returns>복제된 <see langword="XmlDocument" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 노드에 대 한 복사 생성자로 사용 됩니다. 복제 된 노드에 부모가 없는 (<xref:System.Xml.XmlNode.ParentNode%2A> 반환 `null`).  
  
 하는 경우 `deep` 됩니다 `true`, 복제 된 노드에 포함 모든 자식 노드를이 고, 그렇지는 `XmlDocument` 노드에 복제 됩니다. 참조 된 <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> 이 메서드가 다른 노드 형식에서 어떻게 동작 하는지 확인 하는 방법입니다.  
  
   
  
## Examples  
 다음 예제에서는 전체 및 단순 복제본 간의 차이 보여 줍니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 이름을 가진 <see cref="T:System.Xml.XmlAttribute" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">특성의 정규화된 이름입니다. 이름에 콜론이 포함되어 있는 경우, <see cref="P:System.Xml.XmlNode.Prefix" /> 속성은 첫 번째 콜론 앞의 이름 부분을 반영하고 <see cref="P:System.Xml.XmlDocument.LocalName" /> 속성은 첫 번째 콜론 뒤의 이름 부분을 반영합니다. 접두사가 xmlns같은 인식된 기본 제공되는 접두사가 아닌 경우 <see cref="P:System.Xml.XmlNode.NamespaceURI" />는 비어 있습니다. 이 경우 <see langword="NamespaceURI" />에 http://www.w3.org/2000/xmlns/의 값이 있습니다.</param>
        <summary>지정된 <see cref="P:System.Xml.XmlDocument.Name" />을 가진 <see cref="T:System.Xml.XmlAttribute" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` 에 추가할 수는 <xref:System.Xml.XmlElement> 사용 하 여를 <xref:System.Xml.XmlElement.SetAttributeNode%2A> 메서드.  
  
   
  
## Examples  
 다음 특성을 만듭니다. 및 XML 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">특성의 정규화된 이름입니다. 이름에 콜론이 포함되어 있는 경우, <see cref="P:System.Xml.XmlNode.Prefix" /> 속성은 콜론 앞의 이름 부분을 반영하고 <see cref="P:System.Xml.XmlDocument.LocalName" /> 속성은 콜론 뒤의 이름 부분을 반영합니다.</param>
        <param name="namespaceURI">특성의 네임스페이스 URI입니다. 정규화된 이름에 xmlns 접두사가 포함된 경우 이 매개 변수는 http://www.w3.org/2000/xmlns/이어야 합니다.</param>
        <summary>지정된 정규화된 이름과 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 <see cref="T:System.Xml.XmlAttribute" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` 에 추가할 수는 <xref:System.Xml.XmlElement> 사용 하 여를 <xref:System.Xml.XmlElement.SetAttributeNode%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">특성의 접두사입니다. String.Empty와 <see langword="null" />은 같습니다.</param>
        <param name="localName">특성의 로컬 이름입니다.</param>
        <param name="namespaceURI">특성의 네임스페이스 URI입니다. String.Empty와 <see langword="null" />은 같습니다. <paramref name="prefix" />가 xmlns일 경우 이 매개 변수는 http://www.w3.org/2000/xmlns/이어야 합니다. 그렇지 않으면 예외가 throw됩니다.</param>
        <summary>지정된 <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 <see cref="T:System.Xml.XmlAttribute" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlAttribute` 에 추가할 수는 <xref:System.Xml.XmlElement> 사용 하 여를 <xref:System.Xml.XmlElement.SetAttributeNode%2A> 메서드.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateCDataSection : string -&gt; System.Xml.XmlCDataSection&#xA;override this.CreateCDataSection : string -&gt; System.Xml.XmlCDataSection" Usage="xmlDocument.CreateCDataSection data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">새 <see langword="XmlCDataSection" />의 콘텐츠입니다.</param>
        <summary>지정된 데이터가 포함된 <see cref="T:System.Xml.XmlCDataSection" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlCDataSection" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), CDataSection 노드 때 허용 됩니다 및 EntityReference 노드에 요소 노드 내에서 EntityReference 노드 특성 노드의 자식이 아닙니다. .  
  
   
  
## Examples  
 다음 예제에서는 CDATA 노드를 만들어 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateComment : string -&gt; System.Xml.XmlComment&#xA;override this.CreateComment : string -&gt; System.Xml.XmlComment" Usage="xmlDocument.CreateComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">새 <see langword="XmlComment" />의 콘텐츠입니다.</param>
        <summary>지정된 데이터가 포함된 <see cref="T:System.Xml.XmlComment" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlComment" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), Comment 노드의 경우에 사용할 문서, 요소 및 EntityReference 노드 내에서 EntityReference 노드 특성의 자식이 아닙니다. 노드입니다.  
  
   
  
## Examples  
 다음 예제에서는 주석을 만들고 XML 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateDefaultAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="localName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="prefix">특성의 접두사입니다.</param>
        <param name="localName">특성의 로컬 이름입니다.</param>
        <param name="namespaceURI">특성의 네임스페이스 URI입니다.</param>
        <summary>지정된 접두사, 로컬 이름 및 네임스페이스 URI가 있는 기본 특성을 만듭니다.</summary>
        <returns>새 <see cref="T:System.Xml.XmlAttribute" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment&#xA;override this.CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment" Usage="xmlDocument.CreateDocumentFragment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Xml.XmlDocumentFragment" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlDocumentFragment" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DocumentFragment 노드는 문서에 삽입할 수 없습니다. 그러나 DocumentFragment 노드의 자식을 문서에 삽입할 수 있습니다.  
  
   
  
## Examples  
 다음 예제에서는 XML 문서에 새 노드를 추가합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType&#xA;override this.CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType" Usage="xmlDocument.CreateDocumentType (name, publicId, systemId, internalSubset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="publicId" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="systemId" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="internalSubset" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">문서 형식의 이름입니다.</param>
        <param name="publicId">문서 형식의 공용 식별자이거나 <see langword="null" />입니다. 공용 URI 또는 외부 DTD 하위 집합의 위치를 나타내는 시스템 식별자를 지정할 수 있습니다.</param>
        <param name="systemId">문서 형식의 시스템 식별자이거나 <see langword="null" />입니다. 외부 DTD 하위 집합의 파일 위치를 지정하는 URL입니다.</param>
        <param name="internalSubset">문서 형식의 DTD 내부 하위 집합이거나 <see langword="null" />입니다.</param>
        <summary>새 <see cref="T:System.Xml.XmlDocumentType" /> 개체를 반환합니다.</summary>
        <returns>새 <see langword="XmlDocumentType" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 노드는 구문 <xref:System.Xml.XmlDocumentType.Entities%2A> 고 <xref:System.Xml.XmlDocumentType.Notations%2A> 컬렉션입니다.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 문서 노드 내에서 DocumentType 노드는 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210)에 허용 됩니다. 각 <xref:System.Xml.XmlDocument> DocumentType 노드가 하나만 있을 수 있습니다. 루트 요소 앞에 DocumentType 노드를 삽입 해야 합니다는 `XmlDocument` (문서에 이미 루트 요소를 추가할 수 없습니다 DocumentType 노드).  
  
 전달 된 매개 변수를 결합 하는 유효한 경우 `XmlDocumentType`, 예외가 throw 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 DocumentType 노드를 만들어 XML 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>이 메서드는 상속 요청. 재정의 하려면 완전 신뢰가 필요 합니다 <see langword="CreateDocumentType" /> 메서드.  
  
이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xml.XmlElement" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">요소의 정규화된 이름입니다. 이름에 콜론이 포함되어 있는 경우 <see cref="P:System.Xml.XmlNode.Prefix" /> 속성은 콜론 앞의 이름 부분을 반영하고 <see cref="P:System.Xml.XmlDocument.LocalName" /> 속성은 콜론 뒤의 이름 부분을 반영합니다. 정규화된 이름에는 'xmlns'라는 접두사가 포함될 수 없습니다.</param>
        <summary>지정된 이름을 가진 요소를 만듭니다.</summary>
        <returns>새 <see langword="XmlElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 구현 인스턴스를 반환 합니다 `XmlElement` 인터페이스를 하므로 기본 특성이 반환 되는 개체에서 직접 만들어집니다.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), 요소 노드는 허용 되는 문서 및 요소의 노드 내에서 및 EntityReference 노드의 EntityReference 노드의 자식 없는 경우는 특성 노드  
  
   
  
## Examples  
 다음 예제에서는 새 요소를 만들고 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">요소의 정규화된 이름입니다. 이름에 콜론이 포함되어 있는 경우, <see cref="P:System.Xml.XmlNode.Prefix" /> 속성은 콜론 앞의 이름 부분을 반영하고 <see cref="P:System.Xml.XmlDocument.LocalName" /> 속성은 콜론 뒤의 이름 부분을 반영합니다. 정규화된 이름에는 'xmlns'라는 접두사가 포함될 수 없습니다.</param>
        <param name="namespaceURI">요소의 네임스페이스 URI입니다.</param>
        <summary>정규화된 이름과 <see cref="P:System.Xml.XmlNode.NamespaceURI" />를 가진 <see cref="T:System.Xml.XmlElement" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 C# 코드  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 다음 XML 텍스트에 해당 하는 요소에 대 한 결과입니다.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), 요소 노드는 허용 되는 문서 및 요소의 노드 내에서 및 EntityReference 노드의 EntityReference 노드의 자식 없는 경우는 특성 노드  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">새 요소의 접두사입니다. String.Empty와 <see langword="null" />은 같습니다.</param>
        <param name="localName">새 요소의 로컬 이름입니다.</param>
        <param name="namespaceURI">새 요소의 네임스페이스 URI입니다. String.Empty와 <see langword="null" />은 같습니다.</param>
        <summary>지정된 <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 요소를 만듭니다.</summary>
        <returns>새 <see cref="T:System.Xml.XmlElement" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 다음 C# 코드  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 다음 XML 텍스트와 같은 요소를 만듭니다.  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), 요소 노드는 허용 되는 문서 및 요소의 노드 내에서 및 EntityReference 노드의 EntityReference 특성 노드를 벗어날 때입니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 기존 XML 문서에 새 요소를 추가합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">엔터티 참조의 이름입니다.</param>
        <summary>지정된 이름을 가진 <see cref="T:System.Xml.XmlEntityReference" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlEntityReference" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우 참조 된 엔터티가 알려져의 자식 목록 합니다 `XmlEntityReference` 노드에 해당 하는 동일 이루어집니다 <xref:System.Xml.XmlEntity> 노드.  
  
 엔터티 참조에 대 한 대체 텍스트에서 사용 된 네임 스페이스 (예를 들어, 엔터티 참조 노드를 삽입할 때 문서에) 엔터티 참조 노드의 부모 먼저 설정 시간에 바인딩됩니다. 예를 들어 다음 엔터티:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 호출 하는 경우 `CreateEntityReference("a")` 받게 EntityReference 형식의 단일 노드 자식이 없는 합니다. 다음 노드를 자식으로이 노드를 추가 하는 경우  
  
```  
<item xmlns="urn:1"/>  
```  
  
 호출 시 다음 <xref:System.Xml.XmlNode.AppendChild%2A>, 새로 만든된 엔터티 참조 노드의 부모 설정 되 고이 네임 스페이스 컨텍스트에서 자식을 확장 됩니다. 자식 요소 노드의 `b` NamespaceURI 같음 해야 `urn:1`합니다. 엔터티 참조의 자식 노드가 엔터티 참조에는 다른 기본 네임 스페이스 컨텍스트가 있는 문서의 위치를 이동 하는 경우에 동일 합니다. 이 발생 하지 않습니다 기존 엔터티 참조 노드를 사용 하 여 복제 하는 엔터티 참조 또는 제거 하 고 삽입할 때 <xref:System.Xml.XmlDocument.CloneNode%2A>합니다. 새로 만든된 엔터티 참조에만 발생합니다.  
  
 해당 엔터티를 정의 하지 않은 DocumentType에서 엔터티 참조 노드를 추가 하면 엔터티 참조가 정의 되어 있지 않으므로 해당 유일한 자식 노드가 빈 텍스트 노드가 됩니다.  
  
 기본 제공 엔터티 amp, lt, gt, a p o s, 및 q u o t도 허용 됩니다 하 고 적절 한 확장 된 문자 값을 가진 자식 텍스트 노드를 갖게 됩니다.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), EntityReference 노드 요소, 특성 및 EntityReference 노드 내에서 허용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 두 엔터티 참조 노드를 만들고 XML 문서에 삽입 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이름이 잘못되었습니다(예: '#'으로 시작하는 이름은 올바르지 않음).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>이 문서를 탐색하기 위한 새로운 <see cref="T:System.Xml.XPath.XPathNavigator" /> 개체를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>이 문서를 탐색하기 위한 새로운 <see cref="T:System.Xml.XPath.XPathNavigator" /> 개체를 만듭니다.</summary>
        <returns><see cref="T:System.Xml.XPath.XPathNavigator" /> 개체</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 참조 <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> 이 메서드를 사용 하는 예제입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="node">검색기를 맨 처음 배치할 <see cref="T:System.Xml.XmlNode" />입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlNode" />에 있는 이 문서를 탐색하기 위한 <see cref="T:System.Xml.XPath.XPathNavigator" /> 개체를 만듭니다.</summary>
        <returns><see cref="T:System.Xml.XPath.XPathNavigator" /> 개체</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 참조 <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> 이 메서드를 사용 하는 예제입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Xml.XmlNode" />를 만듭니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (nodeTypeString, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">새 노드의 <see cref="T:System.Xml.XmlNodeType" /> 문자열 버전입니다. 이 매개 변수는 아래 테이블에 나열된 값 중 하나여야 합니다.</param>
        <param name="name">새 노드의 정규화된 이름입니다. 이름에 콜론이 포함된 경우에는 <see cref="P:System.Xml.XmlNode.Prefix" /> 및 <see cref="P:System.Xml.XmlDocument.LocalName" /> 구성 요소로 구문 분석됩니다.</param>
        <param name="namespaceURI">새 노드의 네임스페이스 URI입니다.</param>
        <summary>지정된 노드 형식, <see cref="P:System.Xml.XmlDocument.Name" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 <see cref="T:System.Xml.XmlNode" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `nodeTypeString` 매개 변수는 대/소문자 구분 및 다음 표에 있는 값 중 하나 여야 합니다.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|특성|특성|  
|cdatasection|CDATA|  
|comment|주석|  
|문서|문서|  
|documentfragment|DocumentFragment|  
|documenttype|DocumentType|  
|요소|요소|  
|entityreference|EntityReference|  
|processinginstruction|ProcessingInstruction|  
|significantwhitespace|SignificantWhitespace|  
|텍스트|텍스트|  
|whitespace|Whitespace|  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 다음 표에서 어떤 NodeType 보여 줍니다. [행]는 W3C Extensible Markup Language (XML) 1.0 권장 사항 (www.w3.org/TR/1998/REC-xml-19980210)에 따라 다른 NodeType [column] 내에서 허용 됩니다.  
  
||문서|DocumentType|XmlDeclaration|요소|특성|텍스트|CDATA|태그|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|예|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|예 *|no|no|no|no|no|no|no|no|  
|`Element`|예|no|no|예|no|no|no|no|예 * * *|  
|`Attribute`|no|no|no|예 * * *|no|no|no|no|no|  
|`Text`|no|no|no|예|예|no|no|no|예|  
|`CDATA`|no|no|no|예|no|no|no|no|예 * * *|  
|`Markup**`|예|no|no|예|no|no|no|no|no|  
|`EntityReference`|no|no|no|예|예|no|no|no|예|  
  
 \* XmlDeclaration 노드는 문서 노드의 첫 번째 자식 이어야 합니다.  
  
 * * 태그 ProcessingInstruction 및 주석 노드를 포함합니다.  
  
 요소 및 CDATA 노드 EntityReference 노드 특성 노드의 자식이 아닙니다. 경우에 EntityReference 노드의 허용 됩니다.  
  
 특성은 요소 노드의 자식은 아닙니다. 특성은 특성 컬렉션에 있는 요소 노드에 속하는 안에 포함 됩니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 요소를 만들고 문서에 삽입 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이름이 제공되지 않았으며 <see langword="XmlNodeType" />에 이름이 필요합니다. 또는 <paramref name="nodeTypeString" />이(가) 아래 나열된 문자열 중 하나가 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">새 노드의 <see langword="XmlNodeType" />입니다.</param>
        <param name="name">새 노드의 정규화된 이름입니다. 이름에 콜론이 포함되어 있으면 <see cref="P:System.Xml.XmlNode.Prefix" /> 및 <see cref="P:System.Xml.XmlDocument.LocalName" /> 구성 요소로 구문 분석됩니다.</param>
        <param name="namespaceURI">새 노드의 네임스페이스 URI입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 <see cref="T:System.Xml.XmlNode" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 다음 표에서 어떤 NodeType 보여 줍니다. [행]는 W3C Extensible Markup Language (XML) 1.0 권장 사항 (www.w3.org/TR/1998/REC-xml-19980210)에 따라 다른 NodeType [column] 내에서 허용 됩니다.  
  
||문서|DocumentType|XmlDeclaration|요소|특성|텍스트|CDATA|태그|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|예|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|예 *|no|no|no|no|no|no|no|no|  
|`Element`|예|no|no|예|no|no|no|no|예 * * *|  
|`Attribute`|no|no|no|예 * * *|no|no|no|no|no|  
|`Text`|no|no|no|예|예|no|no|no|예|  
|`CDATA`|no|no|no|예|no|no|no|no|예 * * *|  
|`Markup**`|예|no|no|예|no|no|no|no|no|  
|`EntityReference`|no|no|no|예|예|no|no|no|예|  
  
 \* XmlDeclaration 노드는 문서 노드의 첫 번째 자식 이어야 합니다.  
  
 * * 태그 ProcessingInstruction 및 주석 노드를 포함합니다.  
  
 요소 및 CDATA 노드 EntityReference 노드 특성 노드의 자식이 아닙니다. 경우에 EntityReference 노드의 허용 됩니다.  
  
 특성은 요소 노드의 자식은 아닙니다. 특성은 특성 컬렉션에 있는 요소 노드에 속하는 안에 포함 됩니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 새 요소를 만들고 XML 문서에 삽입 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이름이 제공되지 않았으며 <see langword="XmlNodeType" />에 이름이 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, prefix, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">새 노드의 <see langword="XmlNodeType" />입니다.</param>
        <param name="prefix">새 노드의 접두사입니다.</param>
        <param name="name">새 노드의 지역 이름입니다.</param>
        <param name="namespaceURI">새 노드의 네임스페이스 URI입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />가 있는 <see cref="T:System.Xml.XmlNode" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 다음 표에서 어떤 NodeType 보여 줍니다. [행]는 W3C Extensible Markup Language (XML) 1.0 권장 사항 (www.w3.org/TR/1998/REC-xml-19980210)에 따라 다른 NodeType [column] 내에서 허용 됩니다.  
  
||문서|DocumentType|XmlDeclaration|요소|특성|텍스트|CDATA|태그|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|예|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|예 *|no|no|no|no|no|no|no|no|  
|`Element`|예|no|no|예|no|no|no|no|예 * * *|  
|`Attribute`|no|no|no|예 * * *|no|no|no|no|no|  
|`Text`|no|no|no|예|예|no|no|no|예|  
|`CDATA`|no|no|no|예|no|no|no|no|예 * * *|  
|`Markup**`|예|no|no|예|no|no|no|no|no|  
|`EntityReference`|no|no|no|예|예|no|no|no|예|  
  
 \* XmlDeclaration 노드는 문서 노드의 첫 번째 자식 이어야 합니다.  
  
 * * 태그 ProcessingInstruction 및 주석 노드를 포함합니다.  
  
 요소 및 CDATA 노드 EntityReference 노드 특성 노드의 자식이 아닙니다. 경우에 EntityReference 노드의 허용 됩니다.  
  
 특성은 요소 노드의 자식은 아닙니다. 특성은 요소 노드에 속하는 특성 컬렉션 안에 포함 됩니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 문서에 새 요소를 추가합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">이름이 제공되지 않았으며 <see langword="XmlNodeType" />에 이름이 필요합니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction&#xA;override this.CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction" Usage="xmlDocument.CreateProcessingInstruction (target, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">처리 명령의 이름입니다.</param>
        <param name="data">처리 명령의 데이터입니다.</param>
        <summary>지정된 이름과 데이터가 있는 <see cref="T:System.Xml.XmlProcessingInstruction" />을 만듭니다.</summary>
        <returns>새 <see langword="XmlProcessingInstruction" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210), ProcessingInstruction 노드는 경우에 허용 문서, 요소 및 EntityReference 노드 내에서 EntityReference 노드의 자식이 아닙니다. 특성 노드.  
  
   
  
## Examples  
 다음 예제에서는 ProcessingInstruction 노드를 만들어 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace&#xA;override this.CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace" Usage="xmlDocument.CreateSignificantWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">문자열에는 &amp;#20; &amp;#10; &amp;#13; 및 &amp;#9; 문자만 포함되어야 합니다.</param>
        <summary><see cref="T:System.Xml.XmlSignificantWhitespace" /> 노드를 만듭니다.</summary>
        <returns>새 <see langword="XmlSignificantWhitespace" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다. 수동으로 문서 서식을 지정 하려는 경우 사용 됩니다.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서에 유효 공백 문자를 추가합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateTextNode : string -&gt; System.Xml.XmlText&#xA;override this.CreateTextNode : string -&gt; System.Xml.XmlText" Usage="xmlDocument.CreateTextNode text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Text 노드의 텍스트입니다.</param>
        <summary>지정된 텍스트가 있는 <see cref="T:System.Xml.XmlText" />를 만듭니다.</summary>
        <returns>새 <see langword="XmlText" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 요소, 특성 및 EntityReference 노드 내에서 텍스트 노드는 W3C Extensible Markup Language (XML) 1.0 권장 사항에 따라 (www.w3.org/TR/1998/REC-xml-19980210)에 허용 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 새 요소를 만들고 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateWhitespace : string -&gt; System.Xml.XmlWhitespace&#xA;override this.CreateWhitespace : string -&gt; System.Xml.XmlWhitespace" Usage="xmlDocument.CreateWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">문자열에는 &amp;#20; &amp;#10; &amp;#13; 및 &amp;#9; 문자만 포함되어야 합니다.</param>
        <summary><see cref="T:System.Xml.XmlWhitespace" /> 노드를 만듭니다.</summary>
        <returns>새 <see langword="XmlWhitespace" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다. 수동으로 문서 서식을 지정 하려는 경우 사용 됩니다.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 문서에 공백을 추가합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberSignature Language="F#" Value="abstract member CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration&#xA;override this.CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration" Usage="xmlDocument.CreateXmlDeclaration (version, encoding, standalone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">버전은 "1.0"이어야 합니다.</param>
        <param name="encoding">인코딩 특성 값입니다. <see cref="T:System.Xml.XmlDocument" />를 파일이나 스트림으로 저장할 경우 사용하는 인코딩입니다. 그러므로 <see cref="T:System.Text.Encoding" /> 클래스에서 지원하는 문자열로 설정되어야 합니다. 그렇지 않으면 <see cref="M:System.Xml.XmlDocument.Save(System.String)" />이 실패합니다. <see langword="null" /> 또는 String.Empty일 경우 <see langword="Save" /> 메서드에서 인코딩 특성을 XML 선언에 기록하지 않으므로 기본 인코딩인 UTF-8을 사용하게 됩니다.  
  
참고: <see langword="XmlDocument" />를 <see cref="T:System.IO.TextWriter" />나 <see cref="T:System.Xml.XmlTextWriter" />로 저장하면 이 인코딩 값이 삭제됩니다. 대신 <see langword="TextWriter" /> 또는 <see langword="XmlTextWriter" />의 인코딩을 사용합니다. 그러면 기록된 XML을 올바른 인코딩을 사용하여 다시 읽을 수 있습니다.</param>
        <param name="standalone">값은 "Yes" 또는 "No"여야 합니다. 값이 <see langword="null" />이나 String.Empty일 경우에는 <see langword="Save" /> 메서드에서 독립형 특성을 XML 선언에 기록하지 않습니다.</param>
        <summary>지정된 값이 있는 <see cref="T:System.Xml.XmlDeclaration" /> 노드를 만듭니다.</summary>
        <returns>새 <see langword="XmlDeclaration" /> 노드입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 특성에서 특수 속성으로 노출 되는 `XmlDeclaration` 노드를 아니라 <xref:System.Xml.XmlAttribute> 노드.  
  
 이 메서드가 문서의 컨텍스트에서 새 개체를 만들고, 있지만 추가 되지 않습니다 자동으로 새 개체를 문서 트리에입니다. 새 개체를 추가 하려면 명시적으로 노드 삽입 메서드 중 하나가 호출 해야 합니다.  
  
 W3C Extensible Markup Language (XML) 1.0 권장 사항 (www.w3.org/TR/1998/REC-xml-19980210)에 따라는 `XmlDeclaration` 노드가 첫 번째 노드는 문서 여야 합니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 XML 선언을 만들어 문서에 추가 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="version" /> 또는 <paramref name="standalone" />의 값이 위에서 지정한 값 이외의 값입니다.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentElement : System.Xml.XmlElement" Usage="System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>문서의 루트 <see cref="T:System.Xml.XmlElement" />를 가져옵니다.</summary>
        <value>XML 문서 트리의 루트를 나타내는 <see langword="XmlElement" />입니다. 루트가 없으면 <see langword="null" />이 반환됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 다음 예제에서는 XML 문서의 루트 요소를 표시합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **출력:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.XmlDocumentType" Usage="System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>DOCTYPE 선언이 포함된 노드를 가져옵니다.</summary>
        <value>DocumentType(DOCTYPE 선언)이 포함된 <see cref="T:System.Xml.XmlNode" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` 하나의 자식으로 가질 수 있습니다 <xref:System.Xml.XmlNodeType> DocumentType 같음.  
  
> [!NOTE]
>  이 속성은 읽기 전용입니다. DocumentType 노드를 변경 하려면 기존 노드를 삭제를 사용 하 여 새 하나 만듭니다는 <xref:System.Xml.XmlDocument.CreateDocumentType%2A> 메서드를 문서에 새 노드를 추가 합니다.  
  
   
  
## Examples  
 다음 예제에서는 가져오고 문서의 DOCTYPE 선언을 표시 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.GetElementById elementId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementId">일치시킬 특성 ID입니다.</param>
        <summary>지정된 ID의 <see cref="T:System.Xml.XmlElement" />를 가져옵니다.</summary>
        <returns>일치하는 ID가 있으면 <see langword="XmlElement" />, 일치하는 요소가 없을 경우에는 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문서에 일치 하는 ID 사용 하 여 여러 요소를이 메서드는 문서의 첫 번째 일치 하는 요소를 반환 합니다.  
  
> [!NOTE]
>  DOM 구현 형식 id 특성을 정의 하는 정보가 있어야 합니다. XSD 스키마 또는 Dtd를 특성 유형 ID 정의할 수 있지만이 버전의 제품 지원 Dtd에서 정의 된 합니다. DTD에서 정의 하지 않으면 "ID" 아닌 이름 가진 특성 ID를 입력 합니다. Id 형식 특성이 인지 알 수 없는 구현을 반환 해야 하는 `null`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `GetElementById` 메서드를 사용합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 이 예제에서는 파일을 사용 하 여 `ids.xml`입력으로 합니다.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED>]>  
<root>  
  <Person SSN='A111' Name='Fred'/>  
  <Person SSN='A222' Name='Tom'/>  
  <Customer id='A222334444'/>  
  <Team members='A222334444 A333445555'/>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 이름과 일치하는 모든 하위 요소의 목록이 포함된 <see cref="T:System.Xml.XmlNodeList" />를 반환합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">일치시킬 정규화된 이름입니다. 일치하는 노드의 <see langword="Name" /> 속성과 일치합니다. 특수 값 "*"은 모든 태그와 일치합니다.</param>
        <summary>지정된 <see cref="P:System.Xml.XmlDocument.Name" />과 일치하는 모든 하위 요소의 목록이 포함된 <see cref="T:System.Xml.XmlNodeList" />를 반환합니다.</summary>
        <returns>일치하는 모든 노드 목록이 포함된 <see cref="T:System.Xml.XmlNodeList" />입니다. <paramref name="name" />과 일치하는 노드가 없으면 빈 컬렉션이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 노드는 이러한에서 발생 하는 문서 순서로 배치 됩니다.  
  
> [!NOTE]
>  사용 하는 것이 좋습니다.는 <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> 하거나 <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> 메서드 대신를 <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> 메서드.  
  
   
  
## Examples  
 다음 예에서는 `XmlDocument` 사용 하 여 개체를 `GetElementsByTagName` 메서드와 결과 <xref:System.Xml.XmlNodeList> 모든 책 제목을 표시 하는 개체입니다.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 이 예제에서는 `books.xml` 파일을 입력으로 사용합니다.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">일치시킬 LocalName입니다. 특수 값 "*"은 모든 태그와 일치합니다.</param>
        <param name="namespaceURI">일치시킬 NamespaceURI입니다.</param>
        <summary>지정된 <see cref="P:System.Xml.XmlDocument.LocalName" /> 및 <see cref="P:System.Xml.XmlNode.NamespaceURI" />와 일치하는 모든 하위 요소의 목록이 포함된 <see cref="T:System.Xml.XmlNodeList" />를 반환합니다.</summary>
        <returns>일치하는 모든 노드 목록이 포함된 <see cref="T:System.Xml.XmlNodeList" />입니다. 지정된 <paramref name="localName" /> 및 <paramref name="namespaceURI" />와 일치하는 노드가 없으면 빈 컬렉션이 반환됩니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 노드는 이러한에서 발생 하는 문서 트리에서 순서로 배치 됩니다.  
  
> [!NOTE]
>  사용 하는 것이 좋습니다.는 <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> 하거나 <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> 메서드 대신를 <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> 메서드.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Implementation : System.Xml.XmlImplementation" Usage="System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 문서에 대한 <see cref="T:System.Xml.XmlImplementation" /> 개체를 가져옵니다.</summary>
        <value>현재 문서에 대한 <see langword="XmlImplementation" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` 동일한에서 만들어진 개체 `XmlImplementation` 동일한 공유 <xref:System.Xml.XmlNameTable>합니다. 이는 사용자를 특성 및 요소 이름 문자열 대신 개체와 비교할 수 있습니다.  
  
 하지만 합니다 `XmlDocument` 개체에 동일한 구현을 공유, 다른 한 문서에서 노드를 이동 하려면 사용 해야는 <xref:System.Xml.XmlDocument.ImportNode%2A> 메서드.  
  
   
  
## Examples  
 다음 예제에서는 새 `XmlDocument` 다른 문서 구현을 사용 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberSignature Language="F#" Value="abstract member ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode&#xA;override this.ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.ImportNode (node, deep)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">가져올 노드입니다.</param>
        <param name="deep">전체 복제를 수행하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</param>
        <summary>다른 문서에서 현재 문서로 노드를 가져옵니다.</summary>
        <returns>가져온 <see cref="T:System.Xml.XmlNode" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 노드는 부모가 없습니다. 원본 노드는 변경 되거나 원래 문서에서 제거 `ImportNode` 소스 노드의 복사본을 만듭니다.  
  
 노드를 가져오면 만듭니다는 `XmlNode` 가져오기 문서를 사용 하 여 소유 하는 개체 <xref:System.Xml.XmlNode.Name%2A> 및 <xref:System.Xml.XmlNode.NodeType%2A> 동일 원본 노드에 해당 합니다. 새 개체에는 네임 스페이스에 관련 된 특성 (<xref:System.Xml.XmlNode.Prefix%2A>하십시오 <xref:System.Xml.XmlNode.LocalName%2A>, 및 <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 가져온 노드와 값 노드 유형에 따라는 `deep` 매개 변수를 추가 정보를 적절 하 게 복사 됩니다. 이 메서드는 예상 되는 동작 간에 XML 이나 HTML 소스의 조각을 한 문서에서 복사 된 경우 미러 하려고 시도 (인식 하는 XML의 경우 두 개의 문서가 있을 수 다른 Dtd).  
  
 다음 표에서 각 특정 동작을 설명 <xref:System.Xml.XmlNodeType>합니다.  
  
|XmlNodeType|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|특성|합니다 <xref:System.Xml.XmlAttribute.Specified%2A> 속성이 `true` 생성 되 <xref:System.Xml.XmlAttribute>합니다. 원본의 하위 `XmlAttribute` 을 재귀적으로 가져오고 결과 노드를 다시 조합 하는 해당 하위 트리를 구성 합니다.|합니다 `deep` 매개 변수가 적용 되지 않습니다 `XmlAttribute` 노드,는 항상 가져올 때 사용 하 여 해당 자식 항목을 수행 합니다.|  
|CData|해당 데이터를 포함하여 노드를 복사합니다.|해당 데이터를 포함하여 노드를 복사합니다.|  
|주석|해당 데이터를 포함하여 노드를 복사합니다.|해당 데이터를 포함하여 노드를 복사합니다.|  
|DocumentFragment|소스 노드의 하위 항목을 재귀적으로 가져오고 결과 노드를 다시 조합하여 해당하는 하위 트리를 구성합니다.|빈 <xref:System.Xml.XmlDocumentFragment> 생성 됩니다.|  
|DocumentType|해당 데이터를 포함하여 노드를 복사합니다.*|해당 데이터를 포함하여 노드를 복사합니다.*|  
|요소|소스 요소와 지정 된 특성 노드 해당 하위 항목 재귀적으로 가져오고 결과 노드를 다시 해당 하위 트리를 형성 하 합니다.<br /><br /> 참고: 기본 특성이 복사되지 않습니다. 가져오고 있는 문서에 이 요소 이름에 대한 기본 특성이 정의되어 있는 경우 이 특성이 할당됩니다.|소스 요소 노드를 가져온 특성 및 생성 된 지정 된 `XmlAttribute` 노드에 연결 되 고 생성 된 <xref:System.Xml.XmlElement>합니다.<br /><br /> 참고: 기본 특성이 복사되지 않습니다. 가져오고 있는 문서에 이 요소 이름에 대한 기본 특성이 정의되어 있는 경우 이 특성이 할당됩니다.|  
|EntityReference|이 메서드는만 복사 소스와 대상 문서가 다르게 정의 된 엔터티를 가질 수 있으므로 <xref:System.Xml.XmlEntityReference> 노드. 대체 텍스트는 포함되지 않습니다. 대상 문서에 엔터티가 정의되어 있는 경우 해당 값이 할당됩니다.|이 메서드는만 복사 소스와 대상 문서가 다르게 정의 된 엔터티를 가질 수 있으므로 <xref:System.Xml.XmlEntityReference> 노드. 대체 텍스트는 포함되지 않습니다. 대상 문서에 엔터티가 정의되어 있는 경우 해당 값이 할당됩니다.|  
|ProcessingInstruction|가져온 노드에서 대상과 데이터 값을 복사합니다.|가져온 노드에서 대상과 데이터 값을 복사합니다.|  
|텍스트|해당 데이터를 포함하여 노드를 복사합니다.|해당 데이터를 포함하여 노드를 복사합니다.|  
|SignificantWhitespace|해당 데이터를 포함하여 노드를 복사합니다.|해당 데이터를 포함하여 노드를 복사합니다.|  
|Whitespace|해당 데이터를 포함하여 노드를 복사합니다.|해당 데이터를 포함하여 노드를 복사합니다.|  
|XmlDeclaration|가져온 노드에서 대상과 데이터 값을 복사합니다.|가져온 노드에서 대상과 데이터 값을 복사합니다.|  
|다른 모든 노드 형식입니다.|이 노드 형식은 가져올 수 없습니다.|이 노드 형식은 가져올 수 없습니다.|  
  
 * DocumentType 노드를 가져올 수 있습니다, 있지만 문서는 오직 하나의 DocumentType만 있을 수 있습니다. 문서에는 현재 DocumenType 노드에, 경우에 새 필터를 추가 하기 전에 제거 해야 합니다.  
  
   
  
## Examples  
 다음 예제에서는 원본 XML 문서에 두 번째 XML 문서에서 책 노드를 가져옵니다.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 이 예제에서는 파일을 사용 하 여 `books.xml`입력으로 합니다.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">가져올 수 없는 노드 형식에 대해 이 메서드 호출</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string" Usage="System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>모든 경우에 <see cref="T:System.InvalidOperationException" />을 throw합니다.</summary>
        <value>노드와 모든 자식 노드의 값입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성이 구현되지 않습니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">모든 경우</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 노드의 자식을 나타내는 태그를 가져오거나 설정합니다.</summary>
        <value>현재 노드의 자식을 나타내는 태그입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성을 설정 노드의 자식이 지정된 된 문자열의 구문 분석 된 내용으로 바뀝니다. 현재 네임스페이스 컨텍스트에서 구문 분석이 수행됩니다.  
  
 `InnerXml` 중복 네임 스페이스 선언을 제거합니다. 결과적으로 복사 및 붙여넣기를 여러 번 실행해도 중복 네임스페이스 선언으로 인해 문서 크기가 증가하지 않습니다. 다음은 XSL 문서를 고려해 야 합니다.  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 `InnerXml` 스타일 시트 노드의 속성 다음 문자열을 반환 합니다.  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 노드 id를 보존 하는 데 사용 되는 추가 나타났다가 네임 스페이스 선언을 알 수 있습니다. 이 내부 XML 문자열을 다시 삽입 하는 경우 하면 다시 원래 문서. 즉, `InnerXml` 부모 xsl: stylesheet 요소는 이미 나타났다가 네임 스페이스 선언 및 제거 하는 나타났다가 네임 스페이스 선언이 중복 임을 인식 합니다.  
  
 이동 하는 경우 `InnerXml` 기본 네임 스페이스를 사용 하 여 문서에 없는 기본 네임 스페이스를 사용 하 여 문서에서 동작은 약간 다릅니다. 다음 XML 문자열을 사용 하는 것이 좋습니다.  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` 네임 스페이스 선언이 없는 일반 XML 문자열을 반환합니다.  
  
```xml  
<item>123</item>  
```  
  
 그런 다음이 문자열 같은 기본 네임 스페이스에 있는 문서에 삽입 하면:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` 구문 분석 문자열에서 컨텍스트 및 새 노드 urn: 1 네임 스페이스를 선택 합니다. 결과 다음과 같습니다.  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 이제 요청 하면는 `InnerXml` 다음 다시 가져옵니다.  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Xmlns를 수동으로 추가 해야 하는 다음 네임 스페이스가 없는 있는 문서에서 온 사실을 유지 하기 위해 삽입된 된 항목을 명시적으로 하려는 경우 = "" 선언 하 고 결과 문자열을 삽입 합니다.  
  
```xml  
<item xmlns="">123</item>  
```  
  
 모든 작업의 결과 다음과 같습니다.  
  
1.  잘라내기 및 붙여넣기 `InnerXml` 사용 하지 않는 문서 간의 네임 스페이스는 간단 하 고 문자열에서 "xmlns" 중복을 만들지 않습니다.  
  
2.  `InnerXml` 잘라내기 및 붙여넣기 (즉, XSL 스타일 시트) 둘 이상의 네임 스페이스에 있는 문서 간에 사용할 수 있습니다.  
  
3.  나타났다가 선언을 문자열에 자동으로 나타나고 노드 계층 구조에서 사라집니다.  
  
4.  이동할 경우에서 `InnerXml` 없는 기본 네임 스페이스에 기본 네임 스페이스가 있는 문서에 있는 문서에서 새 노드는 새 기본 네임 스페이스를 선택 합니다.  
  
 경우 `InnerXml` 설정 된 현재 문서에서 정의 되지 않은 엔터티 참조를 포함 하는 텍스트를 사용 하 여 결과 트리에 빈 EntityReference 노드 포함 됩니다.  
  
 이 속성은 DOM(문서 개체 모델)에 대한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 속성을 설정할 때 지정된 XML이 올바른 형식이 아닙니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 노드가 읽기 전용인지를 나타내는 값을 가져옵니다.</summary>
        <value>현재 노드가 읽기 전용이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. <see langword="XmlDocument" /> 노드에서는 항상 <see langword="false" />를 반환합니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 읽기 전용 노드는 해당 속성, 특성 또는 자식 항목을 변경할 수 없습니다. 읽기 전용 노드 트리에서 제거 하 고 다른 위치에 삽입할 수 있습니다.  
  
 이 속성은 DOM(문서 개체 모델)에 대한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 `IsReadOnly` 속성을 사용하는 방법을 보여 줍니다.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>지정된 XML 데이터를 <see cref="T:System.IO.Stream" />, URL, <see cref="T:System.IO.TextReader" /> 또는 <see cref="T:System.Xml.XmlReader" />에서 로드합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">로드할 XML 문서가 포함된 스트림입니다.</param>
        <summary>지정된 스트림에서 XML 문서를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` 메서드는 항상 유효 공백 유지 합니다. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 속성 불필요 한 공백을 요소 콘텐츠에서 공백을 보존 되는지 여부를 결정 합니다. 기본값은 `false`; 요소 콘텐츠에서 공백을 유지 되지 않습니다.  
  
 유효성 검사를 수행 합니다 하는 경우 유효성 검사를 만들 수 있습니다 <xref:System.Xml.XmlReader> 를 사용 하 여 인스턴스를 <xref:System.Xml.XmlReaderSettings> 클래스 및 <xref:System.Xml.XmlReader.Create%2A> 메서드. 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 이 메서드는 입력 (예: utf-8, ANSI 및 등)에 XML 문자열 형식의 자동으로 검색합니다. 스트림을 읽는 데 사용 되는 인코딩을 알아야 응용 프로그램에 필요한 경우는 <xref:System.Xml.XmlTextReader> 스트림의 읽을 개체를 사용 하 여는 <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> 인코딩을 결정 하는 속성입니다. 사용 해야 하는 경우는 <xref:System.Xml.XmlDocument> XML 작업할 개체를 사용할 수는 <xref:System.Xml.XmlTextReader> 만들려면 개체입니다. 자세한 내용은 [XPathDocument 및 XmlDocument를 사용 하 여 XML 데이터를 읽는](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md)합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML에 로드 또는 구문 분석 오류가 있습니다. 이 경우 <see cref="T:System.IO.FileNotFoundException" />이 발생합니다.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">XML 데이터를 문서에 제공하기 위해 사용하는 <see langword="TextReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.IO.TextReader" />에서 XML 문서를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` 메서드는 항상 유효 공백 유지 합니다. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 속성 불필요 한 공백을 요소 콘텐츠에서 공백을 보존 되는지 여부를 결정 합니다. 기본값은 `false`; 요소 콘텐츠에서 공백을 유지 되지 않습니다.  
  
 유효성 검사를 수행 합니다 하는 경우 유효성 검사를 만들 수 있습니다 <xref:System.Xml.XmlReader> 를 사용 하 여 인스턴스를 <xref:System.Xml.XmlReaderSettings> 클래스 및 <xref:System.Xml.XmlReader.Create%2A> 메서드. 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 합니다 <xref:System.IO.StringReader> XML 데이터의 문자열이 로드 클래스를 `XmlDocument` 개체입니다.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML에 로드 또는 구문 분석 오류가 있습니다. 이 경우 문서는 빈 상태로 유지됩니다.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filename">로드할 XML 문서가 포함된 파일의 URL입니다. URL은 로컬 파일 또는 HTTP URL(웹 주소)일 수 있습니다.</param>
        <summary>지정된 URL에서 XML 문서를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` 메서드는 항상 유효 공백 유지 합니다. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 속성 불필요 한 공백을 요소 콘텐츠에서 공백을 보존 되는지 여부를 결정 합니다. 기본값은 `false`; 요소 콘텐츠에서 공백을 유지 되지 않습니다.  
  
 유효성 검사를 수행 합니다 하는 경우 유효성 검사를 만들 수 있습니다 <xref:System.Xml.XmlReader> 를 사용 하 여 인스턴스를 <xref:System.Xml.XmlReaderSettings> 클래스 및 <xref:System.Xml.XmlReader.Create%2A> 메서드. 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML에 로드 또는 구문 분석 오류가 있습니다. 이 경우 <see cref="T:System.IO.FileNotFoundException" />이 발생합니다.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filename" />가 빈 문자열이거나 공백만 포함하거나 <see cref="F:System.IO.Path.InvalidPathChars" />로 정의된 하나 이상의 잘못된 문자를 포함합니다.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" />가 <see langword="null" />입니다.</exception>
        <exception cref="T:System.IO.PathTooLongException">지정된 경로, 파일 이름 또는 둘 다가 시스템에서 정의한 최대 길이를 초과합니다.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">지정된 경로가 잘못되었습니다(예: 매핑되지 않은 드라이브에 있음).</exception>
        <exception cref="T:System.IO.IOException">파일을 여는 동안 I/O 오류가 발생했습니다.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="filename" />에 읽기 전용인 파일이 지정되었습니다.  
  
또는 
현재 플랫폼이 해당 작업을 지원하지 않는 경우  
  
또는 
 <paramref name="filename" />에 디렉터리가 지정되었습니다.  
  
또는 
호출자에게 필요한 권한이 없는 경우</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="filename" />에 지정된 파일을 찾을 수 없습니다.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="filename" />의 형식이 잘못되었습니다.</exception>
        <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XML 데이터를 문서에 제공하기 위해 사용하는 <see langword="XmlReader" />입니다.</param>
        <summary>지정된 <see cref="T:System.Xml.XmlReader" />에서 XML 문서를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  `Load` 메서드는 항상 유효 공백 유지 합니다. <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 속성 불필요 한 공백을 요소 콘텐츠에서 공백을 보존 되는지 여부를 결정 합니다. 기본값은 `false`; 요소 콘텐츠에서 공백을 유지 되지 않습니다.  
  
 초기 상태에서 판독기가 있으면 (<xref:System.Xml.XmlReader.ReadState%2A> ReadState.Initial =), `Load` 판독기의 전체 내용을 사용 하 고 찾은 내용에서 DOM을 빌드합니다.  
  
 판독기가 이미 "n" 깊이가 일부 노드에 배치 됩니다을 하는 경우이 메서드는 해당 노드 및 모든 후속 형제 "n" 수준을 닫는 끝 태그 최대 로드 합니다. 이 다음과 같은 결과가 있습니다.  
  
 현재 노드와 해당 형제 다음과 같은 살펴보기:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` 문서 루트 수준 요소가 두 개를 포함할 수 없으므로 예외가 throw 됩니다. 현재 노드와 해당 형제 다음과 같은 살펴보기:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` 성공 하지만 루트 수준 요소가 없기 때문에 불완전 한 DOM 트리를 해야 합니다. 문서를 저장할 추가 해야 합니다는 루트 수준 요소가 고, 그렇지 <xref:System.Xml.XmlDocument.Save%2A> 예외가 throw 됩니다.  
  
 판독기가 배치 될 때까지 읽기를 계속 공백이 나 특성 노드를 예를 들어 문서의 루트 수준에 대해 유효 하지 않은 리프 노드에 판독기가 배치 하는 경우 루트에 사용할 수 있는 노드에 있습니다. 이때 문서가 로드되기 시작합니다.  
  
 유효성 검사를 수행 합니다 하는 경우 유효성 검사를 만들 수 있습니다 <xref:System.Xml.XmlReader> 를 사용 하 여 인스턴스를 <xref:System.Xml.XmlReaderSettings> 클래스 및 <xref:System.Xml.XmlReader.Create%2A> 메서드. 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 마지막 책 노드의 로드를 `books.xml` XML 문서에는 파일입니다.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 이 예제에서는 파일을 사용 하 여 `books.xml`입력으로 합니다.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML에 로드 또는 구문 분석 오류가 있습니다. 이 경우 문서는 빈 상태로 유지됩니다.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberSignature Language="F#" Value="abstract member LoadXml : string -&gt; unit&#xA;override this.LoadXml : string -&gt; unit" Usage="xmlDocument.LoadXml xml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">로드할 XML 문서가 포함된 문자열입니다.</param>
        <summary>지정된 문자열에서 XML 문서를 로드합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 기본적으로는 `LoadXml` 메서드 공백이 나 유효 공백을 유지 하지 않습니다.  
  
 이 메서드는 Dtd를 구문 분석 하지만 DTD 또는 스키마 유효성 검사를 수행 하지 않습니다. 유효성 검사를 수행 합니다 하는 경우 유효성 검사를 만들 수 있습니다 <xref:System.Xml.XmlReader> 를 사용 하 여 인스턴스를 <xref:System.Xml.XmlReaderSettings> 클래스 및 <xref:System.Xml.XmlReader.Create%2A> 메서드. 자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.  
  
 로드 하려는 경우는 <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, 또는 <xref:System.Xml.XmlReader>,이 메서드 대신 Load 메서드를 사용 합니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 XML을 로드는 `XmlDocument` 개체 및 파일에 저장 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML에 로드 또는 구문 분석 오류가 있습니다. 이 경우 문서는 빈 상태로 유지됩니다.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>노드의 로컬 이름을 가져옵니다.</summary>
        <value><see langword="XmlDocument" /> 노드의 경우 로컬 이름이 #document가 됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 된 로컬 이름에 따라 달라 집니다는 <xref:System.Xml.XmlDocument.NodeType%2A> 노드. 각 노드 형식에 대해 반환 되는 로컬 이름을 설명 하는 테이블을 참조 합니다 <xref:System.Xml.XmlNode.LocalName%2A> 속성에는 <xref:System.Xml.XmlNode> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>노드의 정규화된 이름을 가져옵니다.</summary>
        <value><see langword="XmlDocument" /> 노드의 경우 이름이 #document가 됩니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 반환 되는 이름에 따라 달라 집니다는 <xref:System.Xml.XmlDocument.NodeType%2A> 노드. 각 노드 형식에 대해 반환 되는 이름을 설명 하는 테이블을 참조 합니다 <xref:System.Xml.XmlNode.Name%2A> 속성에는 <xref:System.Xml.XmlNode> 클래스입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 구현과 관련된 <see cref="T:System.Xml.XmlNameTable" />을 가져옵니다.</summary>
        <value>문서 내에서 원자화된 버전의 문자열을 가져올 수 있게 해주는 <see langword="XmlNameTable" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 각 `XmlDocument` 개체에는 <xref:System.Xml.NameTable> 개체입니다. 요소 및 특성 이름에 저장 되는 `NameTable` 원자화 된 문자열입니다. 즉, 문서의 이름을 참조 하는 경우에 여러 번 저장 된 한 번만에 `NameTable`합니다. 예를 들어, 문서 이름 "고객"을 사용 하 여 여러 요소에 있을 경우 `NameTable` 해당 이름에 대 한 요청을 받을 때마다 동일한 개체를 반환 합니다. 결과적으로, 사용자 개체 비교를 사용 하 여 비용이 많이 드는 문자열 비교 대신이 문자열에 코드를 작성할 수 있습니다.  
  
 원자화된 문자열에 대한 자세한 내용은 <xref:System.Xml.XmlNameTable>을 참조하십시오.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberSignature Language="F#" Value="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드의 <see cref="P:System.Xml.XmlNode.Value" />가 변경된 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트는 값을 가진 노드에만 적용 됩니다.  
  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberSignature Language="F#" Value="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드의 <see cref="P:System.Xml.XmlNode.Value" />를 변경할 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트에는 추가 검사를 수행 하 고 필요한 경우 작업을 중지 하려면 예외를 throw 할 수 있습니다. 예외가 발생 하는 경우는 `XmlDocument` 원래 상태로 돌아갑니다. 이 이벤트는 값을 가진 노드에만 적용 됩니다.  
  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberSignature Language="F#" Value="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드를 다른 노드에 삽입한 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberSignature Language="F#" Value="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드를 다른 노드에 삽입할 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트에는 추가 검사를 수행 하 고 필요한 경우 작업을 중지 하려면 예외를 throw 할 수 있습니다. 예외가 발생 하는 경우는 `XmlDocument` 원래 상태로 돌아갑니다.  
  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드를 부모에서 제거한 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 문서에 속하는 노드를 문서에서 제거할 경우에 발생합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 이벤트에는 추가 검사를 수행 하 고 필요한 경우 작업을 중지 하려면 예외를 throw 할 수 있습니다. 예외가 발생 하는 경우는 `XmlDocument` 원래 상태로 돌아갑니다.  
  
 문서에 삽입 되었는지 여부 또는이 문서에서 만든 모든 노드는이 이벤트에 포함 됩니다.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 노드의 형식을 가져옵니다.</summary>
        <value>노드 형식입니다. <see langword="XmlDocument" /> 노드의 경우 이 값은 XmlNodeType.Document가 됩니다.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>현재 노드가 속하는 <see cref="T:System.Xml.XmlDocument" />를 가져옵니다.</summary>
        <value><see langword="XmlDocument" /> 노드(<see cref="P:System.Xml.XmlDocument.NodeType" />이 XmlNodeType.Document)의 경우 이 속성에서는 항상 <see langword="null" />을 반환합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>부모가 있을 수 있는 노드의 경우 이 노드의 부모 노드를 가져옵니다.</summary>
        <value>항상 <see langword="null" />를 반환합니다.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveWhitespace : bool with get, set" Usage="System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>요소 콘텐츠에서 공백을 유지할지를 나타내는 값을 가져오거나 설정합니다.</summary>
        <value>공백을 유지하려면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다. 기본값은 <see langword="false" />입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성 로드 하는 동안 공백이 처리 되는 방식을 결정 하 고 프로세스를 저장 합니다.  
  
 경우 `PreserveWhitespace` 은 `true` 하기 전에 <xref:System.Xml.XmlDocument.Load%2A> 또는 <xref:System.Xml.XmlDocument.LoadXml%2A> 가 호출 공백 노드는 유지 되지 않으면이 속성이 `false`공백 없는, 중요 한 공백이 유지 됩니다.  
  
 경우 `PreserveWhitespace` 는 `true` 하기 전에 <xref:System.Xml.XmlDocument.Save%2A> 은 출력에 유지 되지 않으면이 속성이 문서에서 공백을 호출 `false`, `XmlDocument` 자동으로 들여씁니다 출력 합니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 파일에서 공백을 제거 하는 방법을 보여 줍니다.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 파일을 사용 하는 예제 `book.xml` 입력으로 합니다.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode&#xA;override this.ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode" Usage="xmlDocument.ReadNode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XML 소스입니다.</param>
        <summary><see cref="T:System.Xml.XmlNode" />의 내용을 기준으로 <see cref="T:System.Xml.XmlReader" /> 개체를 만듭니다. 판독기는 노드나 특성에 위치해야 합니다.</summary>
        <returns>새 <see langword="XmlNode" />이거나 더 이상 노드가 없으면 <see langword="null" />입니다.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 하나를 읽고 `XmlNode` 지정된 된 판독기에서 다음 노드에 판독기를 배치 합니다. 이 메서드는 형식을 만드는 `XmlNode` 일치는 <xref:System.Xml.XmlNode.NodeType%2A> 에 현재 판독기가 합니다. (초기 상태에서 판독기가 있으면 `ReadNode` 판독기 첫 번째 노드를 이동 하 고 해당 노드에서 다음 작동 합니다.)  
  
 판독기가 요소를 시작 하는 경우 `ReadNode` 모든 특성 및 모든 자식 노드를 읽고 현재 노드의 끝 태그를 포함 합니다. `XmlNode` 반환 읽은 모든 내용을 나타내는 하위 트리가 포함 되어 있습니다. 판독기는 끝 태그 바로 뒤에 배치 됩니다.  
  
 `ReadNode` 특성을 읽을 수도 있지만 경우 판독기를 다음 특성으로 진행 하지 않습니다. 이 옵션을 사용 하면 다음 C# 코드를 작성할 수 있습니다.  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` 값을 사용할 특성 그러나 호출한 후 즉 `ReadNode` 특성에 <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> 반환 `false`합니다.  
  
   
  
## Examples  
 다음 예제에서는 `ReadNode` 새 노드를 만들려면 다음 문서에 새 노드를 삽입 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 이 예제에서는 파일을 사용 하 여 `cd.xml`입력으로 합니다.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">판독기가 유효한 DOM 노드(예: EndElement 또는 EndEntity)로 변환되지 않는 노드 형식 위치에 있습니다.</exception>
        <block subset="none" type="overrides"><para>이 메서드는 상속 요청. 재정의 하려면 완전 신뢰가 필요 합니다 <see langword="ReadNode" /> 메서드.  
  
이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.</para></block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>XML 문서를 지정된 위치에 저장합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.Stream -&gt; unit&#xA;override this.Save : System.IO.Stream -&gt; unit" Usage="xmlDocument.Save outStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">저장할 스트림입니다.</param>
        <summary>XML 문서를 지정된 스트림에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 공백이 유지 됩니다 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 로 설정 된 `true`합니다.  
  
 현재 XmlDeclaration `XmlDocument` 개체 인코딩 특성에 저장된 된 문서를 확인 합니다. 인코딩 특성의 값을 가져옵니다는 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> 속성입니다. 경우는 `XmlDocument` 않습니다 XmlDeclaration, 없거나는 XmlDeclaration 인코딩 특성에 없는 경우 저장된 된 문서 것 하나 중 하나입니다.  
  
 문서를 저장 하는 경우 (로컬 이름 + 네임 스페이스 URI) 노드 id를 올바르게 유지 하도록 xmlns 특성 생성 됩니다. 예를 들어 다음 C# 코드  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 이 xml 특성을 생성 `<item xmls="urn:1"/>`합니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 만 <xref:System.Xml.XmlDocument.Save%2A> 메서드는 올바른 형식의 XML 문서를 적용 합니다. 다른 모든 `Save` 오버 로드는 단편만 잘 구성 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 작업을 수행하면 올바른 형식의 XML 문서가 생성되지 않습니다(예: 문서 요소 또는 중복 XML 선언 없음).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.TextWriter -&gt; unit&#xA;override this.Save : System.IO.TextWriter -&gt; unit" Usage="xmlDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">저장할 대상 <see langword="TextWriter" />입니다.</param>
        <summary>XML 문서를 지정된 <see cref="T:System.IO.TextWriter" />에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 인코딩을 합니다 `TextWriter` 기록 되는 인코딩을 결정 (인코딩의 바뀝니다 XmlDeclaration 노드 인코딩는 `TextWriter`). 있는 경우에 지정 된 인코딩이 합니다 `TextWriter`, `XmlDocument` 인코딩 특성이 없는 저장 됩니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 만 <xref:System.Xml.XmlDocument.Save%2A> 메서드는 올바른 형식의 XML 문서를 적용 합니다. 다른 모든 `Save` 오버 로드는 단편만 잘 구성 된 합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 작업을 수행하면 올바른 형식의 XML 문서가 생성되지 않습니다(예: 문서 요소 또는 중복 XML 선언 없음).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Save : string -&gt; unit&#xA;override this.Save : string -&gt; unit" Usage="xmlDocument.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filename">문서를 저장할 파일의 위치입니다.</param>
        <summary>XML 문서를 지정된 파일에 저장합니다. 지정한 파일이 존재하면 이 메서드를 덮어씁니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에만 출력 파일에 공백이 유지 됩니다 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 로 설정 된 `true`합니다.  
  
 현재 XmlDeclaration `XmlDocument` 개체 인코딩 특성에 저장된 된 문서를 확인 합니다. 인코딩 특성의 값을 가져옵니다는 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> 속성입니다. 경우는 `XmlDocument` 않습니다 XmlDeclaration, 없거나는 XmlDeclaration 인코딩 특성에 없는 경우 저장된 된 문서 것 하나 중 하나입니다.  
  
 문서를 저장 하는 경우 (로컬 이름 + 네임 스페이스 URI) 노드 id를 올바르게 유지 하도록 xmlns 특성 생성 됩니다. 예를 들어 다음 C# 코드  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 이 xml 특성을 생성 `<item xmls="urn:1"/>`합니다.  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 만 <xref:System.Xml.XmlDocument.Save%2A> 메서드는 올바른 형식의 XML 문서를 적용 합니다. 다른 모든 `Save` 오버 로드는 단편만 잘 구성 된 합니다.  
  
   
  
## Examples  
 다음 예제에서는 XmlDocument 개체로 XML을 로드 하려면 수정 하 고 data.xml 라는 파일에 저장 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Data.xml 파일을 다음 XML이 포함 됩니다. `<item><name>wrench</name><price>10.95</price></item>`합니다.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 작업을 수행하면 올바른 형식의 XML 문서가 생성되지 않습니다(예: 문서 요소 또는 중복 XML 선언 없음).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Xml.XmlWriter -&gt; unit&#xA;override this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.Save w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">저장할 대상 <see langword="XmlWriter" />입니다.</param>
        <summary>XML 문서를 지정된 <see cref="T:System.Xml.XmlWriter" />에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 경우에 공백이 유지 됩니다 <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> 로 설정 된 `true`합니다.  
  
 인코딩을 합니다 `XmlWriter` 기록 되는 인코딩을 결정 (인코딩의 바뀝니다 XmlDeclaration 노드 인코딩는 `XmlWriter`). 있는 경우에 지정 된 인코딩이 합니다 `XmlWriter`, `XmlDocument` 인코딩 특성이 없는 저장 됩니다.  
  
 문서를 저장 하는 경우 xmlns 특성 (LocalName + NamespaceURI) 노드 id를 올바르게 유지 하도록 생성 됩니다. 예를 들어 다음 C# 코드  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 이 xml 특성을 생성합니다.  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다.  
  
 만 <xref:System.Xml.XmlDocument.Save%2A> 메서드는 올바른 형식의 XML 문서를 적용 합니다. 다른 모든 `Save` 오버 로드는 단편만 잘 구성 된 합니다.  
  
   
  
## Examples  
 다음 예제에서는 XML을 로드는 `XmlDocument` 개체 및 파일에 저장 합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 작업을 수행하면 올바른 형식의 XML 문서가 생성되지 않습니다(예: 문서 요소 또는 중복 XML 선언 없음).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>노드의 PSVI(스키마 유효성 검사 이후 정보 집합)를 반환합니다.</summary>
        <value>노드의 PSVI를 나타내는 <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 속성의 PSVI 콘텐츠 노드의 유효성이 검사 된 후 설정 됩니다.  
  
 이 속성은 DOM(문서 개체 모델)에 대한 Microsoft 확장입니다.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>이 <see cref="T:System.Xml.XmlDocument" />에 연결된 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 개체를 가져오거나 설정합니다.</summary>
        <value>이 <see cref="T:System.Xml.XmlDocument" />에 연결된 XSD(XML 스키마 정의) 언어를 포함하는 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 개체이거나, 빈 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 개체입니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 에 포함 된 스키마는 <xref:System.Xml.Schema.XmlSchemaSet> 연관 된 개체를 <xref:System.Xml.XmlDocument> 개체 유효성 검사에 사용 되 때 합니다 <xref:System.Xml.XmlDocument.Validate%2A> 메서드의 <xref:System.Xml.XmlDocument> 실행 됩니다.  
  
 경우는 <xref:System.Xml.XmlDocument> 개체에서 XML 데이터를 사용 하 여 초기화 됩니다는 <xref:System.Xml.XmlReader> 개체를 <xref:System.Xml.Schema.XmlSchemaSet> 개체에서 로드 되는 <xref:System.Xml.XmlReaderSettings.Schemas%2A> 속성의는 <xref:System.Xml.XmlReader> 개체.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="P:System.Xml.XmlDocument.Schemas" /> 속성에 포함된 XSD(XML 스키마 정의) 언어 스키마를 기준으로 <see cref="T:System.Xml.XmlDocument" />의 유효성을 검사합니다.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="xmlDocument.Validate validationEventHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">스키마 유효성 검사 경고 및 오류에 대한 정보를 받는 <see cref="T:System.Xml.Schema.ValidationEventHandler" /> 개체입니다.</param>
        <summary><see cref="P:System.Xml.XmlDocument.Schemas" /> 속성에 포함된 XSD(XML 스키마 정의) 언어 스키마를 기준으로 <see cref="T:System.Xml.XmlDocument" />의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> 메서드의 XML 데이터의 유효성을 검사 합니다 <xref:System.Xml.XmlDocument> 에 포함 된 스키마에 대해는 <xref:System.Xml.XmlDocument.Schemas%2A> 속성입니다. <xref:System.Xml.XmlDocument.Validate%2A> 메서드 infoset 확대를 수행 합니다. 특히, 유효성 검사에 성공한 후 스키마 기본값이 적용 됩니다, 텍스트 값이 필요에 따라 원자 값으로 변환 및 형식 정보는 유효성이 검사 된 정보 항목과 연결 됩니다. 결과 이전에 형식화 되지 않은 XML 하위 트리를는 <xref:System.Xml.XmlDocument> 형식화 된 하위 트리를 사용 하 여 대체 합니다.  
  
 다음은 사용 하는 경우를 고려해 야 할 중요 한 정보는 <xref:System.Xml.XmlDocument.Validate%2A> 메서드.  
  
-   스키마 위치 힌트와 같은 `xsi:schemaLocation` 또는 `xsi:noNamespaceSchemaLocation` 무시 됩니다.  
  
-   인라인 스키마는 무시 됩니다.  
  
-   유효성 검사 중에 스키마 유효성 검사 오류가 발생 하는 경우는 <xref:System.Xml.XmlDocument> 가 올바른 형식 정보를 사용 하 여 일부 노드 없이 일부와 부분적으로 유효성을 검사 합니다.  
  
-   유효성 검사 프로세스는 고유성 및 참조 제약 조건에 대 한 확인이 포함 됩니다 (`xs:ID`, `xs:IDREF`를 `xs:key`합니다 `xs:keyref`, 및 `xs:unique`).  
  
   
  
## Examples  
 다음 예제에서는 <xref:System.Xml.XmlDocument.Validate%2A> 메서드를 사용하는 방법을 보여줍니다. 이 예에서는 만듭니다는 <xref:System.Xml.XmlDocument> 사용 하 여 연결 된 XSD 스키마를 포함 하는 <xref:System.Xml.XmlReaderSettings> 및 <xref:System.Xml.XmlReader> 개체입니다. 이 예제에서는 다음 사용은 <xref:System.Xml.XPath.XPathNavigator> 스키마 유효성 검사 오류를 생성 하는 XML 문서에 있는 요소의 형식화 된 값을 올바르게 수정 하는 클래스입니다.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 이 예제에서는 사용 된 `contosoBooks.xml` 및 `contosoBooks.xsd` 파일을 입력으로 합니다.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">스키마 유효성 검사 이벤트가 발생했으며 <see cref="T:System.Xml.Schema.ValidationEventHandler" /> 개체가 지정되지 않았습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler * System.Xml.XmlNode -&gt; unit" Usage="xmlDocument.Validate (validationEventHandler, nodeToValidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">스키마 유효성 검사 경고 및 오류에 대한 정보를 받는 <see cref="T:System.Xml.Schema.ValidationEventHandler" /> 개체입니다.</param>
        <param name="nodeToValidate"><see cref="T:System.Xml.XmlDocument" />에서 만든 <see cref="T:System.Xml.XmlNode" /> 개체이며 유효성을 검사할 대상입니다.</param>
        <summary><see cref="P:System.Xml.XmlDocument.Schemas" /> 속성에 포함된 XSD(XML 스키마 정의) 언어 스키마를 기준으로, 지정된 <see cref="T:System.Xml.XmlNode" /> 개체의 유효성을 검사합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDocument.Validate%2A> 메서드의 XML 데이터의 유효성을 검사 합니다 <xref:System.Xml.XmlNode> 개체에 포함 된 스키마에 대해는 <xref:System.Xml.XmlDocument.Schemas%2A> 속성입니다. <xref:System.Xml.XmlDocument.Validate%2A> 메서드 infoset 확대를 수행 합니다. 특히, 유효성 검사에 성공한 후 스키마 기본값이 적용 됩니다, 텍스트 값이 필요에 따라 원자 값으로 변환 및 형식 정보는 유효성이 검사 된 정보 항목과 연결 됩니다. 결과 이전에 형식화 되지 않은 XML 하위 트리를는 <xref:System.Xml.XmlDocument> 형식화 된 하위 트리를 사용 하 여 대체 합니다.  
  
 다음은 사용 하는 경우를 고려해 야 할 중요 한 정보는 <xref:System.Xml.XmlDocument.Validate%2A> 메서드.  
  
-   스키마 위치 힌트와 같은 `xsi:schemaLocation` 또는 `xsi:noNamespaceSchemaLocation` 무시 됩니다.  
  
-   인라인 스키마는 무시 됩니다.  
  
-   유효성 검사 중에 스키마 유효성 검사 오류가 발생 하는 경우는 <xref:System.Xml.XmlDocument> 가 올바른 형식 정보를 사용 하 여 일부 노드 없이 일부와 부분적으로 유효성을 검사 합니다.  
  
 유효성 검사 프로세스 고유성 및 참조 제약 조건에 대 한 확인을 포함 유효성을 검사할 노드입니다 루트 노드인 경우 (`xs:ID`, `xs:IDREF`를 `xs:key`, `xs:keyref`, 및 `xs:unique`)이 고, 그렇지 않으면 고유성 및 참조 제약 조건 생략 됩니다.  
  
   
  
## Examples  
 예는 <xref:System.Xml.XmlDocument.Validate%2A> 메서드를 참조 합니다 <xref:System.Xml.XmlDocument.Validate%2A> 메서드.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Xml.XmlNode" /> 개체 매개 변수는 <see cref="T:System.Xml.XmlDocument" />에서 만들어지지 않았습니다.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlNode" /> 개체 매개 변수는 요소, 특성, 문서 조각 또는 루트 노드가 아닙니다.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">스키마 유효성 검사 이벤트가 발생했으며 <see cref="T:System.Xml.Schema.ValidationEventHandler" /> 개체가 지정되지 않았습니다.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberSignature Language="F#" Value="override this.WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteContentTo xw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">저장할 대상 <see langword="XmlWriter" />입니다.</param>
        <summary><see langword="XmlDocument" /> 노드의 모든 자식을 지정된 <see cref="T:System.Xml.XmlWriter" />에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다. 기능적으로 <xref:System.Xml.XmlDocument.InnerXml%2A> 속성입니다.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> 속성 기록 되는 인코딩을 결정 합니다. 경우는 `Encoding` 속성에 값이 없는 `XmlDocument` 인코딩 특성이 없는 기록 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 화면에 표시 되는 문서를 표시합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">저장할 대상 <see langword="XmlWriter" />입니다.</param>
        <summary><see langword="XmlDocument" /> 노드를 지정된 <see cref="T:System.Xml.XmlWriter" />에 저장합니다.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 이 메서드는 문서 개체 모델 (DOM)에 대 한 Microsoft 확장입니다. 기능적으로 <xref:System.Xml.XmlNode.OuterXml%2A> 속성입니다.  
  
 <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> 속성 기록 되는 인코딩을 결정 합니다. 경우는 `Encoding` 속성에 값이 없는 `XmlDocument` 인코딩 특성이 없는 기록 됩니다.  
  
   
  
## Examples  
 다음 예제에서는 화면에 표시 되는 문서를 표시합니다.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>외부 리소스 확인을 위해 사용할 <see cref="T:System.Xml.XmlResolver" />를 설정합니다.</summary>
        <value>사용할 <see langword="XmlResolver" />입니다.  
  
.NET Framework 버전 1.1에서는 완전히 신뢰할 수 있는 호출자만 <see langword="XmlResolver" />를 지정할 수 있습니다.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlResolver` Dtd를 로드 또는 엔터티 참조 확장에 사용할 수 있습니다. 사용 하 여를 <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> 속성에 자격 증명을 설정할 수 있습니다를 `XmlResolver` 보안 네트워크 리소스에 저장 된 리소스에 액세스할 수 있습니다.  
  
-   문서를 사용 하 여 로드 한 경우는 <xref:System.Xml.XmlReader> (즉, 스트림을 사용 하 여 로드 된 경우 파일 및 등)를 `XmlResolver` 에 `XmlDocument` 항상 사용 됩니다.  
  
-   문서를 사용 하 여 로드 하는 경우는 <xref:System.Xml.XmlTextReader>, 확인자에는 `XmlTextReader` DocumentType 노드에서 DTD 참조를 확인 하는 데 사용 됩니다. 확인 기는 `XmlDocument` 엔터티 참조를 확장 하는 데 사용 됩니다.  
  
-   문서를 사용 하 여 로드 하는 경우는 <xref:System.Xml.XmlValidatingReader>, 확인자에는 `XmlDocument` 사용 되지 않습니다.  
  
-   확장 하는 클래스를 사용 하 여 문서를 로드 하는 경우 `XmlReader` 하며 `XmlReader` 엔터티를 확인할 수 없습니다 (<xref:System.Xml.XmlReader.CanResolveEntity%2A> 반환 `false`), `XmlResolver` 에서 `XmlDocument` DocumentType 노드에서 참조를 확인 하는 데 사용 됩니다 및 모든 엔터티 참조를 확장 합니다.  
  
> [!NOTE]
>  경우는 `XmlDocument` 를 사용 하 여 로드 되는 <xref:System.Xml.XmlReader> 있었습니다는 `XmlResolver` 를 설정를 `XmlResolver` 에 `XmlReader` 에서 캐시 되지 않습니다를 `XmlDocument` 후 <xref:System.Xml.XmlDocument.Load%2A> 완료 합니다.  
  
 .NET Framework의 버전 1.1에서는이 속성을 설정 하지 않으면 응용 프로그램의 신뢰 수준을 기본 동작을 결정 합니다.  
  
 `Fully trusted code:` 기본값을 사용 하는 문서의 <xref:System.Xml.XmlUrlResolver> 사용자 자격 증명 없이 합니다. 사용 하 여 네트워크 리소스에 액세스 하는 데 인증이 필요 합니다 `XmlResolver` 속성에 지정할는 `XmlResolver` 에 필요한 자격 증명입니다.  
  
 `Semi-trusted code:` 합니다 `XmlResolver` 속성이 `null`합니다. 외부 리소스가 확인 되지 않습니다.  
  
 보안에 대 한 자세한 내용은 하며 `XmlResolver` 속성을 참조 하세요 [외부 리소스 확인](~/docs/standard/data/xml/resolving-external-resources.md)합니다.  
  
 이 속성은 DOM(문서 개체 모델)에 대한 Microsoft 확장입니다.  
  
   
  
## Examples  
 다음 예제에서는 DTD 파일에 대 한 참조를 포함 하는 XML 문서를 로드 합니다. `XmlResolver` 속성은 네트워크 리소스에 액세스 하는 데 필요한 자격 증명을 설정 하는 데 사용 됩니다.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 이 예제에서는 입력으로 다음 데이터 파일을 사용 합니다.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">이 속성이 <see langword="null" />로 설정되어 있고 외부 DTD 또는 엔터티가 발생했습니다.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>