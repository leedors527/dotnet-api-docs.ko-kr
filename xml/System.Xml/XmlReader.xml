<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11875a359d825ee237c2cf3f626d350c996a05d8" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ko-KR" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53499854" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="58cdf-101">빠르고, 캐시되지 않으며 앞으로만 이동 가능한 XML 데이터 액세스를 제공하는 판독기를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-101">Represents a reader that provides fast, noncached, forward-only access to XML data.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-102"><xref:System.Xml.XmlReader> 문서 또는 스트림에 XML 데이터에 대 한 정방향 전용, 읽기 전용 액세스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-102"><xref:System.Xml.XmlReader> provides forward-only, read-only access to XML data in a document or stream.</span></span> <span data-ttu-id="58cdf-103">이 클래스는 W3C에 맞는 [Extensible Markup Language (XML) 1.0 (1.0(fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) 하며 [XML 1.0에서 네임 스페이스 (세 번째 버전)](https://www.w3.org/TR/REC-xml-names/) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-103">This class conforms to the W3C [Extensible Markup Language (XML) 1.0 (fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) and the [Namespaces in XML 1.0 (third edition)](https://www.w3.org/TR/REC-xml-names/) recommendations.</span></span>  
  
 <span data-ttu-id="58cdf-104"><xref:System.Xml.XmlReader> 메서드를 사용 하 여 XML 데이터를 탐색 하 고 노드의 내용을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-104"><xref:System.Xml.XmlReader> methods let you move through XML data and read the contents of a node.</span></span> <span data-ttu-id="58cdf-105">클래스의 속성을 판독기 위치는 현재 노드의 값을 반영 합니다. <xref:System.Xml.XmlReader.ReadState%2A> 속성 값은 XML 판독기의 현재 상태를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-105">The properties of the class reflect the value of the current node, which is where the reader is positioned.The <xref:System.Xml.XmlReader.ReadState%2A> property value indicates the current state of the XML reader.</span></span> <span data-ttu-id="58cdf-106">속성으로 예를 들어 <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> 여는 <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> 메서드 및 <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> 하 여는 <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-106">For example, the property is set to <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> by the <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> method and <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> by the <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58cdf-107"><xref:System.Xml.XmlReader> 또한 데이터 규칙 검사 및 DTD 또는 스키마에 대해 유효성 검사를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-107"><xref:System.Xml.XmlReader> also provides data conformance checks and validation against a DTD or schema.</span></span>  
  
 <span data-ttu-id="58cdf-108"><xref:System.Xml.XmlReader> 데이터를 검색 하는 끌어오기 모델을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-108"><xref:System.Xml.XmlReader> uses a pull model to retrieve data.</span></span> <span data-ttu-id="58cdf-109">이 모델:</span><span class="sxs-lookup"><span data-stu-id="58cdf-109">This model:</span></span>  
  
-   <span data-ttu-id="58cdf-110">상태 관리를 자연스럽 고 위에서 아래로 하향 프로시저 방식을 간소화합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-110">Simplifies state management by a natural, top-down procedural refinement.</span></span>  
  
-   <span data-ttu-id="58cdf-111">여러 입력된 스트림 및 계층화를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-111">Supports multiple input streams and layering.</span></span>  
  
-   <span data-ttu-id="58cdf-112">클라이언트 쪽을 문자열 직접 기록 및 따라서 복사본을 다른 문자열의 필요성을 방지 하는 버퍼를 파서에 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-112">Enables the client to give the parser a buffer into which the string is directly written, and thus avoids the necessity of an extra string copy.</span></span>  
  
-   <span data-ttu-id="58cdf-113">선택적 처리를 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-113">Supports selective processing.</span></span> <span data-ttu-id="58cdf-114">클라이언트 항목을 건너뛰고 애플리케이션에 관심 있는 것을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-114">The client can skip items and process those that are of interest to the application.</span></span> <span data-ttu-id="58cdf-115">또한 (예: 표준화) XML 스트림이 처리 되는 방식을 관리 하는 사전에 속성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-115">You can also set properties in advance to manage how the XML stream is processed (for example, normalization).</span></span>  
  
 <span data-ttu-id="58cdf-116">섹션 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-116">In this section:</span></span>  
  
 <span data-ttu-id="58cdf-117">[XML 판독기 만들기](#xmlreader_create) </span><span class="sxs-lookup"><span data-stu-id="58cdf-117">[Creating an XML reader](#xmlreader_create) </span></span>  
 <span data-ttu-id="58cdf-118">[XML 데이터 유효성 검사](#xmlreader_validate) </span><span class="sxs-lookup"><span data-stu-id="58cdf-118">[Validating XML data](#xmlreader_validate) </span></span>  
 <span data-ttu-id="58cdf-119">[데이터 규칙](#xmlreader_data) </span><span class="sxs-lookup"><span data-stu-id="58cdf-119">[Data conformance](#xmlreader_data) </span></span>  
 <span data-ttu-id="58cdf-120">[노드 탐색](#xmlreader_nodes) </span><span class="sxs-lookup"><span data-stu-id="58cdf-120">[Navigating through nodes](#xmlreader_nodes) </span></span>  
 <span data-ttu-id="58cdf-121">[읽을 XML 요소](#xmlreader_elements) </span><span class="sxs-lookup"><span data-stu-id="58cdf-121">[Reading XML elements](#xmlreader_elements) </span></span>  
 <span data-ttu-id="58cdf-122">[읽을 XML 특성](#xmlreader_attributes) </span><span class="sxs-lookup"><span data-stu-id="58cdf-122">[Reading XML attributes](#xmlreader_attributes) </span></span>  
 <span data-ttu-id="58cdf-123">[읽을 XML 콘텐츠](#xmlreader_content) </span><span class="sxs-lookup"><span data-stu-id="58cdf-123">[Reading XML content](#xmlreader_content) </span></span>  
 <span data-ttu-id="58cdf-124">[CLR 형식으로 변환](#xmlreader_clr) </span><span class="sxs-lookup"><span data-stu-id="58cdf-124">[Converting to CLR types](#xmlreader_clr) </span></span>  
 <span data-ttu-id="58cdf-125">[비동기 프로그래밍](#xmlreader_async) </span><span class="sxs-lookup"><span data-stu-id="58cdf-125">[Asynchronous programming](#xmlreader_async) </span></span>  
 [<span data-ttu-id="58cdf-126">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="58cdf-126">Security considerations</span></span>](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a><span data-ttu-id="58cdf-127">XML 판독기 만들기</span><span class="sxs-lookup"><span data-stu-id="58cdf-127">Creating an XML reader</span></span>  
 <span data-ttu-id="58cdf-128">사용 된 <xref:System.Xml.XmlReader.Create%2A> 메서드를는 <xref:System.Xml.XmlReader> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="58cdf-128">Use the <xref:System.Xml.XmlReader.Create%2A> method to create an <xref:System.Xml.XmlReader> instance.</span></span>  
  
 <span data-ttu-id="58cdf-129">.NET Framework의 구체적 구현을 제공 하지만 <xref:System.Xml.XmlReader> 와 같은 클래스를 <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, 및 <xref:System.Xml.XmlValidatingReader> 클래스 좋습니다 특수 한 클래스를 사용 하 여 이러한 시나리오에만:</span><span class="sxs-lookup"><span data-stu-id="58cdf-129">Although the .NET Framework provides concrete implementations of the <xref:System.Xml.XmlReader> class, such as the <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, and the <xref:System.Xml.XmlValidatingReader> classes, we recommend that you use the specialized classes only in these scenarios:</span></span>  
  
-   <span data-ttu-id="58cdf-130">XML DOM 하위 트리를 읽고 싶은 경우는 <xref:System.Xml.XmlNode> 개체는 <xref:System.Xml.XmlNodeReader> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-130">When you want to read an XML DOM subtree from an <xref:System.Xml.XmlNode> object, use the <xref:System.Xml.XmlNodeReader> class.</span></span> <span data-ttu-id="58cdf-131">그러나 (이 클래스 지원 하지 않습니다 DTD 또는 스키마 유효성 검사 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-131">(However, this class doesn't support DTD or schema validation.)</span></span>  
  
-   <span data-ttu-id="58cdf-132">요청 시 엔터티를 확장 해야, 없는 텍스트 콘텐츠 정규화 하거나 기본 반환 하는 특성을 사용 하지 않으려면는 <xref:System.Xml.XmlTextReader> 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-132">If you must expand entities on request, you don't want your text content normalized, or you don't want default attributes returned, use the <xref:System.Xml.XmlTextReader> class.</span></span>  
  
 <span data-ttu-id="58cdf-133">XML 판독기에서 사용 하도록 설정 하려는 기능의 집합을 지정 하려면를 <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> 개체는 <xref:System.Xml.XmlReader.Create%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-133">To specify the set of features you want to enable on the XML reader, pass an <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> object to the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="58cdf-134">단일을 사용할 수 있습니다 <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> 같은 기능을 갖춘 여러 판독기를 만들 개체 또는 수정 된 <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> 다양 한 기능을 사용 하 여 새 판독기를 만들 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-134">You can use a single <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> object to create multiple readers with the same functionality, or modify the <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> object to create a new reader with a different set of features.</span></span> <span data-ttu-id="58cdf-135">또한 기존 판독기에 기능을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-135">You can also easily add features to an existing reader.</span></span>  
  
 <span data-ttu-id="58cdf-136">사용 하지 않는 경우는 <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> 개체를 기본 설정이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-136">If you don't use a <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> object, default settings are used.</span></span> <span data-ttu-id="58cdf-137">참조 된 <xref:System.Xml.XmlReader.Create%2A> 세부 정보에 대 한 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-137">See the <xref:System.Xml.XmlReader.Create%2A> reference page for details.</span></span>  
  
 <span data-ttu-id="58cdf-138"><xref:System.Xml.XmlReader> throw는 <xref:System.Xml.XmlException> xml 구문 분석 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-138"><xref:System.Xml.XmlReader> throws an <xref:System.Xml.XmlException> on XML parse errors.</span></span> <span data-ttu-id="58cdf-139">예외가 throw 되 면 판독기의 상태 예측 가능한 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-139">After an exception is thrown, the state of the reader is not predictable.</span></span> <span data-ttu-id="58cdf-140">예를 들어, 보고 된 노드 유형을 현재 노드의 실제 노드 형식과 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-140">For example, the reported node type may be different from the actual node type of the current node.</span></span> <span data-ttu-id="58cdf-141">사용 된 <xref:System.Xml.XmlReader.ReadState%2A> 판독기가 오류 상태에 있는지 여부를 확인할 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-141">Use the <xref:System.Xml.XmlReader.ReadState%2A> property to check whether the reader is in error state.</span></span>  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a><span data-ttu-id="58cdf-142">XML 데이터 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="58cdf-142">Validating XML data</span></span>  
 <span data-ttu-id="58cdf-143">XML 문서 요소 관계, 데이터 형식 및 내용 제약 조건의 구조를 정의 하려면 문서 유형 정의 (DTD) 또는 XML 스키마 정의 언어 (XSD)를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-143">To define the structure of an XML document and its element relationships, data types, and content constraints, you use a document type definition (DTD) or XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="58cdf-144">XML 문서에서 정의한 한 모든 구문 요구 사항을 충족 하는 경우에 잘 구성 되려면 것으로 간주 됩니다 합니다 [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-144">An XML document is considered to be well formed if it meets all the syntactical requirements defined by the [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/).</span></span> <span data-ttu-id="58cdf-145">올바른 형식이 고 해당 DTD 또는 스키마에 정의 된 제약 조건에도 부합 하는 경우 유효한 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-145">It's considered valid if it's well formed and also conforms to the constraints defined by its DTD or schema.</span></span> <span data-ttu-id="58cdf-146">(참조를 [W3C XML Schema Part 1: 구조](https://www.w3.org/TR/xmlschema-1/) 하며 [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) 권장 사항입니다.) 그러므로 유효한 모든 XML 문서가 제대로 구성되었더라도 제대로 구성된 XML 문서가 모두 유효한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-146">(See the [W3C XML Schema Part 1: Structures](https://www.w3.org/TR/xmlschema-1/) and the [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) recommendations.) Therefore, although all valid XML documents are well formed, not all well-formed XML documents are valid.</span></span>  
  
 <span data-ttu-id="58cdf-147">인라인 XSD 스키마에서 DTD에 대 한 데이터를 확인할 수 있습니다 또는 XSD 스키마에 저장 된는 <xref:System.Xml.Schema.XmlSchemaSet> 개체 (캐시);에서 이러한 시나리오를 설명 하는 <xref:System.Xml.XmlReader.Create%2A> 참조 페이지.</span><span class="sxs-lookup"><span data-stu-id="58cdf-147">You can validate the data against a DTD, an inline XSD Schema, or an XSD Schema stored in an <xref:System.Xml.Schema.XmlSchemaSet> object (a cache); these scenarios are described on the <xref:System.Xml.XmlReader.Create%2A> reference page.</span></span> <span data-ttu-id="58cdf-148"><xref:System.Xml.XmlReader> Xml-data Reduced (XDR) 스키마 유효성 검사를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-148"><xref:System.Xml.XmlReader> doesn't support XML-Data Reduced (XDR) schema validation.</span></span>  
  
 <span data-ttu-id="58cdf-149">다음 설정을 사용 합니다 <xref:System.Xml.XmlReaderSettings> 있으면 유효성 검사의 유형을 지정 하는 클래스는 <xref:System.Xml.XmlReader> 인스턴스 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-149">You use the following settings on the <xref:System.Xml.XmlReaderSettings> class to specify what type of validation, if any, the <xref:System.Xml.XmlReader> instance supports.</span></span>  
  
|<span data-ttu-id="58cdf-150">이 사용 하 여 <xref:System.Xml.XmlReaderSettings> 멤버</span><span class="sxs-lookup"><span data-stu-id="58cdf-150">Use this <xref:System.Xml.XmlReaderSettings> member</span></span>|<span data-ttu-id="58cdf-151">지정할 함수</span><span class="sxs-lookup"><span data-stu-id="58cdf-151">To specify</span></span>|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<span data-ttu-id="58cdf-152"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-152"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> property</span></span>|<span data-ttu-id="58cdf-153">DTD 처리를 허용할지 여부를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-153">Whether to allow DTD processing.</span></span> <span data-ttu-id="58cdf-154">기본값은 DTD 처리를 허용하지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-154">The default is to disallow DTD processing.</span></span>|  
|<span data-ttu-id="58cdf-155"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-155"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> property</span></span>|<span data-ttu-id="58cdf-156">판독기 데이터의 유효성을 검사 해야 하는지 여부 및 어떤 유형의 (DTD 또는 스키마)를 수행할 유효성 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-156">Whether the reader should validate data, and what type of validation to perform (DTD or schema).</span></span> <span data-ttu-id="58cdf-157">기본값은 데이터 유효성 검사를 수행하지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-157">The default is no data validation.</span></span>|  
|<span data-ttu-id="58cdf-158"><xref:System.Xml.XmlReaderSettings.ValidationEventHandler> 이벤트</span><span class="sxs-lookup"><span data-stu-id="58cdf-158"><xref:System.Xml.XmlReaderSettings.ValidationEventHandler> event</span></span>|<span data-ttu-id="58cdf-159">유효성 검사 이벤트에 대 한 정보를 받기 위해 이벤트 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-159">An event handler for receiving information about validation events.</span></span> <span data-ttu-id="58cdf-160">이벤트 처리기를 지정하지 않으면 첫 번째 유효성 검사 오류에서 <xref:System.Xml.XmlException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-160">If an event handler is not provided, an <xref:System.Xml.XmlException> is thrown on the first validation error.</span></span>|  
|<span data-ttu-id="58cdf-161"><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-161"><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> property</span></span>|<span data-ttu-id="58cdf-162">통해 추가 유효성 검사 옵션은 <xref:System.Xml.Schema.XmlSchemaValidationFlags> 열거형 멤버:</span><span class="sxs-lookup"><span data-stu-id="58cdf-162">Additional validation options through the <xref:System.Xml.Schema.XmlSchemaValidationFlags> enumeration members:</span></span><br /><br /> <span data-ttu-id="58cdf-163">-   `AllowXmlAttributes`--XML 특성을 허용 하는 중 (`xml:*`) 스키마에 정의 되어 있지는 경우에 인스턴스 문서에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-163">-   `AllowXmlAttributes`-- Allow XML attributes (`xml:*`) in instance documents even when they're not defined in the schema.</span></span> <span data-ttu-id="58cdf-164">데이터 형식을 기준으로 특성의 유효성이 검사됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-164">The attributes are validated based on their data type.</span></span> <span data-ttu-id="58cdf-165">참조 된 <xref:System.Xml.Schema.XmlSchemaValidationFlags> 특정 시나리오에서 사용 하는 설정에 대 한 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-165">See the <xref:System.Xml.Schema.XmlSchemaValidationFlags> reference page for  the setting to use in specific scenarios.</span></span> <span data-ttu-id="58cdf-166">(기본적으로 해제 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-166">(Disabled by default.)</span></span><br /><span data-ttu-id="58cdf-167">-   `ProcessIdentityConstraints` -프로세스 id 제약 조건 (`xs:ID`, `xs:IDREF`를 `xs:key`합니다 `xs:keyref`, `xs:unique`) 유효성 검사 중 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-167">-   `ProcessIdentityConstraints` --Process identity constraints (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) encountered during validation.</span></span> <span data-ttu-id="58cdf-168">(기본적으로 사용 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-168">(Enabled by default.)</span></span><br /><span data-ttu-id="58cdf-169">-   `ProcessSchemaLocation` -지정 된 스키마를 처리 합니다 `xsi:schemaLocation` 또는 `xsi:noNamespaceSchemaLocation` 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-169">-   `ProcessSchemaLocation` --Process schemas specified by the `xsi:schemaLocation` or `xsi:noNamespaceSchemaLocation` attribute.</span></span> <span data-ttu-id="58cdf-170">(기본적으로 사용 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-170">(Enabled by default.)</span></span><br /><span data-ttu-id="58cdf-171">-   `ProcessInlineSchema`-유효성 검사 중 인라인 XML 스키마를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-171">-   `ProcessInlineSchema`-- Process inline XML Schemas during validation.</span></span> <span data-ttu-id="58cdf-172">(기본적으로 해제 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-172">(Disabled by default.)</span></span><br /><span data-ttu-id="58cdf-173">-   `ReportValidationWarnings`-유효성 검사 경고가 발생 하면 이벤트를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-173">-   `ReportValidationWarnings`--Report events if a validation warning occurs.</span></span> <span data-ttu-id="58cdf-174">일반적으로 특정 요소나 특성을 유효성 검사하기 위한 DTD 또는 XML 스키마가 없을 경우 경고가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-174">A warning is typically issued when there is no DTD or XML Schema to validate a particular element or attribute against.</span></span> <span data-ttu-id="58cdf-175">알림에는 <xref:System.Xml.XmlReaderSettings.ValidationEventHandler>가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-175">The <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> is used for notification.</span></span> <span data-ttu-id="58cdf-176">(기본적으로 해제 합니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-176">(Disabled by default.)</span></span>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<span data-ttu-id="58cdf-177">유효성 검사에 사용할 <xref:System.Xml.Schema.XmlSchemaSet>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-177">The <xref:System.Xml.Schema.XmlSchemaSet> to use for validation.</span></span>|  
|<span data-ttu-id="58cdf-178"><xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-178"><xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property</span></span>|<span data-ttu-id="58cdf-179"><xref:System.Xml.XmlResolver> 확인 하 고 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-179">The <xref:System.Xml.XmlResolver> for resolving and accessing external resources.</span></span> <span data-ttu-id="58cdf-180">DTD 및 스키마와 같은 외부 엔터티에 포함할 수 있습니다 `xs:include` 또는 `xs:import` XML 스키마에 포함 된 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-180">This can include external entities such as DTD and schemas, and any `xs:include` or `xs:import` elements contained in the XML Schema.</span></span> <span data-ttu-id="58cdf-181">지정 하지 않으면를 <xref:System.Xml.XmlResolver>는 <xref:System.Xml.XmlReader> 기본값을 사용 하 여 <xref:System.Xml.XmlUrlResolver> 사용자 자격 증명 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-181">If you don't specify an <xref:System.Xml.XmlResolver>, the <xref:System.Xml.XmlReader> uses a default <xref:System.Xml.XmlUrlResolver> with no user credentials.</span></span>|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a><span data-ttu-id="58cdf-182">데이터 규칙</span><span class="sxs-lookup"><span data-stu-id="58cdf-182">Data conformance</span></span>  
 <span data-ttu-id="58cdf-183">만든 XML 판독기를 <xref:System.Xml.XmlReader.Create%2A> 메서드는 기본적으로 다음 규정 준수 요구 사항을 충족 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-183">XML readers that are created by the <xref:System.Xml.XmlReader.Create%2A> method meet the following compliance requirements by default:</span></span>  
  
-   <span data-ttu-id="58cdf-184">새 줄 및 특성 값은 W3C에 따라 정규화 됩니다 [XML 1.0 권장 사항](https://www.w3.org/TR/2006/REC-xml-20060816/)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-184">New lines and attribute value are normalized according to the W3C [XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/).</span></span>  
  
-   <span data-ttu-id="58cdf-185">모든 엔터티가 자동으로 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-185">All entities are automatically expanded.</span></span>  
  
-   <span data-ttu-id="58cdf-186">문서 종류 정의에서 선언 된 기본 특성은 판독기의 유효성을 검사 하지 않습니다 하는 경우에 항상 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-186">Default attributes declared in the document type definition are always added even when the reader doesn't validate.</span></span>  
  
-   <span data-ttu-id="58cdf-187">올바른 XML 네임 스페이스 URI에 매핑되는 XML 접두사는 선언 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-187">Declaration of XML prefix mapped to the correct XML namespace URI is allowed.</span></span>  
  
-   <span data-ttu-id="58cdf-188">표기법 이름을 단일에서 `NotationType` 특성 선언 하 고 `NmTokens` 단일에서 `Enumeration` 특성 선언에는 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-188">The notation names in a single `NotationType` attribute declaration and `NmTokens` in a single `Enumeration` attribute declaration are distinct.</span></span>  
  
 <span data-ttu-id="58cdf-189">이 사용 하 여 <xref:System.Xml.XmlReaderSettings> 규칙의 형식을 확인 하면를 지정 하는 속성을 사용 하도록 설정 하려면:</span><span class="sxs-lookup"><span data-stu-id="58cdf-189">Use these <xref:System.Xml.XmlReaderSettings> properties to specify the type of conformance checks you want to enable:</span></span>  
  
|<span data-ttu-id="58cdf-190">이 사용 하 여 <xref:System.Xml.XmlReaderSettings> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-190">Use this <xref:System.Xml.XmlReaderSettings> property</span></span>|<span data-ttu-id="58cdf-191">대상</span><span class="sxs-lookup"><span data-stu-id="58cdf-191">To</span></span>|<span data-ttu-id="58cdf-192">기본</span><span class="sxs-lookup"><span data-stu-id="58cdf-192">Default</span></span>|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<span data-ttu-id="58cdf-193"><xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-193"><xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> property</span></span>|<span data-ttu-id="58cdf-194">다음에 대 한 검사를 사용할지 설정:</span><span class="sxs-lookup"><span data-stu-id="58cdf-194">Enable or disable checks for the following:</span></span><br /><br /> <span data-ttu-id="58cdf-195">자 정의 된 대로 유효한 XML 문자 범위 내에 [2.2 문자](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) W3C XML 1.0 Recommendation의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-195">-   Characters are within the range of legal XML characters, as defined by the [2.2 Characters](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) section of the W3C XML 1.0 Recommendation.</span></span><br /><span data-ttu-id="58cdf-196">-모든 XML 이름이 유효 하 여 정의 된 대로 합니다 [2.3 Common Syntactic Constructs](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) W3C XML 1.0 Recommendation의 섹션입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-196">-   All XML names are valid, as defined by the [2.3 Common Syntactic Constructs](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) section of the W3C XML 1.0 Recommendation.</span></span><br /><br /> <span data-ttu-id="58cdf-197">이 속성 설정 된 경우 `true` (기본값)는 <xref:System.Xml.XmlException> XML 파일에 잘못 된 문자 또는 잘못 된 XML 이름을 포함 하는 경우 예외가 throw 됩니다 (예를 들어 요소 이름이 숫자로 시작할).</span><span class="sxs-lookup"><span data-stu-id="58cdf-197">When this property is set to `true` (default), an <xref:System.Xml.XmlException> exception is thrown if the XML file contains illegal characters or invalid XML names (for example, an element name starts with a number).</span></span>|<span data-ttu-id="58cdf-198">문자 및 이름 확인이 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-198">Character and name checking is enabled.</span></span><br /><br /> <span data-ttu-id="58cdf-199"><xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>를 `false`로 설정하면 문자 엔터티 참조에 대해 문자 검사가 수행되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-199">Setting <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> to `false` turns off character checking for character entity references.</span></span> <span data-ttu-id="58cdf-200">판독기가 텍스트 데이터를 처리 하는 경우에 항상 XML 이름이이 설정에 관계 없이 유효한 지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-200">If the reader is processing text data, it always checks that XML names are valid, regardless of this setting.</span></span> <span data-ttu-id="58cdf-201">**참고:** DTD가 있을 경우 XML 1.0 권장 사항에서는 문서 수준 규칙을 요구 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-201">**Note:**  The XML 1.0 recommendation requires document-level conformance when a DTD is present.</span></span> <span data-ttu-id="58cdf-202">따라서 판독기 지원 하도록 구성 된 경우 <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, 문서 형식 정의 (DTD)를 포함 하는 XML 데이터는 <xref:System.Xml.XmlException> throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-202">Therefore, if the reader is configured to support <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, but the XML data contains a document type definition (DTD), an <xref:System.Xml.XmlException> is thrown.</span></span>|  
|<span data-ttu-id="58cdf-203"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-203"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> property</span></span>|<span data-ttu-id="58cdf-204">적용할 규칙 수준을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-204">Choose the level of conformance to enforce:</span></span><br /><br /> <span data-ttu-id="58cdf-205">-   <xref:System.Xml.ConformanceLevel.Document>.</span><span class="sxs-lookup"><span data-stu-id="58cdf-205">-   <xref:System.Xml.ConformanceLevel.Document>.</span></span> <span data-ttu-id="58cdf-206">에 대 한 규칙을 준수 하는 [올바른 형식의 XML 1.0 문서](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-206">Conforms to the rules for a [well-formed XML 1.0 document](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).</span></span><br /><span data-ttu-id="58cdf-207">-   <xref:System.Xml.ConformanceLevel.Fragment>.</span><span class="sxs-lookup"><span data-stu-id="58cdf-207">-   <xref:System.Xml.ConformanceLevel.Fragment>.</span></span> <span data-ttu-id="58cdf-208">로 사용할 수 있는 올바른 형식의 문서 조각에 대 한 규칙을 준수 하는 [외부 엔터티를 구문 분석](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-208">Conforms to the rules for a well-formed document fragment that can be consumed as an [external parsed entity](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).</span></span><br /><span data-ttu-id="58cdf-209">-   <xref:System.Xml.ConformanceLevel.Auto>.</span><span class="sxs-lookup"><span data-stu-id="58cdf-209">-   <xref:System.Xml.ConformanceLevel.Auto>.</span></span> <span data-ttu-id="58cdf-210">판독기에 의해 결정 되며 수준을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-210">Conforms to the level decided by the reader.</span></span><br /><br /> <span data-ttu-id="58cdf-211">에 데이터가 없으면는 <xref:System.Xml.XmlException> 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-211">If the data isn't in conformance, an <xref:System.Xml.XmlException> exception is thrown.</span></span>|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a><span data-ttu-id="58cdf-212">노드 탐색</span><span class="sxs-lookup"><span data-stu-id="58cdf-212">Navigating through nodes</span></span>  
 <span data-ttu-id="58cdf-213">현재 노드는 XML 판독기가 현재 있는 위치 XML 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-213">The current node is the XML node on which the XML reader is currently positioned.</span></span> <span data-ttu-id="58cdf-214">모든 <xref:System.Xml.XmlReader> 메서드는이 노드 및 모든 관련 된 작업을 수행할 <xref:System.Xml.XmlReader> 속성은 현재 노드의 값을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-214">All <xref:System.Xml.XmlReader> methods perform operations in relation to this node, and all <xref:System.Xml.XmlReader> properties reflect the value of the current node.</span></span>  
  
 <span data-ttu-id="58cdf-215">다음 메서드를 사용 하면 쉽게 노드를 탐색 하 고 데이터를 구문 분석에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-215">The following methods make it easy to navigate through nodes and parse data.</span></span>  
  
|<span data-ttu-id="58cdf-216">이 사용 하 여 <xref:System.Xml.XmlReaderSettings> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-216">Use this <xref:System.Xml.XmlReaderSettings> method</span></span>|<span data-ttu-id="58cdf-217">대상</span><span class="sxs-lookup"><span data-stu-id="58cdf-217">To</span></span>|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|<span data-ttu-id="58cdf-218">첫 번째 노드를 읽고 스트림 하나의 노드를 통해 한 번에 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-218">Read the first node, and advance through the stream one node at a time.</span></span> <span data-ttu-id="58cdf-219">이러한 호출 내에서 일반적으로 수행 되는 `while` 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-219">Such calls are typically performed inside a `while` loop.</span></span><br /><br /> <span data-ttu-id="58cdf-220">사용 된 <xref:System.Xml.XmlReader.NodeType%2A> 현재 노드의 형식 (예: 특성, 주석, 요소 및 등)를 가져올 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-220">Use the <xref:System.Xml.XmlReader.NodeType%2A> property to get the type (for example, attribute, comment, element, and so on) of the current node.</span></span>|  
|<xref:System.Xml.XmlReader.Skip%2A>|<span data-ttu-id="58cdf-221">현재 노드의 자식을 건너뛰고 노드로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-221">Skip the children of the current node and move to the next node.</span></span>|  
|<span data-ttu-id="58cdf-222"><xref:System.Xml.XmlReader.MoveToContent%2A> 및 <xref:System.Xml.XmlReader.MoveToContentAsync%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-222"><xref:System.Xml.XmlReader.MoveToContent%2A> and <xref:System.Xml.XmlReader.MoveToContentAsync%2A></span></span>|<span data-ttu-id="58cdf-223">콘텐츠가 아닌 노드를 건너뛰고 콘텐츠 노드가 또는 파일의 끝을 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-223">Skip non-content nodes and move to the next content node or to the end of the file.</span></span><br /><br /> <span data-ttu-id="58cdf-224">비 콘텐츠 노드에 포함 <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>합니다 <xref:System.Xml.XmlNodeType.Whitespace>, 및 <xref:System.Xml.XmlNodeType.SignificantWhitespace>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-224">Non-content nodes include <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, and <xref:System.Xml.XmlNodeType.SignificantWhitespace>.</span></span><br /><br /> <span data-ttu-id="58cdf-225">노드에 포함 공백 없는 텍스트 콘텐츠 <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , 및 <xref:System.Xml.XmlNodeType.EndEntity>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-225">Content nodes include non-white space text, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , and <xref:System.Xml.XmlNodeType.EndEntity>.</span></span>|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|<span data-ttu-id="58cdf-226">요소를 읽고 모든 자식 및 새 반환 <xref:System.Xml.XmlReader> 로 설정 인스턴스입니다 <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-226">Read an element and all its children, and return a new <xref:System.Xml.XmlReader> instance set to <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="58cdf-227">이 메서드는 XML 요소 주위에 경계를 만드는 데 유용 예를 들어, 데이터 처리에 대 한 다른 구성 요소를 전달 하 고 데이터의 양을 제한 하려면 구성 요소 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-227">This method is useful for creating boundaries around XML elements; for example, if you want to pass data to another component for processing and you want to limit how much of your data the component can access.</span></span>|  
  
 <span data-ttu-id="58cdf-228">참조 된 <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> 한 번에 텍스트 스트림 하나의 노드를 탐색 하 고 각 노드 유형의 표시의 예 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-228">See the <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> reference page for an example of navigating through a text stream one node at a time and displaying the type of each node.</span></span>  
  
 <span data-ttu-id="58cdf-229">다음 섹션에서는 특정 유형의 요소, 특성 등의 데이터를 읽는 방법을 설명 하 고 형식화 된 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-229">The following sections describe how you can read specific types of data, such as elements, attributes, and typed data.</span></span>  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a><span data-ttu-id="58cdf-230">읽을 XML 요소</span><span class="sxs-lookup"><span data-stu-id="58cdf-230">Reading XML elements</span></span>  
 <span data-ttu-id="58cdf-231">다음 표에서 메서드 및 속성을 나열 하는 <xref:System.Xml.XmlReader> 요소를 처리 하기 위한 클래스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-231">The following table lists the methods and properties that the <xref:System.Xml.XmlReader> class provides for processing elements.</span></span> <span data-ttu-id="58cdf-232"><xref:System.Xml.XmlReader>가 요소에 있는 경우 <xref:System.Xml.XmlReader.Name%2A>과 같은 노드 속성은 이 요소의 값을 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-232">After the <xref:System.Xml.XmlReader> is positioned on an element, the node properties, such as <xref:System.Xml.XmlReader.Name%2A>, reflect the element values.</span></span> <span data-ttu-id="58cdf-233">아래 설명된 멤버 외에도 <xref:System.Xml.XmlReader> 클래스의 일반 메서드 및 속성을 사용하여 프로세스 요소를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-233">In addition to the members described below, any of the general methods and properties of the <xref:System.Xml.XmlReader> class can also be used to process elements.</span></span> <span data-ttu-id="58cdf-234">예를 들어, <xref:System.Xml.XmlReader.ReadInnerXml%2A> 메서드를 사용하여 요소 내용을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-234">For example, you can use the <xref:System.Xml.XmlReader.ReadInnerXml%2A> method to read the contents of an element.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-235">3.1의 섹션을 참조 합니다 [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) 시작 태그의 정의 태그 및 빈 요소 태그를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-235">See section 3.1 of the [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) for definitions of start tags, end tags, and empty element tags.</span></span>  
  
|<span data-ttu-id="58cdf-236">이 사용 하 여 <xref:System.Xml.XmlReader> 멤버</span><span class="sxs-lookup"><span data-stu-id="58cdf-236">Use this <xref:System.Xml.XmlReader> member</span></span>|<span data-ttu-id="58cdf-237">대상</span><span class="sxs-lookup"><span data-stu-id="58cdf-237">To</span></span>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<span data-ttu-id="58cdf-238"><xref:System.Xml.XmlReader.IsStartElement%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-238"><xref:System.Xml.XmlReader.IsStartElement%2A> method</span></span>|<span data-ttu-id="58cdf-239">현재 노드가 시작 태그 또는 빈 요소 태그 인지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-239">Check if the current node is a start tag or an empty element tag.</span></span>|  
|<span data-ttu-id="58cdf-240"><xref:System.Xml.XmlReader.ReadStartElement%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-240"><xref:System.Xml.XmlReader.ReadStartElement%2A> method</span></span>|<span data-ttu-id="58cdf-241">현재 노드가 요소 인지 확인 하 고 판독기를 다음 노드로 진행 (호출 <xref:System.Xml.XmlReader.IsStartElement%2A> 뒤에 <xref:System.Xml.XmlReader.Read%2A>).</span><span class="sxs-lookup"><span data-stu-id="58cdf-241">Check that the current node is an element and advance the reader to the next node (calls <xref:System.Xml.XmlReader.IsStartElement%2A> followed by <xref:System.Xml.XmlReader.Read%2A>).</span></span>|  
|<span data-ttu-id="58cdf-242"><xref:System.Xml.XmlReader.ReadEndElement%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-242"><xref:System.Xml.XmlReader.ReadEndElement%2A> method</span></span>|<span data-ttu-id="58cdf-243">현재 노드가 끝 태그 인지 확인 하 고 판독기를 다음 노드로 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-243">Check that the current node is an end tag and advance the reader to the next node.</span></span>|  
|<span data-ttu-id="58cdf-244"><xref:System.Xml.XmlReader.ReadElementString%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-244"><xref:System.Xml.XmlReader.ReadElementString%2A> method</span></span>|<span data-ttu-id="58cdf-245">텍스트 전용 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-245">Read a text-only element.</span></span>|  
|<span data-ttu-id="58cdf-246"><xref:System.Xml.XmlReader.ReadToDescendant%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-246"><xref:System.Xml.XmlReader.ReadToDescendant%2A> method</span></span>|<span data-ttu-id="58cdf-247">지정 된 이름을 가진 하위 항목 (자식) 요소 다음에 XML 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-247">Advance the XML reader to the next descendant (child) element that has the specified name.</span></span>|  
|<span data-ttu-id="58cdf-248"><xref:System.Xml.XmlReader.ReadToNextSibling%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-248"><xref:System.Xml.XmlReader.ReadToNextSibling%2A> method</span></span>|<span data-ttu-id="58cdf-249">XML 판독기를 지정 된 이름을 가진 다음 형제 요소로 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-249">Advance the XML reader to the next sibling element that has the specified name.</span></span>|  
|<span data-ttu-id="58cdf-250"><xref:System.Xml.XmlReader.IsEmptyElement%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-250"><xref:System.Xml.XmlReader.IsEmptyElement%2A> property</span></span>|<span data-ttu-id="58cdf-251">현재 요소에 끝 요소 태그가 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-251">Check if the current element has an end element tag.</span></span> <span data-ttu-id="58cdf-252">예:</span><span class="sxs-lookup"><span data-stu-id="58cdf-252">For example:</span></span><br /><br /> <span data-ttu-id="58cdf-253">-   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> 는 `true`.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-253">-   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> is `true`.)</span></span><br /><span data-ttu-id="58cdf-254">-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> 는 `false`이지만 요소의 콘텐츠가 비어 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-254">-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> is `false`, although the element's content is empty.)</span></span>|  
  
 <span data-ttu-id="58cdf-255">요소의 텍스트 콘텐츠를 읽는 예제를 참조 하세요.를 <xref:System.Xml.XmlReader.ReadString%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-255">For an example of reading the text content of elements, see the <xref:System.Xml.XmlReader.ReadString%2A> method.</span></span> <span data-ttu-id="58cdf-256">다음 예제에서는 요소를 사용 하 여 처리를 `while` 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-256">The following example processes elements by using a `while` loop.</span></span>  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a><span data-ttu-id="58cdf-257">읽을 XML 특성</span><span class="sxs-lookup"><span data-stu-id="58cdf-257">Reading XML attributes</span></span>  
 <span data-ttu-id="58cdf-258">XML 특성은 가장 일반적으로 요소에 찾았지만 XML 선언 및 문서 형식 노드에서도 사용할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-258">XML attributes are most commonly found on elements, but they're also allowed on XML declaration and document type nodes.</span></span>  
  
 <span data-ttu-id="58cdf-259">요소 노드에 있을 경우는 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드를 사용 하면 요소의 특성 목록을 통해 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-259">When positioned on an element node, the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method lets you go through the attribute list of the element.</span></span> <span data-ttu-id="58cdf-260">후 유의 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 가 호출 된 노드 속성과 같은 <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, 및 <xref:System.Xml.XmlReader.Prefix%2A> 특성 요소의 속성이 아니라 속한, 해당 특성의 속성을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-260">Note that after <xref:System.Xml.XmlReader.MoveToAttribute%2A> has been called, node properties such as <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, and <xref:System.Xml.XmlReader.Prefix%2A> reflect the properties of that attribute, not the properties of the element the attribute belongs to.</span></span>  
  
 <span data-ttu-id="58cdf-261"><xref:System.Xml.XmlReader> 클래스는 이러한 메서드 및 속성을 읽고 요소에 특성 처리를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-261">The <xref:System.Xml.XmlReader> class provides these methods and properties to read and process attributes on elements.</span></span>  
  
|<span data-ttu-id="58cdf-262">이 사용 하 여 <xref:System.Xml.XmlReader> 멤버</span><span class="sxs-lookup"><span data-stu-id="58cdf-262">Use this <xref:System.Xml.XmlReader> member</span></span>|<span data-ttu-id="58cdf-263">대상</span><span class="sxs-lookup"><span data-stu-id="58cdf-263">To</span></span>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<span data-ttu-id="58cdf-264"><xref:System.Xml.XmlReader.HasAttributes%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-264"><xref:System.Xml.XmlReader.HasAttributes%2A> property</span></span>|<span data-ttu-id="58cdf-265">현재 노드에 특성이 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-265">Check whether the current node has any attributes.</span></span>|  
|<span data-ttu-id="58cdf-266"><xref:System.Xml.XmlReader.AttributeCount%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-266"><xref:System.Xml.XmlReader.AttributeCount%2A> property</span></span>|<span data-ttu-id="58cdf-267">현재 요소에 특성의 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-267">Get the number of attributes on the current element.</span></span>|  
|<span data-ttu-id="58cdf-268"><xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-268"><xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> method</span></span>|<span data-ttu-id="58cdf-269">요소에서 첫 번째 특성으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-269">Move to the first attribute in an element.</span></span>|  
|<span data-ttu-id="58cdf-270"><xref:System.Xml.XmlReader.MoveToNextAttribute%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-270"><xref:System.Xml.XmlReader.MoveToNextAttribute%2A> method</span></span>|<span data-ttu-id="58cdf-271">요소에 다음 특성으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-271">Move to the next attribute in an element.</span></span>|  
|<span data-ttu-id="58cdf-272"><xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-272"><xref:System.Xml.XmlReader.MoveToAttribute%2A> method</span></span>|<span data-ttu-id="58cdf-273">지정된 된 특성으로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-273">Move to a specified attribute.</span></span>|  
|<span data-ttu-id="58cdf-274"><xref:System.Xml.XmlReader.GetAttribute%2A> 메서드 또는 <xref:System.Xml.XmlReader.Item%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-274"><xref:System.Xml.XmlReader.GetAttribute%2A> method or <xref:System.Xml.XmlReader.Item%2A> property</span></span>|<span data-ttu-id="58cdf-275">지정된 된 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-275">Get the value of a specified attribute.</span></span>|  
|<span data-ttu-id="58cdf-276"><xref:System.Xml.XmlReader.IsDefault%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-276"><xref:System.Xml.XmlReader.IsDefault%2A> property</span></span>|<span data-ttu-id="58cdf-277">현재 노드가 DTD 나 스키마에서 정의한 기본값에서 생성 된 특성 인지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-277">Check whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</span></span>|  
|<span data-ttu-id="58cdf-278"><xref:System.Xml.XmlReader.MoveToElement%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-278"><xref:System.Xml.XmlReader.MoveToElement%2A> method</span></span>|<span data-ttu-id="58cdf-279">현재 특성이 있는 요소로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-279">Move to the element that owns the current attribute.</span></span> <span data-ttu-id="58cdf-280">이 메서드를 사용 하 여 해당 특성을 통해 이동한 후 요소 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-280">Use this method to return to an element after navigating through its attributes.</span></span>|  
|<span data-ttu-id="58cdf-281"><xref:System.Xml.XmlReader.ReadAttributeValue%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-281"><xref:System.Xml.XmlReader.ReadAttributeValue%2A> method</span></span>|<span data-ttu-id="58cdf-282">하나 이상의 특성 값을 구문 분석할 `Text`, `EntityReference`, 또는 `EndEntity` 노드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-282">Parse the attribute value into one or more `Text`, `EntityReference`, or `EndEntity` nodes.</span></span>|  
  
 <span data-ttu-id="58cdf-283">또한 일반 <xref:System.Xml.XmlReader> 메서드 및 속성을 사용하여 특성을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-283">Any of the general <xref:System.Xml.XmlReader> methods and properties can also be used to process attributes.</span></span> <span data-ttu-id="58cdf-284">예를 들어, 특성에 <xref:System.Xml.XmlReader>를 배치한 후 <xref:System.Xml.XmlReader.Name%2A> 및 <xref:System.Xml.XmlReader.Value%2A> 속성은 이 특성 값을 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-284">For example, after the <xref:System.Xml.XmlReader> is positioned on an attribute, the <xref:System.Xml.XmlReader.Name%2A> and <xref:System.Xml.XmlReader.Value%2A> properties reflect the values of the attribute.</span></span> <span data-ttu-id="58cdf-285">내용 `Read` 메서드를 사용하여 특성 값을 얻을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-285">You can also use any of the content `Read` methods to get the value of the attribute.</span></span>  
  
 <span data-ttu-id="58cdf-286">이 예제에서는 <xref:System.Xml.XmlReader.AttributeCount%2A> 속성 요소에는 모든 속성을 통해 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-286">This example uses the <xref:System.Xml.XmlReader.AttributeCount%2A> property to navigate through all the attributes on an element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 <span data-ttu-id="58cdf-287">이 예제에서는 합니다 <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> 의 메서드를 `while` 특성을 통해 탐색 하는 루프입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-287">This example uses the <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> method in a `while` loop to navigate through the attributes.</span></span>  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 <span data-ttu-id="58cdf-288">**XML 선언 노드에 특성 읽기**</span><span class="sxs-lookup"><span data-stu-id="58cdf-288">**Reading attributes on XML declaration nodes**</span></span>  
  
 <span data-ttu-id="58cdf-289">XML 선언 노드에 XML 판독기가 배치 하는 경우는 <xref:System.Xml.XmlReader.Value%2A> 속성 버전, 독립 실행형 및 인코딩 정보를 단일 문자열로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-289">When the XML reader is positioned on an XML declaration node, the <xref:System.Xml.XmlReader.Value%2A> property returns the version, standalone, and encoding information as a single string.</span></span> <span data-ttu-id="58cdf-290"><xref:System.Xml.XmlReader> 가 만든 개체를 <xref:System.Xml.XmlReader.Create%2A> 메서드를 <xref:System.Xml.XmlTextReader> 클래스 및 <xref:System.Xml.XmlValidatingReader> 버전, 독립 실행형 및 인코딩 항목을 특성으로 클래스를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-290"><xref:System.Xml.XmlReader> objects created by the <xref:System.Xml.XmlReader.Create%2A> method, the <xref:System.Xml.XmlTextReader> class, and the <xref:System.Xml.XmlValidatingReader> class expose the version, standalone, and encoding items as attributes.</span></span>  
  
 <span data-ttu-id="58cdf-291">**문서 유형 노드 특성 읽기**</span><span class="sxs-lookup"><span data-stu-id="58cdf-291">**Reading attributes on document type nodes**</span></span>  
  
 <span data-ttu-id="58cdf-292">문서 형식 노드에 XML 판독기가 배치 하는 경우는 <xref:System.Xml.XmlReader.GetAttribute%2A> 메서드 및 <xref:System.Xml.XmlReader.Item%2A> SYSTEM 및 PUBLIC 리터럴에 대 한 값을 반환 하도록 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-292">When the XML reader is positioned on a document type node, the <xref:System.Xml.XmlReader.GetAttribute%2A> method and <xref:System.Xml.XmlReader.Item%2A> property can be used to return the values for the SYSTEM and PUBLIC literals.</span></span> <span data-ttu-id="58cdf-293">예를 들어, `reader.GetAttribute("PUBLIC")`를 호출하면 PUBLIC 값이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-293">For example, calling `reader.GetAttribute("PUBLIC")` returns the PUBLIC value.</span></span>  
  
 <span data-ttu-id="58cdf-294">**처리 명령 노드 특성을 읽는 중**</span><span class="sxs-lookup"><span data-stu-id="58cdf-294">**Reading attributes on processing instruction nodes**</span></span>  
  
 <span data-ttu-id="58cdf-295">처리 명령 노드에 <xref:System.Xml.XmlReader>를 배치하면 <xref:System.Xml.XmlReader.Value%2A> 속성은 전체 텍스트 내용을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-295">When the <xref:System.Xml.XmlReader> is positioned on a processing instruction node, the <xref:System.Xml.XmlReader.Value%2A> property returns the entire text content.</span></span> <span data-ttu-id="58cdf-296">처리 명령 노드의 항목 특성으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-296">Items in the processing instruction node aren't treated as attributes.</span></span> <span data-ttu-id="58cdf-297">사용 하 여 읽을 수 없습니다는 <xref:System.Xml.XmlReader.GetAttribute%2A> 또는 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-297">They can't be read with the <xref:System.Xml.XmlReader.GetAttribute%2A> or <xref:System.Xml.XmlReader.MoveToAttribute%2A> method.</span></span>  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a><span data-ttu-id="58cdf-298">읽을 XML 콘텐츠</span><span class="sxs-lookup"><span data-stu-id="58cdf-298">Reading XML content</span></span>  
 <span data-ttu-id="58cdf-299">XMLReader 클래스에는 XML 파일에서 콘텐츠를 읽기 및 문자열 값으로 콘텐츠를 반환 하는 다음 멤버도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-299">The XMLReader class includes the following members that read content from an XML file and return the content as string values.</span></span> <span data-ttu-id="58cdf-300">(CLR 형식을 반환할 참조 된 [다음 섹션](#xmlreader_clr).)</span><span class="sxs-lookup"><span data-stu-id="58cdf-300">(To return CLR types, see the [next section](#xmlreader_clr).)</span></span>  
  
|<span data-ttu-id="58cdf-301">이 사용 하 여 <xref:System.Xml.XmlReader> 멤버</span><span class="sxs-lookup"><span data-stu-id="58cdf-301">Use this <xref:System.Xml.XmlReader> member</span></span>|<span data-ttu-id="58cdf-302">대상</span><span class="sxs-lookup"><span data-stu-id="58cdf-302">To</span></span>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<span data-ttu-id="58cdf-303"><xref:System.Xml.XmlReader.Value%2A> 속성</span><span class="sxs-lookup"><span data-stu-id="58cdf-303"><xref:System.Xml.XmlReader.Value%2A> property</span></span>|<span data-ttu-id="58cdf-304">현재 노드의 텍스트 콘텐츠를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-304">Get the text content of the current node.</span></span> <span data-ttu-id="58cdf-305">반환 되는 값 노드 형식에 따라 다릅니다. 참조 된 <xref:System.Xml.XmlReader.Value%2A> 세부 정보에 대 한 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-305">The value returned depends on the node type; see the <xref:System.Xml.XmlReader.Value%2A> reference page for details.</span></span>|  
|<span data-ttu-id="58cdf-306"><xref:System.Xml.XmlReader.ReadString%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-306"><xref:System.Xml.XmlReader.ReadString%2A> method</span></span>|<span data-ttu-id="58cdf-307">요소 또는 텍스트 노드의 내용을 문자열로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-307">Get the content of an element or text node as a string.</span></span> <span data-ttu-id="58cdf-308">이 메서드는 처리 명령과 주석에서 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-308">This method stops on processing instructions and comments.</span></span><br /><br /> <span data-ttu-id="58cdf-309">이 메서드가 특정 노드 형식을 처리 하는 방법에 대 한 내용은 참조는 <xref:System.Xml.XmlReader.ReadString%2A> 참조 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-309">For details on how this method handles specific node types, see the <xref:System.Xml.XmlReader.ReadString%2A> reference page.</span></span>|  
|<span data-ttu-id="58cdf-310"><xref:System.Xml.XmlReader.ReadInnerXml%2A> 및 <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-310"><xref:System.Xml.XmlReader.ReadInnerXml%2A> and <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> methods</span></span>|<span data-ttu-id="58cdf-311">현재 노드를 시작 및 끝 태그를 제외한 태그를 포함 한 모든 콘텐츠를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-311">Get all the content of the current node, including the markup, but excluding start and end tags.</span></span> <span data-ttu-id="58cdf-312">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="58cdf-312">For example, for:</span></span><br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <span data-ttu-id="58cdf-313"><xref:System.Xml.XmlReader.ReadInnerXml%2A> 이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-313"><xref:System.Xml.XmlReader.ReadInnerXml%2A> returns:</span></span><br /><br /> `this<child id="123"/>`|  
|<span data-ttu-id="58cdf-314"><xref:System.Xml.XmlReader.ReadOuterXml%2A> 및 <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-314"><xref:System.Xml.XmlReader.ReadOuterXml%2A> and <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> methods</span></span>|<span data-ttu-id="58cdf-315">현재 노드와 해당 자식에 태그 및 시작/끝 태그를 포함 하 여 모든 콘텐츠를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-315">Get all the content of the current node and its children, including markup and start/end tags.</span></span> <span data-ttu-id="58cdf-316">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="58cdf-316">For example, for:</span></span><br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <span data-ttu-id="58cdf-317"><xref:System.Xml.XmlReader.ReadOuterXml%2A> 이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-317"><xref:System.Xml.XmlReader.ReadOuterXml%2A> returns:</span></span><br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a><span data-ttu-id="58cdf-318">CLR 형식으로 변환</span><span class="sxs-lookup"><span data-stu-id="58cdf-318">Converting to CLR types</span></span>  
 <span data-ttu-id="58cdf-319">멤버를 사용할 수는 <xref:System.Xml.XmlReader> (다음 표에 나열 된) 클래스를 XML 데이터를 읽고 문자열 대신 런타임 (CLR) 형식으로 공용 언어 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-319">You can use the members of the <xref:System.Xml.XmlReader> class (listed in the following table) to read XML data and return values as common language runtime (CLR) types instead of strings.</span></span> <span data-ttu-id="58cdf-320">이러한 멤버를 사용 하면 수동으로 구문 분석 하거나 문자열 값을 변환할 필요 없이 코딩 작업에 가장 적합 한 표현으로 값을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-320">These members enable you to get values in the representation that is most appropriate for your coding task without having to manually parse or convert string values.</span></span>  
  
-   <span data-ttu-id="58cdf-321">합니다 **ReadElementContentAs** 메서드 요소 노드 형식 에서만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-321">The **ReadElementContentAs** methods can only be called on element node types.</span></span> <span data-ttu-id="58cdf-322">자식 요소 또는 혼합 내용이 포함된 요소에서는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-322">These methods cannot be used on elements that contain child elements or mixed content.</span></span> <span data-ttu-id="58cdf-323">호출할 경우 <xref:System.Xml.XmlReader> 개체는 시작 태그를 읽고 요소 내용을 읽은 다음 끝 요소 태그를 지나서 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-323">When called, the <xref:System.Xml.XmlReader> object reads the start tag, reads the element content, and then moves past the end element tag.</span></span> <span data-ttu-id="58cdf-324">처리 명령과 주석은 무시되며 엔터티는 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-324">Processing instructions and comments are ignored and entities are expanded.</span></span>  
  
-   <span data-ttu-id="58cdf-325">합니다 **ReadContentAs** 메서드는 현재 판독기 위치에서 텍스트 콘텐츠를 읽고 XML 데이터 형식 정보를 사용 하 여 연결 된 데이터 나 스키마가 없는 경우 텍스트 콘텐츠를 요청된 된 반환 형식으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-325">The **ReadContentAs** methods read the text content at the current reader position, and if the XML data doesn't have any schema or data type information associated with it, convert the text content to the requested return type.</span></span> <span data-ttu-id="58cdf-326">텍스트, 공백, 유효 공백 및 CDATA 섹션이 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-326">Text, white space, significant white space and CDATA sections are concatenated.</span></span> <span data-ttu-id="58cdf-327">주석 및 처리 지침을 건너뛰고 지정 된 엔터티 참조는 자동으로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-327">Comments and processing instructions are skipped, and entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-328">합니다 <xref:System.Xml.XmlReader> 정의한 규칙을 사용 하는 클래스를 [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-328">The <xref:System.Xml.XmlReader> class uses the rules defined by the [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) recommendation.</span></span>  
  
|<span data-ttu-id="58cdf-329">이 사용 하 여 <xref:System.Xml.XmlReader> 메서드</span><span class="sxs-lookup"><span data-stu-id="58cdf-329">Use this <xref:System.Xml.XmlReader> method</span></span>|<span data-ttu-id="58cdf-330">이 CLR 유형을 반환 하려면</span><span class="sxs-lookup"><span data-stu-id="58cdf-330">To return this CLR type</span></span>|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<span data-ttu-id="58cdf-331"><xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-331"><xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A></span></span>|<xref:System.Boolean>|  
|<span data-ttu-id="58cdf-332"><xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-332"><xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A></span></span>|<xref:System.DateTime>|  
|<span data-ttu-id="58cdf-333"><xref:System.Xml.XmlReader.ReadContentAsDouble%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-333"><xref:System.Xml.XmlReader.ReadContentAsDouble%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A></span></span>|<xref:System.Double>|  
|<span data-ttu-id="58cdf-334"><xref:System.Xml.XmlReader.ReadContentAsLong%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-334"><xref:System.Xml.XmlReader.ReadContentAsLong%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A></span></span>|<xref:System.Int64>|  
|<span data-ttu-id="58cdf-335"><xref:System.Xml.XmlReader.ReadContentAsInt%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-335"><xref:System.Xml.XmlReader.ReadContentAsInt%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A></span></span>|<xref:System.Int32>|  
|<span data-ttu-id="58cdf-336"><xref:System.Xml.XmlReader.ReadContentAsString%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-336"><xref:System.Xml.XmlReader.ReadContentAsString%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsString%2A></span></span>|<xref:System.String>|  
|<span data-ttu-id="58cdf-337"><xref:System.Xml.XmlReader.ReadContentAs%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAs%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-337"><xref:System.Xml.XmlReader.ReadContentAs%2A> and <xref:System.Xml.XmlReader.ReadElementContentAs%2A></span></span>|<span data-ttu-id="58cdf-338">사용 하 여 지정한 유형의 `returnType` 매개 변수</span><span class="sxs-lookup"><span data-stu-id="58cdf-338">The type you specify with the `returnType` parameter</span></span>|  
|<span data-ttu-id="58cdf-339"><xref:System.Xml.XmlReader.ReadContentAsObject%2A> 및 <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A></span><span class="sxs-lookup"><span data-stu-id="58cdf-339"><xref:System.Xml.XmlReader.ReadContentAsObject%2A> and <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A></span></span>|<span data-ttu-id="58cdf-340">지정 된 대로 가장 적절 한 형식에는 <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-340">The most appropriate type, as specified by the <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="58cdf-341">참조 [System.Xml 클래스의 형식 지원](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) 매핑 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-341">See [Type Support in the System.Xml Classes](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) for mapping information.</span></span>|  
  
 <span data-ttu-id="58cdf-342">쉽게 요소 형식으로 인해 CLR 형식으로 변환할 수 없는, 경우에 성공적으로 변환 되도록 스키마 매핑을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-342">If an element can't easily be converted to a CLR type because of its format, you can use a schema mapping to ensure a successful conversion.</span></span> <span data-ttu-id="58cdf-343">다음 예제에서는.xsd 파일을 사용 하 여 변환 하는 `hire-date` 요소를를 `xs:date` 유형 및 사용 하 여는 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> 으로 요소를 반환 하는 방법을 <xref:System.DateTime> 개체.</span><span class="sxs-lookup"><span data-stu-id="58cdf-343">The following example uses an .xsd file to convert the `hire-date` element to the `xs:date` type, and then uses the <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> method to return the element as a <xref:System.DateTime> object.</span></span>  
  
 <span data-ttu-id="58cdf-344">**입력 (에서는 hireDate.xml):**</span><span class="sxs-lookup"><span data-stu-id="58cdf-344">**Input (hireDate.xml):**</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 <span data-ttu-id="58cdf-345">**스키마 (hireDate.xsd):**</span><span class="sxs-lookup"><span data-stu-id="58cdf-345">**Schema (hireDate.xsd):**</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 <span data-ttu-id="58cdf-346">**코드:**</span><span class="sxs-lookup"><span data-stu-id="58cdf-346">**Code:**</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 <span data-ttu-id="58cdf-347">**출력:**</span><span class="sxs-lookup"><span data-stu-id="58cdf-347">**Output:**</span></span>  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a><span data-ttu-id="58cdf-348">비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="58cdf-348">Asynchronous programming</span></span>  
 <span data-ttu-id="58cdf-349">대부분의 <xref:System.Xml.XmlReader> 메서드는 "Async" 메서드 이름의 끝에 있는 비동기 버전이 있으며 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-349">Most of the <xref:System.Xml.XmlReader> methods have asynchronous counterparts that have "Async" at the end of their method names.</span></span> <span data-ttu-id="58cdf-350">예를 들어, 비동기 <xref:System.Xml.XmlReader.ReadContentAsObject%2A> 는 <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-350">For example, the asynchronous equivalent of <xref:System.Xml.XmlReader.ReadContentAsObject%2A> is <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.</span></span>  
  
 <span data-ttu-id="58cdf-351">비동기 메서드 호출을 사용 하 여 다음 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-351">The following methods can be used with asynchronous method calls:</span></span>  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 <span data-ttu-id="58cdf-352">다음 섹션에서는 비동기 메서드인 없는 메서드에 대 한 비동기 사용량에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-352">The following sections describe asynchronous usage for methods that don't have asynchronous counterparts.</span></span>  
  
 <span data-ttu-id="58cdf-353">**ReadStartElement 메서드**</span><span class="sxs-lookup"><span data-stu-id="58cdf-353">**ReadStartElement method**</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 <span data-ttu-id="58cdf-354">**ReadEndElement 메서드**</span><span class="sxs-lookup"><span data-stu-id="58cdf-354">**ReadEndElement method**</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 <span data-ttu-id="58cdf-355">**ReadToNextSibling 메서드**</span><span class="sxs-lookup"><span data-stu-id="58cdf-355">**ReadToNextSibling method**</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 <span data-ttu-id="58cdf-356">**ReadToFollowing 메서드**</span><span class="sxs-lookup"><span data-stu-id="58cdf-356">**ReadToFollowing method**</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 <span data-ttu-id="58cdf-357">**ReadToDescendant 메서드**</span><span class="sxs-lookup"><span data-stu-id="58cdf-357">**ReadToDescendant method**</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a><span data-ttu-id="58cdf-358">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="58cdf-358">Security considerations</span></span>  
 <span data-ttu-id="58cdf-359">작업할 때 다음 사항을 고려 합니다 <xref:System.Xml.XmlReader> 클래스:</span><span class="sxs-lookup"><span data-stu-id="58cdf-359">Consider the following when working with the <xref:System.Xml.XmlReader> class:</span></span>  
  
-   <span data-ttu-id="58cdf-360">throw 된 예외는 <xref:System.Xml.XmlReader> 앱에 버블링 하지 않을 경로 정보가 노출 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-360">Exceptions thrown from the <xref:System.Xml.XmlReader> can disclose path information that you might not want bubbled up to your app.</span></span> <span data-ttu-id="58cdf-361">응용 프로그램 예외를 catch 하 고 적절 하 게 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-361">Your app must catch exceptions and process them appropriately.</span></span>  
  
-   <span data-ttu-id="58cdf-362">서비스 거부 문제에 대 한 유지 하려는 경우 또는 신뢰할 수 없는 소스를 처리 하는 경우 DTD 처리를 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-362">Do not enable DTD processing if you're concerned about denial of service issues or if you're dealing with untrusted sources.</span></span> <span data-ttu-id="58cdf-363">기본적으로 DTD 처리가 비활성화 됩니다 <xref:System.Xml.XmlReader> 개체에 의해 생성 된 <xref:System.Xml.XmlReader.Create%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-363">DTD processing is disabled by default for <xref:System.Xml.XmlReader> objects created by the <xref:System.Xml.XmlReader.Create%2A> method.</span></span>  
  
     <span data-ttu-id="58cdf-364">DTD 처리를 활성화하는 경우 <xref:System.Xml.XmlSecureResolver>를 사용하여 <xref:System.Xml.XmlReader>가 액세스할 수 있는 리소스를 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-364">If you have DTD processing enabled, you can use the <xref:System.Xml.XmlSecureResolver> to restrict the resources that the <xref:System.Xml.XmlReader> can access.</span></span> <span data-ttu-id="58cdf-365">또한 XML 처리에 필요한 메모리 및 시간을 제한할 수 있도록 앱을 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-365">You can also design your app so that the XML processing is memory and time constrained.</span></span> <span data-ttu-id="58cdf-366">예를 들어, ASP.NET 앱의 제한 시간을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-366">For example, you can configure time-out limits in your ASP.NET app.</span></span>  
  
-   <span data-ttu-id="58cdf-367">XML 데이터에는 스키마 파일과 같은 외부 리소스에 대한 참조가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-367">XML data can include references to external resources such as a schema file.</span></span> <span data-ttu-id="58cdf-368">기본적으로 사용 하 여 외부 리소스는 확인을 <xref:System.Xml.XmlUrlResolver> 사용자 자격 증명이 없는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-368">By default, external resources are resolved by using an <xref:System.Xml.XmlUrlResolver> object with no user credentials.</span></span> <span data-ttu-id="58cdf-369">이러한 경우 다음 중 하나를 수행하여 보안을 강화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-369">You can secure this further by doing one of the following:</span></span>  
  
    -   <span data-ttu-id="58cdf-370"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-370">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
  
    -   <span data-ttu-id="58cdf-371"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-371">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to `null`.</span></span>  
  
-   <span data-ttu-id="58cdf-372"><xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 하 고 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 의 유효성 검사 플래그는 <xref:System.Xml.XmlReaderSettings> 개체는 기본적으로 설정 되어 있지 않으면입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-372">The <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> and <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> validation flags of an <xref:System.Xml.XmlReaderSettings> object aren't set by default.</span></span> <span data-ttu-id="58cdf-373">그러므로 신뢰할 수 없는 소스의 XML 데이터를 처리할 때 스키마 기반 공격으로부터 <xref:System.Xml.XmlReader>를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-373">This helps to protect the <xref:System.Xml.XmlReader> against schema-based attacks when it is processing XML data from an untrusted source.</span></span> <span data-ttu-id="58cdf-374">이 플래그를 설정하면 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체의 <xref:System.Xml.XmlReaderSettings>를 사용하여 <xref:System.Xml.XmlReader>에서 인스턴스 문서에 나타난 스키마 위치를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-374">When these flags are set, the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> of the <xref:System.Xml.XmlReaderSettings> object is used to resolve schema locations encountered in the instance document in the <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="58cdf-375">경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 속성이로 설정 되어 `null`, 스키마 위치 확인 되지 경우에 합니다 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 및 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 유효성 검사 플래그를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-375">If the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property is set to `null`, schema locations aren't resolved even if the <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> and <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> validation flags are set.</span></span>  
  
     <span data-ttu-id="58cdf-376">문서의 유효성을 검사하는 동안 스키마를 추가하면 새 형식이 추가되고 해당 문서에 대한 유효성 검사 결과가 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-376">Schemas added during validation add new types and can change the validation outcome of the document being validated.</span></span> <span data-ttu-id="58cdf-377">결과적으로 외부 스키마는 신뢰할 수 있는 소스에서만 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-377">As a result, external schemas should only be resolved from trusted sources.</span></span>  
  
     <span data-ttu-id="58cdf-378">사용 하지 않도록 설정 하는 것이 좋습니다는 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> 문서의 많은 부분을 통해 id 제약 조건이 있는 스키마에 대해 가용성 우선 시나리오에서 신뢰할 수 없는 큰 XML 문서 유효성을 검사할 때 플래그를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-378">We recommend disabling the <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> flag when validating untrusted, large XML documents in high availability scenarios against a schema that has identity constraints over a large part of the document.</span></span> <span data-ttu-id="58cdf-379">이 플래그는 기본적으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-379">This flag is enabled by default.</span></span>  
  
-   <span data-ttu-id="58cdf-380">XML 데이터에는 처리하는 데 시간이 많이 걸리는 수많은 특성, 네임스페이스 선언, 중첩된 요소 등이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-380">XML data can contain a large number of attributes, namespace declarations, nested elements and so on that require a substantial amount of time to process.</span></span> <span data-ttu-id="58cdf-381">전송 되는 입력의 크기를 제한 하는 <xref:System.Xml.XmlReader>, 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-381">To limit the size of the input that is sent to the <xref:System.Xml.XmlReader>, you can:</span></span>  
  
    -   <span data-ttu-id="58cdf-382">설정 하 여 문서의 크기를 제한 합니다 <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-382">Limit the size of the document by setting the <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> property.</span></span>  
  
    -   <span data-ttu-id="58cdf-383">설정 하 여 확장명 엔터티의 결과인 문자 수를 제한 합니다 <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-383">Limit the number of characters that result from expanding entities by setting the <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> property.</span></span>  
  
    -   <span data-ttu-id="58cdf-384">사용자 지정 만들기 `IStream` 에 대 한 구현을 <xref:System.Xml.XmlReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-384">Create a custom `IStream` implementation for the <xref:System.Xml.XmlReader>.</span></span>  
  
-   <span data-ttu-id="58cdf-385"><xref:System.Xml.XmlReader.ReadValueChunk%2A> 메서드를 사용 하 여 데이터의 큰 스트림을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-385">The <xref:System.Xml.XmlReader.ReadValueChunk%2A> method can be used to handle large streams of data.</span></span> <span data-ttu-id="58cdf-386">이 메서드는 전체 값에 대한 단일 문자열을 할당하는 대신 한 번에 적은 수의 문자를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-386">This method reads a small number of characters at a time instead of allocating a single string for the whole value.</span></span>  
  
-   <span data-ttu-id="58cdf-387">많은 수의 고유 로컬 이름, 네임 스페이스 또는 접두사를 사용 하 여 XML 문서를 읽을 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-387">When reading an XML document with a large number of unique local names, namespaces, or prefixes, a problem can occur.</span></span> <span data-ttu-id="58cdf-388">파생 된 클래스를 사용 하는 경우 <xref:System.Xml.XmlReader>를 호출 하는 <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, 또는 <xref:System.Xml.XmlReader.NamespaceURI%2A> 각 항목에 대 한 속성에서 반환된 된 문자열에 추가 됩니다을 <xref:System.Xml.NameTable>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-388">If you are using a class that derives from <xref:System.Xml.XmlReader>, and you call the <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, or <xref:System.Xml.XmlReader.NamespaceURI%2A> property for each item, the returned string is added to a <xref:System.Xml.NameTable>.</span></span> <span data-ttu-id="58cdf-389">포함 된 컬렉션의 <xref:System.Xml.NameTable> 줄 지 않아 문자열 핸들의 가상 메모리 누수 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-389">The collection held by the <xref:System.Xml.NameTable> never decreases in size, creating a virtual memory leak of the string handles.</span></span> <span data-ttu-id="58cdf-390">파생 하는 것이 완화는 <xref:System.Xml.NameTable> 클래스 및 최대 크기 할당량을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-390">One mitigation for this is to derive from the <xref:System.Xml.NameTable> class and enforce a maximum size quota.</span></span> <span data-ttu-id="58cdf-391">(사용 하지 않으려면 방법이 없기를 <xref:System.Xml.NameTable>, 또는 전환의 <xref:System.Xml.NameTable> 가득 찼을 때).</span><span class="sxs-lookup"><span data-stu-id="58cdf-391">(There is no way to prevent the use of a <xref:System.Xml.NameTable>, or to switch the <xref:System.Xml.NameTable> when it is full).</span></span> <span data-ttu-id="58cdf-392">되는 다른 완화 언급 된 속성을 사용 하지 않도록 하 고 대신 사용 하는 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 메서드를 <xref:System.Xml.XmlReader.IsStartElement%2A> 메서드 해당 메서드에 문자열을 반환 하지 채워지지 않습니다 되지 않도록 하 가능한 경우는 <xref:System.Xml.NameTable> 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-392">Another mitigation is to avoid using the properties mentioned and instead use the <xref:System.Xml.XmlReader.MoveToAttribute%2A> method with the <xref:System.Xml.XmlReader.IsStartElement%2A> method where possible; those methods don't return strings and thus avoid the problem of overfilling the <xref:System.Xml.NameTable> collection.</span></span>  
  
-   <span data-ttu-id="58cdf-393"><xref:System.Xml.XmlReaderSettings> 개체에는 사용자 자격 증명과 같은 중요한 정보가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-393"><xref:System.Xml.XmlReaderSettings> objects can contain sensitive information such as user credentials.</span></span> <span data-ttu-id="58cdf-394">신뢰할 수 없는 구성 요소는 <xref:System.Xml.XmlReaderSettings> 개체 및 해당 사용자 자격 증명을 사용하여 <xref:System.Xml.XmlReader> 개체를 만들어 데이터를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-394">An untrusted component could use the <xref:System.Xml.XmlReaderSettings> object and its user credentials to create <xref:System.Xml.XmlReader> objects to read data.</span></span> <span data-ttu-id="58cdf-395">캐시할 때 주의 해야 <xref:System.Xml.XmlReaderSettings> 개체를 전달 하는 경우 또는 <xref:System.Xml.XmlReaderSettings> 다른 하나는 구성 요소에서 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-395">Be careful when caching <xref:System.Xml.XmlReaderSettings> objects, or when passing the <xref:System.Xml.XmlReaderSettings> object from one component to another.</span></span>  
  
-   <span data-ttu-id="58cdf-396">신뢰할 수 없는 소스로부터 <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> 및 <xref:System.Xml.XmlResolver> 개체 등의 지원 구성 요소를 받지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-396">Do not accept supporting components, such as <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, and <xref:System.Xml.XmlResolver> objects, from an untrusted source.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-397">다음 예제 코드에서는 비동기 API를 사용 하 여 XML을 구문 분석 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-397">The following example code shows how to use the asynchronous API to parse XML.</span></span>  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md"><span data-ttu-id="58cdf-398">XML 문서 및 데이터</span><span class="sxs-lookup"><span data-stu-id="58cdf-398">XML Documents and Data</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-399"><see langword="XmlReader" /> 클래스의 새 인스턴스를 초기화합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-399">Initializes a new instance of the <see langword="XmlReader" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-400">이 생성자는이 형식에 대 한 상태를 초기화 하기 위해 파생된 클래스 생성자에서 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-400">This constructor is called by derived class constructors to initialize state in this type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-401">파생 클래스에서 재정의되면 현재 노드에 포함된 특성 수를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-401">When overridden in a derived class, gets the number of attributes on the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-402">현재 노드에 포함된 특성의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-402">The number of attributes on the current node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-403">이 속성이 관련이 `Element`, `DocumentType` 및 `XmlDeclaration` 노드만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-403">This property is relevant to `Element`, `DocumentType` and `XmlDeclaration` nodes only.</span></span> <span data-ttu-id="58cdf-404">(다른 노드 형식 특성이 없습니다.)</span><span class="sxs-lookup"><span data-stu-id="58cdf-404">(Other node types do not have attributes.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-405">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-405">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-406">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-406">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-407">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-407">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-408">파생 클래스에서 재정의되면 현재 노드의 기본 URI를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-408">When overridden in a derived class, gets the base URI of the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-409">현재 노드의 기본 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-409">The base URI of the current node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-410">네트워크에 연결 된 XML 문서를 다양 한 W3C 표준 포함 메커니즘을 사용 하 여 집계 데이터의 청크 이루어집니다 및 서로 다른 위치에서 제공 되는 노드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-410">A networked XML document is comprised of chunks of data aggregated using various W3C standard inclusion mechanisms and therefore contains nodes that come from different places.</span></span> <span data-ttu-id="58cdf-411">DTD 엔터티 예가이 있고이 Dtd에 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-411">DTD entities are an example of this, but this is not limited to DTDs.</span></span> <span data-ttu-id="58cdf-412">기본 URI 알려 이러한 노드를 가져온 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-412">The base URI tells you where these nodes came from.</span></span> <span data-ttu-id="58cdf-413">반환 되는 노드에 대 한 기본 URI 인지 (예를 들어, 구문 분석 된 경우 메모리 내 문자열에서), `String.Empty` 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-413">If there is no base URI for the nodes being returned (for example, they were parsed from an in-memory string), `String.Empty` is returned.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-414">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-414">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-415">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-415">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-416"><see cref="T:System.Xml.XmlReader" />가 이진 콘텐츠 읽기 메서드를 구현하는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-416">Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" /> implements the binary content read methods.</span></span></summary>
        <value><span data-ttu-id="58cdf-417">이진 콘텐츠 읽기 메서드를 구현하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-417"><see langword="true" /> if the binary content read methods are implemented; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-418">이진 콘텐츠 읽기 메서드를 포함 합니다 <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>를 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, 및 <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-418">The binary content read methods include the <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, and <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> methods.</span></span> <span data-ttu-id="58cdf-419">이 속성을 반환 하는 경우 `false` 는 <xref:System.NotSupportedException> 이진 파일 중 하나를 읽을 때 반환 되는 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-419">If this property returns `false` a <xref:System.NotSupportedException> is returned when any of the binary read methods is called.</span></span>  
  
 <span data-ttu-id="58cdf-420">모든 Microsoft.NET Framework 구현 된 <xref:System.Xml.XmlReader> 반환 클래스 `true` 이 속성에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-420">All Microsoft .NET Framework implementations of the <xref:System.Xml.XmlReader> class return `true` for this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-421">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-421">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-422">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-422">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-423"><see cref="T:System.Xml.XmlReader" />가 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 메서드를 구현하는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-423">Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" /> implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> method.</span></span></summary>
        <value><span data-ttu-id="58cdf-424"><see cref="T:System.Xml.XmlReader" />가 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 메서드를 구현하면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-424"><see langword="true" /> if the <see cref="T:System.Xml.XmlReader" /> implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> method; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-425">텍스트 구문 분석 <xref:System.Xml.XmlReader> 정적에서 생성 된 개체 <xref:System.Xml.XmlReader.Create%2A> 메서드를 항상 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-425">Text parsing <xref:System.Xml.XmlReader> objects that were created from the static <xref:System.Xml.XmlReader.Create%2A> method always return `true`.</span></span> <span data-ttu-id="58cdf-426">다른 모든 Microsoft.NET Framework 구현과 합니다 <xref:System.Xml.XmlReader> 클래스를 포함 하는 <xref:System.Xml.XmlTextReader> 클래스, 반환 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-426">All other Microsoft .NET Framework implementations of the <xref:System.Xml.XmlReader> class, including the <xref:System.Xml.XmlTextReader> class, return `false`.</span></span>  
  
 <span data-ttu-id="58cdf-427">이 속성을 반환 하는 경우 `false` 를 <xref:System.NotSupportedException> 때 반환 되는 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-427">If this property returns `false` a <xref:System.NotSupportedException> is returned when the <xref:System.Xml.XmlReader.ReadValueChunk%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-428">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-428">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-429">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-429">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-430">이 판독기가 엔터티를 구문 분석하고 확인할 수 있는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-430">Gets a value indicating whether this reader can parse and resolve entities.</span></span></summary>
        <value><span data-ttu-id="58cdf-431">판독기가 엔터티를 구문 분석하고 확인할 수 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-431"><see langword="true" /> if the reader can parse and resolve entities; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-432">이 속성은 항상 반환 `false` 의 구현을 위한 <xref:System.Xml.XmlReader> DTD 정보를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-432">This property always returns `false` for implementations of <xref:System.Xml.XmlReader> that do not support DTD information.</span></span> <span data-ttu-id="58cdf-433">이 경우 호출 <xref:System.Xml.XmlReader.ResolveEntity%2A> 예외를 throw 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-433">In this case, calling <xref:System.Xml.XmlReader.ResolveEntity%2A> throws an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-434">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-434">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-435">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-435">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-436">파생 클래스에서 재정의되면 <see cref="P:System.Xml.XmlReader.ReadState" />를 <see cref="F:System.Xml.ReadState.Closed" />로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-436">When overridden in a derived class, changes the <see cref="P:System.Xml.XmlReader.ReadState" /> to <see cref="F:System.Xml.ReadState.Closed" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-437">이 메서드는 또한 읽는 동안 보유 한 모든 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-437">This method also releases any resources held during reading.</span></span> <span data-ttu-id="58cdf-438">경우 <xref:System.Xml.XmlReader.Close%2A> 이미 호출 조치가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-438">If <xref:System.Xml.XmlReader.Close%2A> has already been called, no action is performed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-439">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-439">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-440">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-440">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="58cdf-441">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-441">Creates a new <see cref="T:System.Xml.XmlReader" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-442">대부분의 합니다 <xref:System.Xml.XmlReader.Create%2A> 오버 로드 포함를 `settings` 허용 하는 매개 변수는 <xref:System.Xml.XmlReaderSettings> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-442">Most of the <xref:System.Xml.XmlReader.Create%2A> overloads include a `settings` parameter that accepts an <xref:System.Xml.XmlReaderSettings> object.</span></span> <span data-ttu-id="58cdf-443">이 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-443">You can use this object to:</span></span>  
  
-   <span data-ttu-id="58cdf-444">지원 되는 원하는 어떤 기능을 지정 합니다 <xref:System.Xml.XmlReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-444">Specify which features you want supported on the <xref:System.Xml.XmlReader> object.</span></span>  
  
-   <span data-ttu-id="58cdf-445">재사용을 <xref:System.Xml.XmlReaderSettings> 여러 판독기를 만들 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-445">Reuse the <xref:System.Xml.XmlReaderSettings> object to create multiple readers.</span></span> <span data-ttu-id="58cdf-446">같은 설정을 사용하면 같은 기능을 갖춘 여러 판독기를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-446">You can use the same settings to create multiple readers with the same functionality.</span></span> <span data-ttu-id="58cdf-447">설정을 수정할 수 있습니다 또는 <xref:System.Xml.XmlReaderSettings> 인스턴스 및 다양 한 기능을 사용 하 여 새 판독기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-447">Or, you can modify the settings on an <xref:System.Xml.XmlReaderSettings> instance and create a new reader with a different set of features.</span></span>  
  
-   <span data-ttu-id="58cdf-448">기존 XML 판독기에 기능을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-448">Add features to an existing XML reader.</span></span> <span data-ttu-id="58cdf-449"><xref:System.Xml.XmlReader.Create%2A> 메서드는 다른 <xref:System.Xml.XmlReader> 개체를 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-449">The <xref:System.Xml.XmlReader.Create%2A> method can accept another <xref:System.Xml.XmlReader> object.</span></span> <span data-ttu-id="58cdf-450">내부 <xref:System.Xml.XmlReader> 개체는 사용자 정의 판독기 수를 <xref:System.Xml.XmlTextReader> 개체 또는 다른 <xref:System.Xml.XmlReader> 추가 기능을 추가 하려는 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="58cdf-450">The underlying <xref:System.Xml.XmlReader> object can be a user-defined reader, a <xref:System.Xml.XmlTextReader> object, or another <xref:System.Xml.XmlReader> instance that you want to add additional features to.</span></span>  
  
-   <span data-ttu-id="58cdf-451">향상 된 규칙 검사에 대 한 규정 준수 등의 기능을 최대한 활용 합니다 [XML 1.0 (1.0(fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) 에서만 사용할 수 있는 권장 사항을 <xref:System.Xml.XmlReader> 정적으로 생성 된 개체 <xref:System.Xml.XmlReader.Create%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-451">Take full advantage of features such as better conformance checking and compliance to the [XML 1.0 (fourth edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) recommendation that are available only on <xref:System.Xml.XmlReader> objects created by the static <xref:System.Xml.XmlReader.Create%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-452">.NET Framework의 구체적 구현이 포함 되어 있지만 합니다 <xref:System.Xml.XmlReader> 클래스와 같은 합니다 <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, 및 <xref:System.Xml.XmlValidatingReader> 만드는 것을 권장 클래스 <xref:System.Xml.XmlReader> 인스턴스를 사용 하 여는 <xref:System.Xml.XmlReader.Create%2A> 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-452">Although the .NET Framework includes concrete implementations of the <xref:System.Xml.XmlReader> class, such as the <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, and the <xref:System.Xml.XmlValidatingReader> classes, we recommend that you create <xref:System.Xml.XmlReader> instances by using the <xref:System.Xml.XmlReader.Create%2A> method.</span></span>  
  
## <a name="default-settings"></a><span data-ttu-id="58cdf-453">기본 설정</span><span class="sxs-lookup"><span data-stu-id="58cdf-453">Default settings</span></span>  
 <span data-ttu-id="58cdf-454">사용 하는 경우는 <xref:System.Xml.XmlReader.Create%2A> 받지 않은 오버 로드는 <xref:System.Xml.XmlReaderSettings> 다음과 같은 기본 판독기 설정 되는 개체:</span><span class="sxs-lookup"><span data-stu-id="58cdf-454">If you use a <xref:System.Xml.XmlReader.Create%2A> overload that doesn't accept a <xref:System.Xml.XmlReaderSettings> object, the following default reader settings are used:</span></span>  
  
|<span data-ttu-id="58cdf-455">설정</span><span class="sxs-lookup"><span data-stu-id="58cdf-455">Setting</span></span>|<span data-ttu-id="58cdf-456">기본</span><span class="sxs-lookup"><span data-stu-id="58cdf-456">Default</span></span>|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|<span data-ttu-id="58cdf-457">0</span><span class="sxs-lookup"><span data-stu-id="58cdf-457">0</span></span>|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|<span data-ttu-id="58cdf-458">0</span><span class="sxs-lookup"><span data-stu-id="58cdf-458">0</span></span>|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<span data-ttu-id="58cdf-459">빈 <xref:System.Xml.Schema.XmlSchemaSet> 개체</span><span class="sxs-lookup"><span data-stu-id="58cdf-459">An empty <xref:System.Xml.Schema.XmlSchemaSet> object</span></span>|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<span data-ttu-id="58cdf-460"><xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> 사용 하도록 설정</span><span class="sxs-lookup"><span data-stu-id="58cdf-460"><xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> enabled</span></span>|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|<span data-ttu-id="58cdf-461">새 <xref:System.Xml.XmlUrlResolver> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-461">A new <xref:System.Xml.XmlUrlResolver> object.</span></span>  <span data-ttu-id="58cdf-462">.NET Framework 4.5.2부터이 설정에 기본값은 `null`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-462">Starting with the .NET Framework 4.5.2, this setting has a default value of `null`.</span></span>|  
  
## <a name="settings-for-common-scenarios"></a><span data-ttu-id="58cdf-463">일반적인 시나리오에 대 한 설정</span><span class="sxs-lookup"><span data-stu-id="58cdf-463">Settings for common scenarios</span></span>  
 <span data-ttu-id="58cdf-464">다음은 <xref:System.Xml.XmlReaderSettings> 일반적인 XML 판독기 시나리오 중 일부에 대해 설정 해야 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-464">Here are the <xref:System.Xml.XmlReaderSettings> properties you should set for some of the typical XML reader scenarios.</span></span>  
  
|<span data-ttu-id="58cdf-465">요구 사항</span><span class="sxs-lookup"><span data-stu-id="58cdf-465">Requirement</span></span>|<span data-ttu-id="58cdf-466">Set</span><span class="sxs-lookup"><span data-stu-id="58cdf-466">Set</span></span>|  
|-----------------|---------|  
|<span data-ttu-id="58cdf-467">데이터에는 올바른 형식의 XML 문서 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-467">Data must be a well-formed XML document.</span></span>|<span data-ttu-id="58cdf-468"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> <xref:System.Xml.ConformanceLevel.Document>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-468"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> to <xref:System.Xml.ConformanceLevel.Document>.</span></span>|  
|<span data-ttu-id="58cdf-469">데이터에는 올바른 형식의 XML 구문 분석 된 엔터티를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-469">Data must be a well-formed XML parsed entity.</span></span>|<span data-ttu-id="58cdf-470"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> <xref:System.Xml.ConformanceLevel.Fragment>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-470"><xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> to <xref:System.Xml.ConformanceLevel.Fragment>.</span></span>|  
|<span data-ttu-id="58cdf-471">데이터는 DTD에 대해 유효성이 검사 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-471">Data must be validated against a DTD.</span></span>|<span data-ttu-id="58cdf-472"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> - <xref:System.Xml.DtdProcessing.Parse></span><span class="sxs-lookup"><span data-stu-id="58cdf-472"><xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> to <xref:System.Xml.DtdProcessing.Parse></span></span><br /><span data-ttu-id="58cdf-473"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> <xref:System.Xml.ValidationType.DTD>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-473"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> to <xref:System.Xml.ValidationType.DTD>.</span></span>|  
|<span data-ttu-id="58cdf-474">데이터는 XML 스키마에 대해 유효성이 검사 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-474">Data must be validated against an XML schema.</span></span>|<span data-ttu-id="58cdf-475"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> - <xref:System.Xml.ValidationType.Schema></span><span class="sxs-lookup"><span data-stu-id="58cdf-475"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> to <xref:System.Xml.ValidationType.Schema></span></span><br /><span data-ttu-id="58cdf-476"><xref:System.Xml.XmlReaderSettings.Schemas%2A> 에 <xref:System.Xml.Schema.XmlSchemaSet> 유효성 검사에 사용할 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-476"><xref:System.Xml.XmlReaderSettings.Schemas%2A> to the <xref:System.Xml.Schema.XmlSchemaSet> to use for validation.</span></span> <span data-ttu-id="58cdf-477"><xref:System.Xml.XmlReader> Xml-data Reduced (XDR) 스키마 유효성 검사를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-477">Note that <xref:System.Xml.XmlReader> doesn't support XML-Data Reduced (XDR) schema validation.</span></span>|  
|<span data-ttu-id="58cdf-478">데이터는 인라인 XML 스키마에 대해 유효성이 검사 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-478">Data must be validated against an inline XML schema.</span></span>|<span data-ttu-id="58cdf-479"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> - <xref:System.Xml.ValidationType.Schema></span><span class="sxs-lookup"><span data-stu-id="58cdf-479"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> to <xref:System.Xml.ValidationType.Schema></span></span><br /><span data-ttu-id="58cdf-480"><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-480"><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> to <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.</span></span>|  
|<span data-ttu-id="58cdf-481">형식 지원.</span><span class="sxs-lookup"><span data-stu-id="58cdf-481">Type support.</span></span>|<span data-ttu-id="58cdf-482"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> - <xref:System.Xml.ValidationType.Schema></span><span class="sxs-lookup"><span data-stu-id="58cdf-482"><xref:System.Xml.XmlReaderSettings.ValidationType%2A> to <xref:System.Xml.ValidationType.Schema></span></span><br /><span data-ttu-id="58cdf-483"><xref:System.Xml.XmlReaderSettings.Schemas%2A> 에 <xref:System.Xml.Schema.XmlSchemaSet> 사용 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-483"><xref:System.Xml.XmlReaderSettings.Schemas%2A> to the <xref:System.Xml.Schema.XmlSchemaSet> to use.</span></span>|  
  
 <span data-ttu-id="58cdf-484"><xref:System.Xml.XmlReader> Xml-data Reduced (XDR) 스키마 유효성 검사를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-484"><xref:System.Xml.XmlReader> doesn't support XML-Data Reduced (XDR) schema validation.</span></span>  
  
## <a name="asynchronous-programming"></a><span data-ttu-id="58cdf-485">비동기 프로그래밍</span><span class="sxs-lookup"><span data-stu-id="58cdf-485">Asynchronous programming</span></span>  
 <span data-ttu-id="58cdf-486">동기 모드에서는 <xref:System.Xml.XmlReader.Create%2A> 메서드 파일, 스트림 또는 텍스트 판독기의 버퍼에서 데이터의 첫 번째 청크를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-486">In synchronous mode, the <xref:System.Xml.XmlReader.Create%2A> method reads the first chunk of data from the buffer of the file, stream, or text reader.</span></span> <span data-ttu-id="58cdf-487">I/O 작업이 실패 하면 예외가 throw 될 수 있습니다이 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-487">This may throw an exception if an I/O operation fails.</span></span> <span data-ttu-id="58cdf-488">비동기 모드에서 첫 번째 I/O 작업이 읽기 작업을 사용 하 여 발생 하므로 읽기 작업이 수행 될 때 발생 하는 예외를 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-488">In asynchronous mode, the first I/O operation occurs with a read operation, so exceptions that arise will be thrown when the read operation occurs.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58cdf-489">보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="58cdf-489">Security considerations</span></span>  
 <span data-ttu-id="58cdf-490">기본적으로 <xref:System.Xml.XmlReader> 사용 하는 <xref:System.Xml.XmlUrlResolver> 리소스를 열려면 사용자 자격 증명 없이 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-490">By default, the <xref:System.Xml.XmlReader> uses an <xref:System.Xml.XmlUrlResolver> object with no user credentials to open resources.</span></span> <span data-ttu-id="58cdf-491">이 기본적으로 XML 판독기 위치에 액세스할 수 있는 자격 증명이 필요 하지 않은 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-491">This means that, by default, the XML reader can access any location that doesn't require credentials.</span></span> <span data-ttu-id="58cdf-492">사용 된 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 리소스에 대 한 액세스를 제어 하는 속성:</span><span class="sxs-lookup"><span data-stu-id="58cdf-492">Use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to control access to resources:</span></span>  
  
-   <span data-ttu-id="58cdf-493">설정할 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 에 <xref:System.Xml.XmlSecureResolver> XML 판독기에 액세스할 수 있는 리소스를 제한 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-493">Set <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> to an <xref:System.Xml.XmlSecureResolver> object to restrict the resources that the XML reader can access.</span></span>  
  
 <span data-ttu-id="58cdf-494">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-494">-or-</span></span>  
  
-   <span data-ttu-id="58cdf-495">설정 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 에 `null` XML 판독기가 외부 리소스를 열기 하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-495">Set <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> to `null` to prevent the XML reader from opening any external resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-496">이 예제에서는 불필요 한 공백을 제거, 주석, 제거 및 조각 수준 규칙 검사를 수행 하는 XML 판독기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-496">This example creates an XML reader that strips insignificant white space, strips comments, and performs fragment-level conformance checking.</span></span>  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 <span data-ttu-id="58cdf-497">다음 예제에서는 <xref:System.Xml.XmlUrlResolver> 파일에 액세스 하려면 기본 자격 증명을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-497">The following example uses an <xref:System.Xml.XmlUrlResolver> with default credentials to access a file.</span></span>  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 <span data-ttu-id="58cdf-498">다음 코드는 다른 판독기 내에서 판독기 인스턴스를 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-498">The following code wraps a reader instance within another reader.</span></span>  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 <span data-ttu-id="58cdf-499">이 예제에서는 DTD 및 XML 스키마 유효성 검사를 추가 하는 판독기를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-499">This example chains readers to add DTD and XML schema validation.</span></span>  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-500">XML 데이터가 포함된 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-500">The stream that contains the XML data.</span></span>  
  
<span data-ttu-id="58cdf-501"><see cref="T:System.Xml.XmlReader" />는 스트림의 첫 번째 바이트를 검색하여 바이트 순서 표시나 다른 인코딩 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-501">The <see cref="T:System.Xml.XmlReader" /> scans the first bytes of the stream looking for a byte order mark or other sign of encoding.</span></span> <span data-ttu-id="58cdf-502">인코딩이 확인되면 이 인코딩을 사용하여 스트림을 읽고, 입력을 문자 스트림(유니코드)으로 구문 분석하는 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-502">When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</span></span></param>
        <summary><span data-ttu-id="58cdf-503">기본 설정의 지정된 스트림을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-503">Creates a new <see cref="T:System.Xml.XmlReader" /> instance using the specified stream with default settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-504">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-504">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-505"><xref:System.Xml.XmlReaderSettings> 개체 기본 설정 사용 하 여 판독기를 만드는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-505">An <xref:System.Xml.XmlReaderSettings> object with default settings is used to create the reader.</span></span> <span data-ttu-id="58cdf-506">만들어진된 판독기에서 지원할 기능을 지정 하려는 경우는 오버 로드를 사용 하 여는 <xref:System.Xml.XmlReaderSettings> 해당 인수의 하나로 개체를 전달는 <xref:System.Xml.XmlReaderSettings> 올바른 설정 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-506">If you wish to specify the features to support on the created reader, use the overload that takes an <xref:System.Xml.XmlReaderSettings> object as one of its arguments, and pass in an <xref:System.Xml.XmlReaderSettings> object with the correct settings.</span></span>  
  
 <span data-ttu-id="58cdf-507">기본값 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-507">A default <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-508">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-508">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-509">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-509">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-510">인증이 필요한 네트워크 리소스에 대 한 외부 리소스가 있으면 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여 필요한 자격 증명으로는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-510">If the external resource is located on a network resource that requires authentication, specify an <xref:System.Xml.XmlResolver> with the necessary credentials using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-511">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-511">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-512">다음 예제는 <xref:System.Xml.XmlReader> 개체에서 읽는 <xref:System.IO.FileStream>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-512">The following example creates an <xref:System.Xml.XmlReader> object that reads from a <xref:System.IO.FileStream>.</span></span>  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-513"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-513">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58cdf-514"><see cref="T:System.Xml.XmlReader" />에는 XML 데이터 위치에 액세스할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-514">The <see cref="T:System.Xml.XmlReader" /> does not have sufficient permissions to access the location of the XML data.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-515">XML 데이터를 읽어올 텍스트 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-515">The text reader from which to read the XML data.</span></span> <span data-ttu-id="58cdf-516">텍스트 판독기는 유니코드 문자 스트림을 반환하므로 XML 선언에 지정된 인코딩은 XML 판독기가 데이터 스트림을 디코딩하는 데 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-516">A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration is not used by the XML reader to decode the data stream.</span></span></param>
        <summary><span data-ttu-id="58cdf-517">지정된 텍스트 판독기를 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-517">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified text reader.</span></span></summary>
        <returns><span data-ttu-id="58cdf-518">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-518">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-519"><xref:System.Xml.XmlReaderSettings> 개체 기본 설정 사용 하 여 판독기를 만드는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-519">An <xref:System.Xml.XmlReaderSettings> object with default settings is used to create the reader.</span></span> <span data-ttu-id="58cdf-520">만들어진된 판독기에서 지원할 기능을 지정 하려는 경우는 오버 로드를 사용 하 여는 <xref:System.Xml.XmlReaderSettings> 해당 인수의 하나로 개체를 전달는 <xref:System.Xml.XmlReaderSettings> 올바른 설정 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-520">If you wish to specify the features to support on the created reader, use the overload that takes an <xref:System.Xml.XmlReaderSettings> object as one of its arguments, and pass in an <xref:System.Xml.XmlReaderSettings> object with the correct settings.</span></span>  
  
 <span data-ttu-id="58cdf-521">기본값 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-521">A default <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-522">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-522">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-523">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-523">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-524">인증이 필요한 네트워크 리소스에 대 한 외부 리소스가 있으면 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여 필요한 자격 증명으로는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-524">If the external resource is located on a network resource that requires authentication, specify an <xref:System.Xml.XmlResolver> with the necessary credentials using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-525">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-525">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-526">다음 예제에서는 <xref:System.IO.StringReader> 클래스는 XML 문자열을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-526">The following example uses the <xref:System.IO.StringReader> class to read an XML string.</span></span>  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-527"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-527">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri"><span data-ttu-id="58cdf-528">XML 데이터를 포함하는 파일의 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-528">The URI for the file that contains the XML data.</span></span> <span data-ttu-id="58cdf-529"><see cref="T:System.Xml.XmlUrlResolver" /> 클래스는 경로를 정규 데이터 표현으로 변환하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-529">The <see cref="T:System.Xml.XmlUrlResolver" /> class is used to convert the path to a canonical data representation.</span></span></param>
        <summary><span data-ttu-id="58cdf-530">지정된 URI를 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-530">Creates a new <see cref="T:System.Xml.XmlReader" /> instance with specified URI.</span></span></summary>
        <returns><span data-ttu-id="58cdf-531">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-531">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-532"><xref:System.Xml.XmlReaderSettings> 개체 기본 설정 사용 하 여 판독기를 만드는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-532">An <xref:System.Xml.XmlReaderSettings> object with default settings is used to create the reader.</span></span> <span data-ttu-id="58cdf-533">만들어진된 판독기에서 지원할 기능을 지정 하려는 경우는 오버 로드를 사용 하 여는 <xref:System.Xml.XmlReaderSettings> 해당 인수의 하나로 개체를 전달는 <xref:System.Xml.XmlReaderSettings> 올바른 설정 포함 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-533">If you wish to specify the features to support on the created reader, use the overload that takes an <xref:System.Xml.XmlReaderSettings> object as one of its arguments, and pass in an <xref:System.Xml.XmlReaderSettings> object with the correct settings.</span></span>  
  
 <span data-ttu-id="58cdf-534">기본값 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-534">A default <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-535">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-535">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-536">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-536">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-537">인증이 필요한 네트워크 리소스에 대 한 외부 리소스가 있으면 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여 필요한 자격 증명으로는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-537">If the external resource is located on a network resource that requires authentication, specify an <xref:System.Xml.XmlResolver> with the necessary credentials using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-538">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-538">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-539">다음 예제에서는 <xref:System.Xml.XmlReader> URI로 지정 된 XML 데이터 파일을 읽는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-539">The following example creates an <xref:System.Xml.XmlReader> object that reads XML data file specified by the URI.</span></span>  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-540"><paramref name="inputUri" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-540">The <paramref name="inputUri" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58cdf-541"><see cref="T:System.Xml.XmlReader" />에는 XML 데이터 위치에 액세스할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-541">The <see cref="T:System.Xml.XmlReader" /> does not have sufficient permissions to access the location of the XML data.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="58cdf-542">URI로 식별된 파일이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-542">The file identified by the URI does not exist.</span></span></exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="58cdf-543"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-543">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.FormatException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="58cdf-544">URI 형식이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-544">The URI format is not correct.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-545">XML 데이터가 포함된 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-545">The stream that contains the XML data.</span></span>  
  
<span data-ttu-id="58cdf-546"><see cref="T:System.Xml.XmlReader" />는 스트림의 첫 번째 바이트를 검색하여 바이트 순서 표시나 다른 인코딩 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-546">The <see cref="T:System.Xml.XmlReader" /> scans the first bytes of the stream looking for a byte order mark or other sign of encoding.</span></span> <span data-ttu-id="58cdf-547">인코딩이 확인되면 이 인코딩을 사용하여 스트림을 읽고, 입력을 문자 스트림(유니코드)으로 구문 분석하는 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-547">When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-548">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-548">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-549">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-549">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-550">지정된 스트림 및 설정을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-550">Creates a new <see cref="T:System.Xml.XmlReader" /> instance with the specified stream and settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-551">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-551">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-552">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-552">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-553">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-553">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-554">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-554">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-555">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-555">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-556">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-556">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-557"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-557">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-558">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-558">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-559"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-559">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-560">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-560">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-561"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-561">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-562">XML 데이터를 읽어올 텍스트 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-562">The text reader from which to read the XML data.</span></span> <span data-ttu-id="58cdf-563">텍스트 판독기는 유니코드 문자 스트림을 반환하므로 XML 선언에 지정된 인코딩은 XML 판독기가 데이터 스트림을 디코딩하는 데 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-563">A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the XML reader to decode the data stream.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-564">새 <see cref="T:System.Xml.XmlReader" />의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-564">The settings for the new <see cref="T:System.Xml.XmlReader" />.</span></span> <span data-ttu-id="58cdf-565">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-565">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-566">지정된 텍스트 판독기 및 설정을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-566">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified text reader and settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-567">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-567">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-568">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-568">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-569">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-569">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-570">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-570">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-571">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-571">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-572">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-572">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-573"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-573">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-574">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-574">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-575"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-575">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-576">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-576">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-577"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-577">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri"><span data-ttu-id="58cdf-578">XML 데이터를 포함하는 파일의 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-578">The URI for the file containing the XML data.</span></span> <span data-ttu-id="58cdf-579"><see cref="T:System.Xml.XmlReaderSettings" /> 개체의 <see cref="T:System.Xml.XmlResolver" /> 개체는 경로를 정규 데이터 표현으로 변환하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-579">The <see cref="T:System.Xml.XmlResolver" /> object on the <see cref="T:System.Xml.XmlReaderSettings" /> object is used to convert the path to a canonical data representation.</span></span> <span data-ttu-id="58cdf-580"><see cref="P:System.Xml.XmlReaderSettings.XmlResolver" />가 <see langword="null" />이면 새 <see cref="T:System.Xml.XmlUrlResolver" /> 개체가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-580">If <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> is <see langword="null" />, a new <see cref="T:System.Xml.XmlUrlResolver" /> object is used.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-581">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-581">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-582">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-582">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-583">지정된 URI 및 설정을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-583">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified URI and settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-584">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-584">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-585">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-585">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-586">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-586">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-587">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-587">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-588">즉는 <xref:System.Xml.XmlReader> 인증 필요 하지 않은 모든 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-588">This means that the <xref:System.Xml.XmlReader> can access any locations that does not require authentication.</span></span> <span data-ttu-id="58cdf-589">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-589">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-590">리소스를 제한할 수 있습니다는 합니다 <xref:System.Xml.XmlReader> 설정 하 여 액세스할 수는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 속성을는 <xref:System.Xml.XmlSecureResolver> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-590">You can restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
  
 <span data-ttu-id="58cdf-591">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-591">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-592">다음 예제에서는 <xref:System.Xml.XmlReader> 문서 유형 정의 (DTD) 유효성 검사를 지 원하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-592">The following example creates an <xref:System.Xml.XmlReader> object that supports document type definition (DTD) validation.</span></span>  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-593"><paramref name="inputUri" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-593">The <paramref name="inputUri" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="58cdf-594">URI로 지정된 파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-594">The file specified by the URI cannot be found.</span></span></exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="58cdf-595"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows 스토어 앱용 .NET</see> 또는 <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">이식 가능한 클래스 라이브러리</see>에서 대신 기본 클래스 예외 <see cref="T:System.FormatException" />을 catch합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-595">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.FormatException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="58cdf-596">URI 형식이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-596">The URI format is not correct.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="58cdf-597">내부 XML 판독기로 사용할 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-597">The object that you want to use as the underlying XML reader.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-598">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-598">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span>  
  
<span data-ttu-id="58cdf-599"><see cref="T:System.Xml.XmlReaderSettings" /> 개체의 규칙 수준은 기본 판독기의 규칙 수준과 일치하거나 <see cref="F:System.Xml.ConformanceLevel.Auto" />로 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-599">The conformance level of the <see cref="T:System.Xml.XmlReaderSettings" /> object must either match the conformance level of the underlying reader, or it must be set to <see cref="F:System.Xml.ConformanceLevel.Auto" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-600">지정된 XML 판독기 및 설정을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-600">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified XML reader and settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-601">지정된 <see cref="T:System.Xml.XmlReader" /> 개체를 래핑하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-601">An object that is wrapped around the specified <see cref="T:System.Xml.XmlReader" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-602">이 메서드는 기본 추가 기능을 사용 하면 <xref:System.Xml.XmlReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-602">This method allows you add additional features to an underlying <xref:System.Xml.XmlReader> object.</span></span> <span data-ttu-id="58cdf-603">기본 <xref:System.Xml.XmlReader> 다른 개체 일 수 있습니다 <xref:System.Xml.XmlReader> 하 여 만든 개체를 <xref:System.Xml.XmlReader.Create%2A> 메서드를 요소나 <xref:System.Xml.XmlReader> 구체적인 중 하나를 사용 하 여 만든 개체 <xref:System.Xml.XmlReader> 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-603">The underlying <xref:System.Xml.XmlReader> object can be another <xref:System.Xml.XmlReader> object created by the <xref:System.Xml.XmlReader.Create%2A> method, or an <xref:System.Xml.XmlReader> object created using one of the concrete <xref:System.Xml.XmlReader> implementations.</span></span>  
  
 <span data-ttu-id="58cdf-604">기본값 <xref:System.Xml.XmlUrlResolver> 자격 증명이 없는 되는 스키마와 같은 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-604">A default <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a schema.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-605">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-605">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-606">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-606">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-607">인증이 필요한 네트워크 리소스에 대 한 외부 리소스가 있으면 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여 필요한 자격 증명으로는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-607">If the external resource is located on a network resource that requires authentication, specify an <xref:System.Xml.XmlResolver> with the necessary credentials using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-608">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-608">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-609"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-609">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-610">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-610">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-611"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-611">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-612">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-612">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-613">다음 예제에서는 유효성을 검사 하 <xref:System.Xml.XmlReader> 개체를 래핑하는 <xref:System.Xml.XmlNodeReader> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-613">The following example creates a validating <xref:System.Xml.XmlReader> object that is wrapped around an <xref:System.Xml.XmlNodeReader> object.</span></span>  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-614"><paramref name="reader" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-614">The <paramref name="reader" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-615"><see cref="T:System.Xml.XmlReaderSettings" /> 개체가 기본 판독기의 규칙 수준과 일치하지 않는 규칙 수준을 지정하는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-615">If the <see cref="T:System.Xml.XmlReaderSettings" /> object specifies a conformance level that is not consistent with conformance level of the underlying reader.</span></span>  
  
<span data-ttu-id="58cdf-616">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-616">-or-</span></span> 
<span data-ttu-id="58cdf-617">기본 <see cref="T:System.Xml.XmlReader" />가 <see cref="F:System.Xml.ReadState.Error" /> 또는 <see cref="F:System.Xml.ReadState.Closed" /> 상태에 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-617">The underlying <see cref="T:System.Xml.XmlReader" /> is in an <see cref="F:System.Xml.ReadState.Error" /> or <see cref="F:System.Xml.ReadState.Closed" /> state.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-618">XML 데이터가 포함된 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-618">The stream that contains the XML data.</span></span>  
  
<span data-ttu-id="58cdf-619"><see cref="T:System.Xml.XmlReader" />는 스트림의 첫 번째 바이트를 검색하여 바이트 순서 표시나 다른 인코딩 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-619">The <see cref="T:System.Xml.XmlReader" /> scans the first bytes of the stream looking for a byte order mark or other sign of encoding.</span></span> <span data-ttu-id="58cdf-620">인코딩이 확인되면 이 인코딩을 사용하여 스트림을 읽고, 입력을 문자 스트림(유니코드)으로 구문 분석하는 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-620">When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-621">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-621">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-622">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-622">This value can be <see langword="null" />.</span></span></param>
        <param name="baseUri"><span data-ttu-id="58cdf-623">읽을 엔터티 또는 문서의 기본 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-623">The base URI for the entity or document being read.</span></span> <span data-ttu-id="58cdf-624">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-624">This value can be <see langword="null" />.</span></span>  
  
 <span data-ttu-id="58cdf-625">**보안 정보** 기본 URI는 XML 문서의 상대 URI를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-625">**Security Note** The base URI is used to resolve the relative URI of the XML document.</span></span> <span data-ttu-id="58cdf-626">신뢰할 수 없는 소스의 기본 URI는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-626">Do not use a base URI from an untrusted source.</span></span></param>
        <summary><span data-ttu-id="58cdf-627">지정된 스트림, 기본 URI 및 설정을 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-627">Creates a new <see cref="T:System.Xml.XmlReader" /> instance using the specified stream, base URI, and settings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-628">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-628">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-629">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-629">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-630">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-630">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-631">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-631">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-632">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-632">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-633">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-633">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-634"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-634">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-635">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-635">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-636"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-636">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-637">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-637">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-638"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-638">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-639">XML 데이터가 포함된 스트림입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-639">The stream that contains the XML data.</span></span>  
  
<span data-ttu-id="58cdf-640"><see cref="T:System.Xml.XmlReader" />는 스트림의 첫 번째 바이트를 검색하여 바이트 순서 표시나 다른 인코딩 기호를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-640">The <see cref="T:System.Xml.XmlReader" /> scans the first bytes of the stream looking for a byte order mark or other sign of encoding.</span></span> <span data-ttu-id="58cdf-641">인코딩이 확인되면 이 인코딩을 사용하여 스트림을 읽고, 입력을 문자 스트림(유니코드)으로 구문 분석하는 작업이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-641">When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-642">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-642">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-643">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-643">This value can be <see langword="null" />.</span></span></param>
        <param name="inputContext"><span data-ttu-id="58cdf-644">XML 조각을 구문 분석하는 데 필요한 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-644">The context information required to parse the XML fragment.</span></span> <span data-ttu-id="58cdf-645">컨텍스트 정보에는 사용할 <see cref="T:System.Xml.XmlNameTable" />, 인코딩, 네임스페이스 범위, 현재 <c>xml:lang</c>과 <c>xml:space</c> 범위, 기본 URI 및 문서 종류 정의가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-645">The context information can include the <see cref="T:System.Xml.XmlNameTable" /> to use, encoding, namespace scope, the current <c>xml:lang</c> and <c>xml:space</c> scope, base URI, and document type definition.</span></span>  
  
<span data-ttu-id="58cdf-646">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-646">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-647">구문 분석을 위해 지정한 스트림, 설정 및 컨텍스트 정보를 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-647">Creates a new <see cref="T:System.Xml.XmlReader" /> instance using the specified stream, settings, and context information for parsing.</span></span></summary>
        <returns><span data-ttu-id="58cdf-648">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-648">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-649">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-649">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-650">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-650">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-651">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-651">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-652">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-652">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-653">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-653">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-654"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-654">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-655">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-655">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-656"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-656">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-657">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-657">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-658"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-658">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-659">XML 데이터를 읽어올 텍스트 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-659">The text reader from which to read the XML data.</span></span> <span data-ttu-id="58cdf-660">텍스트 판독기는 유니코드 문자 스트림을 반환하므로 XML 선언에 지정된 인코딩은 <see cref="T:System.Xml.XmlReader" />가 데이터 스트림을 디코딩하는 데 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-660">A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the <see cref="T:System.Xml.XmlReader" /> to decode the data stream.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-661">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-661">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-662">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-662">This value can be <see langword="null" />.</span></span></param>
        <param name="baseUri"><span data-ttu-id="58cdf-663">읽을 엔터티 또는 문서의 기본 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-663">The base URI for the entity or document being read.</span></span> <span data-ttu-id="58cdf-664">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-664">This value can be <see langword="null" />.</span></span>  
  
 <span data-ttu-id="58cdf-665">**보안 정보** 기본 URI는 XML 문서의 상대 URI를 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-665">**Security Note** The base URI is used to resolve the relative URI of the XML document.</span></span> <span data-ttu-id="58cdf-666">신뢰할 수 없는 소스의 기본 URI는 사용하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-666">Do not use a base URI from an untrusted source.</span></span></param>
        <summary><span data-ttu-id="58cdf-667">지정된 텍스트 판독기, 설정 및 기본 URI를 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-667">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified text reader, settings, and base URI.</span></span></summary>
        <returns><span data-ttu-id="58cdf-668">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-668">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-669">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-669">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-670">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-670">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-671">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-671">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-672">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-672">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-673">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-673">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-674"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-674">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-675">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-675">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-676"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-676">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-677">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-677">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-678"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-678">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="58cdf-679">XML 데이터를 읽어올 텍스트 판독기입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-679">The text reader from which to read the XML data.</span></span> <span data-ttu-id="58cdf-680">텍스트 판독기는 유니코드 문자 스트림을 반환하므로 XML 선언에 지정된 인코딩은 XML 판독기가 데이터 스트림을 디코딩하는 데 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-680">A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the XML reader to decode the data stream.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-681">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-681">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-682">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-682">This value can be <see langword="null" />.</span></span></param>
        <param name="inputContext"><span data-ttu-id="58cdf-683">XML 조각을 구문 분석하는 데 필요한 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-683">The context information required to parse the XML fragment.</span></span> <span data-ttu-id="58cdf-684">컨텍스트 정보에는 사용할 <see cref="T:System.Xml.XmlNameTable" />, 인코딩, 네임스페이스 범위, 현재 <c>xml:lang</c>과 <c>xml:space</c> 범위, 기본 URI 및 문서 종류 정의가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-684">The context information can include the <see cref="T:System.Xml.XmlNameTable" /> to use, encoding, namespace scope, the current <c>xml:lang</c> and <c>xml:space</c> scope, base URI, and document type definition.</span></span>  
  
<span data-ttu-id="58cdf-685">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-685">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-686">지정된 텍스트 판독기, 설정 및 컨텍스트 정보를 구문 분석에 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-686">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified text reader, settings, and context information for parsing.</span></span></summary>
        <returns><span data-ttu-id="58cdf-687">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-687">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-688">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-688">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-689">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-689">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-690">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-690">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-691">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-691">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-692">리소스를 제어 하려면 다음 방법 중 하나를 사용할 수는 <xref:System.Xml.XmlReader> 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-692">You can use one of the following methods to control which resources the <xref:System.Xml.XmlReader> can access:</span></span>  
>   
>  -   <span data-ttu-id="58cdf-693"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 개체로 설정하여 <xref:System.Xml.XmlSecureResolver>에서 액세스 가능한 리소스를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-693">Restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
>   
>  <span data-ttu-id="58cdf-694">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-694">-or-</span></span>  
>   
>  -   <span data-ttu-id="58cdf-695"><xref:System.Xml.XmlReader> 속성을 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>로 설정하여 `null`가 모든 외부 리소스를 열 수 없도록 하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-695">Do not allow the <xref:System.Xml.XmlReader> to open any external resources by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to `null`.</span></span>  
  
 <span data-ttu-id="58cdf-696">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-696">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-697">다음 예제에서는 <xref:System.Xml.XmlReader> XML 조각을 읽는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-697">The following example creates an <xref:System.Xml.XmlReader> object that reads an XML fragment.</span></span>  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-698"><paramref name="input" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-698">The <paramref name="input" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-699"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 및 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 속성 둘 다에 값이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-699">The <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> and <see cref="P:System.Xml.XmlParserContext.NameTable" /> properties both contain values.</span></span> <span data-ttu-id="58cdf-700"><see langword="NameTable" /> 속성 중 하나만 설정 및 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-700">(Only one of these <see langword="NameTable" /> properties can be set and used).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri"><span data-ttu-id="58cdf-701">XML 데이터를 포함하는 파일의 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-701">The URI for the file containing the XML data.</span></span> <span data-ttu-id="58cdf-702"><see cref="T:System.Xml.XmlReaderSettings" /> 개체의 <see cref="T:System.Xml.XmlResolver" /> 개체는 경로를 정규 데이터 표현으로 변환하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-702">The <see cref="T:System.Xml.XmlResolver" /> object on the <see cref="T:System.Xml.XmlReaderSettings" /> object is used to convert the path to a canonical data representation.</span></span> <span data-ttu-id="58cdf-703"><see cref="P:System.Xml.XmlReaderSettings.XmlResolver" />가 <see langword="null" />이면 새 <see cref="T:System.Xml.XmlUrlResolver" /> 개체가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-703">If <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> is <see langword="null" />, a new <see cref="T:System.Xml.XmlUrlResolver" /> object is used.</span></span></param>
        <param name="settings"><span data-ttu-id="58cdf-704">새 <see cref="T:System.Xml.XmlReader" /> 인스턴스의 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-704">The settings for the new <see cref="T:System.Xml.XmlReader" /> instance.</span></span> <span data-ttu-id="58cdf-705">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-705">This value can be <see langword="null" />.</span></span></param>
        <param name="inputContext"><span data-ttu-id="58cdf-706">XML 조각을 구문 분석하는 데 필요한 컨텍스트 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-706">The context information required to parse the XML fragment.</span></span> <span data-ttu-id="58cdf-707">컨텍스트 정보에는 사용할 <see cref="T:System.Xml.XmlNameTable" />, 인코딩, 네임스페이스 범위, 현재 <c>xml:lang</c>과 <c>xml:space</c> 범위, 기본 URI 및 문서 종류 정의가 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-707">The context information can include the <see cref="T:System.Xml.XmlNameTable" /> to use, encoding, namespace scope, the current <c>xml:lang</c> and <c>xml:space</c> scope, base URI, and document type definition.</span></span>  
  
<span data-ttu-id="58cdf-708">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-708">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-709">지정된 URI, 설정 및 컨텍스트 정보를 구문 분석에 사용하여 새 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-709">Creates a new <see cref="T:System.Xml.XmlReader" /> instance by using the specified URI, settings, and context information for parsing.</span></span></summary>
        <returns><span data-ttu-id="58cdf-710">스트림의 XML 데이터를 읽는 데 사용되는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-710">An object that is used to read the XML data in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-711">기본적으로는 <xref:System.Xml.XmlUrlResolver> 없는 자격 증명을 사용 하 여 문서 유형 정의 (DTD), 엔터티, 스키마 등 모든 외부 리소스에 액세스 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-711">By default an <xref:System.Xml.XmlUrlResolver> with no credentials is used to access any external resources such as a document type definition (DTD), entities, schemas, and so on.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-712">기본값은 없습니다.NET Framework 4.5.2부터 <xref:System.Xml.XmlUrlResolver> 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-712">Starting with the .NET Framework 4.5.2, no default <xref:System.Xml.XmlUrlResolver> is provided.</span></span> <span data-ttu-id="58cdf-713">솔루션의.NET Framework 4.5.2 이상 버전을 대상으로 하는 경우 지정는 <xref:System.Xml.XmlResolver> 를 사용 하 여는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-713">If your solution targets the .NET Framework 4.5.2 or later versions, specify an <xref:System.Xml.XmlResolver> using the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58cdf-714">즉는 <xref:System.Xml.XmlReader> 인증 필요 하지 않은 모든 위치에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-714">This means that the <xref:System.Xml.XmlReader> can access any locations that does not require authentication.</span></span> <span data-ttu-id="58cdf-715">사용 하 여 외부 리소스를 인증을 요구 하는 네트워크 리소스에 있는 경우는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 속성에 지정할는 <xref:System.Xml.XmlResolver> 에 필요한 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-715">If the external resource is located on a network resource that requires authentication, use the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> property to specify an <xref:System.Xml.XmlResolver> with the necessary credentials.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-716">리소스를 제한할 수 있습니다는 합니다 <xref:System.Xml.XmlReader> 설정 하 여 액세스할 수는 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 속성을는 <xref:System.Xml.XmlSecureResolver> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-716">You can restrict the resources that the <xref:System.Xml.XmlReader> can access by setting the <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property to an <xref:System.Xml.XmlSecureResolver> object.</span></span>  
  
 <span data-ttu-id="58cdf-717">만들어진 <xref:System.Xml.XmlReader> 개체는 엔터티 참조를 확장 하 고 줄 바꿈 문자의 XML 표준화를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-717">The created <xref:System.Xml.XmlReader> object expands entity references and performs XML normalization of new line characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-718"><see langword="inputUri" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-718">The <see langword="inputUri" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="58cdf-719"><see cref="T:System.Xml.XmlReader" />에는 XML 데이터 위치에 액세스할 수 있는 충분한 권한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-719">The <see cref="T:System.Xml.XmlReader" /> does not have sufficient permissions to access the location of the XML data.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-720"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 및 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 속성 둘 다에 값이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-720">The <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> and <see cref="P:System.Xml.XmlParserContext.NameTable" /> properties both contain values.</span></span> <span data-ttu-id="58cdf-721"><see langword="NameTable" /> 속성 중 하나만 설정 및 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-721">(Only one of these <see langword="NameTable" /> properties can be set and used).</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="58cdf-722">URI로 지정된 파일을 찾을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-722">The file specified by the URI cannot be found.</span></span></exception>
        <exception cref="T:System.UriFormatException"><span data-ttu-id="58cdf-723">URI 형식이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-723">The URI format is not correct.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-724">파생 클래스에서 재정의되면 XML 문서에서 현재 노드의 수준을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-724">When overridden in a derived class, gets the depth of the current node in the XML document.</span></span></summary>
        <value><span data-ttu-id="58cdf-725">XML 문서의 현재 노드 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-725">The depth of the current node in the XML document.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-726">참조 <xref:System.Xml.XmlTextReader.Depth%2A> (에 `XmlTextReader` 클래스)이이 속성을 사용 하는 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-726">See <xref:System.Xml.XmlTextReader.Depth%2A> (in the `XmlTextReader` class) for an example using this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-727">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-727">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-728">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-728">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-729">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-729">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-730">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-730">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-731"><see cref="T:System.Xml.XmlReader" /> 클래스에서 사용하는 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-731">Releases the resources used by the <see cref="T:System.Xml.XmlReader" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-732"><see cref="T:System.Xml.XmlReader" /> 클래스의 현재 인스턴스에서 사용하는 모든 리소스를 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-732">Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlReader" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-733">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-733">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-734">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-734">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="58cdf-735">관리되는 리소스와 관리되지 않는 리소스를 모두 해제하려면 <see langword="true" />로 설정하고, 관리되지 않는 리소스만 해제하려면 <see langword="false" />로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-735"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="58cdf-736"><see cref="T:System.Xml.XmlReader" />에서 사용하는 관리되지 않는 리소스를 해제하고, 관리되는 리소스를 선택적으로 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-736">Releases the unmanaged resources used by the <see cref="T:System.Xml.XmlReader" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-737">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-737">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-738">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-738">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-739">파생 클래스에서 재정의되면 판독기가 스트림의 끝에 배치되었는지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-739">When overridden in a derived class, gets a value indicating whether the reader is positioned at the end of the stream.</span></span></summary>
        <value><span data-ttu-id="58cdf-740">판독기가 스트림의 맨 끝에 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-740"><see langword="true" /> if the reader is positioned at the end of the stream; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-741">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-741">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-742">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-742">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-743">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-743">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-744">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-744">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-745">파생 클래스에서 재정의되면 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-745">When overridden in a derived class, gets the value of an attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i"><span data-ttu-id="58cdf-746">특성의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-746">The index of the attribute.</span></span> <span data-ttu-id="58cdf-747">인덱스는 0부터 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-747">The index is zero-based.</span></span> <span data-ttu-id="58cdf-748">첫 번째 특성의 인덱스는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-748">(The first attribute has index 0.)</span></span></param>
        <summary><span data-ttu-id="58cdf-749">파생 클래스에서 재정의되면 지정된 인덱스가 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-749">When overridden in a derived class, gets the value of the attribute with the specified index.</span></span></summary>
        <returns><span data-ttu-id="58cdf-750">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-750">The value of the specified attribute.</span></span> <span data-ttu-id="58cdf-751">이 메서드는 판독기를 이동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-751">This method does not move the reader.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-752">다음 예제에서는 세 번째 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-752">The following example gets the value of the third attribute.</span></span>  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-753"><paramref name="i" />가 범위에서 벗어난 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-753"><paramref name="i" /> is out of range.</span></span> <span data-ttu-id="58cdf-754">음수가 아니어야 하며 특성 컬렉션의 크기보다 작아야합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-754">It must be non-negative and less than the size of the attribute collection.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-755">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-755">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-756">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-756">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-757">특성의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-757">The qualified name of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-758">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.Name" />이 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-758">When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.Name" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-759">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-759">The value of the specified attribute.</span></span> <span data-ttu-id="58cdf-760">지정된 특성이 없거나 값이 <see langword="String.Empty" />이면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-760">If the attribute is not found or the value is <see langword="String.Empty" />, <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-761">이 메서드는 판독기를 이동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-761">This method does not move the reader.</span></span>  
  
 <span data-ttu-id="58cdf-762">판독기가 위치에 `DocumentType` 노드를이 메서드는 PUBLIC과 SYSTEM 리터럴, 예를 들어, 가져오는 데 사용할 수 있습니다 `reader.GetAttribute("PUBLIC")`</span><span class="sxs-lookup"><span data-stu-id="58cdf-762">If the reader is positioned on a `DocumentType` node, this method can be used to get the PUBLIC and SYSTEM literals, for example, `reader.GetAttribute("PUBLIC")`</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-763">다음 예제에서는 ISBN 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-763">The following example gets the value of the ISBN attribute.</span></span>  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-764"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-764"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-765">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-765">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-766">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-766">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-767">특성의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-767">The local name of the attribute.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-768">특성의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-768">The namespace URI of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-769">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" />가 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-769">When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-770">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-770">The value of the specified attribute.</span></span> <span data-ttu-id="58cdf-771">지정된 특성이 없거나 값이 <see langword="String.Empty" />이면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-771">If the attribute is not found or the value is <see langword="String.Empty" />, <see langword="null" /> is returned.</span></span> <span data-ttu-id="58cdf-772">이 메서드는 판독기를 이동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-772">This method does not move the reader.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-773">다음 XML 특정 네임 스페이스의 특성을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-773">The following XML contains an attribute in a specific namespace:</span></span>  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 <span data-ttu-id="58cdf-774">조회 수는 `dt:type` (접두사와 로컬 이름)의 인수를 하나 또는 두 개의 인수 (로컬 이름 및 네임 스페이스 URI)를 사용 하 여 특성:</span><span class="sxs-lookup"><span data-stu-id="58cdf-774">You can lookup the `dt:type` attribute using one argument (prefix and local name) or two arguments (local name and namespace URI):</span></span>  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 <span data-ttu-id="58cdf-775">조회 하는 `xmlns:dt` 특성에 다음 인수 중 하나를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-775">To lookup the `xmlns:dt` attribute, use one of the following arguments:</span></span>  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 <span data-ttu-id="58cdf-776">사용 하 여이 정보를 가져올 수도 있습니다는 <xref:System.Xml.XmlReader.Prefix%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-776">You can also get this information using the <xref:System.Xml.XmlReader.Prefix%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-777"><paramref name="name" />가 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-777"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-778">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-778">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-779">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-779">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-780">현재 노드의 값을 비동기적으로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-780">Asynchronously gets the value of the current node.</span></span></summary>
        <returns><span data-ttu-id="58cdf-781">현재 노드의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-781">The value of the current node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-782">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-782">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-783">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-783">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-784">이 경우에 "비동기 작업이 이미 진행 중입니다." 메시지를 표시하며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-784">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress".</span></span>

<span data-ttu-id="58cdf-785">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-785">-or-</span></span>

<span data-ttu-id="58cdf-786"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-786">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-787">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-787">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-788">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-788">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-789">현재 노드에 특성이 있는지를 나타내는 값을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-789">Gets a value indicating whether the current node has any attributes.</span></span></summary>
        <value><span data-ttu-id="58cdf-790">현재 노드에 특성이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-790"><see langword="true" /> if the current node has attributes; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-791">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-791">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-792">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-792">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-793">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-793">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-794">파생 클래스에서 재정의되면 현재 노드에 <see cref="P:System.Xml.XmlReader.Value" />가 있는지 여부를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-794">When overridden in a derived class, gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlReader.Value" />.</span></span></summary>
        <value><span data-ttu-id="58cdf-795">현재 판독기가 위치한 노드에 <see langword="Value" />가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-795"><see langword="true" /> if the node on which the reader is currently positioned can have a <see langword="Value" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="58cdf-796"><see langword="false" />인 경우 노드의 값은 <see langword="String.Empty" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-796">If <see langword="false" />, the node has a value of <see langword="String.Empty" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-797">다음 표에서는 반환할 값이 있는 노드 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-797">The following table lists node types that have a value to return.</span></span>  
  
|<span data-ttu-id="58cdf-798">노드 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-798">Node Type</span></span>|<span data-ttu-id="58cdf-799">값</span><span class="sxs-lookup"><span data-stu-id="58cdf-799">Value</span></span>|  
|---------------|-----------|  
|`Attribute`|<span data-ttu-id="58cdf-800">특성 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-800">The value of the attribute.</span></span>|  
|`CDATA`|<span data-ttu-id="58cdf-801">CDATA 섹션 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-801">The content of the CDATA section.</span></span>|  
|`Comment`|<span data-ttu-id="58cdf-802">주석의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-802">The content of the comment.</span></span>|  
|`DocumentType`|<span data-ttu-id="58cdf-803">내부 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-803">The internal subset.</span></span>|  
|`ProcessingInstruction`|<span data-ttu-id="58cdf-804">대상을 제외한 전체 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-804">The entire content, excluding the target.</span></span>|  
|`SignificantWhitespace`|<span data-ttu-id="58cdf-805">혼합된 콘텐츠 모델의 태그 간 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-805">The white space between markup in a mixed content model.</span></span>|  
|`Text`|<span data-ttu-id="58cdf-806">텍스트 노드의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-806">The content of the text node.</span></span>|  
|`Whitespace`|<span data-ttu-id="58cdf-807">태그 사이의 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-807">The white space between markup.</span></span>|  
|`XmlDeclaration`|<span data-ttu-id="58cdf-808">선언 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-808">The content of the declaration.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-809">참조 <xref:System.Xml.XmlTextReader.HasValue%2A> (에 `XmlTextReader` 클래스)이이 메서드를 사용 하는 샘플에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-809">See <xref:System.Xml.XmlTextReader.HasValue%2A> (in the `XmlTextReader` class) for a sample using this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-810">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-810">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-811">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-811">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-812">파생 클래스에서 재정의되면 현재 노드가 DTD나 스키마에서 정의한 기본값에서 생성된 값을 가진 특성인지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-812">When overridden in a derived class, gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</span></span></summary>
        <value><span data-ttu-id="58cdf-813">현재 노드가 DTD나 스키마에서 정의한 기본값에서 생성된 값을 가진 특성이면 <see langword="true" />이고, 특성 값이 명시적으로 설정되었으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-813"><see langword="true" /> if the current node is an attribute whose value was generated from the default value defined in the DTD or schema; <see langword="false" /> if the attribute value was explicitly set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-814">`IsDefault` 항상 반환 `false` 의 구현에 대 한 `XmlReader` 는 스키마 또는 DTD 정보를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-814">`IsDefault` always returns `false` for implementations of `XmlReader` that do not support schema or DTD information.</span></span> <span data-ttu-id="58cdf-815">특성 노드에만이 속성이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-815">This property applies only to an attribute node.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-816">다음 예제에서는 루트 요소에서 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-816">The following example displays all attributes on the root element.</span></span>  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 <span data-ttu-id="58cdf-817">이 예제에서는 입력으로 다음 파일을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-817">The example uses the following files as input.</span></span>  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-818">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-818">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-819">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-819">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-820">파생 클래스에서 재정의되면 현재 노드가 <c>&lt;MyElement/&gt;</c>와 같은 빈 요소인지를 나타내는 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-820">When overridden in a derived class, gets a value indicating whether the current node is an empty element (for example, <c>&lt;MyElement/&gt;</c>).</span></span></summary>
        <value><span data-ttu-id="58cdf-821"><see langword="true" /> 현재 노드가 요소 이면 (<see cref="P:System.Xml.XmlReader.NodeType" /> equals <see langword="XmlNodeType.Element" />)로 끝나는 <c>/ &gt;</c>고, 그렇지 않으면 <see langword="false" />합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-821"><see langword="true" /> if the current node is an element (<see cref="P:System.Xml.XmlReader.NodeType" /> equals <see langword="XmlNodeType.Element" />) that ends with <c>/&gt;</c>; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-822">이 속성을 사용하여 다음 간의 차이를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-822">This property enables you to determine the difference between the following:</span></span>  
  
 <span data-ttu-id="58cdf-823">`<item num="123"/>` (`IsEmptyElement` 는 `true`).</span><span class="sxs-lookup"><span data-stu-id="58cdf-823">`<item num="123"/>` (`IsEmptyElement` is `true`).</span></span>  
  
 <span data-ttu-id="58cdf-824">`<item num="123"></item>` (`IsEmptyElement` 는 `false`요소 내용이 비어 있지만).</span><span class="sxs-lookup"><span data-stu-id="58cdf-824">`<item num="123"></item>` (`IsEmptyElement` is `false`, although element content is empty).</span></span>  
  
 <span data-ttu-id="58cdf-825">해당 `EndElement` 빈 요소에 대 한 노드 생성 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-825">A corresponding `EndElement` node is not generated for empty elements.</span></span>  
  
 <span data-ttu-id="58cdf-826">기본 콘텐츠 스키마 유효성 검사로 인해 요소에 추가한 경우 `IsEmptyElement` 그대로 반환 `true`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-826">If default content has been added to an element due to schema validation, `IsEmptyElement` still returns `true`.</span></span> <span data-ttu-id="58cdf-827">요소에는 기본값이 여부에 관계가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-827">It has no bearing on whether or not the element has a default value.</span></span> <span data-ttu-id="58cdf-828">즉, `IsEmptyElement` 원본 문서의 요소 했습니다 끝 요소 태그가 있는지 여부를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-828">In other words, `IsEmptyElement` simply reports whether or not the element in the source document had an end element tag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-829">다음 예제에서는 각 요소의 텍스트 콘텐츠를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-829">The following example displays the text content of each element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 <span data-ttu-id="58cdf-830">이 예제에서는 파일을 사용 하 여 `elems.xml`입력으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-830">The example uses the file, `elems.xml`, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-831">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-831">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-832">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-832">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="58cdf-833">유효성을 검사할 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-833">The name to validate.</span></span></param>
        <summary><span data-ttu-id="58cdf-834">문자열 인수가 유효한 XML 이름인지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-834">Returns a value indicating whether the string argument is a valid XML name.</span></span></summary>
        <returns><span data-ttu-id="58cdf-835">유효한 이름이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-835"><see langword="true" /> if the name is valid; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-836">이 메서드는 사용 합니다 [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) 이름이 올바른지 여부를 확인 하려면.</span><span class="sxs-lookup"><span data-stu-id="58cdf-836">This method uses the [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) to determine whether the name is valid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-837"><paramref name="str" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-837">The <paramref name="str" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="58cdf-838">유효성을 검사할 이름 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-838">The name token to validate.</span></span></param>
        <summary><span data-ttu-id="58cdf-839">문자열 인수가 유효한 XML 이름 토큰인지를 나타내는 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-839">Returns a value indicating whether or not the string argument is a valid XML name token.</span></span></summary>
        <returns><span data-ttu-id="58cdf-840">유효한 이름 토큰이면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-840"><see langword="true" /> if it is a valid name token; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-841">이 메서드를 사용 합니다 [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) 이름 토큰이 유효한 지 여부를 확인 하려면.</span><span class="sxs-lookup"><span data-stu-id="58cdf-841">This method uses the [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) to determine whether the name token is valid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-842"><paramref name="str" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-842">The <paramref name="str" /> value is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-843">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-843">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-844">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-844">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-845">현재 콘텐츠 노드가 시작 태그인지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-845">Tests if the current content node is a start tag.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-846"><see cref="M:System.Xml.XmlReader.MoveToContent" />를 호출하고 현재 콘텐츠 노드가 시작 태그 또는 빈 요소 태그인지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-846">Calls <see cref="M:System.Xml.XmlReader.MoveToContent" /> and tests if the current content node is a start tag or empty element tag.</span></span></summary>
        <returns><span data-ttu-id="58cdf-847"><see cref="M:System.Xml.XmlReader.MoveToContent" />가 시작 태그나 빈 요소 태그를 찾으면 <see langword="true" />이고, <see langword="false" /> 이외의 노드 형식을 찾으면 <see langword="XmlNodeType.Element" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-847"><see langword="true" /> if <see cref="M:System.Xml.XmlReader.MoveToContent" /> finds a start tag or empty element tag; <see langword="false" /> if a node type other than <see langword="XmlNodeType.Element" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-848">공백, 설명 및 처리 명령 콘텐츠 노드에 판독기가 배치 될 때까지이 메서드는 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-848">This method skips white space, comments, and processing instructions until the reader is positioned on a content node.</span></span> <span data-ttu-id="58cdf-849">현재 노드가 요소 이면에 다음 메서드를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-849">The method then tests if the current node is an element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-850">다음 예제에서는 각 요소의 텍스트 콘텐츠를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-850">The following example displays the text content of each element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 <span data-ttu-id="58cdf-851">이 예제에서는 파일을 사용 하 여 `elems.xml`입력으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-851">The example uses the file, `elems.xml`, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-852">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-852">Incorrect XML is encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-853">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-853">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-854">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-854">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-855">찾은 요소의 <see langword="Name" /> 속성과 일치하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-855">The string matched against the <see langword="Name" /> property of the element found.</span></span></param>
        <summary><span data-ttu-id="58cdf-856"><see cref="M:System.Xml.XmlReader.MoveToContent" />를 호출하고 현재 콘텐츠 노드가 시작 태그 또는 빈 요소 태그인지 여부와 찾은 요소의 <see cref="P:System.Xml.XmlReader.Name" /> 속성이 지정된 인수와 일치하는지 여부를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-856">Calls <see cref="M:System.Xml.XmlReader.MoveToContent" /> and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.Name" /> property of the element found matches the given argument.</span></span></summary>
        <returns><span data-ttu-id="58cdf-857">테스트한 결과 현재 노드가 요소이고 <see langword="true" /> 속성이 지정된 문자열과 일치하면 <see langword="Name" />이고,</span><span class="sxs-lookup"><span data-stu-id="58cdf-857"><see langword="true" /> if the resulting node is an element and the <see langword="Name" /> property matches the specified string.</span></span> <span data-ttu-id="58cdf-858"><see langword="false" /> 이외의 노드 형식을 찾거나 요소 <see langword="XmlNodeType.Element" /> 속성이 지정된 문자열과 일치하지 않으면 <see langword="Name" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-858"><see langword="false" /> if a node type other than <see langword="XmlNodeType.Element" /> was found or if the element <see langword="Name" /> property does not match the specified string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-859">공백, 설명 및 처리 명령 콘텐츠 노드에 판독기가 배치 될 때까지이 메서드는 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-859">This method skips white space, comments, and processing instructions until the reader is positioned on a content node.</span></span> <span data-ttu-id="58cdf-860">현재 노드가 요소 이면에 다음 메서드를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-860">The method then tests if the current node is an element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-861">다음 예제에서는 각 가격 요소를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-861">The following example displays each price element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-862">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-862">Incorrect XML is encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-863">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-863">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-864">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-864">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname"><span data-ttu-id="58cdf-865">찾은 요소의 <see langword="LocalName" /> 속성과 일치하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-865">The string to match against the <see langword="LocalName" /> property of the element found.</span></span></param>
        <param name="ns"><span data-ttu-id="58cdf-866">찾은 요소의 <see langword="NamespaceURI" /> 속성과 일치하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-866">The string to match against the <see langword="NamespaceURI" /> property of the element found.</span></span></param>
        <summary><span data-ttu-id="58cdf-867"><see cref="M:System.Xml.XmlReader.MoveToContent" />를 호출하고 현재 콘텐츠 노드가 시작 태그 또는 빈 요소 태그인지 여부와 찾은 요소의 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 속성이 지정된 인수와 일치하는지 여부를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-867">Calls <see cref="M:System.Xml.XmlReader.MoveToContent" /> and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" /> properties of the element found match the given strings.</span></span></summary>
        <returns><span data-ttu-id="58cdf-868">테스트한 결과 현재 노드가 요소이면 <see langword="true" />이고,</span><span class="sxs-lookup"><span data-stu-id="58cdf-868"><see langword="true" /> if the resulting node is an element.</span></span> <span data-ttu-id="58cdf-869"><see langword="false" /> 이외의 노드 형식을 찾거나 요소의 <see langword="XmlNodeType.Element" /> 및 <see langword="LocalName" /> 속성이 지정된 문자열과 일치하지 않으면 <see langword="NamespaceURI" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-869"><see langword="false" /> if a node type other than <see langword="XmlNodeType.Element" /> was found or if the <see langword="LocalName" /> and <see langword="NamespaceURI" /> properties of the element do not match the specified strings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-870">공백, 설명 및 처리 명령 콘텐츠 노드에 판독기가 배치 될 때까지이 메서드는 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-870">This method skips white space, comments, and processing instructions until the reader is positioned on a content node.</span></span> <span data-ttu-id="58cdf-871">현재 노드가 요소 이면에 다음 메서드를 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-871">The method then tests if the current node is an element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-872">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-872">Incorrect XML is encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-873">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-873">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-874">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-874">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-875">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-875">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-876">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-876">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-877">파생 클래스에서 재정의되면 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-877">When overridden in a derived class, gets the value of the attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i"><span data-ttu-id="58cdf-878">특성의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-878">The index of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-879">파생 클래스에서 재정의되면 지정된 인덱스가 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-879">When overridden in a derived class, gets the value of the attribute with the specified index.</span></span></summary>
        <value><span data-ttu-id="58cdf-880">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-880">The value of the specified attribute.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-881">이 속성은 판독기를 이동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-881">This property does not move the reader.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-882">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-882">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-883">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-883">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-884">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-884">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-885">특성의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-885">The qualified name of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-886">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.Name" />이 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-886">When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.Name" />.</span></span></summary>
        <value><span data-ttu-id="58cdf-887">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-887">The value of the specified attribute.</span></span> <span data-ttu-id="58cdf-888">특성이 없으면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-888">If the attribute is not found, <see langword="null" /> is returned.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-889">이 속성은 판독기를 이동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-889">This property does not move the reader.</span></span>  
  
 <span data-ttu-id="58cdf-890">판독기가 위치에 `DocumentType` 노드를이 메서드는 PUBLIC과 SYSTEM 리터럴, 예를 들어, 가져오는 데 사용할 수 있습니다 `reader["PUBLIC"]`</span><span class="sxs-lookup"><span data-stu-id="58cdf-890">If the reader is positioned on a `DocumentType` node, this method can be used to get the PUBLIC and SYSTEM literals, for example, `reader["PUBLIC"]`</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-891">다음 예제에서는 ISBN 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-891">The following example gets the value of the ISBN attribute.</span></span>  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-892">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-892">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-893">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-893">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-894">특성의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-894">The local name of the attribute.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-895">특성의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-895">The namespace URI of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-896">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" />가 있는 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-896">When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</span></span></summary>
        <value><span data-ttu-id="58cdf-897">지정된 특성의 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-897">The value of the specified attribute.</span></span> <span data-ttu-id="58cdf-898">특성이 없으면 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-898">If the attribute is not found, <see langword="null" /> is returned.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-899">이 속성은 판독기를 이동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-899">This property does not move the reader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-900">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-900">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-901">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-901">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-902">파생 클래스에서 재정의되면 현재 노드의 로컬 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-902">When overridden in a derived class, gets the local name of the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-903">접두사를 제거한 현재 노드의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-903">The name of the current node with the prefix removed.</span></span> <span data-ttu-id="58cdf-904">예를 들어 <see langword="LocalName" /> 됩니다 <see langword="book" /> 요소에 대 한 <c>&lt;예&gt;</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-904">For example, <see langword="LocalName" /> is <see langword="book" /> for the element <c>&lt;bk:book&gt;</c>.</span></span>  
  
<span data-ttu-id="58cdf-905">이름이 없는 노드 형식(예: <see langword="Text" />, <see langword="Comment" /> 등)의 경우 이 속성은 <see langword="String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-905">For node types that do not have a name (like <see langword="Text" />, <see langword="Comment" />, and so on), this property returns <see langword="String.Empty" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-906">다음 예제에서는 각 노드의 로컬 이름을 표시 하 고, 있을 경우, 접두사 및 네임 스페이스 URI 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-906">The following example displays the local name of each node, and, if they exist, the prefix and namespace URI.</span></span>  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 <span data-ttu-id="58cdf-907">이 예제에서는 입력으로 book2.xml, 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-907">The example uses the file, book2.xml, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-908">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-908">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-909">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-909">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix"><span data-ttu-id="58cdf-910">확인할 네임스페이스 URI의 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-910">The prefix whose namespace URI you want to resolve.</span></span> <span data-ttu-id="58cdf-911">기본 네임스페이스와 일치시키려면 빈 문자열을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-911">To match the default namespace, pass an empty string.</span></span></param>
        <summary><span data-ttu-id="58cdf-912">파생 클래스에서 재정의되면 현재 요소의 범위에서 네임스페이스 접두사를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-912">When overridden in a derived class, resolves a namespace prefix in the current element's scope.</span></span></summary>
        <returns><span data-ttu-id="58cdf-913">접두사가 매핑되는 네임스페이스 URI이거나 일치하는 접두사가 없는 경우 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-913">The namespace URI to which the prefix maps or <see langword="null" /> if no matching prefix is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-914">다음 XML 문자열에서 판독기가 배치 하는 경우에 `href` 특성을 접두사 `a` 호출 하 여 해결 될 `reader.LookupNamespace("a")`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-914">In the following XML string, if the reader is positioned on the `href` attribute, the prefix `a` is resolved by calling `reader.LookupNamespace("a")`.</span></span> <span data-ttu-id="58cdf-915">반환 된 문자열은 `urn:456`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-915">The returned string is `urn:456`.</span></span>  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-916">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-916">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-917">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-917">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-918">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-918">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-919">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-919">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-920">파생 클래스에서 재정의되면 지정된 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-920">When overridden in a derived class, moves to the specified attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i"><span data-ttu-id="58cdf-921">특성의 인덱스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-921">The index of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-922">파생 클래스에서 재정의되면 지정된 인덱스가 있는 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-922">When overridden in a derived class, moves to the attribute with the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-923">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-923">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-924">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-924">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-925">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-925">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-926">매개 변수에 음수 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-926">The parameter has a negative value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-927">특성의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-927">The qualified name of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-928">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.Name" />이 있는 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-928">When overridden in a derived class, moves to the attribute with the specified <see cref="P:System.Xml.XmlReader.Name" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-929">특성이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-929"><see langword="true" /> if the attribute is found; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="58cdf-930"><see langword="false" />이면, 판독기의 위치는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-930">If <see langword="false" />, the reader's position does not change.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-931">호출한 후 `MoveToAttribute`는 <xref:System.Xml.XmlReader.Name%2A>를 <xref:System.Xml.XmlReader.NamespaceURI%2A>, 및 <xref:System.Xml.XmlReader.Prefix%2A> 속성 특성의 속성을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-931">After calling `MoveToAttribute`, the <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, and <xref:System.Xml.XmlReader.Prefix%2A> properties reflect the properties of that attribute.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-932">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-932">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-933">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-933">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-934">매개 변수가 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-934">The parameter is an empty string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-935">특성의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-935">The local name of the attribute.</span></span></param>
        <param name="ns"><span data-ttu-id="58cdf-936">특성의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-936">The namespace URI of the attribute.</span></span></param>
        <summary><span data-ttu-id="58cdf-937">파생 클래스에서 재정의되면 지정된 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" />가 있는 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-937">When overridden in a derived class, moves to the attribute with the specified <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-938">특성이 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-938"><see langword="true" /> if the attribute is found; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="58cdf-939"><see langword="false" />이면, 판독기의 위치는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-939">If <see langword="false" />, the reader's position does not change.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-940">호출한 후 `MoveToAttribute`는 <xref:System.Xml.XmlReader.Name%2A>를 <xref:System.Xml.XmlReader.NamespaceURI%2A>, 및 <xref:System.Xml.XmlReader.Prefix%2A> 속성 특성의 속성을 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-940">After calling `MoveToAttribute`, the <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, and <xref:System.Xml.XmlReader.Prefix%2A> properties reflect the properties of that attribute.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-941">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-941">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-942">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-942">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-943">두 매개 변수 값이 모두 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-943">Both parameter values are <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-944">현재 노드가 콘텐츠 노드(공백 없는 텍스트, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> 또는 <see langword="EndEntity" />)인지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-944">Checks whether the current node is a content (non-white space text, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" />, or <see langword="EndEntity" />) node.</span></span> <span data-ttu-id="58cdf-945">해당 노드가 콘텐츠 노드가 아니면 판독기는 다음 콘텐츠 노드나 파일의 끝으로 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-945">If the node is not a content node, the reader skips ahead to the next content node or end of file.</span></span> <span data-ttu-id="58cdf-946">판독기는 <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> 또는 <see langword="SignificantWhitespace" /> 같은 형식의 노드를 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-946">It skips over nodes of the following type: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" />, or <see langword="SignificantWhitespace" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-947">메서드를 사용하여 찾은 현재 노드의 <see cref="P:System.Xml.XmlReader.NodeType" />이거나 판독기가 입력 스트림의 끝에 도달한 경우에는 <see langword="XmlNodeType.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-947">The <see cref="P:System.Xml.XmlReader.NodeType" /> of the current node found by the method or <see langword="XmlNodeType.None" /> if the reader has reached the end of the input stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-948">현재 노드의 특성 노드의 경우이 메서드 판독기 다시 이동 특성이 있는 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-948">If the current node is an attribute node, this method moves the reader back to the element that owns the attribute.</span></span>  
  
 <span data-ttu-id="58cdf-949">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.MoveToContentAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-949">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-950">중단 하지 않고 임의 XML 태그를 건너뛸 수 있는 코드를 작성 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-950">This is useful when you want to write code that can skip over random XML markup without breaking.</span></span> <span data-ttu-id="58cdf-951">예를 들어 다음 코드가 있다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-951">For example, suppose you have the following code:</span></span>  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 <span data-ttu-id="58cdf-952">이 코드는 중단 되지 않고 다음 입력을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-952">This code can handle the following inputs without breaking:</span></span>  
  
```xml  
<price>123.4</price>  
```  
  
 <span data-ttu-id="58cdf-953">를 갖는</span><span class="sxs-lookup"><span data-stu-id="58cdf-953">and</span></span>  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 <span data-ttu-id="58cdf-954">를 갖는</span><span class="sxs-lookup"><span data-stu-id="58cdf-954">and</span></span>  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 <span data-ttu-id="58cdf-955">를 갖는</span><span class="sxs-lookup"><span data-stu-id="58cdf-955">and</span></span>  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-956">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-956">Incorrect XML encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-957">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-957">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-958">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-958">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-959">현재 노드가 콘텐츠 노드인지를 비동기적으로 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-959">Asynchronously checks whether the current node is a content node.</span></span> <span data-ttu-id="58cdf-960">해당 노드가 콘텐츠 노드가 아니면 판독기는 다음 콘텐츠 노드나 파일의 끝으로 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-960">If the node is not a content node, the reader skips ahead to the next content node or end of file.</span></span></summary>
        <returns><span data-ttu-id="58cdf-961">메서드를 사용하여 찾은 현재 노드의 <see cref="P:System.Xml.XmlReader.NodeType" />이거나 판독기가 입력 스트림의 끝에 도달한 경우에는 <see langword="XmlNodeType.None" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-961">The <see cref="P:System.Xml.XmlReader.NodeType" /> of the current node found by the method or <see langword="XmlNodeType.None" /> if the reader has reached the end of the input stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-962">비동기 버전이 <xref:System.Xml.XmlReader.MoveToContent%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-962">This is the asynchronous version of <xref:System.Xml.XmlReader.MoveToContent%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-963">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-963">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-964">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-964">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-965">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-965">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-966">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-966">-or-</span></span>

<span data-ttu-id="58cdf-967"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-967">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-968">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-968">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-969">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-969">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-970">파생 클래스에서 재정의되면 현재 특성 노드를 포함하는 요소로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-970">When overridden in a derived class, moves to the element that contains the current attribute node.</span></span></summary>
        <returns><span data-ttu-id="58cdf-971">판독기가 특성에 있으면(특성이 있는 요소로 판독기가 이동하면) <see langword="true" />이고, 판독기가 특성에 없으면(판독기의 위치가 바뀌지 않으면) <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-971"><see langword="true" /> if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" /> if the reader is not positioned on an attribute (the position of the reader does not change).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-972">이 메서드를 사용 하 여 해당 특성을 통해 이동한 후 요소 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-972">Use this method to return to an element after navigating through its attributes.</span></span> <span data-ttu-id="58cdf-973">이 메서드는 다음 노드 형식 중 하나에 판독기를 이동 합니다. `Element`, `DocumentType`, 또는 `XmlDeclaration`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-973">This method moves the reader to one of the following node types: `Element`, `DocumentType`, or `XmlDeclaration`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-974">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-974">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-975">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-975">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-976">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-976">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-977">파생 클래스에서 재정의되면 첫 번째 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-977">When overridden in a derived class, moves to the first attribute.</span></span></summary>
        <returns><span data-ttu-id="58cdf-978">특성이 있으면(판독기가 첫 번째 특성으로 이동하면) <see langword="true" />이고, 그렇지 않으면(판독기의 위치가 바뀌지 않으면) <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-978"><see langword="true" /> if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" /> (the position of the reader does not change).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-979">다음 예제에서는 첫 번째 특성의 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-979">The following example gets the value of the first attribute.</span></span>  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-980">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-980">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-981">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-981">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-982">파생 클래스에서 재정의되면 다음 특성으로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-982">When overridden in a derived class, moves to the next attribute.</span></span></summary>
        <returns><span data-ttu-id="58cdf-983">다음 특성이 있으면 <see langword="true" />이고, 더 이상 특성이 없으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-983"><see langword="true" /> if there is a next attribute; <see langword="false" /> if there are no more attributes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-984">현재 노드가 요소 노드인 경우이 메서드는 <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-984">If the current node is an element node, this method is equivalent to <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>.</span></span> <span data-ttu-id="58cdf-985">하는 경우 `MoveToNextAttribute` 반환 `true`, 판독기의 위치가 바뀌지 않으면이 고, 그렇지 않으면 다음 특성으로 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-985">If `MoveToNextAttribute` returns `true`, the reader moves to the next attribute; otherwise, the position of the reader does not change.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-986">다음 예에서는 현재 노드의 모든 특성을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-986">The following example displays all attributes on the current node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-987">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-987">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-988">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-988">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-989">파생 클래스에서 재정의되면 현재 노드의 정규화된 이름을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-989">When overridden in a derived class, gets the qualified name of the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-990">현재 노드의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-990">The qualified name of the current node.</span></span> <span data-ttu-id="58cdf-991">예를 들어 <see langword="Name" /> 됩니다 <see langword="bk:book" /> 요소에 대 한 <c>&lt;예&gt;</c>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-991">For example, <see langword="Name" /> is <see langword="bk:book" /> for the element <c>&lt;bk:book&gt;</c>.</span></span>  
  
<span data-ttu-id="58cdf-992">반환되는 이름은 다음과 같이 노드의 <see cref="P:System.Xml.XmlReader.NodeType" />에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-992">The name returned is dependent on the <see cref="P:System.Xml.XmlReader.NodeType" /> of the node.</span></span> <span data-ttu-id="58cdf-993">다음 노드 형식은 나열된 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-993">The following node types return the listed values.</span></span> <span data-ttu-id="58cdf-994">기타 모든 노드 형식은 빈 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-994">All other node types return an empty string.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="58cdf-995">노드 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-995">Node type</span></span> 
 </term><description> <span data-ttu-id="58cdf-996">name</span><span class="sxs-lookup"><span data-stu-id="58cdf-996">Name</span></span> 
 </description></listheader><item><term><see langword="Attribute" /></term><description> <span data-ttu-id="58cdf-997">특성 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-997">The name of the attribute.</span></span>  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> <span data-ttu-id="58cdf-998">문서 형식 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-998">The document type name.</span></span>  
  
 </description></item><item><term><see langword="Element" /></term><description> <span data-ttu-id="58cdf-999">태그 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-999">The tag name.</span></span>  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> <span data-ttu-id="58cdf-1000">참조된 엔터티의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1000">The name of the entity referenced.</span></span>  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> <span data-ttu-id="58cdf-1001">처리 명령의 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1001">The target of the processing instruction.</span></span>  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> <span data-ttu-id="58cdf-1002">리터럴 문자열 <see langword="xml" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1002">The literal string <see langword="xml" />.</span></span>  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-1003">다음 예제에서는 XML 파일을 읽고 각 노드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1003">The following example reads an XML file and displays each of the nodes.</span></span>  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 <span data-ttu-id="58cdf-1004">이 샘플에서는 사용 된 `items.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1004">The sample uses the `items.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1005">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1005">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1006">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1006">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-1007">파생 클래스에서 재정의되면 판독기가 배치된 노드의 네임스페이스 URI를 W3C 네임스페이스 사양에 정의된 대로 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1007">When overridden in a derived class, gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</span></span></summary>
        <value><span data-ttu-id="58cdf-1008">현재 노드의 네임스페이스 URI이거나 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1008">The namespace URI of the current node; otherwise an empty string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1009">이 속성이 관련이 `Element` 고 `Attribute` 노드만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1009">This property is relevant to `Element` and `Attribute` nodes only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1010">다음 예제에서는 각 노드의 로컬 이름을 표시 하 고, 있을 경우, 접두사 및 네임 스페이스 URI 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1010">The following example displays the local name of each node, and, if they exist, the prefix and namespace URI.</span></span>  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 <span data-ttu-id="58cdf-1011">이 예제에서는 입력으로 book2.xml, 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1011">The example uses the file, book2.xml, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1012">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1012">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1013">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1013">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-1014">파생 클래스에서 재정의되면 이 구현과 관련된 <see cref="T:System.Xml.XmlNameTable" />을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1014">When overridden in a derived class, gets the <see cref="T:System.Xml.XmlNameTable" /> associated with this implementation.</span></span></summary>
        <value><span data-ttu-id="58cdf-1015">노드 내에 있는 문자열의 원자화된 버전을 가져올 수 있도록 하는 <see langword="XmlNameTable" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1015">The <see langword="XmlNameTable" /> enabling you to get the atomized version of a string within the node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1016">반환 된 모든 노드 및 특성 이름은 <xref:System.Xml.XmlReader> 를 사용 하 여 원자화 되는 `NameTable`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1016">All node and attribute names returned from <xref:System.Xml.XmlReader> are atomized using the `NameTable`.</span></span> <span data-ttu-id="58cdf-1017">이름이 같은 여러 번에 반환 될 때 (예를 들어 `Customer`), 한 다음 동일한 `String` 해당 이름의 개체가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1017">When the same name is returned multiple times (for example, `Customer`), then the same `String` object will be returned for that name.</span></span> <span data-ttu-id="58cdf-1018">이렇게 하면 개체에 비용이 많이 드는 문자열 비교 대신 이러한 문자열 비교를 수행 하는 효율적인 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1018">This makes it possible for you to write efficient code that does object comparisons on these strings instead of expensive string comparisons.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1019">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1019">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1020">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1020">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-1021">파생 클래스에서 재정의되면 현재 노드의 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1021">When overridden in a derived class, gets the type of the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-1022">현재 노드의 형식을 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1022">One of the enumeration values that specify the type of the current node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-1023">다음 예제에서는 XML 파일을 읽고 각 노드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1023">The following example reads an XML file and displays each of the nodes.</span></span>  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 <span data-ttu-id="58cdf-1024">이 샘플에서는 사용 된 `items.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1024">The sample uses the `items.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1025">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1025">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1026">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1026">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-1027">파생 클래스에서 재정의되면 현재 노드와 관련된 네임스페이스 접두사를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1027">When overridden in a derived class, gets the namespace prefix associated with the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-1028">현재 노드와 관련된 네임스페이스 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1028">The namespace prefix associated with the current node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-1029">다음 예제에서는 각 노드의 로컬 이름을 표시 하 고, 있을 경우, 접두사 및 네임 스페이스 URI 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1029">The following example displays the local name of each node, and, if they exist, the prefix and namespace URI.</span></span>  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 <span data-ttu-id="58cdf-1030">이 예제에서는 입력으로 book2.xml, 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1030">The example uses the file, book2.xml, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1031">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1031">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1032">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1032">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-1033">파생 클래스에서 재정의되면 특성 노드의 값을 묶는 데 사용되는 따옴표 문자를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1033">When overridden in a derived class, gets the quotation mark character used to enclose the value of an attribute node.</span></span></summary>
        <value><span data-ttu-id="58cdf-1034">특성 노드의 값을 묶을 때 사용하는 인용 부호 문자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1034">The quotation mark character (" or ') used to enclose the value of an attribute node.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1035">특성 노드에만이 속성이 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1035">This property applies only to an attribute node.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1036">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1036">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1037">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1037">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1038">파생 클래스에서 재정의되면 스트림에서 다음 노드를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1038">When overridden in a derived class, reads the next node from the stream.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1039">서명을 읽었으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1039"><see langword="true" /> if the next node was read successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1040">경우는 <xref:System.Xml.XmlReader> 처음 사용할 수 있는 정보가 없는 만들고 초기화 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1040">When an <xref:System.Xml.XmlReader> is first created and initialized, there is no information available.</span></span> <span data-ttu-id="58cdf-1041">호출 해야 <xref:System.Xml.XmlReader.Read%2A> 첫 번째 노드를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1041">You must call <xref:System.Xml.XmlReader.Read%2A> to read the first node.</span></span> <span data-ttu-id="58cdf-1042">합니다 <xref:System.Xml.XmlReader.Read%2A> 메서드를 시작 하는 데 사용할 XML 판독기의 상태를 설정 <xref:System.Xml.ReadState> 메서드를이 시점에서의 값을 반환 된 파일의 끝에 도달할 때까지 순차적으로 XML 파일을 통해 이동 하 고 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1042">The <xref:System.Xml.XmlReader.Read%2A> method sets the state of the XML reader to initiate <xref:System.Xml.ReadState> and moves through the XML file sequentially until it reaches the end of the file, at which point the method returns a value of `false`.</span></span>  
  
 <span data-ttu-id="58cdf-1043">이 메서드는 데이터 스트림에서 4 바이트 이상 구문 분석을 시작 하기 위해 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1043">This method requires at least four bytes from the data stream in order to begin parsing.</span></span> <span data-ttu-id="58cdf-1044">메서드가 반환 하는 4 바이트 미만인 반환 되 고 스트림의 자세한 데이터가 없는, `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1044">If fewer than four bytes are returned and there is no more data in the stream, the method returns `false`.</span></span> <span data-ttu-id="58cdf-1045">스트림에서 더 많은 데이터를 네 번째 바이트가 수신 될 때까지 구문 분석 메서드가 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1045">If there is more data in the stream, the method will block parsing until receipt of the fourth byte.</span></span>  
  
 <span data-ttu-id="58cdf-1046">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1046">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1047">다음 예제에서는 XML 파일을 읽고 각 노드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1047">The following example reads an XML file and displays each of the nodes.</span></span>  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 <span data-ttu-id="58cdf-1048">이 샘플에서는 사용 된 `items.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1048">The sample uses the `items.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 <span data-ttu-id="58cdf-1049">**출력:**</span><span class="sxs-lookup"><span data-stu-id="58cdf-1049">**Output:**</span></span>  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1050">XML을 구문 분석하는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1050">An error occurred while parsing the XML.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1051">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1051">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1052">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1052">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1053">스트림에서 다음 노드를 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1053">Asynchronously reads the next node from the stream.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1054">다음 노드를 읽었으면 <see langword="true" />이고, 더 이상 읽을 노드가 없으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1054"><see langword="true" /> if the next node was read successfully; <see langword="false" /> if there are no more nodes to read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1055">비동기 버전이 <xref:System.Xml.XmlReader.Read%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1055">This is the asynchronous version of <xref:System.Xml.XmlReader.Read%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1056">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1056">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1057">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1057">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1058">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1058">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1059">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1059">-or-</span></span>

<span data-ttu-id="58cdf-1060"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1060">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1061">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1061">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1062">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1062">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1063">파생 클래스에서 재정의되면 하나 이상의 <see langword="Text" />, <see langword="EntityReference" /> 또는 <see langword="EndEntity" /> 노드로 특성 값을 구문 분석합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1063">When overridden in a derived class, parses the attribute value into one or more <see langword="Text" />, <see langword="EntityReference" />, or <see langword="EndEntity" /> nodes.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1064">반환할 노드가 있는 경우 <see langword="true" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1064"><see langword="true" /> if there are nodes to return.</span></span>  
  
 <span data-ttu-id="58cdf-1065">처음 호출할 때 판독기가 특성 노드에 있거나 모든 특성 값을 읽은 경우 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1065"><see langword="false" /> if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.</span></span>  
  
<span data-ttu-id="58cdf-1066"><c>misc=""</c>와 같은 빈 특성은 <see langword="true" />를 반환하며 이것은 단일 노드가 <see langword="String.Empty" />의 값을 갖는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1066">An empty attribute, such as, <c>misc=""</c>, returns <see langword="true" /> with a single node with a value of <see langword="String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1067">이 메서드를 사용 하 여 호출한 후 <xref:System.Xml.XmlReader.MoveToAttribute%2A> 특성 값을 구성 하는 텍스트 또는 엔터티 참조 노드를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1067">Use this method after calling <xref:System.Xml.XmlReader.MoveToAttribute%2A> to read through the text or entity reference nodes that make up the attribute value.</span></span> <span data-ttu-id="58cdf-1068"><xref:System.Xml.XmlReader.Depth%2A> 특성 값 노드 1을 더한 특성 노드의 깊이 증가 하 고 내부 및 외부로 일반 엔터티 참조를 단계별로 실행할 때 1 씩 감소 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1068">The <xref:System.Xml.XmlReader.Depth%2A> of the attribute value nodes is one plus the depth of the attribute node; it increments and decrements by one when you step into and out of general entity references.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1069">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1069">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1070">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1070">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="58cdf-1071">반환될 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1071">The type of the value to be returned.</span></span>  
  
 <span data-ttu-id="58cdf-1072">**참고** .NET Framework 3.5 릴리스에서는 <paramref name="returnType" /> 매개 변수 값이 <see cref="T:System.DateTimeOffset" /> 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1072">**Note** With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" /> parameter can now be the <see cref="T:System.DateTimeOffset" /> type.</span></span></param>
        <param name="namespaceResolver"><span data-ttu-id="58cdf-1073">형식 변환과 관련된 모든 네임스페이스 접두사를 확인하는 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1073">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> object that is used to resolve any namespace prefixes related to type conversion.</span></span> <span data-ttu-id="58cdf-1074">예를 들어, <see cref="T:System.Xml.XmlQualifiedName" /> 개체를 <c>xs:string</c>으로 변환할 때 이 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1074">For example, this can be used when converting an <see cref="T:System.Xml.XmlQualifiedName" /> object to an <c>xs:string</c>.</span></span>  
  
<span data-ttu-id="58cdf-1075">이 값은 <see langword="null" />일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1075">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="58cdf-1076">지정한 형식의 개체로 콘텐츠를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1076">Reads the content as an object of the type specified.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1077">요청된 형식으로 변환된 특성 값 또는 연결된 텍스트 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1077">The concatenated text content or attribute value converted to the requested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1078">이 메서드는 현재 판독기 위치에서 텍스트 콘텐츠를 읽고 요청된 된 반환 형식으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1078">This method reads the text content at the current reader position and converts it to the requested return type.</span></span> <span data-ttu-id="58cdf-1079">텍스트, 공백, 유효 공백 및 CDATA 섹션이 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1079">Text, white space, significant white space and CDATA sections are concatenated.</span></span> <span data-ttu-id="58cdf-1080">주석 및 처리 명령은 건너뛰고 엔터티 참조는 자동으로 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1080">Comments and processing instructions are skipped and entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1081">이 메서드를 읽고, 필요한 경우 변환 현재 노드의 값이 원자 값 항목을 콘텐츠 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1081">This method is used to read, convert if necessary, and return atomic value items from the current node content.</span></span> <span data-ttu-id="58cdf-1082">현재 노드의 값을 포함 하는 대상 형식의 인스턴스가 현재 노드의 형식에 대 한 올바른 매핑에 대해서는 입력된 형식이 면 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1082">If the input type is a valid mappings for the type of the current node then an instance of the target type containing the value of the current node is returned.</span></span> <span data-ttu-id="58cdf-1083">설명 섹션을 참조 합니다 <xref:System.Xml.XmlReader> referencepage 기본 매핑의 목록에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1083">See the Remarks section in the <xref:System.Xml.XmlReader> referencepage for a list of the default mappings.</span></span>  
  
 <span data-ttu-id="58cdf-1084">예를 들어, 다음 XML 텍스트를 설치한 경우:</span><span class="sxs-lookup"><span data-stu-id="58cdf-1084">For example, if you had the following XML text:</span></span>  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 <span data-ttu-id="58cdf-1085">데이터를 입력 하 고 문자열 배열에 제공 되는 경우는 <xref:System.Xml.XmlReader.ReadContentAs%2A> 메서드를 호출한 다음 정수 값의 유효한 CLR 형식 매핑 목록에 따라 문자열에서 변환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1085">If the data is typed and a string array is supplied to the <xref:System.Xml.XmlReader.ReadContentAs%2A> method call, then the integer values are converted from strings according to the list of valid CLR type mappings.</span></span>  
  
 <span data-ttu-id="58cdf-1086">데이터를 형식화 되지 경우 및 문자열 배열에 제공 되는 <xref:System.Xml.XmlReader.ReadContentAs%2A> 메서드 호출에 콘텐츠를 별도 문자열로 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1086">If the data is untyped and a string array is supplied to the <xref:System.Xml.XmlReader.ReadContentAs%2A> method call, then the content is parsed into separate strings.</span></span> <span data-ttu-id="58cdf-1087">두 문자열을 포함 하는 배열 값 "123" 및 "456"를 사용 하 여 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1087">An array containing two strings is returned with the values "123" and "456".</span></span> <span data-ttu-id="58cdf-1088">콘텐츠에서 공백은 유지 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1088">The spaces are not preserved from the content.</span></span>  
  
 <span data-ttu-id="58cdf-1089">형식화 되지 않은 데이터를 읽을 때 일반적 콘텐츠 제공된 된 형식에 따라 구문 분석 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1089">In general when reading untyped data the content is parsed according to the supplied type.</span></span> <span data-ttu-id="58cdf-1090">예를 들어 정수 배열에 제공 되는 <xref:System.Xml.XmlReader.ReadContentAs%2A> 메서드는 문자열은 정수의 배열로 구문 분석 한 다음 호출 {123,456}합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1090">For example, if an integer array is supplied to the <xref:System.Xml.XmlReader.ReadContentAs%2A> method call then the string is parsed into an array of integers {123,456}.</span></span>  
  
 <span data-ttu-id="58cdf-1091">다음 예제에서는 XML 텍스트에 공백으로 구분 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1091">In the following example the XML text is not separated by spaces</span></span>  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 <span data-ttu-id="58cdf-1092">콘텐츠를 형식화 되지 경우 및 문자열 배열에 제공 되는 <xref:System.Xml.XmlReader.ReadContentAs%2A> 메서드 호출 후 "123456789" 값을 사용 하 여 연결 된 문자열이 반환 됩니다 하나를 포함 하는 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1092">If the content is untyped and a string array is supplied to the <xref:System.Xml.XmlReader.ReadContentAs%2A> method call then an array containing one concatenated string is returned with the value "123456789".</span></span>  
  
 <span data-ttu-id="58cdf-1093">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1093">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1094">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1094">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1095">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1095">Return value</span></span>|<span data-ttu-id="58cdf-1096">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1096">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1097">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1097">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1098">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1098">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1099">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1099">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1100">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1100">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1101">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1101">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1102">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1102">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1103">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1103">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1104">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1104">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1105">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1105">An empty string.</span></span>|<span data-ttu-id="58cdf-1106">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1106">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1107"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1107">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1108">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1108">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1109">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1109">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1110">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1110">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1111">다음 예제에서는 <xref:System.Xml.XmlReader.ReadContentAs%2A> 문자열 개체의 배열로 색 요소의 콘텐츠를 반환 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1111">The following example uses the <xref:System.Xml.XmlReader.ReadContentAs%2A> method to return the contents of the colors element into an array of string objects.</span></span>  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 <span data-ttu-id="58cdf-1112">이 예제에서는 `dataFile_2.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1112">The example uses the `dataFile_2.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1113">콘텐츠가 대상 형식에 맞지 않는 형식인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1113">The content is not in the correct format for the target type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1114">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1114">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1115"><paramref name="returnType" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1115">The <paramref name="returnType" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1116">현재 노드가 지원되는 노드 형식이 아닌 경우.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1116">The current node is not a supported node type.</span></span> <span data-ttu-id="58cdf-1117">자세한 내용은 아래 표를 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1117">See the table below for details.</span></span>

<span data-ttu-id="58cdf-1118">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1118">-or-</span></span>

<span data-ttu-id="58cdf-1119">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1119">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1120">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1120">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="58cdf-1121"><see langword="Decimal.MaxValue" />를 읽는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1121">Read <see langword="Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="58cdf-1122">반환될 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1122">The type of the value to be returned.</span></span></param>
        <param name="namespaceResolver"><span data-ttu-id="58cdf-1123">형식 변환과 관련된 모든 네임스페이스 접두사를 확인하는 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1123">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> object that is used to resolve any namespace prefixes related to type conversion.</span></span></param>
        <summary><span data-ttu-id="58cdf-1124">지정한 형식의 개체로 콘텐츠를 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1124">Asynchronously reads the content as an object of the type specified.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1125">요청된 형식으로 변환된 특성 값 또는 연결된 텍스트 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1125">The concatenated text content or attribute value converted to the requested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1126">비동기 버전이 <xref:System.Xml.XmlReader.ReadContentAs%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1126">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadContentAs%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1127">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1127">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1128">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1128">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1129">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1129">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1130">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1130">-or-</span></span>

<span data-ttu-id="58cdf-1131"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1131">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1132">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1132">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1133">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1133">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1134">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1134">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1135">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1135">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1136">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1136">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1137">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1137">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1138">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1138">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1139">콘텐츠를 읽고 Base64 디코딩된 이진 바이트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1139">Reads the content and returns the Base64 decoded binary bytes.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1140">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1140">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1141">이 메서드는 콘텐츠를 스트리밍하는 `Base64` content 및 디코딩된 이진 바이트를 반환 합니다 (예를 들어, 인라인 `Base64` 인코딩된 GIF 이미지) 버퍼에 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1141">This method streams the content, decodes the `Base64` content, and returns the decoded binary bytes (for example, an inline `Base64` encoded GIF image) into the buffer.</span></span> <span data-ttu-id="58cdf-1142">포함 된 텍스트의 큰 스트림을 읽도록 연속적으로이 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1142">This method can be called successively to read large streams of embedded text.</span></span> <span data-ttu-id="58cdf-1143">자세한 내용은 RFC 1521을 참조 하세요. "MIME (Multipurpose Internet Mail Extensions) 파트 1:를 지정 하 고 인터넷 메시지 본문의 형식을 설명 하는 메커니즘".</span><span class="sxs-lookup"><span data-stu-id="58cdf-1143">For more information, see RFC 1521, "MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies".</span></span> <span data-ttu-id="58cdf-1144">Rfc를 구할 수는 [의견 웹 사이트에 대 한 요청](https://go.microsoft.com/fwlink/?LinkId=37119)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1144">You can obtain RFCs from the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkId=37119).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1145">에 대 한 호출 간의 판독기 속성을 액세스 하지 않아야 합니다 <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 메서드는 메서드가 값을 반환할 때까지 `0`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1145">You should not access any of the reader properties between calls to the <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> method until the method returns the value `0`.</span></span>  
  
 <span data-ttu-id="58cdf-1146">이 메서드에 다음과 같은 동작이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1146">This method has the following behavior:</span></span>  
  
-   <span data-ttu-id="58cdf-1147"><xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 값을 반환 합니다 `0` 에서 작동 하 던 바이트 스트림 끝에 도달 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1147"><xref:System.Xml.XmlReader.ReadContentAsBase64%2A> returns the value `0` when it has reached the end of the byte stream it was operating on.</span></span> <span data-ttu-id="58cdf-1148">판독기는 첫 번째 비 콘텐츠 노드에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1148">The reader is positioned on the first non-content node.</span></span>  
  
-   <span data-ttu-id="58cdf-1149">더 적은 요청 하면 남아 스트림 판독기의 현재 위치에 남아 있는 것 보다 바이트의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1149">If you ask for fewer, or the exact number of, bytes than are left in the stream the reader remains in its current position.</span></span>  
  
-   <span data-ttu-id="58cdf-1150"><xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 다음 XML 노드 형식에서 지원 되지 않습니다: `Element`, `XmlDeclaration`, `None`, `Document`를 `DocumentType`를 `Notation`, `Entity`, `DocumentFragment`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1150"><xref:System.Xml.XmlReader.ReadContentAsBase64%2A> is not supported on the following XML node types: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.</span></span>  
  
 <span data-ttu-id="58cdf-1151">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1151">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1152"><paramref name="buffer" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1152">The <paramref name="buffer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1153"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />가 현재 노드에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1153"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> is not supported on the current node.</span></span>

<span data-ttu-id="58cdf-1154">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1154">-or-</span></span>

<span data-ttu-id="58cdf-1155">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1155">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1156">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1156">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-1157">버퍼 내의 인덱스 또는 인덱스와 개수를 합한 값이 할당된 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1157">The index into the buffer or index + count is larger than the allocated buffer size.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58cdf-1158">구현된 <see cref="T:System.Xml.XmlReader" />에서 이 메서드를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1158">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1159">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1159">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1160">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1160">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1161">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1161">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1162">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1162">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1163">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1163">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1164">콘텐츠를 비동기적으로 읽고 Base64 디코딩된 이진 바이트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1164">Asynchronously reads the content and returns the Base64 decoded binary bytes.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1165">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1165">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1166">비동기 버전이 <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1166">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1167">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1167">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1168">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1168">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1169">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1169">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1170">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1170">-or-</span></span>

<span data-ttu-id="58cdf-1171"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1171">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1172">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1172">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1173">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1173">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1174">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1174">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1175">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1175">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1176">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1176">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1177">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1177">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1178">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1178">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1179">콘텐츠를 읽고 <see langword="BinHex" /> 디코딩된 이진 바이트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1179">Reads the content and returns the <see langword="BinHex" /> decoded binary bytes.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1180">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1180">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1181">이 메서드는 콘텐츠를 스트리밍하는 `BinHex` content 및 디코딩된 이진 바이트를 반환 합니다 (예를 들어, 인라인 `BinHex` 인코딩된 GIF 이미지) 버퍼에 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1181">This method streams the content, decodes the `BinHex` content, and returns the decoded binary bytes (for example, an inline `BinHex` encoded GIF image) into the buffer.</span></span> <span data-ttu-id="58cdf-1182">포함 된 텍스트의 큰 스트림을 읽도록 연속적으로이 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1182">This method can be called successively to read large streams of embedded text.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1183">에 대 한 호출 간의 판독기 속성을 액세스 하지 않아야 합니다 <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 메서드는 메서드가 값을 반환할 때까지 `0`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1183">You should not access any of the reader properties between calls to the <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> method until the method returns the value `0`.</span></span>  
  
 <span data-ttu-id="58cdf-1184">이 메서드에 다음과 같은 동작이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1184">This method has the following behavior:</span></span>  
  
-   <span data-ttu-id="58cdf-1185"><xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 값을 반환 합니다 `0` 에서 작동 하 던 바이트 스트림 끝에 도달 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1185"><xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> returns the value `0` when it has reached the end of the byte stream it was operating on.</span></span> <span data-ttu-id="58cdf-1186">판독기는 첫 번째 비 콘텐츠 노드에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1186">The reader is positioned on the first non-content node.</span></span>  
  
-   <span data-ttu-id="58cdf-1187">더 적은 묻는 경우 남아 있는 것 보다는 스트림 판독기 바이트의 정확한 수를 현재 위치에 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1187">If you ask for fewer, or the exact number, of bytes than are left in the stream the reader remains in its current position.</span></span>  
  
-   <span data-ttu-id="58cdf-1188"><xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 다음 XML 노드 형식에서 지원 되지 않습니다: `Element`, `XmlDeclaration`를 `None`, `Document`를 `DocumentType`를 `Notation, Entity`, `DocumentFragment`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1188"><xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> is not supported on the following XML node types: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.</span></span>  
  
 <span data-ttu-id="58cdf-1189">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1189">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1190"><paramref name="buffer" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1190">The <paramref name="buffer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1191"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />가 현재 노드에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1191"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> is not supported on the current node.</span></span>

<span data-ttu-id="58cdf-1192">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1192">-or-</span></span>

<span data-ttu-id="58cdf-1193">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1193">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1194">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1194">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-1195">버퍼 내의 인덱스 또는 인덱스와 개수를 합한 값이 할당된 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1195">The index into the buffer or index + count is larger than the allocated buffer size.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58cdf-1196">구현된 <see cref="T:System.Xml.XmlReader" />에서 이 메서드를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1196">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1197">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1197">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1198">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1198">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1199">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1199">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1200">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1200">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1201">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1201">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1202">콘텐츠를 비동기적으로 읽고 <see langword="BinHex" /> 디코딩된 이진 바이트를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1202">Asynchronously reads the content and returns the <see langword="BinHex" /> decoded binary bytes.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1203">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1203">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1204">비동기 버전이 <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1204">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1205">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1205">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1206">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1206">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1207">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1207">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1208">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1208">-or-</span></span>

<span data-ttu-id="58cdf-1209"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1209">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1210">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1210">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1211">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1211">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1212">현재 위치의 텍스트 콘텐츠를 <see langword="Boolean" />으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1212">Reads the text content at the current position as a <see langword="Boolean" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1213">텍스트 콘텐츠에 해당하는 <see cref="T:System.Boolean" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1213">The text content as a <see cref="T:System.Boolean" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1214">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1214">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1215">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1215">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1216">콘텐츠 형식이 면 `xsd:boolean`, 판독기는 unboxed 반환 <xref:System.Boolean> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1216">If the content is typed `xsd:boolean`, the reader returns an unboxed <xref:System.Boolean> object.</span></span> <span data-ttu-id="58cdf-1217">콘텐츠 형식화 되지 않은 경우 `xsd:boolean`, 판독기를 변환 하려고 시도 <xref:System.Boolean> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1217">If the content is not typed `xsd:boolean`, the reader attempts to convert it to a <xref:System.Boolean> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1218">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1218">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1219">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1219">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1220">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1220">Return value</span></span>|<span data-ttu-id="58cdf-1221">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1221">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1222">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1222">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1223">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1223">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1224">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1224">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1225">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1225">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1226">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1226">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1227">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1227">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1228">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1228">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1229">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1229">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1230">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1230">An empty string.</span></span>|<span data-ttu-id="58cdf-1231">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1231">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1232"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1232">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1233">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1233">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1234">자세한 내용은 참조는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1234">For more information, see the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1235">다음 예제에서는 합니다 <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> 메서드를 B로 특성을 읽을 수`oolean` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1235">The following example uses the <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> method to read the attribute as a B`oolean` value.</span></span>  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 <span data-ttu-id="58cdf-1236">이 예제에서는 `dataFile_2.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1236">The example uses the `dataFile_2.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1237">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1237">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1238">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1238">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1239">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1239">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1240">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1240">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1241">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.DateTime" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1241">Reads the text content at the current position as a <see cref="T:System.DateTime" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1242">텍스트 콘텐츠에 해당하는 <see cref="T:System.DateTime" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1242">The text content as a <see cref="T:System.DateTime" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1243">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1243">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1244">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1244">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1245">콘텐츠 형식이 면 `xsd:dateTime`, 판독기는 unboxed 반환 <xref:System.DateTime> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1245">If the content is typed `xsd:dateTime`, the reader returns an unboxed <xref:System.DateTime> object.</span></span> <span data-ttu-id="58cdf-1246">콘텐츠 형식화 되지 않은 경우 `xsd:dateTime`, 판독기를 변환 하려고 시도 <xref:System.DateTime> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1246">If the content is not typed `xsd:dateTime`, the reader attempts to convert it to a <xref:System.DateTime> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1247">내용 형식이 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>로 지정된 경우 `xsd:gMonthDay` 값을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1247">You cannot rely on the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value when the content is typed as `xsd:gMonthDay`.</span></span> <span data-ttu-id="58cdf-1248"><xref:System.Xml.XmlReader> 항상 설정 된 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 1904로이 예에서 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1248"><xref:System.Xml.XmlReader> always sets the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value to 1904 in this case.</span></span>  
  
 <span data-ttu-id="58cdf-1249">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1249">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1250">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1250">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1251">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1251">Return value</span></span>|<span data-ttu-id="58cdf-1252">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1252">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1253">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1253">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1254">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1254">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1255">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1255">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1256">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1256">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1257">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1257">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1258">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1258">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1259">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1259">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1260">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1260">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1261">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1261">An empty string.</span></span>|<span data-ttu-id="58cdf-1262">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1262">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1263"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1263">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1264">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1264">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1265">자세한 내용은 참조는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1265">For more information, see the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1266">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1266">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1267">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1267">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1268">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1268">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1269">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1269">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1270">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.DateTimeOffset" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1270">Reads the text content at the current position as a <see cref="T:System.DateTimeOffset" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1271">텍스트 콘텐츠에 해당하는 <see cref="T:System.DateTimeOffset" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1271">The text content as a <see cref="T:System.DateTimeOffset" /> object.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1272">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1272">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1273">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1273">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1274">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.Decimal" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1274">Reads the text content at the current position as a <see cref="T:System.Decimal" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1275">현재 위치의 텍스트 콘텐츠에 해당하는 <see cref="T:System.Decimal" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1275">The text content at the current position as a <see cref="T:System.Decimal" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1276">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1276">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1277">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1277">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1278">콘텐츠 형식이 면 `xsd:decimal`, 판독기는 unboxed 반환 <xref:System.Decimal> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1278">If the content is typed `xsd:decimal`, the reader returns an unboxed <xref:System.Decimal> object.</span></span> <span data-ttu-id="58cdf-1279">콘텐츠 형식화 되지 않은 경우 `xsd:decimal`, 판독기를 변환 하려고 시도 <xref:System.Decimal> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1279">If the content is not typed `xsd:decimal`, the reader attempts to convert it to a <xref:System.Decimal> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1280">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1280">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1281">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1281">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1282">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1282">Return value</span></span>|<span data-ttu-id="58cdf-1283">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1283">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1284">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1284">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1285">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1285">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1286">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1286">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1287">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1287">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1288">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1288">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1289">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1289">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1290">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1290">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1291">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1291">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1292">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1292">An empty string.</span></span>|<span data-ttu-id="58cdf-1293">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1293">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1294"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1294">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1295">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1295">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1296">자세한 내용은 참조는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1296">For more information, see the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1297">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1297">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1298">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1298">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1299">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1299">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1300">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1300">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1301">현재 위치의 텍스트 콘텐츠를 배정밀도 부동 소수점 숫자로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1301">Reads the text content at the current position as a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1302">텍스트 콘텐츠에 해당하는 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1302">The text content as a double-precision floating-point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1303">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1303">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1304">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1304">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1305">콘텐츠 형식이 경우 `xsd:double`, 판독기를 배정밀도 부동 소수점 숫자로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1305">If the content is typed `xsd:double`, the reader returns a double-precision floating-point number.</span></span> <span data-ttu-id="58cdf-1306">콘텐츠 형식화 되지 않은 경우 `xsd:double`, 판독기가 정의 된 규칙에 따라 배정밀도 부동 소수점 숫자로 변환 하려고 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1306">If the content is not typed `xsd:double`, the reader attempts to convert it to a double-precision floating-point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1307">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1307">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1308">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1308">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1309">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1309">Return value</span></span>|<span data-ttu-id="58cdf-1310">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1310">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1311">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1311">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1312">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1312">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1313">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1313">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1314">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1314">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1315">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1315">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1316">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1316">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1317">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1317">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1318">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1318">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1319">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1319">An empty string.</span></span>|<span data-ttu-id="58cdf-1320">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1320">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1321"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1321">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1322">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1322">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1323">자세한 내용은 참조는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1323">For more information, see the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1324">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1324">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1325">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1325">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1326">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1326">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1327">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1327">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1328">현재 위치의 텍스트 콘텐츠를 단정밀도 부동 소수점 숫자로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1328">Reads the text content at the current position as a single-precision floating point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1329">현재 위치의 텍스트 콘텐츠에 해당하는 단정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1329">The text content at the current position as a single-precision floating point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1330">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1330">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1331">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1331">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1332">콘텐츠 형식이 경우 `xsd:float`, 판독기는 unboxed 반환 단 정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1332">If the content is typed `xsd:float`, the reader returns an unboxed a single-precision floating point number.</span></span> <span data-ttu-id="58cdf-1333">콘텐츠 형식화 되지 않은 경우 `xsd:float`, 판독기를 정의한 규칙에 따라 단 정밀도 부동 소수점 숫자로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1333">If the content is not typed `xsd:float`, the reader attempts to convert it to a single-precision floating point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1334">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1334">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1335">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1335">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1336">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1336">Return value</span></span>|<span data-ttu-id="58cdf-1337">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1337">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1338">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1338">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1339">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1339">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1340">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1340">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1341">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1341">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1342">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1342">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1343">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1343">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1344">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1344">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1345">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1345">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1346">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1346">An empty string.</span></span>|<span data-ttu-id="58cdf-1347">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1347">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1348"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1348">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1349">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1349">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1350">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1350">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1351">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1351">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1352">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1352">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1353">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1353">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1354">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1354">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1355">현재 위치의 텍스트 콘텐츠를 부호 있는 32비트 정수로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1355">Reads the text content at the current position as a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1356">텍스트 콘텐츠에 해당하는 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1356">The text content as a 32-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1357">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1357">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1358">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1358">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1359">콘텐츠 형식이 경우 `xsd:integer`, 판독기 unboxed 32 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1359">If the content is typed `xsd:integer`, the reader returns an unboxed 32-bit signed integer.</span></span> <span data-ttu-id="58cdf-1360">콘텐츠 형식화 되지 않은 경우 `xsd:integer`, 판독기에서 정의 된 규칙에 따라 32 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1360">If the content is not typed `xsd:integer`, the reader attempts to convert it to a 32-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1361">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1361">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1362">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1362">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1363">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1363">Return value</span></span>|<span data-ttu-id="58cdf-1364">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1364">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1365">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1365">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1366">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1366">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1367">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1367">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1368">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1368">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1369">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1369">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1370">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1370">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1371">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1371">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1372">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1372">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1373">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1373">An empty string.</span></span>|<span data-ttu-id="58cdf-1374">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1374">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1375"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1375">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1376">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1376">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1377">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1377">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1378">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1378">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1379">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1379">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1380">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1380">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1381">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1381">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1382">현재 위치의 텍스트 콘텐츠를 부호 있는 64비트 정수로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1382">Reads the text content at the current position as a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1383">텍스트 콘텐츠에 해당하는 부호 있는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1383">The text content as a 64-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1384">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1384">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1385">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1385">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1386">콘텐츠 형식이 경우 `xsd:long`, 판독기 unboxed 64 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1386">If the content is typed `xsd:long`, the reader returns an unboxed 64-bit signed integer.</span></span> <span data-ttu-id="58cdf-1387">콘텐츠 형식화 되지 않은 경우 `xsd:long`, 판독기에서 정의 된 규칙에 따라 64 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1387">If the content is not typed `xsd:long`, the reader attempts to convert it to a 64-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1388">다음 표에서이 메서드는 각 노드 형식을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1388">The following table describes this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1389">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1389">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1390">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1390">Return value</span></span>|<span data-ttu-id="58cdf-1391">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1391">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1392">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1392">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1393">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1393">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1394">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1394">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1395">동일 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1395">Same as `XmlConvert.ToXxx` on attribute value.</span></span>|<span data-ttu-id="58cdf-1396">판독기의 현재 위치를 유지</span><span class="sxs-lookup"><span data-stu-id="58cdf-1396">The reader remains in the current position</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1397">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1397">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1398">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1398">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1399">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1399">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1400">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1400">An empty string.</span></span>|<span data-ttu-id="58cdf-1401">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1401">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1402"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1402">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1403">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1403">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1404">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1404">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1405">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1405">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1406">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1406">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1407">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1407">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1408">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1408">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1409">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.Object" />로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1409">Reads the text content at the current position as an <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1410">텍스트 콘텐츠에 해당하는 가장 적합한 CLR(공용 언어 런타임) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1410">The text content as the most appropriate common language runtime (CLR) object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1411">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1411">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1412">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1412">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1413">판독기를 지정 하는 가장 적합 한 형식의 boxed CLR을 반환 콘텐츠를 입력 합니다 <xref:System.Xml.XmlReader.ValueType%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1413">If the content is typed, the reader returns a boxed CLR of the most appropriate type, specified by the <xref:System.Xml.XmlReader.ValueType%2A> property.</span></span> <span data-ttu-id="58cdf-1414">콘텐츠 목록 형식이 면 판독기는 적절 한 형식의 boxed 개체의 배열을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1414">If the content is a list type, the reader returns an array of boxed objects of the appropriate type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1415">콘텐츠를 구문 분석 하는 동안 유효성 검사 오류가 발생 하 고 판독기가 하는 경우는 <xref:System.Xml.XmlReader> 하 여 만든 개체는 <xref:System.Xml.XmlReader.Create%2A> 메서드, 판독기 문자열로 콘텐츠를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1415">If a validation error occurs while parsing the content and the reader is an <xref:System.Xml.XmlReader> object created by the <xref:System.Xml.XmlReader.Create%2A> method, the reader returns the content as a string.</span></span> <span data-ttu-id="58cdf-1416">즉 유효성 검사 오류나 경고가 발생할 때 콘텐츠 비율은 형식화 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1416">In other words when a validation error or warning occurs, the content is considered to be untyped.</span></span>  
  
 <span data-ttu-id="58cdf-1417">형식화되지 않은 내용의 경우 판독기가 해당 내용을 문자열로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1417">If the content is not typed, the reader returns the content as a string.</span></span>  
  
 <span data-ttu-id="58cdf-1418">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1418">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1419">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1419">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1420">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1420">Return value</span></span>|<span data-ttu-id="58cdf-1421">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1421">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1422">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1422">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1423">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1423">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1424">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1424">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1425">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1425">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1426">판독기의 현재 위치를 유지</span><span class="sxs-lookup"><span data-stu-id="58cdf-1426">The reader remains in the current position</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1427">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1427">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1428">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1428">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1429">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1429">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1430">판독기는 스키마 유효성 검사 판독기가 있으면 요소 값 (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 로 설정 된 <xref:System.Xml.ValidationType.Schema>)이 고 그렇지 않으면 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1430">The value of the element if the reader is a schema validating reader (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> is set to <xref:System.Xml.ValidationType.Schema>); otherwise an empty string.</span></span>|<span data-ttu-id="58cdf-1431">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1431">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1432"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1432">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1433">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1433">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1434">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1434">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1435">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1435">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1436">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1436">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1437">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1437">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1438">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1438">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1439">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1439">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1440">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.Object" />로 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1440">Asynchronously reads the text content at the current position as an <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1441">텍스트 콘텐츠에 해당하는 가장 적합한 CLR(공용 언어 런타임) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1441">The text content as the most appropriate common language runtime (CLR) object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1442">비동기 버전이 <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1442">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1443">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1443">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1444">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1444">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1445">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1445">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1446">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1446">-or-</span></span>

<span data-ttu-id="58cdf-1447"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1447">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1448">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1448">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1449">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1449">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1450">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.String" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1450">Reads the text content at the current position as a <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1451">텍스트 콘텐츠에 해당하는 <see cref="T:System.String" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1451">The text content as a <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1452">이 메서드는 텍스트, 공백, 유효 공백 및 CDATA 섹션에 연결 하 고 의견이 나 처리 명령을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1452">This method concatenates text, white space, significant white space, and CDATA sections, and skips any comments or processing instructions.</span></span> <span data-ttu-id="58cdf-1453">엔터티 참조가 자동으로 해결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1453">Entity references are automatically resolved.</span></span>  
  
 <span data-ttu-id="58cdf-1454">이 메서드를 사용할 수를 문자열로 또는 주석을 건너뛰고 처리 명령 하는 동안 텍스트 콘텐츠를 읽기 위해 형식화 된 값을 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1454">This method can be used convert typed values to a string, or to read the text content while skipping comments and processing instructions.</span></span>  
  
 <span data-ttu-id="58cdf-1455">다음 표에이 메서드가 각 노드 형식을 처리 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1455">The following table describes how this method treats each node type.</span></span>  
  
|<span data-ttu-id="58cdf-1456">XmlNodeType</span><span class="sxs-lookup"><span data-stu-id="58cdf-1456">XmlNodeType</span></span>|<span data-ttu-id="58cdf-1457">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-1457">Return value</span></span>|<span data-ttu-id="58cdf-1458">판독기 동작</span><span class="sxs-lookup"><span data-stu-id="58cdf-1458">Reader behavior</span></span>|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|<span data-ttu-id="58cdf-1459">요청한 형식으로 변환된 텍스트, CDATA, 공백 및 유효 공백 노드가 연결된 내용</span><span class="sxs-lookup"><span data-stu-id="58cdf-1459">Concatenated content of text, CDATA, white space and significant white space nodes converted to the requested type.</span></span>|<span data-ttu-id="58cdf-1460">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1460">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1461">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1461">Entity references are automatically expanded.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-1462">호출할 때와 동일한 `XmlConvert.ToXxx` 특성 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1462">Same as calling `XmlConvert.ToXxx` on the attribute value.</span></span>|<span data-ttu-id="58cdf-1463">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1463">The reader remains in the current position.</span></span>|  
|`Comment`<br /><br /> `ProcessingInstruction`|<span data-ttu-id="58cdf-1464">PI(처리 명령) 또는 주석을 무시하고 PI 또는 주석 다음에 연결된 텍스트 내용을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1464">Ignores the processing instruction (PI) or comment and reads the concatenated text content that follows the PI or comment.</span></span>|<span data-ttu-id="58cdf-1465">다음 시작 요소 또는 끝 요소 태그로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1465">Moves to the next start element or end element tag.</span></span> <span data-ttu-id="58cdf-1466">엔터티 참조가 자동으로 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1466">Entity references are automatically expanded.</span></span>|  
|`EndElement`|<span data-ttu-id="58cdf-1467">빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1467">An empty string.</span></span>|<span data-ttu-id="58cdf-1468">판독기는 현재 위치를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1468">The reader remains in the current position.</span></span>|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<span data-ttu-id="58cdf-1469"><xref:System.InvalidOperationException>이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1469">An <xref:System.InvalidOperationException> is thrown.</span></span>|<span data-ttu-id="58cdf-1470">일반적으로 판독기가 현재 위치를 유지하지만 정의되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1470">Undefined, although typically the reader remains in the current position.</span></span>|  
  
 <span data-ttu-id="58cdf-1471">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1471">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1472">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1472">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="58cdf-1473">시도된 캐스팅이 잘못된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1473">The attempted cast is not valid.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1474">문자열 형식이 올바르지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1474">The string format is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1475">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1475">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1476">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1476">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1477">현재 위치의 텍스트 콘텐츠를 <see cref="T:System.String" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1477">Asynchronously reads the text content at the current position as a <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1478">텍스트 콘텐츠에 해당하는 <see cref="T:System.String" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1478">The text content as a <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1479">비동기 버전이 <xref:System.Xml.XmlReader.ReadContentAsString%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1479">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadContentAsString%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1480">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1480">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1481">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1481">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1482">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1482">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1483">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1483">-or-</span></span>

<span data-ttu-id="58cdf-1484"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1484">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1485">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1485">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1486">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1486">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1487">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1487">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1488">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1488">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1489">현재 요소를 읽고 콘텐츠를 지정된 형식의 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1489">Reads the current element and returns the contents as an object of the type specified.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="58cdf-1490">반환될 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1490">The type of the value to be returned.</span></span>  
  
 <span data-ttu-id="58cdf-1491">**참고** .NET Framework 3.5 릴리스에서는 <paramref name="returnType" /> 매개 변수 값이 <see cref="T:System.DateTimeOffset" /> 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1491">**Note** With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" /> parameter can now be the <see cref="T:System.DateTimeOffset" /> type.</span></span></param>
        <param name="namespaceResolver"><span data-ttu-id="58cdf-1492">형식 변환과 관련된 모든 네임스페이스 접두사를 확인하는 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1492">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> object that is used to resolve any namespace prefixes related to type conversion.</span></span></param>
        <summary><span data-ttu-id="58cdf-1493">요소 콘텐츠를 요청된 형식으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1493">Reads the element content as the requested type.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1494">요청된 형식의 개체로 변환된 요소 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1494">The element content converted to the requested typed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1495">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1495">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1496">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1496">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1497">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1497">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1498">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1498">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1499">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1499">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1500">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1500">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1501">다음 예제에서는 합니다 <xref:System.Xml.XmlReader.ReadElementContentAs%2A> 의 콘텐츠를 읽기 위해 메서드를 `date` 노드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1501">The following example uses the <xref:System.Xml.XmlReader.ReadElementContentAs%2A> method to read the content of the `date` node.</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 <span data-ttu-id="58cdf-1502">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1502">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1503"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1503">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1504">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1504">-or-</span></span>

<span data-ttu-id="58cdf-1505">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1505">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1506">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1506">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1507">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1507">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1508">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1508">-or-</span></span> 
<span data-ttu-id="58cdf-1509">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1509">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1510">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1510">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="58cdf-1511"><see langword="Decimal.MaxValue" />를 읽는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1511">Read <see langword="Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="58cdf-1512">반환될 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1512">The type of the value to be returned.</span></span>  
  
 <span data-ttu-id="58cdf-1513">**참고** .NET Framework 3.5 릴리스에서는 <paramref name="returnType" /> 매개 변수 값이 <see cref="T:System.DateTimeOffset" /> 형식이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1513">**Note** With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" /> parameter can now be the <see cref="T:System.DateTimeOffset" /> type.</span></span></param>
        <param name="namespaceResolver"><span data-ttu-id="58cdf-1514">형식 변환과 관련된 모든 네임스페이스 접두사를 확인하는 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1514">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> object that is used to resolve any namespace prefixes related to type conversion.</span></span></param>
        <param name="localName"><span data-ttu-id="58cdf-1515">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1515">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1516">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1516">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1517">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 요소 콘텐츠를 요청된 형식으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1517">Checks that the specified local name and namespace URI matches that of the current element, then reads the element content as the requested type.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1518">요청된 형식의 개체로 변환된 요소 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1518">The element content converted to the requested typed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1519">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1519">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1520">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1520">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1521">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1521">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1522">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1522">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1523">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1523">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1524"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1524">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1525">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1525">-or-</span></span>

<span data-ttu-id="58cdf-1526">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1526">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1527">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1527">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1528">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1528">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1529">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1529">-or-</span></span> 
<span data-ttu-id="58cdf-1530">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1530">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1531">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1531">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1532">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1532">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="58cdf-1533"><see langword="Decimal.MaxValue" />를 읽는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1533">Read <see langword="Decimal.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType"><span data-ttu-id="58cdf-1534">반환될 값의 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1534">The type of the value to be returned.</span></span></param>
        <param name="namespaceResolver"><span data-ttu-id="58cdf-1535">형식 변환과 관련된 모든 네임스페이스 접두사를 확인하는 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1535">An <see cref="T:System.Xml.IXmlNamespaceResolver" /> object that is used to resolve any namespace prefixes related to type conversion.</span></span></param>
        <summary><span data-ttu-id="58cdf-1536">요소 콘텐츠를 요청된 형식으로 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1536">Asynchronously reads the element content as the requested type.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1537">요청된 형식의 개체로 변환된 요소 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1537">The element content converted to the requested typed object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1538">비동기 버전이 <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1538">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1539">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1539">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1540">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1540">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1541">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1541">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>
<span data-ttu-id="58cdf-1542">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1542">-or-</span></span>

<span data-ttu-id="58cdf-1543"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1543">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1544">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1544">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1545">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1545">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1546">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1546">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1547">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1547">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1548">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1548">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1549">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1549">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1550">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1550">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1551">요소를 읽고 <see langword="Base64" /> 콘텐츠를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1551">Reads the element and decodes the <see langword="Base64" /> content.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1552">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1552">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1553">이 메서드는 요소 내용을 읽고, 사용 하 여 디코딩 `Base64` 인코딩 및 디코딩된 이진 바이트를 반환 합니다 (예를 들어, 인라인 `Base64`-인코딩된 GIF 이미지) 버퍼에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1553">This method reads the element content, decodes it using `Base64` encoding, and returns the decoded binary bytes (for example, an inline `Base64`-encoded GIF image) into the buffer.</span></span> <span data-ttu-id="58cdf-1554">자세한 내용은 RFC 1521을 참조 하세요. "MIME (Multipurpose Internet Mail Extensions) 파트 1:를 지정 하 고 인터넷 메시지 본문의 형식을 설명 하는 메커니즘".</span><span class="sxs-lookup"><span data-stu-id="58cdf-1554">For more information, see RFC 1521, "MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies".</span></span> <span data-ttu-id="58cdf-1555">Rfc를 구할 수는 [의견 웹 사이트에 대 한 요청](https://go.microsoft.com/fwlink/?LinkId=37119)합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1555">You can obtain RFCs from the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkId=37119).</span></span>  
  
 <span data-ttu-id="58cdf-1556"><xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> 단순 콘텐츠 요소 읽을 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1556"><xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> can only read simple-content elements.</span></span> <span data-ttu-id="58cdf-1557">요소는 텍스트, 공백, 유효 공백 문자를 CDATA 섹션, 주석과 처리 명령을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1557">The element can contain text, white space, significant white space, CDATA sections, comments and processing instructions.</span></span> <span data-ttu-id="58cdf-1558">이 자동으로 확장 하는 엔터티 참조를 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1558">It can also contain entity references, which are automatically expanded.</span></span> <span data-ttu-id="58cdf-1559">요소는 자식 요소를 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1559">The element cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1560">이 메서드는 매우 비슷합니다는 <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> 한다는 점을 제외 하면 메서드는 요소 노드 형식에만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1560">This method is very similar to the <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> method except that it can only be called on element node types.</span></span>  
  
 <span data-ttu-id="58cdf-1561">경우는 `count` 문서에서 바이트의 수보다 큰 값은 문서에서 바이트의 수와 동일한 경우 또는 <xref:System.Xml.XmlReader> 문서의 나머지 모든 바이트를 읽고 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1561">If the `count` value is higher than the number of bytes in the document, or if it is equal to the number of bytes in the document, the <xref:System.Xml.XmlReader> reads all the remaining bytes in the document and returns the number of bytes read.</span></span> <span data-ttu-id="58cdf-1562">다음 <xref:System.Xml.XmlReader> 메서드 호출 0을 반환 하 고 판독기를 노드 다음의 `EndElement`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1562">The next <xref:System.Xml.XmlReader> method call returns a zero and moves the reader to the node following the `EndElement`.</span></span>  
  
 <span data-ttu-id="58cdf-1563">호출 하는 경우 <xref:System.Xml.XmlReader.Read%2A> 요소 내용을 모두 사용 하기 전에 판독기 겉으로 사용 된 첫 번째 콘텐츠 차례로 <xref:System.Xml.XmlReader.Read%2A> 메서드를 호출한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1563">If you call <xref:System.Xml.XmlReader.Read%2A> before all of the element content is consumed, the reader may behave as if the first content was consumed and then the <xref:System.Xml.XmlReader.Read%2A> method was called.</span></span> <span data-ttu-id="58cdf-1564">이 판독기가 끝 요소가 발견 될 때까지 모든 텍스트를 읽는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1564">This means that the reader will read all the text until the end element is encountered.</span></span> <span data-ttu-id="58cdf-1565">그런 다음 끝 태그 노드 읽기, 다음 노드를 읽을 하 고 노드로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1565">It will then read the end tag node, read the next node, and then position itself on the next subsequent node.</span></span>  
  
 <span data-ttu-id="58cdf-1566">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1566">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1567">다음 예제에서는 인라인 `Base64` 인코딩된 이미지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1567">The following example reads an inline `Base64` encoded image.</span></span> <span data-ttu-id="58cdf-1568">`Base64` 내에 포함 된 데이터는 `<image>` 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1568">The `Base64` data is embedded within the `<image>` element.</span></span> <span data-ttu-id="58cdf-1569"><xref:System.IO.BinaryWriter> 새 이진 데이터 파일을 만드는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1569">A <xref:System.IO.BinaryWriter> is used to create a new binary data file.</span></span>  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1570"><paramref name="buffer" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1570">The <paramref name="buffer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1571">현재 노드가 요소 노드가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1571">The current node is not an element node.</span></span>

<span data-ttu-id="58cdf-1572">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1572">-or-</span></span>

<span data-ttu-id="58cdf-1573">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1573">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1574">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1574">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-1575">버퍼 내의 인덱스 또는 인덱스와 개수를 합한 값이 할당된 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1575">The index into the buffer or index + count is larger than the allocated buffer size.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58cdf-1576">구현된 <see cref="T:System.Xml.XmlReader" />에서 이 메서드를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1576">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1577">요소가 혼합 콘텐츠를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1577">The element contains mixed-content.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1578">요소를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1578">The content cannot be converted to the requested type.</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1579">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1579">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1580">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1580">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1581">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1581">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1582">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1582">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1583">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1583">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1584">요소를 비동기적으로 읽고 <see langword="Base64" /> 콘텐츠를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1584">Asynchronously reads the element and decodes the <see langword="Base64" /> content.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1585">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1585">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1586">비동기 버전이 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1586">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1587">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1587">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1588">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1588">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1589">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1589">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1590">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1590">-or-</span></span>

<span data-ttu-id="58cdf-1591"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1591">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1592">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1592">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1593">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1593">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1594">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1594">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1595">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1595">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1596">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1596">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1597">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1597">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1598">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1598">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1599">요소를 읽고 <see langword="BinHex" /> 콘텐츠를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1599">Reads the element and decodes the <see langword="BinHex" /> content.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1600">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1600">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1601">이 메서드는 요소 내용을 읽고, 사용 하 여 디코딩 `BinHex` 인코딩 및 디코딩된 이진 바이트를 반환 합니다 (예를 들어, 인라인 `BinHex`-인코딩된 GIF 이미지) 버퍼에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1601">This method reads the element content, decodes it using `BinHex` encoding, and returns the decoded binary bytes (for example, an inline `BinHex`-encoded GIF image) into the buffer.</span></span>  
  
 <span data-ttu-id="58cdf-1602">이 메서드는 단순 콘텐츠 요소를 읽을 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1602">This method can only read simple-content elements.</span></span> <span data-ttu-id="58cdf-1603">요소는 텍스트, 공백, 유효 공백 문자를 CDATA 섹션, 주석과 처리 명령을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1603">The element can contain text, white space, significant white space, CDATA sections, comments and processing instructions.</span></span> <span data-ttu-id="58cdf-1604">이 자동으로 확장 하는 엔터티 참조를 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1604">It can also contain entity references, which are automatically expanded.</span></span> <span data-ttu-id="58cdf-1605">요소는 자식 요소를 가질 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1605">The element cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1606">이 메서드는 매우 비슷합니다는 <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> 한다는 점을 제외 하면 메서드는 요소 노드 형식에만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1606">This method is very similar to the <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> method except that it can only be called on element node types.</span></span>  
  
 <span data-ttu-id="58cdf-1607">경우는 `count` 문서에서 바이트의 수보다 큰 값은 문서에서 바이트의 수와 동일한 경우 또는 <xref:System.Xml.XmlReader> 문서의 나머지 모든 바이트를 읽고 읽은 바이트 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1607">If the `count` value is higher than the number of bytes in the document, or if it is equal to the number of bytes in the document, the <xref:System.Xml.XmlReader> reads all the remaining bytes in the document and returns the number of bytes read.</span></span> <span data-ttu-id="58cdf-1608">다음 <xref:System.Xml.XmlReader> 메서드 호출 0을 반환 하 고 판독기를 노드 다음의 `EndElement`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1608">The next <xref:System.Xml.XmlReader> method call returns a zero and moves the reader to the node following the `EndElement`.</span></span>  
  
 <span data-ttu-id="58cdf-1609">호출 하는 경우 <xref:System.Xml.XmlReader.Read%2A> 요소 내용을 모두 사용 하기 전에 판독기 겉으로 사용 된 첫 번째 콘텐츠 차례로 <xref:System.Xml.XmlReader.Read%2A> 메서드를 호출한 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1609">If you call <xref:System.Xml.XmlReader.Read%2A> before all of the element content is consumed, the reader may behave as if the first content was consumed and then the <xref:System.Xml.XmlReader.Read%2A> method was called.</span></span> <span data-ttu-id="58cdf-1610">이 판독기가 끝 요소가 발견 될 때까지 모든 텍스트를 읽는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1610">This means that the reader will read all the text until the end element is encountered.</span></span> <span data-ttu-id="58cdf-1611">그런 다음 끝 태그 노드 읽기, 다음 노드를 읽을 하 고 노드로 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1611">It will then read the end tag node, read the next node, and then position itself on the next subsequent node.</span></span>  
  
 <span data-ttu-id="58cdf-1612">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1612">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1613">다음 예제에서는 인라인 `BinHex` 인코딩된 이미지입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1613">The following example reads an inline `BinHex` encoded image.</span></span> <span data-ttu-id="58cdf-1614">`BinHex` 내에 포함 된 데이터는 `<image>` 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1614">The `BinHex` data is embedded within the `<image>` element.</span></span> <span data-ttu-id="58cdf-1615"><xref:System.IO.BinaryWriter> 새 이진 데이터 파일을 만드는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1615">A <xref:System.IO.BinaryWriter> is used to create a new binary data file.</span></span>  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1616"><paramref name="buffer" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1616">The <paramref name="buffer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1617">현재 노드가 요소 노드가 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1617">The current node is not an element node.</span></span>

<span data-ttu-id="58cdf-1618">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1618">-or-</span></span>

<span data-ttu-id="58cdf-1619">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1619">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1620">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1620">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-1621">버퍼 내의 인덱스 또는 인덱스와 개수를 합한 값이 할당된 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1621">The index into the buffer or index + count is larger than the allocated buffer size.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58cdf-1622">구현된 <see cref="T:System.Xml.XmlReader" />에서 이 메서드를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1622">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1623">요소가 혼합 콘텐츠를 포함하는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1623">The element contains mixed-content.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="58cdf-1624">요소를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1624">The content cannot be converted to the requested type.</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-1625">결과 텍스트를 복사해 넣을 버퍼입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1625">The buffer into which to copy the resulting text.</span></span> <span data-ttu-id="58cdf-1626">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1626">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-1627">버퍼에 넣을 결과 복사가 시작되는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1627">The offset into the buffer where to start copying the result.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-1628">버퍼에 복사할 최대 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1628">The maximum number of bytes to copy into the buffer.</span></span> <span data-ttu-id="58cdf-1629">복사된 실제 바이트 수가 이 메서드에서 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1629">The actual number of bytes copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-1630">요소를 비동기적으로 읽고 <see langword="BinHex" /> 콘텐츠를 디코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1630">Asynchronously reads the element and decodes the <see langword="BinHex" /> content.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1631">버퍼에 쓴 바이트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1631">The number of bytes written to the buffer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1632">비동기 버전이 <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1632">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1633">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1633">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1634">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1634">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1635">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1635">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1636">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1636">-or-</span></span>

<span data-ttu-id="58cdf-1637"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1637">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1638">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1638">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1639">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1639">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1640">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1640">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1641">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1641">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1642">현재 요소 값을 <see cref="T:System.Boolean" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1642">Reads the current element value as a <see cref="T:System.Boolean" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1643">현재 요소를 읽고 콘텐츠를 <see cref="T:System.Boolean" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1643">Reads the current element and returns the contents as a <see cref="T:System.Boolean" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1644">요소 콘텐츠에 해당하는 <see cref="T:System.Boolean" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1644">The element content as a <see cref="T:System.Boolean" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1645">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1645">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1646">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1646">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1647">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1647">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1648">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1648">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1649">요소 콘텐츠를 입력 하는 경우 `xsd:boolean`, 판독기는 unboxed 반환 <xref:System.Boolean> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1649">If the element content is typed `xsd:boolean`, the reader returns an unboxed <xref:System.Boolean> object.</span></span> <span data-ttu-id="58cdf-1650">콘텐츠 형식화 되지 않은 경우 `xsd:boolean`, 판독기를 변환 하려고 시도 <xref:System.Boolean> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1650">If the content is not typed `xsd:boolean`, the reader attempts to convert it to a <xref:System.Boolean> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1651">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1651">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1652"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1652">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1653">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1653">-or-</span></span>

<span data-ttu-id="58cdf-1654">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1654">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1655">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1655">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1656">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1656">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1657">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1657">-or-</span></span> 
<span data-ttu-id="58cdf-1658">요소 콘텐츠를 <see cref="T:System.Boolean" /> 개체로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1658">The element content cannot be converted to a <see cref="T:System.Boolean" /> object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1659">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1659">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1660">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1660">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1661">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1661">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1662">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 <see cref="T:System.Boolean" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1662">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Boolean" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1663">요소 콘텐츠에 해당하는 <see cref="T:System.Boolean" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1663">The element content as a <see cref="T:System.Boolean" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1664">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1664">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1665">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1665">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1666">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1666">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1667">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1667">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1668">콘텐츠 형식이 면 `xsd:boolean`, 판독기는 unboxed 반환 <xref:System.Boolean> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1668">If the content is typed `xsd:boolean`, the reader returns an unboxed <xref:System.Boolean> object.</span></span> <span data-ttu-id="58cdf-1669">콘텐츠 형식화 되지 않은 경우 `xsd:boolean`, 판독기를 변환 하려고 시도 <xref:System.Boolean> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1669">If the content is not typed `xsd:boolean`, the reader attempts to convert it to a <xref:System.Boolean> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1670">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1670">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1671"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1671">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1672">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1672">-or-</span></span>

<span data-ttu-id="58cdf-1673">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1673">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1674">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1674">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1675">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1675">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1676">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1676">-or-</span></span> 
<span data-ttu-id="58cdf-1677">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1677">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1678">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1678">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1679">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1679">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1680">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1680">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1681">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1681">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1682">현재 요소를 읽고 콘텐츠를 <see cref="T:System.DateTime" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1682">Reads the current element and returns the contents as a <see cref="T:System.DateTime" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1683">현재 요소를 읽고 콘텐츠를 <see cref="T:System.DateTime" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1683">Reads the current element and returns the contents as a <see cref="T:System.DateTime" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1684">요소 콘텐츠에 해당하는 <see cref="T:System.DateTime" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1684">The element content as a <see cref="T:System.DateTime" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1685">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1685">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1686">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1686">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1687">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1687">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1688">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1688">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1689">콘텐츠 형식이 면 `xsd:dateTime`, 판독기는 unboxed 반환 <xref:System.DateTime> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1689">If the content is typed `xsd:dateTime`, the reader returns an unboxed <xref:System.DateTime> object.</span></span> <span data-ttu-id="58cdf-1690">콘텐츠 형식화 되지 않은 경우 `xsd:dateTime`, 판독기를 변환 하려고 시도 <xref:System.DateTime> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1690">If the content is not typed `xsd:dateTime`, the reader attempts to convert it to a <xref:System.DateTime> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1691">내용 형식이 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>로 지정된 경우 `xsd:gMonthDay` 값을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1691">You cannot rely on the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value when the content is typed as `xsd:gMonthDay`.</span></span> <span data-ttu-id="58cdf-1692"><xref:System.Xml.XmlReader> 항상 설정 된 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 1904로이 예에서 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1692"><xref:System.Xml.XmlReader> always sets the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value to 1904 in this case.</span></span>  
  
 <span data-ttu-id="58cdf-1693">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1693">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1694">다음 예제에서는 합니다 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> 의 콘텐츠를 읽기 위해 메서드를 `date` 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1694">The following example uses the <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> method to read the content of the `date` element.</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 <span data-ttu-id="58cdf-1695">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1695">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1696"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1696">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1697">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1697">-or-</span></span>

<span data-ttu-id="58cdf-1698">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1698">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1699">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1699">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1700">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1700">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1701">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1701">-or-</span></span> 
<span data-ttu-id="58cdf-1702">요소 콘텐츠를 <see cref="T:System.DateTime" /> 개체로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1702">The element content cannot be converted to a <see cref="T:System.DateTime" /> object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1703">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1703">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1704">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1704">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1705">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1705">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1706">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 <see cref="T:System.DateTime" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1706">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.DateTime" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1707">요소 콘텐츠에 해당하는 <see cref="T:System.DateTime" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1707">The element contents as a <see cref="T:System.DateTime" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1708">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1708">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1709">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1709">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1710">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1710">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1711">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1711">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1712">콘텐츠 형식이 면 `xsd:dateTime`, 판독기는 unboxed 반환 <xref:System.DateTime> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1712">If the content is typed `xsd:dateTime`, the reader returns an unboxed <xref:System.DateTime> object.</span></span> <span data-ttu-id="58cdf-1713">콘텐츠 형식화 되지 않은 경우 `xsd:dateTime`, 판독기를 변환 하려고 시도 <xref:System.DateTime> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1713">If the content is not typed `xsd:dateTime`, the reader attempts to convert it to a <xref:System.DateTime> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-1714">내용 형식이 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>로 지정된 경우 `xsd:gMonthDay` 값을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1714">You cannot rely on the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value when the content is typed as `xsd:gMonthDay`.</span></span> <span data-ttu-id="58cdf-1715"><xref:System.Xml.XmlReader> 항상 설정 된 <xref:System.DateTime.Year%2A?displayProperty=nameWithType> 1904로이 예에서 값입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1715"><xref:System.Xml.XmlReader> always sets the <xref:System.DateTime.Year%2A?displayProperty=nameWithType> value to 1904 in this case.</span></span>  
  
 <span data-ttu-id="58cdf-1716">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1716">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1717"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1717">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1718">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1718">-or-</span></span>

<span data-ttu-id="58cdf-1719">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1719">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1720">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1720">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1721">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1721">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1722">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1722">-or-</span></span> 
<span data-ttu-id="58cdf-1723">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1723">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1724">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1724">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1725">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1725">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1726">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1726">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1727">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1727">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1728">현재 요소 값을 <see cref="T:System.Decimal" /> 개체로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1728">Reads the current element value as a <see cref="T:System.Decimal" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1729">현재 요소를 읽고 콘텐츠를 <see cref="T:System.Decimal" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1729">Reads the current element and returns the contents as a <see cref="T:System.Decimal" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1730">요소 콘텐츠에 해당하는 <see cref="T:System.Decimal" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1730">The element content as a <see cref="T:System.Decimal" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1731">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1731">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1732">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1732">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1733">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1733">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1734">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1734">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1735">판독기가 요소 콘텐츠를 변환 하려고를 <xref:System.Decimal> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1735">The reader attempts to convert the element content to an <xref:System.Decimal> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1736">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1736">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1737"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1737">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1738">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1738">-or-</span></span>

<span data-ttu-id="58cdf-1739">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1739">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1740">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1740">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1741">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1741">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1742">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1742">-or-</span></span> 
<span data-ttu-id="58cdf-1743">요소 콘텐츠를 <see cref="T:System.Decimal" />로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1743">The element content cannot be converted to a <see cref="T:System.Decimal" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1744">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1744">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1745">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1745">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1746">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1746">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1747">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 <see cref="T:System.Decimal" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1747">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Decimal" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1748">요소 콘텐츠에 해당하는 <see cref="T:System.Decimal" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1748">The element content as a <see cref="T:System.Decimal" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1749">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1749">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1750">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1750">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1751">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1751">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1752">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1752">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1753">판독기가 요소 콘텐츠를 변환 하려고를 <xref:System.Decimal> 정의 된 규칙에 따라 개체를 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1753">The reader attempts to convert the element content to an <xref:System.Decimal> object according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1754">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1754">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1755"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1755">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1756">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1756">-or-</span></span>

<span data-ttu-id="58cdf-1757">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1757">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1758">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1758">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1759">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1759">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1760">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1760">-or-</span></span> 
<span data-ttu-id="58cdf-1761">요소 콘텐츠를 <see cref="T:System.Decimal" />로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1761">The element content cannot be converted to a <see cref="T:System.Decimal" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1762">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1762">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1763">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1763">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1764">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1764">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1765">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1765">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1766">현재 요소를 읽고 콘텐츠를 배정밀도 부동 소수점 숫자로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1766">Reads the current element and returns the contents as a double-precision floating-point number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1767">현재 요소를 읽고 콘텐츠를 배정밀도 부동 소수점 숫자로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1767">Reads the current element and returns the contents as a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1768">요소 콘텐츠에 해당하는 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1768">The element content as a double-precision floating-point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1769">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1769">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1770">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1770">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1771">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1771">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1772">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1772">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1773">콘텐츠 형식이 경우 `xsd:double`, 판독기를 배정밀도 부동 소수점 숫자로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1773">If the content is typed `xsd:double`, the reader returns a double-precision floating-point number.</span></span> <span data-ttu-id="58cdf-1774">콘텐츠 형식화 되지 않은 경우 `xsd:double`, 판독기가 정의 된 규칙에 따라 배정밀도 부동 소수점 숫자로 변환 하려고 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1774">If the content is not typed `xsd:double`, the reader attempts to convert it to a double-precision floating-point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1775">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1775">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1776">다음 예제는 메서드를 사용 하 여 요소 콘텐츠를 배정밀도 부동 소수점 숫자로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1776">The following example uses the method to return the element content as a double-precision floating-point number.</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 <span data-ttu-id="58cdf-1777">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1777">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1778"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1778">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1779">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1779">-or-</span></span>

<span data-ttu-id="58cdf-1780">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1780">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1781">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1781">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1782">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1782">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1783">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1783">-or-</span></span> 
<span data-ttu-id="58cdf-1784">요소 콘텐츠를 배정밀도 부동 소수점 숫자로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1784">The element content cannot be converted to a double-precision floating-point number.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1785">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1785">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1786">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1786">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1787">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1787">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1788">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 배정밀도 부동 소수점 숫자로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1788">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1789">요소 콘텐츠에 해당하는 배정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1789">The element content as a double-precision floating-point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1790">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1790">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1791">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1791">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1792">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1792">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1793">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1793">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1794">콘텐츠 형식이 경우 `xsd:double`, 판독기를 배정밀도 부동 소수점 숫자로 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1794">If the content is typed `xsd:double`, the reader returns a double-precision floating-point number.</span></span> <span data-ttu-id="58cdf-1795">콘텐츠 형식화 되지 않은 경우 `xsd:double`, 판독기가 정의 된 규칙에 따라 배정밀도 부동 소수점 숫자로 변환 하려고 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1795">If the content is not typed `xsd:double`, the reader attempts to convert it to a double-precision floating-point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1796">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1796">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1797"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1797">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1798">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1798">-or-</span></span>

<span data-ttu-id="58cdf-1799">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1799">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1800">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1800">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1801">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1801">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1802">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1802">-or-</span></span> 
<span data-ttu-id="58cdf-1803">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1803">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1804">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1804">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1805">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1805">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1806">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1806">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1807">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1807">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1808">현재 요소 값을 단정밀도 부동 소수점 숫자로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1808">Reads the current element value as a single-precision floating-point number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1809">현재 요소를 읽고 콘텐츠를 단정밀도 부동 소수점 숫자로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1809">Reads the current element and returns the contents as single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1810">요소 콘텐츠에 해당하는 단정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1810">The element content as a single-precision floating point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1811">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1811">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1812">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1812">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1813">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1813">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1814">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1814">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1815">판독기 요소 콘텐츠를 단 정밀도 부동 소수점 숫자에서 정의 된 규칙에 따라 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1815">The reader attempts to convert the element content to a single-precision floating point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1816">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1816">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1817"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1817">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1818">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1818">-or-</span></span>

<span data-ttu-id="58cdf-1819">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1819">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1820">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1820">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1821">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1821">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1822">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1822">-or-</span></span> 
<span data-ttu-id="58cdf-1823">요소 콘텐츠를 단정밀도 부동 소수점 숫자로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1823">The element content cannot be converted to a single-precision floating-point number.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1824">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1824">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1825">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1825">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1826">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1826">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1827">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 단정밀도 부동 소수점 숫자로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1827">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1828">요소 콘텐츠에 해당하는 단정밀도 부동 소수점 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1828">The element content as a single-precision floating point number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1829">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1829">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1830">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1830">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1831">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1831">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1832">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1832">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1833">판독기 요소 콘텐츠를 단 정밀도 부동 소수점 숫자에서 정의 된 규칙에 따라 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1833">The reader attempts to convert the element content to a single-precision floating point number according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1834">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1834">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1835"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1835">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1836">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1836">-or-</span></span> 
<span data-ttu-id="58cdf-1837">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1837">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1838">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1838">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1839">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1839">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1840">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1840">-or-</span></span> 
<span data-ttu-id="58cdf-1841">요소 콘텐츠를 단정밀도 부동 소수점 숫자로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1841">The element content cannot be converted to a single-precision floating-point number.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1842">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1842">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1843">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1843">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1844">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1844">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1845">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1845">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1846">현재 요소를 읽고 부호 있는 32비트 정수로 콘텐츠를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1846">Reads the current element and returns the contents as a 32-bit signed integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1847">현재 요소를 읽고 부호 있는 32비트 정수로 콘텐츠를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1847">Reads the current element and returns the contents as a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1848">요소 콘텐츠에 해당하는 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1848">The element content as a 32-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1849">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1849">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1850">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1850">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1851">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1851">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1852">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1852">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1853">콘텐츠 형식이 경우 `xsd:integer`, 판독기 unboxed 32 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1853">If the content is typed `xsd:integer`, the reader returns an unboxed 32-bit signed integer.</span></span> <span data-ttu-id="58cdf-1854">콘텐츠 형식화 되지 않은 경우 `xsd:integer`, 판독기에서 정의 된 규칙에 따라 32 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1854">If the content is not typed `xsd:integer`, the reader attempts to convert it to a 32-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1855">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1855">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1856"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1856">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1857">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1857">-or-</span></span> 
<span data-ttu-id="58cdf-1858">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1858">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1859">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1859">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1860">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1860">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1861">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1861">-or-</span></span> 
<span data-ttu-id="58cdf-1862">요소 콘텐츠를 부호 있는 32비트 정수로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1862">The element content cannot be converted to a 32-bit signed integer.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1863">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1863">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1864">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1864">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1865">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1865">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1866">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 부호 있는 32비트 정수로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1866">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1867">요소 콘텐츠에 해당하는 부호 있는 32비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1867">The element content as a 32-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1868">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1868">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1869">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1869">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1870">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1870">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1871">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1871">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1872">콘텐츠 형식이 경우 `xsd:integer`, 판독기 unboxed 32 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1872">If the content is typed `xsd:integer`, the reader returns an unboxed 32-bit signed integer.</span></span> <span data-ttu-id="58cdf-1873">콘텐츠 형식화 되지 않은 경우 `xsd:integer`, 판독기에서 정의 된 규칙에 따라 32 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1873">If the content is not typed `xsd:integer`, the reader attempts to convert it to a 32-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1874">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1874">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1875"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1875">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1876">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1876">-or-</span></span> 
<span data-ttu-id="58cdf-1877">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1877">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1878">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1878">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1879">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1879">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1880">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1880">-or-</span></span> 
<span data-ttu-id="58cdf-1881">요소 콘텐츠를 부호 있는 32비트 정수로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1881">The element content cannot be converted to a 32-bit signed integer.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1882">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1882">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1883">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1883">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1884">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1884">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1885">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1885">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1886">현재 요소를 읽고 부호 있는 64비트 정수로 콘텐츠를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1886">Reads the current element and returns the contents as a 64-bit signed integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1887">현재 요소를 읽고 부호 있는 64비트 정수로 콘텐츠를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1887">Reads the current element and returns the contents as a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1888">요소 콘텐츠에 해당하는 부호 있는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1888">The element content as a 64-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1889">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1889">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1890">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1890">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1891">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1891">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1892">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1892">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1893">콘텐츠 형식이 경우 `xsd:long`, 판독기 unboxed 64 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1893">If the content is typed `xsd:long`, the reader returns an unboxed 64-bit signed integer.</span></span> <span data-ttu-id="58cdf-1894">콘텐츠 형식화 되지 않은 경우 `xsd:long`, 판독기에서 정의 된 규칙에 따라 64 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1894">If the content is not typed `xsd:long`, the reader attempts to convert it to a 64-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1895">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1895">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1896">다음 예제에서는 합니다 <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> 의 콘텐츠를 읽기 위해 메서드를 `longValue` 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1896">The following example uses the <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> method to read the content of the `longValue` element.</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 <span data-ttu-id="58cdf-1897">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1897">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1898"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1898">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1899">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1899">-or-</span></span> 
<span data-ttu-id="58cdf-1900">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1900">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1901">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1901">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1902">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1902">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1903">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1903">-or-</span></span> 
<span data-ttu-id="58cdf-1904">요소 콘텐츠를 부호 있는 64비트 정수로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1904">The element content cannot be converted to a 64-bit signed integer.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1905">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1905">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1906">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1906">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1907">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1907">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1908">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 부호 있는 64비트 정수로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1908">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1909">요소 콘텐츠에 해당하는 부호 있는 64비트 정수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1909">The element content as a 64-bit signed integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1910">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1910">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1911">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1911">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1912">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1912">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1913">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1913">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1914">콘텐츠 형식이 경우 `xsd:long`, 판독기 unboxed 64 비트 부호 있는 정수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1914">If the content is typed `xsd:long`, the reader returns an unboxed 64-bit signed integer.</span></span> <span data-ttu-id="58cdf-1915">콘텐츠 형식화 되지 않은 경우 `xsd:long`, 판독기에서 정의 된 규칙에 따라 64 비트 부호 있는 정수로 변환 하려고 시도 합니다 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1915">If the content is not typed `xsd:long`, the reader attempts to convert it to a 64-bit signed integer according to the rules defined by the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1916">자세한 내용은 <xref:System.Xml.XmlReader> 참조 페이지의 설명 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1916">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1917"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1917">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1918">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1918">-or-</span></span> 
<span data-ttu-id="58cdf-1919">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1919">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1920">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1920">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1921">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1921">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1922">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1922">-or-</span></span> 
<span data-ttu-id="58cdf-1923">요소 콘텐츠를 부호 있는 64비트 정수로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1923">The element content cannot be converted to a 64-bit signed integer.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1924">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1924">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1925">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1925">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1926">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1926">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1927">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1927">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1928">현재 요소를 읽고 콘텐츠를 <see cref="T:System.Object" />로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1928">Reads the current element and returns the contents as an <see cref="T:System.Object" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1929">현재 요소를 읽고 콘텐츠를 <see cref="T:System.Object" />로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1929">Reads the current element and returns the contents as an <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1930">가장 적합한 형식의 boxed CLR(공용 언어 런타임) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1930">A boxed common language runtime (CLR) object of the most appropriate type.</span></span> <span data-ttu-id="58cdf-1931">적합한 CLR 형식은 <see cref="P:System.Xml.XmlReader.ValueType" /> 속성에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1931">The <see cref="P:System.Xml.XmlReader.ValueType" /> property determines the appropriate CLR type.</span></span> <span data-ttu-id="58cdf-1932">콘텐츠가 목록 형식이면 이 메서드는 적합한 형식의 boxed 개체 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1932">If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1933">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1933">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1934">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1934">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1935">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1935">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1936">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1936">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1937">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1937">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1938">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1938">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1939">다음 예제에서는 메서드를 사용 하 여의 콘텐츠를 읽기 위해는 `price` 노드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1939">The following example uses the method to read the content of the `price` node.</span></span> <span data-ttu-id="58cdf-1940">판독기는 콘텐츠는 올바른 데이터 형식에 매핑할 스키마에서 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1940">The reader uses the information in the schema to map the content to the correct data type.</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 <span data-ttu-id="58cdf-1941">이 예제에서는 입력으로 다음 두 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1941">The example uses the following two files as input.</span></span>  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1942"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1942">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1943">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1943">-or-</span></span> 
<span data-ttu-id="58cdf-1944">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1944">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1945">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1945">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1946">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1946">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1947">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1947">-or-</span></span> 
<span data-ttu-id="58cdf-1948">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1948">The element content cannot be converted to the requested type</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1949">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1949">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-1950">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1950">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-1951">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1951">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-1952">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 <see cref="T:System.Object" />로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1952">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as an <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1953">가장 적합한 형식의 boxed CLR(공용 언어 런타임) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1953">A boxed common language runtime (CLR) object of the most appropriate type.</span></span> <span data-ttu-id="58cdf-1954">적합한 CLR 형식은 <see cref="P:System.Xml.XmlReader.ValueType" /> 속성에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1954">The <see cref="P:System.Xml.XmlReader.ValueType" /> property determines the appropriate CLR type.</span></span> <span data-ttu-id="58cdf-1955">콘텐츠가 목록 형식이면 이 메서드는 적합한 형식의 boxed 개체 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1955">If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1956">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1956">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1957">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1957">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1958">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1958">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1959">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1959">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1960">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1960">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1961"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1961">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1962">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1962">-or-</span></span> 
<span data-ttu-id="58cdf-1963">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1963">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1964">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1964">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1965">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1965">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-1966">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1966">-or-</span></span> 
<span data-ttu-id="58cdf-1967">요소 콘텐츠를 요청한 형식으로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1967">The element content cannot be converted to the requested type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-1968">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1968">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-1969">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1969">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1970">현재 요소를 비동기적으로 읽고 콘텐츠를 <see cref="T:System.Object" />로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1970">Asynchronously reads the current element and returns the contents as an <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1971">가장 적합한 형식의 boxed CLR(공용 언어 런타임) 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1971">A boxed common language runtime (CLR) object of the most appropriate type.</span></span> <span data-ttu-id="58cdf-1972">적합한 CLR 형식은 <see cref="P:System.Xml.XmlReader.ValueType" /> 속성에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1972">The <see cref="P:System.Xml.XmlReader.ValueType" /> property determines the appropriate CLR type.</span></span> <span data-ttu-id="58cdf-1973">콘텐츠가 목록 형식이면 이 메서드는 적합한 형식의 boxed 개체 배열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1973">If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1974">비동기 버전이 <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1974">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-1975">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1975">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1976">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1976">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1977">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1977">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-1978">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1978">-or-</span></span>

<span data-ttu-id="58cdf-1979"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1979">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-1980">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1980">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-1981">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-1981">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1982">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1982">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1983">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1983">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-1984">현재 요소를 읽고 콘텐츠를 <see cref="T:System.String" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1984">Reads the current element and returns the contents as a <see cref="T:System.String" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-1985">현재 요소를 읽고 콘텐츠를 <see cref="T:System.String" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1985">Reads the current element and returns the contents as a <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-1986">요소 콘텐츠에 해당하는 <see cref="T:System.String" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1986">The element content as a <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-1987">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1987">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-1988">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1988">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-1989">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1989">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-1990">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1990">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-1991">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1991">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
 <span data-ttu-id="58cdf-1992">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1992">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-1993">다음 예제에서는 `stringValue` 요소의 텍스트 콘텐츠 (주석을 무시 및 처리 명령)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1993">The following example reads the `stringValue` element and returns the text content (ignoring the comment and processing instruction).</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 <span data-ttu-id="58cdf-1994">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1994">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-1995"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1995">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-1996">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-1996">-or-</span></span>

<span data-ttu-id="58cdf-1997">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1997">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-1998">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-1998">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-1999">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-1999">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-2000">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2000">-or-</span></span> 
<span data-ttu-id="58cdf-2001">요소 콘텐츠를 <see cref="T:System.String" /> 개체로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2001">The element content cannot be converted to a <see cref="T:System.String" /> object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2002">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2002">The method is called with <see langword="null" /> arguments.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-2003">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2003">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-2004">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2004">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-2005">지정된 로컬 이름과 네임스페이스 URI가 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하는지 확인한 다음 현재 요소를 읽고 콘텐츠를 <see cref="T:System.String" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2005">Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2006">요소 콘텐츠에 해당하는 <see cref="T:System.String" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2006">The element content as a <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2007">이 메서드는 시작 태그를 요소의 내용을 읽고 끝 요소 태그를 지나서 판독기를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2007">This method reads the start tag, the contents of the element, and moves the reader past the end element tag.</span></span> <span data-ttu-id="58cdf-2008">엔터티를 확장 하 고 처리 명령과 주석을 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2008">It expands entities and ignores processing instructions and comments.</span></span> <span data-ttu-id="58cdf-2009">요소는 단순 콘텐츠가 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2009">The element can only contain simple content.</span></span> <span data-ttu-id="58cdf-2010">즉, 자식 요소가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2010">That is, it cannot have child elements.</span></span>  
  
 <span data-ttu-id="58cdf-2011">자세한 내용은의 설명 섹션을 참조 하십시오.는 <xref:System.Xml.XmlReader> 참조 페이지 및 [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) 권장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2011">For more information, see the Remarks section of the <xref:System.Xml.XmlReader> reference page and the [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) recommendation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2012">다음 예제에서는 `stringValue` 요소의 텍스트 콘텐츠 (주석을 무시 및 처리 명령)을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2012">The following example reads the `stringValue` element and returns the text content (ignoring the comment and processing instruction).</span></span>  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 <span data-ttu-id="58cdf-2013">이 예제에서는 `dataFile.xml` 파일을 입력으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2013">The example uses the `dataFile.xml` file as input.</span></span>  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2014"><see cref="T:System.Xml.XmlReader" />가 요소에 배치되지 않은 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2014">The <see cref="T:System.Xml.XmlReader" /> is not positioned on an element.</span></span>

<span data-ttu-id="58cdf-2015">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2015">-or-</span></span>

<span data-ttu-id="58cdf-2016">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2016">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2017">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2017">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2018">현재 요소에 자식 요소가 포함된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2018">The current element contains child elements.</span></span>  
  
<span data-ttu-id="58cdf-2019">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2019">-or-</span></span> 
<span data-ttu-id="58cdf-2020">요소 콘텐츠를 <see cref="T:System.String" /> 개체로 변환할 수 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2020">The element content cannot be converted to a <see cref="T:System.String" /> object.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2021">메서드가 <see langword="null" /> 인수를 사용하여 호출된 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2021">The method is called with <see langword="null" /> arguments.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-2022">지정한 로컬 이름과 네임스페이스 URI가 읽고 있는 현재 요소의 로컬 이름 및 네임스페이스 URI와 일치하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2022">The specified local name and namespace URI do not match that of the current element being read.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2023">현재 요소를 비동기적으로 읽고 콘텐츠를 <see cref="T:System.String" /> 개체로 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2023">Asynchronously reads the current element and returns the contents as a <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2024">요소 콘텐츠에 해당하는 <see cref="T:System.String" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2024">The element content as a <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2025">비동기 버전이 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2025">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-2026">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2026">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2027"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2027">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-2028">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2028">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-2029">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2029">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2030">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2030">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2031">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2031">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-2032">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2032">-or-</span></span>

<span data-ttu-id="58cdf-2033">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2033">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2034">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2034">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-2035">단순 텍스트 전용 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2035">Reads the simple text-only elements.</span></span> <span data-ttu-id="58cdf-2036">그러나 이 연산을 더 간단하게 처리하는 방법을 제공하는 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 메서드를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2036">However, we recommend that you use the <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> method instead, because it provides a more straightforward way to handle this operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2037">사용 하는 것이 좋습니다는 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> 메서드 텍스트 요소를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2037">We recommend that you use the <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> method to read a text element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2038">텍스트 전용 요소를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2038">Reads a text-only element.</span></span> <span data-ttu-id="58cdf-2039">그러나 이 연산을 더 간단하게 처리하는 방법을 제공하는 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 메서드를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2039">However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> method instead, because it provides a more straightforward way to handle this operation.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2040">읽은 요소에 포함된 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2040">The text contained in the element that was read.</span></span> <span data-ttu-id="58cdf-2041">요소가 비어 있으면 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2041">An empty string if the element is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2042">사용 하는 것이 좋습니다는 <xref:System.Xml.XmlReader.ReadElementContentAsString> 메서드 텍스트 요소를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2042">We recommend that you use the <xref:System.Xml.XmlReader.ReadElementContentAsString> method to read a text element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2043">다음 콘텐츠 노드가 시작 태그가 아니거나 찾은 요소에 간단한 텍스트 값이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2043">The next content node is not a start tag; or the element found does not contain a simple text value.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2044">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2044">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2045">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2045">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-2046">확인할 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2046">The name to check.</span></span></param>
        <summary><span data-ttu-id="58cdf-2047">텍스트 전용 요소를 읽기 전에 찾은 요소의 <see cref="P:System.Xml.XmlReader.Name" /> 속성이 지정된 문자열과 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2047">Checks that the <see cref="P:System.Xml.XmlReader.Name" /> property of the element found matches the given string before reading a text-only element.</span></span> <span data-ttu-id="58cdf-2048">그러나 이 연산을 더 간단하게 처리하는 방법을 제공하는 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 메서드를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2048">However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> method instead, because it provides a more straightforward way to handle this operation.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2049">읽은 요소에 포함된 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2049">The text contained in the element that was read.</span></span> <span data-ttu-id="58cdf-2050">요소가 비어 있으면 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2050">An empty string if the element is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2051">사용 하는 것이 좋습니다는 <xref:System.Xml.XmlReader.ReadElementContentAsString> 메서드 텍스트 요소를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2051">We recommend that you use the <xref:System.Xml.XmlReader.ReadElementContentAsString> method to read a text element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2052">다음 콘텐츠 노드가 시작 태그가 아닌 경우, <see langword="Name" /> 요소가 지정된 인수와 일치하지 않는 경우 또는 찾은 요소에 간단한 텍스트 값이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2052">If the next content node is not a start tag; if the element <see langword="Name" /> does not match the given argument; or if the element found does not contain a simple text value.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2053">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2053">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2054">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2054">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname"><span data-ttu-id="58cdf-2055">확인할 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2055">The local name to check.</span></span></param>
        <param name="ns"><span data-ttu-id="58cdf-2056">확인할 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2056">The namespace URI to check.</span></span></param>
        <summary><span data-ttu-id="58cdf-2057">텍스트 전용 요소를 읽기 전에 찾은 요소의 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 속성이 지정된 문자열과 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2057">Checks that the <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" /> properties of the element found matches the given strings before reading a text-only element.</span></span> <span data-ttu-id="58cdf-2058">그러나 이 연산을 더 간단하게 처리하는 방법을 제공하는 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> 메서드를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2058">However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> method instead, because it provides a more straightforward way to handle this operation.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2059">읽은 요소에 포함된 텍스트입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2059">The text contained in the element that was read.</span></span> <span data-ttu-id="58cdf-2060">요소가 비어 있으면 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2060">An empty string if the element is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2061">사용 하는 것이 좋습니다는 <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> 메서드 텍스트 요소를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2061">We recommend that you use the <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> method to read a text element.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2062">다음 콘텐츠 노드가 시작 태그가 아닌 경우, <see langword="LocalName" /> 또는 <see langword="NamespaceURI" /> 요소가 지정된 인수와 일치하지 않는 경우 또는 찾은 요소에 간단한 텍스트 값이 없는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2062">If the next content node is not a start tag; if the element <see langword="LocalName" /> or <see langword="NamespaceURI" /> do not match the given arguments; or if the element found does not contain a simple text value.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2063">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2063">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2064">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2064">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2065">현재 콘텐츠 노드가 끝 태그인지 확인하고 판독기를 다음 노드로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2065">Checks that the current content node is an end tag and advances the reader to the next node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-2066">다음 예제에서는 각 요소의 텍스트 콘텐츠를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2066">The following example displays the text content of each element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 <span data-ttu-id="58cdf-2067">이 예제에서는 사용 된 `book3.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2067">The example uses the `book3.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2068">현재 노드가 끝 태그가 아니거나 입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2068">The current node is not an end tag or if incorrect XML is encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2069">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2069">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2070">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2070">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2071">파생 클래스에서 재정의되면 태그를 포함한 모든 콘텐츠를 문자열로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2071">When overridden in a derived class, reads all the content, including markup, as a string.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2072">태그를 포함한 모든 현재 노드의 XML 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2072">All the XML content, including markup, in the current node.</span></span> <span data-ttu-id="58cdf-2073">현재 노드에 자식이 없으면 빈 문자열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2073">If the current node has no children, an empty string is returned.</span></span>  
  
<span data-ttu-id="58cdf-2074">현재 노드가 요소나 특성이 아니면 빈 문자열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2074">If the current node is neither an element nor attribute, an empty string is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2075">이 메서드는 태그를 포함 하 여 현재 노드의 모든 콘텐츠를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2075">This method returns all the content of the current node including the markup.</span></span> <span data-ttu-id="58cdf-2076">현재 노드(시작 태그)와 해당 끝 노드(끝 태그)는 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2076">The current node (start tag) and corresponding end node (end tag) are not returned.</span></span> <span data-ttu-id="58cdf-2077">예를 들어, 다음을 설치한 경우:</span><span class="sxs-lookup"><span data-stu-id="58cdf-2077">For example, if you had the following:</span></span>  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 <span data-ttu-id="58cdf-2078">`ReadInnerXml`은 `this <child id="123"/>`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2078">`ReadInnerXml` returns `this <child id="123"/>`</span></span>  
  
 <span data-ttu-id="58cdf-2079">이 메서드는 다음과 같은 방법으로 요소 및 특성 노드를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2079">This method handles element and attribute nodes in the following manner:</span></span>  
  
|<span data-ttu-id="58cdf-2080">노드 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-2080">Node type</span></span>|<span data-ttu-id="58cdf-2081">호출 전 위치</span><span class="sxs-lookup"><span data-stu-id="58cdf-2081">Position before the call</span></span>|<span data-ttu-id="58cdf-2082">XML 조각</span><span class="sxs-lookup"><span data-stu-id="58cdf-2082">XML fragment</span></span>|<span data-ttu-id="58cdf-2083">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-2083">Return value</span></span>|<span data-ttu-id="58cdf-2084">호출 후 위치</span><span class="sxs-lookup"><span data-stu-id="58cdf-2084">Position after the call</span></span>|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|<span data-ttu-id="58cdf-2085">`item1` 시작 태그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2085">On the `item1` start tag.</span></span>|<span data-ttu-id="58cdf-2086">\<item1>text1\</item1>\<item2>text2\</item2></span><span class="sxs-lookup"><span data-stu-id="58cdf-2086">\<item1>text1\</item1>\<item2>text2\</item2></span></span>|<span data-ttu-id="58cdf-2087">text1</span><span class="sxs-lookup"><span data-stu-id="58cdf-2087">text1</span></span>|<span data-ttu-id="58cdf-2088">`item2` 시작 태그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2088">On the `item2` start tag.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-2089">`attr1` 특성 노드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2089">On the `attr1` attribute node.</span></span>|<span data-ttu-id="58cdf-2090">\<항목 attr1 "val1" attr2 = "val2" = > 텍스트 \< /></span><span class="sxs-lookup"><span data-stu-id="58cdf-2090">\<item attr1="val1" attr2="val2">text\</item></span></span>|<span data-ttu-id="58cdf-2091">val1</span><span class="sxs-lookup"><span data-stu-id="58cdf-2091">val1</span></span>|<span data-ttu-id="58cdf-2092">`attr1` 특성 노드에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2092">Remains on the `attr1` attribute node.</span></span>|  
  
 <span data-ttu-id="58cdf-2093">판독기가 리프 노드에 있을 경우 `ReadInnerXml`을 호출하는 것과 <xref:System.Xml.XmlReader.Read%2A>를 호출하는 것은 같습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2093">If the reader is positioned on a leaf node, calling `ReadInnerXml` is equivalent to calling <xref:System.Xml.XmlReader.Read%2A>.</span></span> <span data-ttu-id="58cdf-2094">메서드는 반환 `String.Empty` 단 특성 노드의 경우 특성의 값이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2094">The method returns `String.Empty` (except for attribute nodes, in which case the value of the attribute is returned).</span></span>  
  
 <span data-ttu-id="58cdf-2095">이 메서드는 올바른 형식의 XML에 대 한 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2095">This method checks for well-formed XML.</span></span> <span data-ttu-id="58cdf-2096">하는 경우 `ReadInnerXml` 에서 호출 되는 <xref:System.Xml.XmlValidatingReader>,이 메서드는 반환 된 콘텐츠가도 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2096">If `ReadInnerXml` is called from an <xref:System.Xml.XmlValidatingReader>, this method also validates the content returned.</span></span>  
  
 <span data-ttu-id="58cdf-2097">구현 되는 <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> 및 `XmlValidatingReader` 클래스는 `ReadOuterXml` 메서드는 네임 스페이스를 인식 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2097">As implemented in the <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> and `XmlValidatingReader` classes the `ReadOuterXml` method is namespace aware.</span></span>  
  
 <span data-ttu-id="58cdf-2098">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2098">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2099">다음 예제에서는 비교 합니다 `ReadInnerXml` 고 <xref:System.Xml.XmlReader.ReadOuterXml%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2099">The following example compares the `ReadInnerXml` and <xref:System.Xml.XmlReader.ReadOuterXml%2A> methods.</span></span>  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 <span data-ttu-id="58cdf-2100">이 예제에서는 사용 `2books.xml` 파일을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2100">The example uses `2books.xml` file as input.</span></span>  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2101">XML의 형식이 잘못되었거나 XML을 구문 분석하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2101">The XML was not well-formed, or an error occurred while parsing the XML.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2102">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2102">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2103">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2103">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2104">태그를 포함한 모든 콘텐츠를 문자열로 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2104">Asynchronously reads all the content, including markup, as a string.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2105">태그를 포함한 모든 현재 노드의 XML 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2105">All the XML content, including markup, in the current node.</span></span> <span data-ttu-id="58cdf-2106">현재 노드에 자식이 없으면 빈 문자열이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2106">If the current node has no children, an empty string is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2107">비동기 버전이 <xref:System.Xml.XmlReader.ReadInnerXml%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2107">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadInnerXml%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-2108">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2108">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2109">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2109">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2110">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2110">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-2111">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2111">-or-</span></span>

<span data-ttu-id="58cdf-2112"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2112">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-2113">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2113">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-2114">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2114">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2115">파생 클래스에서 재정의되면 태그를 포함하여 이 노드 및 모든 자식 노드를 나타내는 콘텐츠를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2115">When overridden in a derived class, reads the content, including markup, representing this node and all its children.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2116">판독기가 요소 또는 특성 노드에 배치되면 이 메서드는 태그를 포함해 현재 노드와 모든 자식 노드의 xml 콘텐츠를 모두 반환하고, 그렇지 않으면 빈 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2116">If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2117">이 메서드는 유사한 <xref:System.Xml.XmlReader.ReadInnerXml%2A> 시작 및 끝 태그를 반환 한다는 점을 제외 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2117">This method is similar to <xref:System.Xml.XmlReader.ReadInnerXml%2A> except it also returns the start and end tags.</span></span>  
  
 <span data-ttu-id="58cdf-2118">이 메서드는 다음과 같은 방법으로 요소 및 특성 노드를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2118">This method handles element and attribute nodes in the following manner:</span></span>  
  
|<span data-ttu-id="58cdf-2119">노드 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-2119">Node type</span></span>|<span data-ttu-id="58cdf-2120">호출 전 위치</span><span class="sxs-lookup"><span data-stu-id="58cdf-2120">Position before the call</span></span>|<span data-ttu-id="58cdf-2121">XML 조각</span><span class="sxs-lookup"><span data-stu-id="58cdf-2121">XML fragment</span></span>|<span data-ttu-id="58cdf-2122">반환 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-2122">Return value</span></span>|<span data-ttu-id="58cdf-2123">호출 후 위치</span><span class="sxs-lookup"><span data-stu-id="58cdf-2123">Position After the Call</span></span>|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|<span data-ttu-id="58cdf-2124">`item1` 시작 태그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2124">On the `item1` start tag.</span></span>|<span data-ttu-id="58cdf-2125">\<item1>text1\</item1>\<item2>text2\</item2></span><span class="sxs-lookup"><span data-stu-id="58cdf-2125">\<item1>text1\</item1>\<item2>text2\</item2></span></span>|<span data-ttu-id="58cdf-2126">\<item1>text1\</item1></span><span class="sxs-lookup"><span data-stu-id="58cdf-2126">\<item1>text1\</item1></span></span>|<span data-ttu-id="58cdf-2127">`item2` 시작 태그에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2127">On the `item2` start tag.</span></span>|  
|`Attribute`|<span data-ttu-id="58cdf-2128">`attr1` 특성 노드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2128">On the `attr1` attribute node.</span></span>|<span data-ttu-id="58cdf-2129">\<항목 attr1 "val1" attr2 = "val2" = > 텍스트 \< /></span><span class="sxs-lookup"><span data-stu-id="58cdf-2129">\<item attr1="val1" attr2="val2">text\</item></span></span>|<span data-ttu-id="58cdf-2130">attr1="val1"</span><span class="sxs-lookup"><span data-stu-id="58cdf-2130">attr1="val1"</span></span>|<span data-ttu-id="58cdf-2131">`attr1` 특성 노드에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2131">Remains on the `attr1` attribute node.</span></span>|  
  
 <span data-ttu-id="58cdf-2132">판독기가 리프 노드에 있을 경우 `ReadOuterXml`을 호출하는 것과 <xref:System.Xml.XmlReader.Read%2A>를 호출하는 것은 같습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2132">If the reader is positioned on a leaf node, calling `ReadOuterXml` is equivalent to calling <xref:System.Xml.XmlReader.Read%2A>.</span></span> <span data-ttu-id="58cdf-2133">메서드는 반환 `String.Empty` (제외 특성 노드의 경우 특성 태그는 반환 하는 경우).</span><span class="sxs-lookup"><span data-stu-id="58cdf-2133">The method returns `String.Empty` (except for attribute nodes, in which case the attribute markup is returned).</span></span>  
  
 <span data-ttu-id="58cdf-2134">이 메서드는 올바른 형식의 XML에 대 한 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2134">This method checks for well-formed XML.</span></span> <span data-ttu-id="58cdf-2135">하는 경우 `ReadOuterXml` 에서 호출 되는 <xref:System.Xml.XmlValidatingReader>,이 메서드는 반환 된 콘텐츠가 있는지도</span><span class="sxs-lookup"><span data-stu-id="58cdf-2135">If `ReadOuterXml` is called from an <xref:System.Xml.XmlValidatingReader>, this method also validates the content returned</span></span>  
  
 <span data-ttu-id="58cdf-2136">구현 되는 <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> 및 `XmlValidatingReader` 클래스는 `ReadOuterXml` 메서드는 네임 스페이스를 인식 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2136">As implemented in the <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> and `XmlValidatingReader` classes the `ReadOuterXml` method is namespace aware.</span></span> <span data-ttu-id="58cdf-2137">다음 XML 텍스트를 지정 된 `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`판독기에 배치 된 경우는 `S:B` 시작 태그에 `ReadOuterXml` 반환 `<S:B xmlns:S="urn:1">hello<S:B/>`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2137">Given the following XML text `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, if the reader were positioned on the `S:B` start tag, `ReadOuterXml` returns `<S:B xmlns:S="urn:1">hello<S:B/>`.</span></span>  
  
 <span data-ttu-id="58cdf-2138">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2138">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2139">다음 예제에서는 비교 합니다 `ReadInnerXml` 고 `ReadOuterXml` 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2139">The following example compares the `ReadInnerXml` and `ReadOuterXml` methods.</span></span>  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 <span data-ttu-id="58cdf-2140">이 예제에서는 사용 `2books.xml` 파일을 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2140">The example uses `2books.xml` file as input.</span></span>  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2141">XML의 형식이 잘못되었거나 XML을 구문 분석하는 동안 오류가 발생한 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2141">The XML was not well-formed, or an error occurred while parsing the XML.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2142">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2142">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2143">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2143">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2144">이 노드 및 이 노드의 모든 자식을 나타내는 태그를 포함한 콘텐츠를 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2144">Asynchronously reads the content, including markup, representing this node and all its children.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2145">판독기가 요소 또는 특성 노드에 배치되면 이 메서드는 태그를 포함해 현재 노드와 모든 자식 노드의 xml 콘텐츠를 모두 반환하고, 그렇지 않으면 빈 문자열을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2145">If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2146">비동기 버전이 <xref:System.Xml.XmlReader.ReadOuterXml%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2146">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadOuterXml%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-2147">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2147">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2148"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2148">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-2149">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2149">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-2150">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2150">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2151">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2151">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2152">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2152">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-2153">현재 노드가 요소인지 확인하고 판독기를 다음 노드로 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2153">Checks that the current node is an element and advances the reader to the next node.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2154">현재 노드가 요소인지 확인하고 판독기를 다음 노드로 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2154">Checks that the current node is an element and advances the reader to the next node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2155">이 메서드를 호출 <xref:System.Xml.XmlReader.IsStartElement%2A> 뒤에 <xref:System.Xml.XmlReader.Read%2A> 있습니다 입력된 스트림에 있는 해당 요소의 내용에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2155">This method calls <xref:System.Xml.XmlReader.IsStartElement%2A> followed by <xref:System.Xml.XmlReader.Read%2A> to position you on the content of that element found in the input stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2156">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2156">Incorrect XML was encountered in the input stream.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2157">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2157">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2158">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2158">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-2159">요소의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2159">The qualified name of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-2160">현재 콘텐츠 노드가 지정된 <see cref="P:System.Xml.XmlReader.Name" />을 가진 요소인지 확인하고 판독기를 다음 노드로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2160">Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.Name" /> and advances the reader to the next node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2161">이 메서드에 대 한 호출에 대 한 호출에 해당 <xref:System.Xml.XmlReader.IsStartElement%2A> 에 대 한 호출 뒤에 <xref:System.Xml.XmlReader.Read%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2161">A call to this method corresponds to a call to <xref:System.Xml.XmlReader.IsStartElement%2A> followed by a call to <xref:System.Xml.XmlReader.Read%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2162">다음 예제에서는 각 요소의 텍스트 콘텐츠를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2162">The following example displays the text content of each element.</span></span>  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 <span data-ttu-id="58cdf-2163">이 예제에서는 사용 된 `book3.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2163">The example uses the `book3.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2164">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2164">Incorrect XML was encountered in the input stream.</span></span>  
  
<span data-ttu-id="58cdf-2165">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2165">-or-</span></span> 
<span data-ttu-id="58cdf-2166">이 요소의 <see cref="P:System.Xml.XmlReader.Name" />는 주어진 <paramref name="name" />에 매치되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2166">The <see cref="P:System.Xml.XmlReader.Name" /> of the element does not match the given <paramref name="name" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2167">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2167">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2168">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2168">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname"><span data-ttu-id="58cdf-2169">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2169">The local name of the element.</span></span></param>
        <param name="ns"><span data-ttu-id="58cdf-2170">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2170">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-2171">현재 콘텐츠 노드가 지정된 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" />가 있는 요소인지 확인하고 판독기를 다음 노드로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2171">Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" /> and advances the reader to the next node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2172">이 메서드에 대 한 호출에 대 한 호출에 해당 <xref:System.Xml.XmlReader.IsStartElement%2A> 에 대 한 호출 뒤에 <xref:System.Xml.XmlReader.Read%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2172">A call to this method corresponds to a call to <xref:System.Xml.XmlReader.IsStartElement%2A> followed by a call to <xref:System.Xml.XmlReader.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2173">입력 스트림에 잘못된 XML이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2173">Incorrect XML was encountered in the input stream.</span></span>  
  
<span data-ttu-id="58cdf-2174">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2174">-or-</span></span> 
<span data-ttu-id="58cdf-2175">검색된 요소의 <see cref="P:System.Xml.XmlReader.LocalName" /> 및 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 속성은 주어진 인수와 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2175">The <see cref="P:System.Xml.XmlReader.LocalName" /> and <see cref="P:System.Xml.XmlReader.NamespaceURI" /> properties of the element found do not match the given arguments.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2176">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2176">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2177">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2177">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2178">파생 클래스에서 재정의되면 판독기의 상태를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2178">When overridden in a derived class, gets the state of the reader.</span></span></summary>
        <value><span data-ttu-id="58cdf-2179">판독기 상태를 지정하는 열거형 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2179">One of the enumeration values that specifies the state of the reader.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2180"><xref:System.Xml.XmlReader.ReadState%2A> 속성이 다음 값 중 하나:</span><span class="sxs-lookup"><span data-stu-id="58cdf-2180">The <xref:System.Xml.XmlReader.ReadState%2A> property has one of the following values:</span></span>  
  
-   <span data-ttu-id="58cdf-2181"><xref:System.Xml.ReadState.Initial>을 때의 <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2181"><xref:System.Xml.ReadState.Initial>, when the <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> method is called.</span></span>  
  
-   <span data-ttu-id="58cdf-2182"><xref:System.Xml.ReadState.Interactive>을 때를 <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> 메서드를 호출 하 고 판독기에서 추가 메서드를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2182"><xref:System.Xml.ReadState.Interactive>, when the <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> method has been called, and additional methods may be called on the reader.</span></span>  
  
-   <span data-ttu-id="58cdf-2183"><xref:System.Xml.ReadState.EndOfFile>때 XML 문서의 끝에 도달 했습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2183"><xref:System.Xml.ReadState.EndOfFile>, when the end of the XML document has been reached successfully.</span></span>  
  
-   <span data-ttu-id="58cdf-2184"><xref:System.Xml.ReadState.Closed>을 때의 <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2184"><xref:System.Xml.ReadState.Closed>, when the <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> method is called.</span></span>  
  
-   <span data-ttu-id="58cdf-2185"><xref:System.Xml.ReadState.Error>때 오류로 인해 읽기 작업을 계속할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2185"><xref:System.Xml.ReadState.Error>, when an error is preventing the read operation from continuing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2186">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2186">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2187">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2187">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2188">파생 클래스에서 재정의되면 요소 또는 텍스트 노드의 내용을 문자열로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2188">When overridden in a derived class, reads the contents of an element or text node as a string.</span></span> <span data-ttu-id="58cdf-2189">그러나 이 연산을 더 간단하게 처리하는 방법을 제공하는 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 메서드를 대신 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2189">However, we recommend that you use the <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> method instead, because it provides a more straightforward way to handle this operation.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2190">요소의 내용이나 빈 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2190">The contents of the element or an empty string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2191">사용 하는 것이 좋습니다는 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> 메서드를 문자열로 요소 또는 텍스트 노드의 내용을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2191">We recommend that you use the <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> method to read the contents of an element or text node as a string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2192">XML을 구문 분석하는 동안 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2192">An error occurred while parsing the XML.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2193">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2193">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2194">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2194">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2195">현재 노드와 해당 하위 노드 전체를 읽는 데 사용되는 새 <see langword="XmlReader" /> 인스턴스를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2195">Returns a new <see langword="XmlReader" /> instance that can be used to read the current node, and all its descendants.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2196"><see cref="F:System.Xml.ReadState.Initial" />로 설정된 새로운 XML 판독기 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2196">A new XML reader instance set to <see cref="F:System.Xml.ReadState.Initial" />.</span></span> <span data-ttu-id="58cdf-2197"><see cref="M:System.Xml.XmlReader.Read" /> 메서드를 호출하면 <see cref="M:System.Xml.XmlReader.ReadSubtree" /> 메서드를 호출하기 전에 현재 노드에 새 판독기가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2197">Calling the <see cref="M:System.Xml.XmlReader.Read" /> method positions the new reader on the node that was current before the call to the <see cref="M:System.Xml.XmlReader.ReadSubtree" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2198"><xref:System.Xml.XmlReader.ReadSubtree%2A> 요소 노드에 대해서만 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2198"><xref:System.Xml.XmlReader.ReadSubtree%2A> can be called only on element nodes.</span></span> <span data-ttu-id="58cdf-2199">전체 하위 트리를 읽을 때 호출 된 <xref:System.Xml.XmlReader.Read%2A> 메서드가 반환 되는 `false`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2199">When the entire sub-tree has been read, calls to the <xref:System.Xml.XmlReader.Read%2A> method returns `false`.</span></span> <span data-ttu-id="58cdf-2200">경우 새 XML 판독기를 닫으면 배치할 원래 readeris는 `EndElement` 하위 트리의 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2200">When the new XML reader has been closed, the original readeris positioned on the `EndElement` node of the sub-tree.</span></span> <span data-ttu-id="58cdf-2201">따라서 호출 하면는 <xref:System.Xml.XmlReader.ReadSubtree%2A> 메서드 읽기 및 새 XML 판독기 하위 트리의 후 책 요소의 시작 태그를 닫 혔, 책 요소의 종료 태그에 원래 XML 판독기가 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2201">Thus, if you called the <xref:System.Xml.XmlReader.ReadSubtree%2A> method on the start tag of the book element, after the sub-tree has been read and the new XML reader has been closed, the original XML reader is positioned on the end tag of the book element.</span></span>  
  
 <span data-ttu-id="58cdf-2202">원래 판독기에서 작업을 수행하려면 먼저 새 판독기를 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2202">You should not perform any operations on the original reader until the new reader has been closed.</span></span> <span data-ttu-id="58cdf-2203">새 판독기를 닫기 전에는 원래 판독기에서 작업을 수행할 수 없으며 수행할 경우 예기치 않은 동작이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2203">This action is not supported and can result in unpredictable behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-2204"><xref:System.Xml.XmlReader.ReadSubtree%2A> creatingcopies 있습니다 수 개별적으로 작업 하는 XML 데이터에 대 한 메서드가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2204">The <xref:System.Xml.XmlReader.ReadSubtree%2A> method isn't intended for creatingcopies of the XML data that you can work with independently.</span></span> <span data-ttu-id="58cdf-2205">훌륭한 XML 요소 주위에 경계를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2205">It's designedto create a boundary around an XML element.</span></span> <span data-ttu-id="58cdf-2206">데이터 처리에 대 한 다른 구성 요소를 전달 하 고 구성 요소에 액세스할 수 있습니다 하 여 데이터의 양을 제한 하려는 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2206">This is useful if you want to pass data to another component for processing and you wish to limit how much of your data the component can access.</span></span> <span data-ttu-id="58cdf-2207">반환 된 XML 판독기를 전달 하는 경우는 <xref:System.Xml.XmlReader.ReadSubtree%2A> 메서드를 다른 애플리케이션으로 해당 XML 요소만 전체 XML 문서에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2207">When you pass an XML reader returned by the <xref:System.Xml.XmlReader.ReadSubtree%2A> method to another application, the application can access only that XML element, not the entire XML document.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2208">다음 예제에서는 <xref:System.Xml.XmlReader.ReadSubtree%2A> 메서드를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2208">The following example shows how to use the <xref:System.Xml.XmlReader.ReadSubtree%2A> method.</span></span>  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 <span data-ttu-id="58cdf-2209">이 항목의 예제를 실행 하려면 다음 XML 데이터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2209">Use the following XML data to run the examples in this topic:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2210">XML reader가 요소에 배치되지 않은 상태에서 이 메서드를 호출한 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2210">The XML reader isn't positioned on an element when this method is called.</span></span>

<span data-ttu-id="58cdf-2211">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2211">-or-</span></span>

<span data-ttu-id="58cdf-2212">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2212">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2213">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2213">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2214">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2214">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2215">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2215">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-2216">일치하는 다음 하위 요소로 <see cref="T:System.Xml.XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2216">Advances the <see cref="T:System.Xml.XmlReader" /> to the next matching descendant element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-2217">판독기를 이동할 요소의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2217">The qualified name of the element you wish to move to.</span></span></param>
        <summary><span data-ttu-id="58cdf-2218">지정된 정규화 이름을 사용하는 다음 하위 요소로 <see cref="T:System.Xml.XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2218">Advances the <see cref="T:System.Xml.XmlReader" /> to the next descendant element with the specified qualified name.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2219">일치하는 하위 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2219"><see langword="true" /> if a matching descendant element is found; otherwise <see langword="false" />.</span></span> <span data-ttu-id="58cdf-2220">일치하는 하위 요소가 없으면 요소의 끝 태그, 즉 <see cref="T:System.Xml.XmlReader" />이 <see langword="XmlNodeType.EndElement" />인 태그에 <see cref="P:System.Xml.XmlReader.NodeType" />가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2220">If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" /> is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" /> is <see langword="XmlNodeType.EndElement" />) of the element.</span></span>  
  
<span data-ttu-id="58cdf-2221"><see cref="T:System.Xml.XmlReader" />를 호출했을 때 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />가 요소에 배치되어 있지 않으면 이 메서드가 <see langword="false" />를 반환하고 <see cref="T:System.Xml.XmlReader" />의 위치는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2221">If the <see cref="T:System.Xml.XmlReader" /> is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> was called, this method returns <see langword="false" /> and the position of the <see cref="T:System.Xml.XmlReader" /> is not changed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-2222">다음 예제에서는 두 번째 book 노드로 구문 분석합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2222">The following example parses the second book node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 <span data-ttu-id="58cdf-2223">이 예제에서는 파일을 사용 하 여 `2books.xml`입력으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2223">The example uses the file, `2books.xml`, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2224">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2224">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2225">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2225">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-2226">매개 변수가 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2226">The parameter is an empty string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-2227">판독기를 이동할 요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2227">The local name of the element you wish to move to.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-2228">판독기를 이동할 하위 요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2228">The namespace URI of the element you wish to move to.</span></span></param>
        <summary><span data-ttu-id="58cdf-2229">지정된 로컬 이름과 네임스페이스 URI를 사용하는 다음 하위 요소로 <see cref="T:System.Xml.XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2229">Advances the <see cref="T:System.Xml.XmlReader" /> to the next descendant element with the specified local name and namespace URI.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2230">일치하는 하위 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2230"><see langword="true" /> if a matching descendant element is found; otherwise <see langword="false" />.</span></span> <span data-ttu-id="58cdf-2231">일치하는 하위 요소가 없으면 요소의 끝 태그, 즉 <see cref="T:System.Xml.XmlReader" />이 <see langword="XmlNodeType.EndElement" />인 태그에 <see cref="P:System.Xml.XmlReader.NodeType" />가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2231">If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" /> is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" /> is <see langword="XmlNodeType.EndElement" />) of the element.</span></span>  
  
<span data-ttu-id="58cdf-2232"><see cref="T:System.Xml.XmlReader" />를 호출했을 때 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />가 요소에 배치되어 있지 않으면 이 메서드가 <see langword="false" />를 반환하고 <see cref="T:System.Xml.XmlReader" />의 위치는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2232">If the <see cref="T:System.Xml.XmlReader" /> is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> was called, this method returns <see langword="false" /> and the position of the <see cref="T:System.Xml.XmlReader" /> is not changed.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2233">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2233">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2234">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2234">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2235">두 매개 변수 값이 모두 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2235">Both parameter values are <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2236">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2236">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2237">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2237">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-2238">명명된 요소를 찾을 때까지 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2238">Reads until the named element is found.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-2239">요소의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2239">The qualified name of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-2240">지정된 정규화된 이름의 요소를 찾을 때까지 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2240">Reads until an element with the specified qualified name is found.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2241">일치하는 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />이고 <see cref="T:System.Xml.XmlReader" />가 파일 끝에 도달합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2241"><see langword="true" /> if a matching element is found; otherwise <see langword="false" /> and the <see cref="T:System.Xml.XmlReader" /> is in an end of file state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2242">이 메서드는 기능적으로 동일한 실행 된 `following::name` 현재 노드의 XPath 식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2242">This method is functionally equivalent executing the `following::name` XPath expression from the current node.</span></span> <span data-ttu-id="58cdf-2243">XML 문서에 명명 된 요소를 찾는 빠른 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2243">It provides a quick way to find a named element in the XML document.</span></span> <span data-ttu-id="58cdf-2244">다음 요소는 지정된 된 이름과 일치 하 고 반환 하 여 판독기 `true` 일치 하는 요소가 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2244">It advances the reader to the next following element that matches the specified name and returns `true` if a matching element is found.</span></span> <span data-ttu-id="58cdf-2245">아래 예제를 사용 하 여 판독기는 읽기 첫 번째 인스턴스의 지정된 된 요소를 앞으로 읽는 동안.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2245">Using the example below, the reader would read to the first instance of the specified element while reading forward.</span></span>  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 <span data-ttu-id="58cdf-2246">이 메서드는 모든 노드 형식에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2246">This method can be called on all node types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2247">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2247">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2248">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2248">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-2249">매개 변수가 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2249">The parameter is an empty string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-2250">요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2250">The local name of the element.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-2251">요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2251">The namespace URI of the element.</span></span></param>
        <summary><span data-ttu-id="58cdf-2252">지정된 로컬 이름 및 네임스페이스 URI를 사용하는 요소를 찾을 때까지 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2252">Reads until an element with the specified local name and namespace URI is found.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2253">일치하는 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />이고 <see cref="T:System.Xml.XmlReader" />가 파일 끝에 도달합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2253"><see langword="true" /> if a matching element is found; otherwise <see langword="false" /> and the <see cref="T:System.Xml.XmlReader" /> is in an end of file state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2254">이 메서드는 기능적으로 동일한 실행 된 `following::name` 현재 노드의 XPath 식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2254">This method is functionally equivalent executing the `following::name` XPath expression from the current node.</span></span> <span data-ttu-id="58cdf-2255">XML 문서에 명명 된 요소를 찾는 빠른 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2255">It provides a quick way to find a named element in the XML document.</span></span> <span data-ttu-id="58cdf-2256">다음 요소는 지정된 된 이름과 일치 하 고 반환 하 여 판독기 `true` 일치 하는 요소가 있으면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2256">It advances the reader to the next following element that matches the specified name and returns `true` if a matching element is found.</span></span>  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 <span data-ttu-id="58cdf-2257">이 메서드는 모든 노드 형식에서 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2257">This method can be called on all node types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2258">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2258">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2259">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2259">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2260">두 매개 변수 값이 모두 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2260">Both parameter values are <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2261">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2261">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2262">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2262">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <summary><span data-ttu-id="58cdf-2263">일치하는 다음 형제 요소로 <see langword="XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2263">Advances the <see langword="XmlReader" /> to the next matching sibling element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="58cdf-2264">판독기를 이동할 형제 요소의 정규화된 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2264">The qualified name of the sibling element you wish to move to.</span></span></param>
        <summary><span data-ttu-id="58cdf-2265">지정된 정규화 이름을 사용하는 다음 형제 요소로 <see langword="XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2265">Advances the <see langword="XmlReader" /> to the next sibling element with the specified qualified name.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2266">일치하는 형제 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2266"><see langword="true" /> if a matching sibling element is found; otherwise <see langword="false" />.</span></span> <span data-ttu-id="58cdf-2267">일치하는 형제 요소가 없으면 부모 요소의 끝 태그, 즉 <see cref="P:System.Xml.XmlReader.NodeType" />이 <see langword="XmlNodeType.EndElement" />인 태그에 <see langword="XmlReader" />가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2267">If a matching sibling element is not found, the <see langword="XmlReader" /> is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" /> is <see langword="XmlNodeType.EndElement" />) of the parent element.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-2268">호출 하지 마세요 <xref:System.Xml.XmlReader.ReadToNextSibling%2A> 때 합니다 `XmlReader` 초기 상태입니다 (<xref:System.Xml.XmlReader.ReadState%2A> 는 <xref:System.Xml.ReadState.Initial>).</span><span class="sxs-lookup"><span data-stu-id="58cdf-2268">Do not call <xref:System.Xml.XmlReader.ReadToNextSibling%2A> when the `XmlReader` is an initial state (<xref:System.Xml.XmlReader.ReadState%2A> is <xref:System.Xml.ReadState.Initial>).</span></span> <span data-ttu-id="58cdf-2269">호출할 수 있습니다 <xref:System.Xml.XmlReader.Read%2A> 이동 하는 `XmlReader` 호출을 <xref:System.Xml.XmlReader.ReadToNextSibling%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2269">You can call <xref:System.Xml.XmlReader.Read%2A> to advance the `XmlReader` and then call the <xref:System.Xml.XmlReader.ReadToNextSibling%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2270">다음 예제에서는 각 book 노드에 ISBN 특성을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2270">The following example reads the ISBN attribute on each book node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2271">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2271">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2272">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2272">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="58cdf-2273">매개 변수가 빈 문자열인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2273">The parameter is an empty string.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName"><span data-ttu-id="58cdf-2274">판독기를 이동할 형제 요소의 로컬 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2274">The local name of the sibling element you wish to move to.</span></span></param>
        <param name="namespaceURI"><span data-ttu-id="58cdf-2275">판독기를 이동할 형제 요소의 네임스페이스 URI입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2275">The namespace URI of the sibling element you wish to move to.</span></span></param>
        <summary><span data-ttu-id="58cdf-2276">지정된 로컬 이름과 네임스페이스 URI를 사용하는 다음 형제 요소로 <see langword="XmlReader" />를 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2276">Advances the <see langword="XmlReader" /> to the next sibling element with the specified local name and namespace URI.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2277">일치하는 형제 요소가 있으면 <see langword="true" />이고, 그렇지 않으면 <see langword="false" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2277"><see langword="true" /> if a matching sibling element is found; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="58cdf-2278">일치하는 형제 요소가 없으면 부모 요소의 끝 태그, 즉 <see cref="P:System.Xml.XmlReader.NodeType" />이 <see langword="XmlNodeType.EndElement" />인 태그에 <see langword="XmlReader" />가 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2278">If a matching sibling element is not found, the <see langword="XmlReader" /> is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" /> is <see langword="XmlNodeType.EndElement" />) of the parent element.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-2279">호출 하지 마세요 <xref:System.Xml.XmlReader.ReadToNextSibling%2A> 때 합니다 `XmlReader` 초기 상태입니다 (<xref:System.Xml.XmlReader.ReadState%2A> 는 <xref:System.Xml.ReadState.Initial>).</span><span class="sxs-lookup"><span data-stu-id="58cdf-2279">Do not call <xref:System.Xml.XmlReader.ReadToNextSibling%2A> when the `XmlReader` is an initial state (<xref:System.Xml.XmlReader.ReadState%2A> is <xref:System.Xml.ReadState.Initial>).</span></span> <span data-ttu-id="58cdf-2280">호출할 수 있습니다 <xref:System.Xml.XmlReader.Read%2A> 이동 하는 `XmlReader` 호출을 <xref:System.Xml.XmlReader.ReadToNextSibling%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2280">You can call <xref:System.Xml.XmlReader.Read%2A> to advance the `XmlReader` and then call the <xref:System.Xml.XmlReader.ReadToNextSibling%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2281">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2281">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2282">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2282">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2283">두 매개 변수 값이 모두 <see langword="null" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2283">Both parameter values are <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-2284">텍스트 콘텐츠를 쓸 버퍼 역할을 하는 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2284">The array of characters that serves as the buffer to which the text contents are written.</span></span> <span data-ttu-id="58cdf-2285">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2285">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-2286"><see cref="T:System.Xml.XmlReader" />가 버퍼 내에서 결과 복사를 시작할 수 있는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2286">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" /> can start to copy the results.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-2287">버퍼에 복사할 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2287">The maximum number of characters to copy into the buffer.</span></span> <span data-ttu-id="58cdf-2288">이 메서드는 복사된 실제 문자 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2288">The actual number of characters copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-2289">XML 문서에 포함된 큰 텍스트 스트림을 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2289">Reads large streams of text embedded in an XML document.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2290">버퍼로 읽어온 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2290">The number of characters read into the buffer.</span></span> <span data-ttu-id="58cdf-2291">텍스트 콘텐츠가 더 이상 없으면 0이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2291">The value zero is returned when there is no more text content.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2292">이 메서드는 적은 수의 문자는 전체 값에 대 한 단일 문자열을 할당 하는 대신 한 번에 스트리밍 방식으로, 즉, XML 문서에 포함 된 텍스트의 큰 스트림을 읽고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2292">This method enables reading of very large streams of text embedded in an XML document in a streaming fashion, that is, a small number of characters at a time instead of allocating a single string for the whole value.</span></span> <span data-ttu-id="58cdf-2293">값이 있는 모든 노드에서이 메서드를 호출할 수 있습니다 (<xref:System.Xml.XmlReader.HasValue%2A> 는 `true`) 이지만 텍스트, 공백 및 유효 공백 노드가에서 호출 하는 경우에 발생 노드 값의 실제 스트리밍.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2293">This method can be called on any node that has a value (<xref:System.Xml.XmlReader.HasValue%2A> is `true`), however actual streaming of the node value only occurs when called on a text, white space and significant white space nodes.</span></span> <span data-ttu-id="58cdf-2294">특성 및 CDATA 노드를 포함 하 여 다른 노드 형식 값은 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2294">Other node type values are cached, including attributes and CDATA nodes.</span></span>  
  
 <span data-ttu-id="58cdf-2295">이 메서드가 반환의 콘텐츠만 합니다 <xref:System.Xml.XmlReader.Value%2A> 속성 이동 하지 않습니다는 <xref:System.Xml.XmlReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2295">This method returns only the content of the <xref:System.Xml.XmlReader.Value%2A> property and does not move the <xref:System.Xml.XmlReader>.</span></span>  
  
 <span data-ttu-id="58cdf-2296">이 메서드는 지정 된 개수의 문자를 읽습니다 (`count`)를 문자 버퍼로 노드 값의 (`buffer`) 지정 된 오프셋 (`index`) 버퍼에 기록 된 문자 수를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2296">This method reads the specified number of characters (`count`) of the node value into a character buffer (`buffer`) at a specified offset (`index`) and returns the number of characters written to the buffer.</span></span> <span data-ttu-id="58cdf-2297">반환 된 `0` 값의 끝에 도달 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2297">It returns the `0` when it has reached the end of the value.</span></span> <span data-ttu-id="58cdf-2298">이 값을 통해 다시 읽기를 시작할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2298">It cannot be restarted to read through the value again.</span></span>  
  
 <span data-ttu-id="58cdf-2299">에 대 한 호출 사이 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 는 <xref:System.Xml.XmlReader> 속성을 제외 하 고 변경 되지 않습니다는 <xref:System.Xml.XmlReader.Value%2A> 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2299">In between calls to <xref:System.Xml.XmlReader.ReadValueChunk%2A> the <xref:System.Xml.XmlReader> properties do no change except for the <xref:System.Xml.XmlReader.Value%2A> property.</span></span> <span data-ttu-id="58cdf-2300">경우는 <xref:System.Xml.XmlReader.Value%2A> 속성에 액세스할 때 부분 값을 반환할 수 있습니다 (아직 반환한 문자로 <xref:System.Xml.XmlReader.ReadValueChunk%2A>) 또는 구현에 따라 전체 값.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2300">When the <xref:System.Xml.XmlReader.Value%2A> property is accessed it may either return a partial value (with characters not yet returned by <xref:System.Xml.XmlReader.ReadValueChunk%2A>) or a full value depending on the implementation.</span></span> <span data-ttu-id="58cdf-2301">모든는 <xref:System.Xml.XmlReader> 구현에는 <xref:System.Xml> 부분 값을 반환 하는 네임 스페이스를 <xref:System.Xml.XmlReader.Value%2A> 속성 구현.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2301">All the <xref:System.Xml.XmlReader> implementations in the <xref:System.Xml> namespace return a partial value for the <xref:System.Xml.XmlReader.Value%2A> property implementation.</span></span>  
  
 <span data-ttu-id="58cdf-2302">모든 읽기에 대 한 호출 사이 메서드를 호출할 수 <xref:System.Xml.XmlReader.ReadValueChunk%2A>입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2302">Any Read method can be called in between calls to <xref:System.Xml.XmlReader.ReadValueChunk%2A>.</span></span> <span data-ttu-id="58cdf-2303">이런 경우는 <xref:System.Xml.XmlReader> 다음 이동 <xref:System.Xml.XmlNodeType> 스트림 및 아직 반환 된 모든 문자에서 생략 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2303">If this occurs, the <xref:System.Xml.XmlReader> moves to the next <xref:System.Xml.XmlNodeType> in the stream and any characters not yet returned are skipped.</span></span>  
  
 <span data-ttu-id="58cdf-2304">사례를 있을 때 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 요청 된 문자 수보다 작은 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2304">There may be a case when <xref:System.Xml.XmlReader.ReadValueChunk%2A> returns less than the requested number of characters.</span></span> <span data-ttu-id="58cdf-2305">예를 들어 200 자로 long 값을 서로게이트 쌍을 사용 하 여 127과 128 했으며 라는 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 128 문자 버퍼를 사용 하 여 메서드 호출 요청된 128 대신 127 자를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2305">For example, if you had a 200-character long value with a surrogate pair at positions 127 and 128 and you called <xref:System.Xml.XmlReader.ReadValueChunk%2A> with a 128-character buffer, the method call would return 127 characters instead of the requested 128.</span></span> <span data-ttu-id="58cdf-2306">서로게이트 쌍에에서 반환할 수는 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2306">The surrogate pair would then be returned in the next <xref:System.Xml.XmlReader.ReadValueChunk%2A> call.</span></span> <span data-ttu-id="58cdf-2307">이 경우 <xref:System.Xml.XmlReader.ReadValueChunk%2A> 수행 하므로 결과는 버퍼의 끝에 불완전 한 서로게이트 쌍을 요청된 하는 128 자 이므로 반환 하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2307">In this case, <xref:System.Xml.XmlReader.ReadValueChunk%2A> did not return the requested 128 characters because doing so would have resulted in an incomplete surrogate pair at the end of the buffer.</span></span>  
  
 <span data-ttu-id="58cdf-2308">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2308">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2309">현재 노드에 값이 없는 경우, 즉 <see cref="P:System.Xml.XmlReader.HasValue" />가 <see langword="false" />인 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2309">The current node does not have a value (<see cref="P:System.Xml.XmlReader.HasValue" /> is <see langword="false" />).</span></span>

<span data-ttu-id="58cdf-2310">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2310">-or-</span></span> 
<span data-ttu-id="58cdf-2311">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2311">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2312">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2312">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="58cdf-2313"><paramref name="buffer" /> 값이 <see langword="null" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2313">The <paramref name="buffer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="58cdf-2314">버퍼 내의 인덱스 또는 인덱스와 개수를 합한 값이 할당된 버퍼 크기보다 큰 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2314">The index into the buffer, or index + count is larger than the allocated buffer size.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="58cdf-2315">구현된 <see cref="T:System.Xml.XmlReader" />에서 이 메서드를 지원하지 않는 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2315">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</span></span></exception>
        <exception cref="T:System.Xml.XmlException"><span data-ttu-id="58cdf-2316">XML 데이터가 올바른 형식이 아닌 경우</span><span class="sxs-lookup"><span data-stu-id="58cdf-2316">The XML data is not well-formed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="58cdf-2317">텍스트 콘텐츠를 쓸 버퍼 역할을 하는 문자 배열입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2317">The array of characters that serves as the buffer to which the text contents are written.</span></span> <span data-ttu-id="58cdf-2318">이 값은 <see langword="null" />일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2318">This value cannot be <see langword="null" />.</span></span></param>
        <param name="index"><span data-ttu-id="58cdf-2319"><see cref="T:System.Xml.XmlReader" />가 버퍼 내에서 결과 복사를 시작할 수 있는 오프셋입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2319">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" /> can start to copy the results.</span></span></param>
        <param name="count"><span data-ttu-id="58cdf-2320">버퍼에 복사할 최대 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2320">The maximum number of characters to copy into the buffer.</span></span> <span data-ttu-id="58cdf-2321">이 메서드는 복사된 실제 문자 수를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2321">The actual number of characters copied is returned from this method.</span></span></param>
        <summary><span data-ttu-id="58cdf-2322">XML 문서에 포함된 큰 텍스트 스트림을 비동기적으로 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2322">Asynchronously reads large streams of text embedded in an XML document.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2323">버퍼로 읽어온 문자 수입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2323">The number of characters read into the buffer.</span></span> <span data-ttu-id="58cdf-2324">텍스트 콘텐츠가 더 이상 없으면 0이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2324">The value zero is returned when there is no more text content.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2325">비동기 버전이 <xref:System.Xml.XmlReader.ReadValueChunk%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2325">This is the asynchronous version of <xref:System.Xml.XmlReader.ReadValueChunk%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-2326">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2326">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2327">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2327">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2328">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2328">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>
<span data-ttu-id="58cdf-2329">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2329">-or-</span></span>

<span data-ttu-id="58cdf-2330"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2330">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-2331">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2331">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-2332">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2332">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2333">파생 클래스에서 재정의되면 <see langword="EntityReference" /> 노드에 대한 엔터티 참조를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2333">When overridden in a derived class, resolves the entity reference for <see langword="EntityReference" /> nodes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2334">판독기가 위치에 `EntityReference` 노드 (`XmlNodeType.EntityReference`) 이면 <xref:System.Xml.XmlReader.Read%2A> 이 메서드를 엔터티 대체 텍스트를 구문 분석 하는 호출 후에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2334">If the reader is positioned on an `EntityReference` node (`XmlNodeType.EntityReference`), if <xref:System.Xml.XmlReader.Read%2A> is called after calling this method, the entity replacement text is parsed.</span></span> <span data-ttu-id="58cdf-2335">엔터티 대체 텍스트를 마치면는 `EndEntity` 노드가 엔터티 참조 범위를 닫습니다 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2335">When the entity replacement text is finished, an `EndEntity` node is returned to close the entity reference scope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58cdf-2336">이 메서드를 호출한 후 엔터티를 특성 값의 일부인 경우 호출 해야 <xref:System.Xml.XmlReader.ReadAttributeValue%2A> 엔터티 한 단계씩 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2336">After calling this method, if the entity is part of an attribute value, you must call <xref:System.Xml.XmlReader.ReadAttributeValue%2A> to step into the entity.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2337">판독기가 <see langword="EntityReference" /> 노드에 배치되지 않고 판독기의 이 구현에서 엔터티를 확인할 수 없는 경우(<see cref="P:System.Xml.XmlReader.CanResolveEntity" />가 <see langword="false" />를 반환하는 경우)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2337">The reader is not positioned on an <see langword="EntityReference" /> node; this implementation of the reader cannot resolve entities (<see cref="P:System.Xml.XmlReader.CanResolveEntity" /> returns <see langword="false" />).</span></span>

<span data-ttu-id="58cdf-2338">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2338">-or-</span></span>

<span data-ttu-id="58cdf-2339">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2339">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2340">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2340">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2341">스키마 유효성 검사의 결과로 현재 노드에 할당된 스키마 정보를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2341">Gets the schema information that has been assigned to the current node as a result of schema validation.</span></span></summary>
        <value><span data-ttu-id="58cdf-2342">현재 노드에 대한 스키마 정보를 포함하는 <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2342">An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> object containing the schema information for the current node.</span></span> <span data-ttu-id="58cdf-2343">스키마 정보는 <see cref="P:System.Xml.XmlReader.ValueType" />(형식화된 값)이 null이 아닌 Element, Attribute 또는 Text 노드에 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2343">Schema information can be set on elements, attributes, or on text nodes with a non-null <see cref="P:System.Xml.XmlReader.ValueType" /> (typed values).</span></span>  
  
<span data-ttu-id="58cdf-2344">현재 노드가 이러한 노드 형식 중 하나가 아니거나, <see langword="XmlReader" /> 인스턴스에서 스키마 정보를 보고하지 않는 경우에는 이 속성이 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2344">If the current node is not one of the above node types, or if the <see langword="XmlReader" /> instance does not report schema information, this property returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="58cdf-2345"><see cref="T:System.Xml.XmlTextReader" /> 또는 <see cref="T:System.Xml.XmlValidatingReader" /> 개체에서 이 속성을 호출하면 항상 <see langword="null" />이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2345">If this property is called from an <see cref="T:System.Xml.XmlTextReader" /> or an <see cref="T:System.Xml.XmlValidatingReader" /> object, this property always returns <see langword="null" />.</span></span> <span data-ttu-id="58cdf-2346">이러한 <see langword="XmlReader" /> 구현에서는 <see langword="SchemaInfo" /> 속성을 통해 스키마 정보를 노출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2346">These <see langword="XmlReader" /> implementations do not expose schema information through the <see langword="SchemaInfo" /> property.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="58cdf-2347">요소에 대한 PSVI(스키마 유효성 검사 이후 정보 집합)을 가져와야 하는 경우 시작 태그 대신에 요소의 종료 태그에 판독기를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2347">If you have to get the post-schema-validation information set (PSVI) for an element, position the reader on the end tag of the element, rather than on the start tag.</span></span> <span data-ttu-id="58cdf-2348">판독기의 <see langword="SchemaInfo" /> 속성을 통해 PSVI를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2348">You get the PSVI through the <see langword="SchemaInfo" /> property of a reader.</span></span> <span data-ttu-id="58cdf-2349"><see cref="Overload:System.Xml.XmlReader.Create" /> 속성을 <see cref="P:System.Xml.XmlReaderSettings.ValidationType" />로 설정하고 <see cref="F:System.Xml.ValidationType.Schema" />를 통해 만든 유효성 검사 판독기는 요소의 종료 태그에 판독기가 배치된 경우에만 요소에 대한 완전한 PSVI가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2349">The validating reader that is created through <see cref="Overload:System.Xml.XmlReader.Create" /> with the <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> property set to <see cref="F:System.Xml.ValidationType.Schema" /> has complete PSVI for an element only when the reader is positioned on the end tag of an element.</span></span>  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2350"><xref:System.Xml.Schema.IXmlSchemaInfo> 인터페이스의 스키마 유효성 검사 이후 정보 집합 PSVI ()는 XML 노드와 연결 된 하위 집합을 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2350">The <xref:System.Xml.Schema.IXmlSchemaInfo> interface exposes a subset of the Post Schema Validation Infoset (PSVI) associated with an XML node.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2351">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2351">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2352">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2352">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2353">이 <see cref="T:System.Xml.XmlReader" /> 인스턴스를 만드는 데 사용되는 <see cref="T:System.Xml.XmlReaderSettings" /> 개체를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2353">Gets the <see cref="T:System.Xml.XmlReaderSettings" /> object used to create this <see cref="T:System.Xml.XmlReader" /> instance.</span></span></summary>
        <value><span data-ttu-id="58cdf-2354">이 판독기 인스턴스를 만드는 데 사용되는 <see cref="T:System.Xml.XmlReaderSettings" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2354">The <see cref="T:System.Xml.XmlReaderSettings" /> object used to create this reader instance.</span></span> <span data-ttu-id="58cdf-2355"><see cref="Overload:System.Xml.XmlReader.Create" /> 메서드를 사용하여 판독기를 만들지 않은 경우 이 속성은 <see langword="null" />을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2355">If this reader was not created using the <see cref="Overload:System.Xml.XmlReader.Create" /> method, this property returns <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="58cdf-2356"><xref:System.Xml.XmlReaderSettings> 개체에는 사용자 자격 증명과 같은 중요 한 정보가 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2356">The <xref:System.Xml.XmlReaderSettings> object can contain sensitive information such as user credentials.</span></span> <span data-ttu-id="58cdf-2357">애플리케이션 반드시 때이 개체를 캐시 하거나 다른 구성 요소에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2357">Applications must be careful when caching this object or passing it to another component.</span></span>  
  
 <span data-ttu-id="58cdf-2358"><xref:System.Xml.XmlReaderSettings> 클래스 만들어진된 판독기 인스턴스에 대해 지원할 기능 집합을 지정 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2358">The <xref:System.Xml.XmlReaderSettings> class is used to specify the set of features to support on the created reader instance.</span></span> <span data-ttu-id="58cdf-2359"><xref:System.Xml.XmlReaderSettings> 이 속성에서 반환 된 개체를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2359">The <xref:System.Xml.XmlReaderSettings> object returned by this property cannot be modified.</span></span> <span data-ttu-id="58cdf-2360">예외가 throw 되 고 개별 설정을 결과 변경 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2360">Any attempt to change individual settings results in an exception being thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2361">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2361">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2362">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2362">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2363">현재 노드의 자식을 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2363">Skips the children of the current node.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2364">다음 xml에서에 판독기가 배치 하는 경우을 입력 합니다 `<a>` 노드 또는 해당 특성, 호출 `Skip` 판독기가 `<b>` 노드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2364">In the following XML input if the reader is positioned on the `<a>` node or any of its attributes, calling `Skip` positions the reader to the `<b>` node.</span></span>  
  
 <span data-ttu-id="58cdf-2365">경우 판독기가 리프 노드에 이미 (같은 합니다 `<x>` 노드 또는 텍스트 노드의 `abc`)를 호출 `Skip` 호출 하는 것 같습니다 <xref:System.Xml.XmlReader.Read%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2365">If the reader is positioned on a leaf node already (such as the `<x>` node or the text node `abc`), calling `Skip` is the same as calling <xref:System.Xml.XmlReader.Read%2A>.</span></span>  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 <span data-ttu-id="58cdf-2366">이 메서드는 올바른 형식의 XML에 대 한 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2366">This method checks for well-formed XML.</span></span>  
  
 <span data-ttu-id="58cdf-2367">판독기가 있으면는 <xref:System.Xml.XmlValidatingReader>,이 메서드는 건너뛴된 콘텐츠에도 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2367">If the reader is an <xref:System.Xml.XmlValidatingReader>, this method also validates the skipped content.</span></span>  
  
 <span data-ttu-id="58cdf-2368">`XmlReader` 구현을 확인 여부는 `Skip` 메서드 외부 엔터티를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2368">The `XmlReader` implementation determines whether or not the `Skip` method will expand external entities.</span></span> <span data-ttu-id="58cdf-2369">다음 표에서 다양 한 유형의 외부 엔터티를 확장 하는지 여부를 설명 합니다. `XmlReader` 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2369">The following table describes whether the external entities are expanded for the various types of `XmlReader` objects.</span></span>  
  
|<span data-ttu-id="58cdf-2370">XmlReader의 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-2370">Type of XmlReader</span></span>|<span data-ttu-id="58cdf-2371">외부 엔터티를 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2371">Expands external entities</span></span>|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|<span data-ttu-id="58cdf-2372">아니요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2372">No.</span></span>|  
|<span data-ttu-id="58cdf-2373"><xref:System.Xml.XmlReader> 생성 된 인스턴스는 <xref:System.Xml.XmlReader.Create%2A> 텍스트 데이터를 읽기 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2373"><xref:System.Xml.XmlReader> instance created by the <xref:System.Xml.XmlReader.Create%2A> method that is reading text data.</span></span>|<span data-ttu-id="58cdf-2374">아니요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2374">No.</span></span>|  
|<span data-ttu-id="58cdf-2375"><xref:System.Xml.XmlReader> 생성 된 인스턴스는 <xref:System.Xml.XmlReader.Create%2A> 이진 데이터를 읽기 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2375"><xref:System.Xml.XmlReader> instance created by the <xref:System.Xml.XmlReader.Create%2A> method that is reading binary data.</span></span>|<span data-ttu-id="58cdf-2376">해당 사항 없음.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2376">Not applicable.</span></span>|  
|<span data-ttu-id="58cdf-2377">스키마 유효성 검사 <xref:System.Xml.XmlReader> 에서 만든 인스턴스는 <xref:System.Xml.XmlReader.Create%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2377">A schema validating <xref:System.Xml.XmlReader> instance created by the <xref:System.Xml.XmlReader.Create%2A> method.</span></span>|<span data-ttu-id="58cdf-2378">예.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2378">Yes.</span></span>|  
|<xref:System.Xml.XmlValidatingReader>|<span data-ttu-id="58cdf-2379">예.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2379">Yes.</span></span>|  
|<span data-ttu-id="58cdf-2380"><xref:System.Xml.XmlReader> 반환한 인스턴스를 <xref:System.Xml.XPath.XPathNavigator> 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2380"><xref:System.Xml.XmlReader> instance returned by a <xref:System.Xml.XPath.XPathNavigator> object.</span></span>|<span data-ttu-id="58cdf-2381">해당 사항 없음.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2381">Not applicable.</span></span>|  
|<xref:System.Xml.XmlNodeReader>|<span data-ttu-id="58cdf-2382">아니요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2382">No.</span></span>|  
|<span data-ttu-id="58cdf-2383"><xref:System.Xml.XmlReader> 인스턴스를 다른 래핑하 <xref:System.Xml.XmlReader> 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2383"><xref:System.Xml.XmlReader> instance wrapped around another <xref:System.Xml.XmlReader> instance.</span></span>|<span data-ttu-id="58cdf-2384">기본 구현에 따라 달라 집니다 <xref:System.Xml.XmlReader>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2384">Depends on the implementation of the underlying <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="58cdf-2385">(합니다 `Skip` 메서드 내부를 <xref:System.Xml.XmlReader> 라고).</span><span class="sxs-lookup"><span data-stu-id="58cdf-2385">(The `Skip` method on the underlying <xref:System.Xml.XmlReader> is called).</span></span>|  
  
 <span data-ttu-id="58cdf-2386">이 메서드의 비동기 버전을 참조 하세요. <xref:System.Xml.XmlReader.SkipAsync%2A>합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2386">For the asynchronous version of this method, see <xref:System.Xml.XmlReader.SkipAsync%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2387">다음 예제에서는 두 번째 book 노드에 시작 하는 XML 파일을 구문 분석 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2387">The following example parses an XML file starting on the second book node.</span></span>  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 <span data-ttu-id="58cdf-2388">이 예제에서는 파일을 사용 하 여 `2books.xml`입력으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2388">The example uses the file, `2books.xml`, as input.</span></span>  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2389">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2389">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2390">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2390">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2391">현재 노드의 자식을 비동기적으로 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2391">Asynchronously skips the children of the current node.</span></span></summary>
        <returns><span data-ttu-id="58cdf-2392">현재 노드입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2392">The current node.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2393">비동기 버전이 <xref:System.Xml.XmlReader.Skip%2A>, 동일한 기능을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2393">This is the asynchronous version of <xref:System.Xml.XmlReader.Skip%2A>, with the same functionality.</span></span> <span data-ttu-id="58cdf-2394">이 메서드를 사용 하려면 설정 해야 합니다 <xref:System.Xml.XmlReaderSettings.Async%2A> 플래그를 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2394">To use this method, you must set the <xref:System.Xml.XmlReaderSettings.Async%2A> flag to `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2395">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2395">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2396">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2396">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span>

<span data-ttu-id="58cdf-2397">또는</span><span class="sxs-lookup"><span data-stu-id="58cdf-2397">-or-</span></span>

<span data-ttu-id="58cdf-2398"><see cref="P:System.Xml.XmlReaderSettings.Async" /> 플래그를 <see langword="true" />로 설정하지 않고 <see cref="T:System.Xml.XmlReader" /> 비동기 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2398">An <see cref="T:System.Xml.XmlReader" /> asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" /> flag to <see langword="true" />.</span></span> <span data-ttu-id="58cdf-2399">이 경우 “비동기 메서드를 사용하려면 XmlReaderSettings.Async를 true로 설정하세요.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2399">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "Set XmlReaderSettings.Async to true if you want to use Async Methods."</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7"><span data-ttu-id="58cdf-2400">Async 및 Await를 사용한 비동기 프로그래밍(C# 및 Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58cdf-2400">Asynchronous Programming with Async and Await (C# and Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="58cdf-2401">이 멤버에 대한 설명은 <see cref="M:System.IDisposable.Dispose" />를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2401">For a description of this member, see <see cref="M:System.IDisposable.Dispose" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="58cdf-2402">이 멤버는 명시적 인터페이스 멤버 구현이며,</span><span class="sxs-lookup"><span data-stu-id="58cdf-2402">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58cdf-2403"><xref:System.Xml.XmlReader> 인스턴스가 <xref:System.IDisposable> 인터페이스로 캐스팅된 경우에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2403">It can be used only when the <xref:System.Xml.XmlReader> instance is cast to an <xref:System.IDisposable> interface.</span></span>

<span data-ttu-id="58cdf-2404">이 멤버 다르게 동작할 수 있습니다에 사용 하는 경우는 [이식 가능한 클래스 라이브러리](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) 프로젝트입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2404">This member may behave differently when it is used in a [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) project.</span></span> <span data-ttu-id="58cdf-2405">자세한 내용은 [이식 가능한 클래스 라이브러리의 API 차이점](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100))합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2405">For more information, see [API Differences in Portable Class Library](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100)).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2406">파생 클래스에서 재정의되면 현재 노드의 텍스트 값을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2406">When overridden in a derived class, gets the text value of the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-2407">노드의 <see cref="P:System.Xml.XmlReader.NodeType" />에 따라 반환되는 값이 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2407">The value returned depends on the <see cref="P:System.Xml.XmlReader.NodeType" /> of the node.</span></span> <span data-ttu-id="58cdf-2408">다음 표에서는 반환할 값이 있는 노드 형식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2408">The following table lists node types that have a value to return.</span></span> <span data-ttu-id="58cdf-2409">다른 모든 노드 형식은 <see langword="String.Empty" />를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2409">All other node types return <see langword="String.Empty" />.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="58cdf-2410">노드 형식</span><span class="sxs-lookup"><span data-stu-id="58cdf-2410">Node type</span></span> 
 </term><description> <span data-ttu-id="58cdf-2411">값</span><span class="sxs-lookup"><span data-stu-id="58cdf-2411">Value</span></span> 
 </description></listheader><item><term><see langword="Attribute" /></term><description> <span data-ttu-id="58cdf-2412">특성 값</span><span class="sxs-lookup"><span data-stu-id="58cdf-2412">The value of the attribute.</span></span>  
  
 </description></item><item><term><see langword="CDATA" /></term><description> <span data-ttu-id="58cdf-2413">CDATA 섹션 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2413">The content of the CDATA section.</span></span>  
  
 </description></item><item><term><see langword="Comment" /></term><description> <span data-ttu-id="58cdf-2414">주석의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2414">The content of the comment.</span></span>  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> <span data-ttu-id="58cdf-2415">내부 하위 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2415">The internal subset.</span></span>  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> <span data-ttu-id="58cdf-2416">대상을 제외한 전체 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2416">The entire content, excluding the target.</span></span>  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> <span data-ttu-id="58cdf-2417">혼합된 콘텐츠 모델의 태그 간 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2417">The white space between markup in a mixed content model.</span></span>  
  
 </description></item><item><term><see langword="Text" /></term><description> <span data-ttu-id="58cdf-2418">텍스트 노드의 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2418">The content of the text node.</span></span>  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> <span data-ttu-id="58cdf-2419">태그 사이의 공백입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2419">The white space between markup.</span></span>  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> <span data-ttu-id="58cdf-2420">선언 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2420">The content of the declaration.</span></span>  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2421">이 속성의 비동기 버전에 대 한 참조를 <xref:System.Xml.XmlReader.GetValueAsync%2A> 메서드.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2421">For the asynchronous version of this property, see the <xref:System.Xml.XmlReader.GetValueAsync%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2422">다음 예제에서는 XML 파일을 읽고 각 노드를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2422">The following example reads an XML file and displays each of the nodes.</span></span>  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 <span data-ttu-id="58cdf-2423">이 샘플에서는 사용 된 `items.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2423">The sample uses the `items.xml` file.</span></span>  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2424">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2424">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2425">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2425">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2426">현재 노드의 CLR(공용 언어 런타임) 형식을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2426">Gets The Common Language Runtime (CLR) type for the current node.</span></span></summary>
        <value><span data-ttu-id="58cdf-2427">노드의 형식화된 값에 해당하는 CLR 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2427">The CLR type that corresponds to the typed value of the node.</span></span> <span data-ttu-id="58cdf-2428">기본값은 <see langword="System.String" />입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2428">The default is <see langword="System.String" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2429">참조 [System.Xml 클래스의 형식 지원](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) 기본 매핑의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2429">See [Type Support in the System.Xml Classes](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) for a list of the default mappings.</span></span>  
  
 <span data-ttu-id="58cdf-2430">형식 요소의 `xs:int` 에 `ValueType` 의 `System.Int32` 기본적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2430">An element of type `xs:int` has a `ValueType` of `System.Int32` by default.</span></span> <span data-ttu-id="58cdf-2431">그러나 합니다 `ValueType` 에 매핑될 수 있는 형식 중 하나일 수 있습니다 `xs:int`와 같은 `System.Int16` 또는 `System.Double`합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2431">However, the `ValueType` could be one of the valid types that can be mapped to `xs:int`, such as `System.Int16` or `System.Double`.</span></span>  
  
 <span data-ttu-id="58cdf-2432">노드 형식화 되었거나 노드가 혼합 된 콘텐츠를 포함 하는 요소 이면 노드 값에 매핑되는 `System.String` 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2432">If a node is un-typed, or if the node is an element that contains mixed content, the node value is mapped to the `System.String` type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2433">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2433">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2434">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2434">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="58cdf-2435">구현자를 제공 해야 합니다는 <see langword="ValueType" /> 만 하는 경우에 모든 노드에 대해는 <see langword="System.String" /> 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2435">Implementers must provide a <see langword="ValueType" /> for every node, even if it is only the <see langword="System.String" /> type.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2436">파생 클래스에서 재정의되면 현재 <see langword="xml:lang" /> 범위를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2436">When overridden in a derived class, gets the current <see langword="xml:lang" /> scope.</span></span></summary>
        <value><span data-ttu-id="58cdf-2437">현재 <see langword="xml:lang" /> 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2437">The current <see langword="xml:lang" /> scope.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58cdf-2438">이 속성을 나타냅니다는 `xml:lang` 내 현재 노드에 있는 범위입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2438">This property represents the `xml:lang` scope within which the current node resides.</span></span> <span data-ttu-id="58cdf-2439">예를 들어, 사용 하 여 XML 조각을 같습니다 `xml:lang` 루트 요소에서 영어 (미국)로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2439">For example, here is an XML fragment with `xml:lang` set to US English in the root element:</span></span>  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 <span data-ttu-id="58cdf-2440">판독기가 배치 하는 경우는 `name` 요소에는 영어 (미국)의 범위에는이 속성을 사용할 수 있습니다 `xml:lang` 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2440">When the reader is positioned on the `name` element, you can use this property to find that it is in the scope of a US English `xml:lang` attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58cdf-2441">참조 <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> 이 속성을 사용 하는 예입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2441">See <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> for an example of using this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2442">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2442">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2443">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2443">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="58cdf-2444">파생 클래스에서 재정의되면 현재 <see langword="xml:space" /> 범위를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2444">When overridden in a derived class, gets the current <see langword="xml:space" /> scope.</span></span></summary>
        <value><span data-ttu-id="58cdf-2445"><see cref="T:System.Xml.XmlSpace" /> 값 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2445">One of the <see cref="T:System.Xml.XmlSpace" /> values.</span></span> <span data-ttu-id="58cdf-2446"><see langword="xml:space" /> 범위가 존재하지 않으면 이 속성은 기본적으로 <see langword="XmlSpace.None" />으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2446">If no <see langword="xml:space" /> scope exists, this property defaults to <see langword="XmlSpace.None" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58cdf-2447">참조 <xref:System.Xml.XmlTextReader.XmlSpace%2A> (에 `XmlTextReader` 클래스)이이 속성을 사용 하는 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2447">See <xref:System.Xml.XmlTextReader.XmlSpace%2A> (in the `XmlTextReader` class) for an example using this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="58cdf-2448">이전 비동기 작업이 완료되기 전에 <see cref="T:System.Xml.XmlReader" /> 메서드가 호출되었습니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2448">An <see cref="T:System.Xml.XmlReader" /> method was called before a previous asynchronous operation finished.</span></span> <span data-ttu-id="58cdf-2449">이 경우 “비동기 작업이 이미 진행 중입니다.” 메시지를 나타내며 <see cref="T:System.InvalidOperationException" />이 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="58cdf-2449">In this case, <see cref="T:System.InvalidOperationException" /> is thrown with the message "An asynchronous operation is already in progress."</span></span></exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>